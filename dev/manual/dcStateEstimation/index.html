<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC State Estimation · JuliaGrid</title><meta name="title" content="DC State Estimation · JuliaGrid"/><meta property="og:title" content="DC State Estimation · JuliaGrid"/><meta property="twitter:title" content="DC State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li class="is-active"><a class="tocitem" href>DC State Estimation</a><ul class="internal"><li><a class="tocitem" href="#DCWLSStateEstimationSolutionManual"><span>Weighted Least-Squares Estimator</span></a></li><li><a class="tocitem" href="#DCLAVtateEstimationSolutionManual"><span>Least Absolute Value Estimator</span></a></li><li><a class="tocitem" href="#DCMeasurementsAlterationManual"><span>Measurement Set Update</span></a></li><li><a class="tocitem" href="#DCStateEstimationUpdateManual"><span>State Estimation Update</span></a></li><li><a class="tocitem" href="#DCSEPowerAnalysisManual"><span>Power Analysis</span></a></li></ul></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>DC State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/dcStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCStateEstimationManual"><a class="docs-heading-anchor" href="#DCStateEstimationManual">DC State Estimation</a><a id="DCStateEstimationManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCStateEstimationManual" title="Permalink"></a></h1><p>To perform the DC state estimation, we first need to have the <code>PowerSystem</code> type that has been created with the DC model, alongside the <code>Measurement</code> type that retains measurement data. Subsequently, we can formulate either the weighted least-squares (WLS) or the least absolute value (LAV) DC state estimation model encapsulated within the type <code>DcStateEstimation</code> using:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.dcLavStateEstimation"><code>dcLavStateEstimation</code></a>.</li></ul><hr/><p>To obtain bus voltage angles and solve the DC state estimation problem, users can use the wrapper function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}"><code>solve!</code></a>.</li></ul><p>After solving the DC state estimation, JuliaGrid provides function for computing powers:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a>.</li></ul><p>Alternatively, instead of using functions responsible for solving state estimation and computing powers, users can use the wrapper function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{DcStateEstimation{WLS{T}}}, Tuple{T}} where T&lt;:Union{Normal, Orthogonal}"><code>stateEstimation!</code></a>.</li></ul><p>Users can also access specialized functions for computing specific types of <a href="../../api/analysis/#DCPowerAnalysisAPI">powers</a> for individual buses, branches, or generators within the power system.</p><hr/><h2 id="DCWLSStateEstimationSolutionManual"><a class="docs-heading-anchor" href="#DCWLSStateEstimationSolutionManual">Weighted Least-Squares Estimator</a><a id="DCWLSStateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCWLSStateEstimationSolutionManual" title="Permalink"></a></h2><p>To solve the DC state estimation and derive WLS estimates using JuliaGrid, the process initiates by defining <code>PowerSystem</code> and <code>Measurement</code> types. Here is an illustrative example:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;)
addBus!(system; label = &quot;Bus 3&quot;)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.5)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.2)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.3)

@wattmeter(label = &quot;Wattmeter ?&quot;)
addWattmeter!(monitoring; bus = &quot;Bus 1&quot;, active = 0.6, variance = 1e-3)
addWattmeter!(monitoring; bus = &quot;Bus 3&quot;, active = -0.4, variance = 1e-2)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 0.18, variance = 1e-4)
addWattmeter!(monitoring; to = &quot;Branch 2&quot;, active = -0.42, variance = 1e-4)</code></pre><p>The <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> function serves to establish the DC state estimation problem:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(monitoring)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here, the user triggers LU factorization as the default method for solving the DC state estimation problem. However, the user also has the option to select alternative factorization methods such as <code>LDLt</code> or <code>QR</code>:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(monitoring, LDLt)</code></pre></div></div><p>To obtain the bus voltage angles, the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function can be invoked as shown:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>Upon obtaining the solution, access the bus voltage angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: -0.09000000000000001
Bus 3: -0.08399999999999999</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on <a href="../../tutorials/dcStateEstimation/#DCSEModelTutorials">DC State Estimation</a> for insights into the implementation.</p></div></div><hr/><h5 id="Wrapper-Function"><a class="docs-heading-anchor" href="#Wrapper-Function">Wrapper Function</a><a id="Wrapper-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-Function" title="Permalink"></a></h5><p>JuliaGrid provides a wrapper function for DC state estimation analysis and also supports the computation of powers using the <a href="../../api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{DcStateEstimation{WLS{T}}}, Tuple{T}} where T&lt;:Union{Normal, Orthogonal}"><code>stateEstimation!</code></a> function:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(monitoring)
stateEstimation!(analysis; verbose = 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number of entries in the coefficient matrix: 10
Number of measurement functions:              4
Number of state variables:                    2

EXIT: The solution of the DC state estimation was found.</code></pre><hr/><h5 id="Alternative-Formulation"><a class="docs-heading-anchor" href="#Alternative-Formulation">Alternative Formulation</a><a id="Alternative-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Formulation" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from finding a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal factorization [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 3.2].</p><p>Specifically, by specifying the <code>Orthogonal</code> argument in the <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> function, JuliaGrid implements a more robust approach to obtain the WLS estimator, which proves particularly beneficial when substantial differences exist among measurement variances:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(monitoring, Orthogonal)
stateEstimation!(analysis)</code></pre><hr/><h5 id="Print-Results-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL">Print Results in the REPL</a><a id="Print-Results-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL" title="Permalink"></a></h5><p>Users have the option to print the results in the REPL using any units that have been configured, such as:</p><pre><code class="language-julia hljs">@voltage(pu, deg)
printBusData(analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-----------------|
| Bus Data        |
|-----------------|
| Label | Voltage |
|       |         |
|   Bus |   Angle |
|       |   [deg] |
|-------|---------|
| Bus 1 |  0.0000 |
| Bus 2 | -5.1566 |
| Bus 3 | -4.8128 |
|-----------------|</code></pre><p>Next, users can easily customize the print results for specific buses, for example:</p><pre><code class="language-julia hljs">printBusData(analysis; label = &quot;Bus 1&quot;, header = true)
printBusData(analysis; label = &quot;Bus 2&quot;)
printBusData(analysis; label = &quot;Bus 3&quot;, footer = true)</code></pre><hr/><h5 id="Save-Results-to-a-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-File">Save Results to a File</a><a id="Save-Results-to-a-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-File" title="Permalink"></a></h5><p>Users can also redirect print output to a file. For example, data can be saved in a text file as follows:</p><pre><code class="language-julia hljs">open(&quot;bus.txt&quot;, &quot;w&quot;) do file
    printBusData(analysis, file)
end</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We also provide functions to print state estimation results, such as estimated values and residuals. For more details, users can consult the <a href="#DCSEPowerAnalysisManual">Power Analysis</a> section of this manual.</p></div></div><hr/><h2 id="DCLAVtateEstimationSolutionManual"><a class="docs-heading-anchor" href="#DCLAVtateEstimationSolutionManual">Least Absolute Value Estimator</a><a id="DCLAVtateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCLAVtateEstimationSolutionManual" title="Permalink"></a></h2><p>The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data analysis procedures [<a href="../../background/bibliography/#aburbook">5</a>, Ch. 6]. However, it is important to note that achieving robustness typically involves increased computational complexity.</p><p>To obtain an LAV estimator, users need to employ one of the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:</p><pre><code class="language-julia hljs">using Ipopt

analysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer)</code></pre><hr/><h5 id="Setup-Initial-Primal-Values"><a class="docs-heading-anchor" href="#Setup-Initial-Primal-Values">Setup Initial Primal Values</a><a id="Setup-Initial-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Initial-Primal-Values" title="Permalink"></a></h5><p>In JuliaGrid, the assignment of initial primal values for optimization variables takes place when the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function is executed. These values are derived from the voltage angles stored in the <code>PowerSystem</code> type and are assigned to the corresponding <code>voltage</code> field within the <code>DcStateEstimation</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: 0.0
Bus 3: 0.0</code></pre><p>Users have the flexibility to customize these values according to their requirements, and they will be utilized as the initial primal values when executing the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function. One practical approach is to obtaine WLS estimator and then apply the resulting solution as the starting point for state estimation:</p><pre><code class="language-julia hljs">wls = dcStateEstimation(monitoring)
stateEstimation!(wls)

setInitialPoint!(analysis, wls)</code></pre><p>As a result, the initial primal values will now reflect the outcome of the WLS state estimation solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: -0.09000000000000001
Bus 3: -0.08399999999999999</code></pre><hr/><h5 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h5><p>To solve the formulated LAV state estimation model, simply execute the following function:</p><pre><code class="language-julia hljs">stateEstimation!(analysis)</code></pre><p>Upon obtaining the solution, access the bus voltage angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: -0.08999999999999997
Bus 3: -0.08399999999999999</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Readers can refer to the <a href="../../tutorials/dcStateEstimation/#DCSELAVTutorials">Least Absolute Value Estimation</a> tutorial for implementation insights.</p></div></div><hr/><h2 id="DCMeasurementsAlterationManual"><a class="docs-heading-anchor" href="#DCMeasurementsAlterationManual">Measurement Set Update</a><a id="DCMeasurementsAlterationManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCMeasurementsAlterationManual" title="Permalink"></a></h2><p>We begin by creating the <code>PowerSystem</code> and <code>Measurement</code> types with the <a href="../../api/measurementModel/#JuliaGrid.ems"><code>ems</code></a> function. The DC model is then configured using <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a> function. After that, we initialize the <code>DcStateEstimation</code> type through the <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> function and solve the resulting state estimation problem:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.5)

dcModel!(system)

@wattmeter(label = &quot;Wattmeter ?&quot;)
addWattmeter!(monitoring; bus = &quot;Bus 2&quot;, active = -0.11, variance = 1e-3)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 0.09, variance = 1e-4)

analysis = dcStateEstimation(monitoring)
stateEstimation!(analysis)</code></pre><p>Next, we modify the existing <code>Measurement</code> type using add and update functions. Then, we create the new <code>DcStateEstimation</code> type based on the modified system and solve the state estimation problem:</p><pre><code class="language-julia hljs">addWattmeter!(monitoring; to = &quot;Branch 1&quot;, active = -0.12, variance = 1e-4)
updateWattmeter!(monitoring; label = &quot;Wattmeter 1&quot;, status = 0)
updateWattmeter!(monitoring; label = &quot;Wattmeter 2&quot;, active = 0.1, noise = false)

analysis = dcStateEstimation(monitoring)
stateEstimation!(analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to restart and recreate the <code>Measurement</code> type from the beginning when implementing changes to the existing measurement set.</p></div></div><hr/><h2 id="DCStateEstimationUpdateManual"><a class="docs-heading-anchor" href="#DCStateEstimationUpdateManual">State Estimation Update</a><a id="DCStateEstimationUpdateManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCStateEstimationUpdateManual" title="Permalink"></a></h2><p>An advanced methodology involves users establishing the <code>DcStateEstimation</code> type using <a href="../../api/stateEstimation/#JuliaGrid.dcStateEstimation"><code>dcStateEstimation</code></a> or <a href="../../api/stateEstimation/#JuliaGrid.dcLavStateEstimation"><code>dcLavStateEstimation</code></a> just once. After this initial setup, users can seamlessly modify existing measurement devices without the need to recreate the <code>DcStateEstimation</code> type.</p><p>This advancement extends beyond the previous scenario where recreating the <code>Measurement</code> type was unnecessary, to now include the scenario where <code>DcStateEstimation</code> also does not need to be recreated. Such efficiency can be particularly advantageous in cases where JuliaGrid can reuse gain matrix factorization.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The addition of new measurements after the creation of <code>DcStateEstimation</code> is not practical in terms of reusing this type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.</p></div></div><p>Let us now revisit our defined <code>PowerSystem</code>, <code>Measurement</code> and <code>DcStateEstimation</code> types:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.5)

dcModel!(system)

@wattmeter(label = &quot;Wattmeter ?&quot;)
addWattmeter!(monitoring; bus = &quot;Bus 2&quot;, active = -0.11, variance = 1e-3)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 0.09, variance = 1e-4)
addWattmeter!(monitoring; to = &quot;Branch 1&quot;, active = -0.12, variance = 1e-4, status = 0)

analysis = dcStateEstimation(monitoring)
stateEstimation!(analysis)</code></pre><p>Next, we modify the existing <code>Measurement</code> type as well as the <code>DcStateEstimation</code> type using add and update functions. We then immediately proceed to solve the state estimation problem:</p><pre><code class="language-julia hljs">updateWattmeter!(analysis; label = &quot;Wattmeter 1&quot;, status = 0)
updateWattmeter!(analysis; label = &quot;Wattmeter 2&quot;, active = 0.1)
updateWattmeter!(analysis; label = &quot;Wattmeter 3&quot;, status = 1, noise = false)

stateEstimation!(analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to rebuild both the <code>Measurement</code> and the <code>DcStateEstimation</code> from the beginning when implementing changes to the existing measurement set. In the scenario of employing the WLS model, JuliaGrid can reuse the symbolic factorizations of LU or LDLt, provided that the nonzero pattern of the gain matrix remains unchanged.</p></div></div><hr/><h5 id="Reusing-Weighted-Least-Squares-Matrix-Factorization"><a class="docs-heading-anchor" href="#Reusing-Weighted-Least-Squares-Matrix-Factorization">Reusing Weighted Least-Squares Matrix Factorization</a><a id="Reusing-Weighted-Least-Squares-Matrix-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Reusing-Weighted-Least-Squares-Matrix-Factorization" title="Permalink"></a></h5><p>Drawing from the preceding example, our focus now shifts to finding a solution involving modifications that entail adjusting the measurement value of the <code>Wattmeter 2</code>. It is important to note that these adjustments do not impact the variance or status of the measurement device, which can affect the gain matrix. To resolve this updated system, users can simply execute the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">updateWattmeter!(analysis; label = &quot;Wattmeter 2&quot;, active = 0.091)

stateEstimation!(analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In this scenario, JuliaGrid will recognize instances where the user has not modified parameters that impact the gain matrix. Consequently, JuliaGrid will leverage the previously performed gain matrix factorization, resulting in a significantly faster solution compared to recomputing the factorization.</p></div></div><hr/><h2 id="DCSEPowerAnalysisManual"><a class="docs-heading-anchor" href="#DCSEPowerAnalysisManual">Power Analysis</a><a id="DCSEPowerAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEPowerAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the DC state estimation, calculating powers related to buses and branches is facilitated by using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function. For instance, let us consider the model for which we obtained the DC state estimation solution:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, conductance = 1e-3)
addBus!(system; label = &quot;Bus 2&quot;)
addBus!(system; label = &quot;Bus 3&quot;)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.5)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.2)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.3)

addWattmeter!(monitoring; bus = &quot;Bus 1&quot;, active = 0.6, variance = 1e-3)
addWattmeter!(monitoring; bus = &quot;Bus 3&quot;, active = -0.4, variance = 1e-2)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 0.18, variance = 1e-4)
addWattmeter!(monitoring; to = &quot;Branch 2&quot;, active = -0.42, variance = 1e-4)

analysis = dcStateEstimation(monitoring)
stateEstimation!(analysis)</code></pre><p>We can compute active powers using the following function:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><p>For example, active power injections corresponding to buses are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.6008333333333332
Bus 2: -0.19983333333333342
Bus 3: -0.4</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers associated with buses, and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function, we suggest referring to the tutorials on.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL-2">Print Results in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL-2" title="Permalink"></a></h5><p>Users can utilize any of the print functions outlined in the <a href="../../api/setupPrint/#setupPrintAPI">Print API</a> related to the DC analysis. For example, to print state estimation data related to wattmeters, we can use:</p><pre><code class="language-julia hljs">@power(MW, pu)
printWattmeterData(analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|---------------------------------------------------------------|
| Wattmeter Data                                                |
|---------------------------------------------------------------|
| Label |                     Active Power                      |
|       |                                                       |
|       | Measurement | Variance | Estimate | Residual | Status |
|       |        [MW] |     [MW] |     [MW] |     [MW] |        |
|-------|-------------|----------|----------|----------|--------|
| 1     |     60.0000 | 1.00e-01 |  60.0833 |  -0.0833 |      1 |
| 2     |    -40.0000 | 1.00e+00 | -40.0000 |   0.0000 |      1 |
| 3     |     18.0000 | 1.00e-02 |  17.9917 |   0.0083 |      1 |
| 4     |    -42.0000 | 1.00e-02 | -41.9917 |  -0.0083 |      1 |
|---------------------------------------------------------------|</code></pre><hr/><h5 id="Save-Results-to-a-CSV-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-CSV-File">Save Results to a CSV File</a><a id="Save-Results-to-a-CSV-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-CSV-File" title="Permalink"></a></h5><p>For CSV output, users should first generate a simple table with <code>style = false</code>, and then save it to a CSV file:</p><pre><code class="language-julia hljs">using CSV

io = IOBuffer()
printWattmeterData(analysis, io; style = false)
CSV.write(&quot;bus.csv&quot;, CSV.File(take!(io); delim = &quot;|&quot;))</code></pre><hr/><h5 id="Active-Power-Injection"><a class="docs-heading-anchor" href="#Active-Power-Injection">Active Power Injection</a><a id="Active-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection" title="Permalink"></a></h5><p>To calculate active power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = injectionPower(analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.6008333333333332</code></pre><hr/><h5 id="Active-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-Power-Injection-from-Generators">Active Power Injection from Generators</a><a id="Active-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate active power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = supplyPower(analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.6008333333333332</code></pre><hr/><h5 id="Active-Power-Flow"><a class="docs-heading-anchor" href="#Active-Power-Flow">Active Power Flow</a><a id="Active-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = fromPower(analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.17991666666666667</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = toPower(analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-0.17991666666666667</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pmuStateEstimation/">« PMU State Estimation</a><a class="docs-footer-nextpage" href="../badDataAnalysis/">Bad Data Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 6 May 2025 11:40">Tuesday 6 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
