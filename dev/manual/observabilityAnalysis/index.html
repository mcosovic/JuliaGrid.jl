<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Observability Analysis · JuliaGrid</title><meta name="title" content="Observability Analysis · JuliaGrid"/><meta property="og:title" content="Observability Analysis · JuliaGrid"/><meta property="twitter:title" content="Observability Analysis · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li class="is-active"><a class="tocitem" href>Observability Analysis</a><ul class="internal"><li><a class="tocitem" href="#Identification-of-Observable-Islands"><span>Identification of Observable Islands</span></a></li><li><a class="tocitem" href="#Observability-Restoration"><span>Observability Restoration</span></a></li><li><a class="tocitem" href="#Optimal-PMU-Placement"><span>Optimal PMU Placement</span></a></li></ul></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Observability Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Observability Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/observabilityAnalysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ObservabilityAnalysisManual"><a class="docs-heading-anchor" href="#ObservabilityAnalysisManual">Observability Analysis</a><a id="ObservabilityAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ObservabilityAnalysisManual" title="Permalink"></a></h1><p>Observability analysis can typically be performed prior to executing the state estimation algorithm, and its primary task is to ensure the existence of a unique state estimator. In other words, the system of equations used in the state estimation algorithm should be solvable.</p><p>Traditionally, observability analysis, which involves identifying observable islands and restoring observability using set of pseudo-measurements, can be performed before both AC and DC state estimation. In this context, users can detect two types of observable islands: flow islands and maximal islands:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.islandTopologicalFlow"><code>islandTopologicalFlow</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.islandTopological"><code>islandTopological</code></a>.</li></ul><p>Once observable islands are identified, observability can be restored by applying:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.restorationGram!"><code>restorationGram!</code></a>.</li></ul><p>Additionally, the optimal PMU placement algorithm can also be viewed from the perspective of observability, as it determines the minimal set of PMUs required to make the system observable and guarantee a unique solution in AC and PMU state estimation, regardless of other measurements:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.pmuPlacement"><code>pmuPlacement</code></a>.</li></ul><hr/><h2 id="Identification-of-Observable-Islands"><a class="docs-heading-anchor" href="#Identification-of-Observable-Islands">Identification of Observable Islands</a><a id="Identification-of-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Identification-of-Observable-Islands" title="Permalink"></a></h2><p>The first step in the process is to define observable islands. JuliaGrid offers two distinct options for identifying these islands: flow-observable islands and maximal-observable islands. The choice depends on the power system&#39;s structure and available measurements. Identifying only flow-observable islands simplifies the island detection process but makes the restoration function more complex.</p><p>Let us begin by defining a power system with measurements at specific locations:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;)
addBus!(system; label = &quot;Bus 3&quot;)
addBus!(system; label = &quot;Bus 4&quot;)
addBus!(system; label = &quot;Bus 5&quot;)
addBus!(system; label = &quot;Bus 6&quot;)
addBus!(system; label = &quot;Bus 7&quot;)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.002)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 5&quot;, reactance = 0.02)
addBranch!(system; label = &quot;Branch 4&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 4&quot;, reactance = 0.03)
addBranch!(system; label = &quot;Branch 5&quot;, from = &quot;Bus 5&quot;, to = &quot;Bus 6&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 6&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 5&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 7&quot;, from = &quot;Bus 6&quot;, to = &quot;Bus 7&quot;, reactance = 0.05)

addWattmeter!(monitoring; label = &quot;Wattmeter 1&quot;, from = &quot;Branch 1&quot;, active = 1.15)
addVarmeter!(monitoring; label = &quot;Varmeter 1&quot;, from = &quot;Branch 1&quot;, reactive = -0.50)

addWattmeter!(monitoring; label = &quot;Wattmeter 2&quot;, from = &quot;Branch 4&quot;, active = 0.20)
addVarmeter!(monitoring; label = &quot;Varmeter 2&quot;, from = &quot;Branch 4&quot;, reactive = -0.02)

addWattmeter!(monitoring; label = &quot;Wattmeter 3&quot;, from = &quot;Branch 5&quot;, active = -0.20)
addVarmeter!(monitoring; label = &quot;Varmeter 3&quot;, from = &quot;Branch 5&quot;, reactive = 0.02)

addWattmeter!(monitoring; label = &quot;Wattmeter 4&quot;, bus = &quot;Bus 2&quot;, active = -0.1)
addVarmeter!(monitoring; label = &quot;Varmeter 4&quot;, bus = &quot;Bus 2&quot;, reactive = -0.01)

addWattmeter!(monitoring; label = &quot;Wattmeter 5&quot;, bus = &quot;Bus 3&quot;, active = -0.30)
addVarmeter!(monitoring; label = &quot;Varmeter 5&quot;, bus = &quot;Bus 3&quot;, reactive = 0.66)</code></pre><p>Attempting to solve this system directly using AC or DC state estimation may not be feasible, as the gain matrix would be singular. To prevent this issue, users can first conduct an observability analysis.</p><p>JuliaGrid employs standard observability analysis performed on the linear decoupled measurement model. Active power measurements from wattmeters are utilized to estimate bus voltage angles, while reactive power measurements from varmeters are used to estimate bus voltage magnitudes. This necessitates that measurements of active and reactive power come in pairs.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We suggest that readers refer to the tutorial on <a href="../../tutorials/observabilityAnalysis/#ACObservabilityAnalysisTutorials">Observability Analysis</a> for insights into the implementation.</p></div></div><hr/><h5 id="Flow-Observable-Islands"><a class="docs-heading-anchor" href="#Flow-Observable-Islands">Flow-Observable Islands</a><a id="Flow-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-Observable-Islands" title="Permalink"></a></h5><p>Now, let us identify flow-observable islands:</p><pre><code class="language-julia hljs">islands = islandTopologicalFlow(monitoring)</code></pre><p>As a result, four flow-observable islands are identified: <code>Bus 1</code> and <code>Bus 2</code> form the first island, <code>Bus 3</code> and <code>Bus 4</code> form the second island, <code>Bus 5</code> and <code>Bus 6</code> constitute the third island, while <code>Bus 7</code> forms the fourth island:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]
 [7]</code></pre><hr/><h5 id="Maximal-Observable-Islands"><a class="docs-heading-anchor" href="#Maximal-Observable-Islands">Maximal-Observable Islands</a><a id="Maximal-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-Observable-Islands" title="Permalink"></a></h5><p>Following that, we will instruct the user on obtaining maximal-observable islands:</p><pre><code class="language-julia hljs">islands = islandTopological(monitoring)</code></pre><p>The outcome reveals the identification of two maximal-observable islands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5, 6]
 [7]</code></pre><p>It is evident that upon comparing this result with the flow-observable islands, the merging of the two injection measurements at <code>Bus 2</code> and <code>Bus 3</code> consolidated the first, second, and third flow-observable islands into a single island.</p><hr/><h2 id="Observability-Restoration"><a class="docs-heading-anchor" href="#Observability-Restoration">Observability Restoration</a><a id="Observability-Restoration-1"></a><a class="docs-heading-anchor-permalink" href="#Observability-Restoration" title="Permalink"></a></h2><p>Before commencing the restoration of observability in the context of the linear decoupled measurement model and observability analysis, it is imperative to ensure that the system possesses one bus voltage magnitude measurement. This necessity arises from the fact that observable islands are identified based on wattmeters, where wattmeters are tasked with estimating voltage angles. Since one voltage angle is already known from the slack bus, the same principle should be applied to bus voltage magnitudes. Therefore, to address this requirement, we add:</p><pre><code class="language-julia hljs">addVoltmeter!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 1.0)</code></pre><p>Subsequently, the user needs to establish a set of pseudo-measurements, where measurements must come in pairs as well. Let us create that set:</p><pre><code class="language-julia hljs">pseudo = measurement(system)

addWattmeter!(pseudo; label = &quot;Pseudo-Wattmeter 1&quot;, bus = &quot;Bus 1&quot;, active = 0.31)
addVarmeter!(pseudo; label = &quot;Pseudo-Varmeter 1&quot;, bus = &quot;Bus 1&quot;, reactive = -0.19)

addWattmeter!(pseudo; label = &quot;Pseudo-Wattmeter 2&quot;, from = &quot;Branch 7&quot;, active = 0.10)
addVarmeter!(pseudo; label = &quot;Pseudo-Varmeter 2&quot;, from = &quot;Branch 7&quot;, reactive = 0.01)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The labels for specific pseudo-measurements must differ from those defined in the measurements stored in the <code>monitoring</code> set. This is necessary because the next step involves adding pseudo-measurements to the <code>monitoring</code> set.</p></div></div><p>Subsequently, the user can execute the <a href="../../api/stateEstimation/#JuliaGrid.restorationGram!"><code>restorationGram!</code></a> function:</p><pre><code class="language-julia hljs">restorationGram!(monitoring, pseudo, islands)</code></pre><p>This function attempts to restore observability using pseudo-measurements. As a result, the inclusion of measurements from <code>Pseudo-Wattmeter 2</code> and <code>Pseudo-Varmeter 2</code> facilitates observability restoration, and these measurements are subsequently added to the <code>monitoring</code> variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.wattmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 6 entries:
  &quot;Wattmeter 1&quot;        =&gt; 1
  &quot;Wattmeter 2&quot;        =&gt; 2
  &quot;Wattmeter 3&quot;        =&gt; 3
  &quot;Wattmeter 4&quot;        =&gt; 4
  &quot;Wattmeter 5&quot;        =&gt; 5
  &quot;Pseudo-Wattmeter 2&quot; =&gt; 6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.varmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 6 entries:
  &quot;Varmeter 1&quot;        =&gt; 1
  &quot;Varmeter 2&quot;        =&gt; 2
  &quot;Varmeter 3&quot;        =&gt; 3
  &quot;Varmeter 4&quot;        =&gt; 4
  &quot;Varmeter 5&quot;        =&gt; 5
  &quot;Pseudo-Varmeter 2&quot; =&gt; 6</code></pre><p>Consequently, the power system becomes observable, allowing the user to proceed with forming the AC state estimation model and solving it. Ensuring the observability of the system does not guarantee obtaining accurate estimates of the state variables. Numerical ill-conditioning may adversely impact the state estimation algorithm. However, in most cases, efficient estimation becomes feasible when the system is observable [<a href="../../background/bibliography/#korres2011observability">3</a>].</p><p>It is also important to note that restoration may face challenges if an inappropriate zero pivot threshold value is selected. By default, this threshold is set to <code>1e-5</code>, but it can be adjusted using the <a href="../../api/stateEstimation/#JuliaGrid.restorationGram!"><code>restorationGram!</code></a> function.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>During the restoration step, if users define bus phasor measurements, these measurements will be considered. Consequently, the system may achieve observability even if multiple islands persist.</p></div></div><hr/><h2 id="Optimal-PMU-Placement"><a class="docs-heading-anchor" href="#Optimal-PMU-Placement">Optimal PMU Placement</a><a id="Optimal-PMU-Placement-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-PMU-Placement" title="Permalink"></a></h2><p>JuliGrid supports two modes for determining optimal PMU placement to make the system observable:</p><ul><li>without legacy measurements,</li><li>with legacy measurements.</li></ul><p>Here, legacy measurements refer only to power flow and injection data. When users choose to include legacy measurements for optimal PMU placement, we assume active and reactive power measurements always appear as pairs. The optimal PMU placement is then determined using only the active power measurements.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We suggest that readers refer to the tutorial on <a href="../../tutorials/observabilityAnalysis/#optimalpmu">Optimal PMU Placement</a> for insights into the implementation.</p></div></div><p>First, create the power system together with the associated monitoring object that will contain the measurements:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;)
addBus!(system; label = &quot;Bus 3&quot;)
addBus!(system; label = &quot;Bus 4&quot;)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)
addBranch!(system; label = &quot;Branch 4&quot;, from = &quot;Bus 3&quot;, to = &quot;Bus 4&quot;, reactance = 0.04)

addWattmeter!(monitoring; bus = &quot;Bus 3&quot;, active = 0.2)
addVarmeter!(monitoring; bus = &quot;Bus 3&quot;, reactive = 0.1)</code></pre><hr/><h5 id="Optimal-Solution-Without-Legacy-Measurements"><a class="docs-heading-anchor" href="#Optimal-Solution-Without-Legacy-Measurements">Optimal Solution Without Legacy Measurements</a><a id="Optimal-Solution-Without-Legacy-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Solution-Without-Legacy-Measurements" title="Permalink"></a></h5><p>After defining the <code>PowerSystem</code> and <code>Measurement</code> types, JuliaGrid allows the determination of the minimal number of PMUs required for system observability using the <a href="../../api/stateEstimation/#JuliaGrid.pmuPlacement"><code>pmuPlacement</code></a> function:</p><pre><code class="language-julia hljs">using GLPK

placement = pmuPlacement(monitoring, GLPK.Optimizer; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><p>In this case, legacy measurements are omitted. The placement variable contains the data for the optimal PMU configuration. Installing PMUs at <code>Bus 2</code> and <code>Bus 3</code> makes the system observable using only these two devices:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.bus)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{String, Int64} with 2 entries. Keys:
  &quot;Bus 2&quot;
  &quot;Bus 3&quot;</code></pre><p>The PMUs installed at <code>Bus 2</code> and <code>Bus 3</code> measure the bus voltage phasor at their respective buses, along with the current phasors of all branches incident to these buses, both at the from-bus and to-bus ends:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.from)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{String, Int64} with 2 entries. Keys:
  &quot;Branch 3&quot;
  &quot;Branch 4&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.to)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{String, Int64} with 3 entries. Keys:
  &quot;Branch 1&quot;
  &quot;Branch 2&quot;
  &quot;Branch 3&quot;</code></pre><hr/><h5 id="Optimal-Solution-with-Legacy-Measurements"><a class="docs-heading-anchor" href="#Optimal-Solution-with-Legacy-Measurements">Optimal Solution with Legacy Measurements</a><a id="Optimal-Solution-with-Legacy-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Solution-with-Legacy-Measurements" title="Permalink"></a></h5><p>Next, we determine the PMU placement that ensures observability while also including legacy measurements:</p><pre><code class="language-julia hljs">placement = pmuPlacement(monitoring, GLPK.Optimizer; legacy = true, verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><p>In this case, installing a PMU at <code>Bus 2</code> is sufficient to render the system observable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.bus)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{String, Int64} with 1 entry. Keys:
  &quot;Bus 2&quot;</code></pre><hr/><h5 id="Phasor-Measurements"><a class="docs-heading-anchor" href="#Phasor-Measurements">Phasor Measurements</a><a id="Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Phasor-Measurements" title="Permalink"></a></h5><p>Using the obtained data, phasor measurements can be created to provide a unique state estimator for both AC and PMU state estimation:</p><pre><code class="language-julia hljs">addPmu!(monitoring; bus = &quot;Bus 2&quot;, magnitude = 1.02, angle = 0.01)
addPmu!(monitoring; from = &quot;Branch 3&quot;, magnitude = 0.49, angle = 0.07)
addPmu!(monitoring; to = &quot;Branch 1&quot;, magnitude = 0.47, angle = -0.54)
addPmu!(monitoring; to = &quot;Branch 2&quot;, magnitude = 1.17, angle = 0.16)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For different approaches to defining measurements after determining the optimal PMU placement, refer to the <a href="../pmuStateEstimation/#PhasorMeasurementsManual">PMU State Estimation</a> manual or the API documentation for the <a href="../../api/stateEstimation/#JuliaGrid.pmuPlacement!"><code>pmuPlacement!</code></a> function.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../measurementModel/">« Measurement Model</a><a class="docs-footer-nextpage" href="../acStateEstimation/">AC State Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 2 October 2025 18:47">Thursday 2 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
