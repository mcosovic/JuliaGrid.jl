<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow · JuliaGrid</title><meta name="title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="og:title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="twitter:title" content="DC Optimal Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimalPowerFlowModelManual"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#DCOptimizationVariablesManual"><span>Optimization Variables</span></a></li><li><a class="tocitem" href="#DCConstraintFunctionsManual"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#DCObjectiveFunctionManual"><span>Objective Function</span></a></li><li><a class="tocitem" href="#SetupStartingPrimalValuesManual"><span>Setup Initial Values</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionManual"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#Primal-and-Dual-Warm-Start"><span>Primal and Dual Warm Start</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisManual"><span>Power Analysis</span></a></li></ul></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/dcOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowManual">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowManual" title="Permalink"></a></h1><p>Similar to <a href="../acOptimalPowerFlow/#ACOptimalPowerFlowManual">AC Optimal Power Flow</a>, JuliaGrid utilizes the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package to construct optimal power flow models, enabling users to manipulate these models using the standard functions provided by JuMP. JuliaGrid supports popular <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> mentioned in the JuMP documentation to solve the optimization problem.</p><p>To perform the DC optimal power flow, we first need to have the <code>PowerSystem</code> type that has been created with the DC model. After that, create the <code>DcOptimalPowerFlow</code> type to establish the DC optimal power flow framework using the function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a>.</li></ul><hr/><p>To solve the DC optimal power flow problem and acquire generator active power outputs and bus voltage angles, users can use of the following function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>After solving the DC optimal power flow, JuliaGrid provides function for computing powers:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{DcPowerFlow}"><code>power!</code></a>.</li></ul><p>Alternatively, instead of using functions responsible for solving optimal power flow and computing powers, users can use the wrapper function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{DcOptimalPowerFlow}"><code>powerFlow!</code></a>.</li></ul><p>Users can also access specialized functions for computing specific types of <a href="../../api/analysis/#DCPowerAnalysisAPI">powers</a> for individual buses, branches, or generators within the power system.</p><hr/><h2 id="DCOptimalPowerFlowModelManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowModelManual">Optimal Power Flow Model</a><a id="DCOptimalPowerFlowModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowModelManual" title="Permalink"></a></h2><p>To set up the DC optimal power flow, we begin by creating the model. To illustrate this, consider the following:</p><pre><code class="language-julia hljs">using JuMP, HiGHS

system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05)

@branch(minDiffAngle = -3.1, maxDiffAngle = 3.1, minFromBus = -0.12, maxFromBus = 0.12)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)

@generator(minActive = 0.0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.6, maxActive = 0.8)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.1, maxActive = 0.3)
addGenerator!(system; label = &quot;Generator 3&quot;, bus = &quot;Bus 2&quot;, active = 0.2, maxActive = 0.4)

cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; generator = &quot;Generator 2&quot;, active = 1, piecewise = [8.0 11.0; 14.0 17.0])
cost!(system; generator = &quot;Generator 3&quot;, active = 1, piecewise = [6 12.3; 8.7 16.8; 11 19])

dcModel!(system)</code></pre><p>Next, the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function is utilized to formulate the DC optimal power flow problem:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)</code></pre><hr/><h2 id="DCOptimizationVariablesManual"><a class="docs-heading-anchor" href="#DCOptimizationVariablesManual">Optimization Variables</a><a id="DCOptimizationVariablesManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimizationVariablesManual" title="Permalink"></a></h2><p>In DC optimal power flow, generator active power outputs are linear functions of bus voltage angles. Thus, the model&#39;s variables include generator active power outputs and bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.all_variables(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{VariableRef}:
 angle[1]
 angle[2]
 angle[3]
 active[1]
 active[2]
 active[3]
 actwise[3]</code></pre><p>It is important to highlight that when dealing with piecewise linear cost functions comprising multiple segments, as exemplified in the case of <code>Generator 3</code>, JuliaGrid automatically generates helper optimization variables, such as <code>actwise[3]</code>, and formulates a set of linear constraints to appropriately handle these cost functions.</p><p>However, in instances where a piecewise linear cost function consists of only a single segment, as demonstrated by <code>Generator 2</code>, the function is modelled as a standard linear function, eliminating the necessity for additional helper optimization variables.</p><p>Please note that JuliaGrid keeps references to all variables categorized into three fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.variable.voltage))</code><code class="nohighlight hljs ansi" style="display:block;">(:angle,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.variable.power))</code><code class="nohighlight hljs ansi" style="display:block;">(:active, :actwise)</code></pre><hr/><h5 id="Variable-Names"><a class="docs-heading-anchor" href="#Variable-Names">Variable Names</a><a id="Variable-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Names" title="Permalink"></a></h5><p>Users have the option to define custom variable names for printing equations, which can help present them in a more compact form. For example:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer; active = &quot;P&quot;, angle = &quot;θ&quot;)</code></pre><hr/><h5 id="Add-Variables"><a class="docs-heading-anchor" href="#Add-Variables">Add Variables</a><a id="Add-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variables" title="Permalink"></a></h5><p>The user has the ability to easily add new variables to the defined DC optimal power flow model by using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.@variable"><code>@variable</code></a> macro from the JuMP package:</p><pre><code class="language-julia hljs">JuMP.@variable(analysis.method.jump, newVariable)</code></pre><p>We can verify that the new variable is included in the defined model by using the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.method.jump, newVariable)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><h5 id="Delete-Variables"><a class="docs-heading-anchor" href="#Delete-Variables">Delete Variables</a><a id="Delete-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Variables" title="Permalink"></a></h5><p>To delete a variable, the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.delete"><code>delete</code></a> function from the JuMP package can be used:</p><pre><code class="language-julia hljs">JuMP.delete(analysis.method.jump, newVariable)</code></pre><p>After deletion, the variable is no longer part of the model:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.method.jump, newVariable)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><h2 id="DCConstraintFunctionsManual"><a class="docs-heading-anchor" href="#DCConstraintFunctionsManual">Constraint Functions</a><a id="DCConstraintFunctionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCConstraintFunctionsManual" title="Permalink"></a></h2><p>JuliGrid keeps track of all the references to internally formed constraints in the <code>constraint</code> field of the <code>DcOptimalPowerFlow</code> type. These constraints are divided into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.constraint))</code><code class="nohighlight hljs ansi" style="display:block;">(:slack, :balance, :voltage, :flow, :capability, :piecewise)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We suggest that readers refer to the tutorial on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowTutorials">DC Optimal Power Flow</a> for insights into the implementation.</p></div></div><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The <code>slack</code> field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function using the <code>angle</code> keyword:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: θ[1] = 0.17</code></pre><p>Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> function, for example:</p><pre><code class="language-julia hljs">updateBus!(analysis; label = &quot;Bus 1&quot;, angle = -0.1)</code></pre><p>Subsequently, the updated slack constraint can be inspected as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: θ[1] = -0.1</code></pre><hr/><h5 id="Bus-Active-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Bus-Active-Power-Balance-Constraints">Bus Active Power Balance Constraints</a><a id="Bus-Active-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Active-Power-Balance-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> field contains references to the equality constraints associated with the active power balance equations defined for each bus. The constant terms in these equations are determined by the <code>active</code> and <code>conductance</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. Additionally, if there are phase shift transformers in the system, the constant terms can also be affected by the <code>shiftAngle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -120 θ[1] + 20 θ[2] + 100 θ[3] + P[1] = 0
Bus 2: 20 θ[1] - 120 θ[2] + 100 θ[3] + P[2] + P[3] = 0.14
Bus 3: 100 θ[1] + 100 θ[2] - 200 θ[3] = 0.05</code></pre><p>During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system, for example:</p><pre><code class="language-julia hljs">updateBus!(analysis; label = &quot;Bus 3&quot;, active = 0.1)
updateGenerator!(analysis; label = &quot;Generator 2&quot;, status = 0)</code></pre><p>Subsequently, the updated set of active power balance constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -120 θ[1] + 20 θ[2] + 100 θ[3] + P[1] = 0
Bus 2: 20 θ[1] - 120 θ[2] + 100 θ[3] + P[3] = 0.14
Bus 3: 100 θ[1] + 100 θ[2] - 200 θ[3] = 0.1</code></pre><hr/><h5 id="Bus-Voltage-Angle-Difference-Constraints"><a class="docs-heading-anchor" href="#Bus-Voltage-Angle-Difference-Constraints">Bus Voltage Angle Difference Constraints</a><a id="Bus-Voltage-Angle-Difference-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Angle-Difference-Constraints" title="Permalink"></a></h5><p>The <code>voltage</code> field contains references to the inequality constraints associated with the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch. These values are specified using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-3.1, 3.1]
Branch 2: θ[1] - θ[3] ∈ [-3.1, 3.1]
Branch 3: θ[2] - θ[3] ∈ [-3.1, 3.1]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Please note that if the limit constraints are set to <code>minDiffAngle = -2π</code> and <code>maxDiffAngle = 2π</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p></div></div><p>Additionally, by employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, we have the ability to modify these constraints as follows:</p><pre><code class="language-julia hljs">updateBranch!(analysis; label = &quot;Branch 1&quot;, minDiffAngle = -1.7, maxDiffAngle = 1.7)</code></pre><p>Subsequently, the updated set of voltage angle difference constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-1.7, 1.7]
Branch 2: θ[1] - θ[3] ∈ [-3.1, 3.1]
Branch 3: θ[2] - θ[3] ∈ [-3.1, 3.1]</code></pre><hr/><h5 id="Branch-Active-Power-Flow-Constraints"><a class="docs-heading-anchor" href="#Branch-Active-Power-Flow-Constraints">Branch Active Power Flow Constraints</a><a id="Branch-Active-Power-Flow-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Active-Power-Flow-Constraints" title="Permalink"></a></h5><p>The <code>flow</code> field refers to the inequality constraints associated with active power flow limits at the from-bus end of each branch. These limits are set using the <code>minFromBus</code> and <code>maxFromBus</code> keywords in the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: 20 θ[1] - 20 θ[2] ∈ [-0.12, 0.12]
Branch 2: 100 θ[1] - 100 θ[3] ∈ [-0.12, 0.12]
Branch 3: 100 θ[2] - 100 θ[3] ∈ [-0.12, 0.12]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If the branch flow limits are set to <code>minFromBus = 0.0</code> and <code>maxFromBus = 0.0</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p></div></div><p>By employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, we have the ability to modify these specific constraints, for example:</p><pre><code class="language-julia hljs">updateBranch!(analysis; label = &quot;Branch 1&quot;, status = 0)
updateBranch!(analysis; label = &quot;Branch 2&quot;, reactance = 0.03, maxFromBus = 0.14)</code></pre><p>Subsequently, the updated set of active power flow constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: 33.333333333333336 θ[1] - 33.333333333333336 θ[3] ∈ [-0.12, 0.14]
Branch 3: 100 θ[2] - 100 θ[3] ∈ [-0.12, 0.12]</code></pre><hr/><h5 id="Generator-Active-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Generator-Active-Power-Capability-Constraints">Generator Active Power Capability Constraints</a><a id="Generator-Active-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Active-Power-Capability-Constraints" title="Permalink"></a></h5><p>The <code>capability</code> field contains references to the inequality constraints associated with the minimum and maximum active power outputs of the generators. These limits are specified using the <code>minActive</code> and <code>maxActive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: P[1] ∈ [0, 0.8]
Generator 2: P[2] = 0
Generator 3: P[3] ∈ [0, 0.4]</code></pre><p>As demonstrated, the active power output of <code>Generator 2</code> is currently fixed at zero due to the earlier action of setting this generator out-of-service. Let us adjust this specific constraint using the <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a> function:</p><pre><code class="language-julia hljs">updateGenerator!(analysis; label = &quot;Generator 2&quot;, status = 1, maxActive = 0.5)</code></pre><p>Subsequently, the updated set of active power capability constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: P[1] ∈ [0, 0.8]
Generator 2: P[2] ∈ [0, 0.5]
Generator 3: P[3] ∈ [0, 0.4]</code></pre><p>It is important to note that bringing back <code>Generator 2</code> into service will also have an impact on the balance constraint, which will once again be influenced by the generator&#39;s output.</p><hr/><h5 id="Active-Power-Piecewise-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Piecewise-Constraints">Active Power Piecewise Constraints</a><a id="Active-Power-Piecewise-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Piecewise-Constraints" title="Permalink"></a></h5><p>In the context of active power modelling, the <code>piecewise</code> field serves as a reference to the inequality constraints related to linear piecewise cost functions. These constraints are created using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function with <code>active = 1</code> specified when dealing with piecewise linear cost functions comprising multiple segments. JuliaGrid takes care of establishing the appropriate inequality constraints for each segment of the piecewise linear cost:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 3: 1.6666666666666672 P[3] - actwise[3] ≤ -2.299999999999997
Generator 3: 0.9565217391304341 P[3] - actwise[3] ≤ -8.478260869565224</code></pre><p>It is worth noting that these constraints can also be automatically updated using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function, and readers can find more details in the section about the objective function.</p><hr/><h5 id="Add-Constraints"><a class="docs-heading-anchor" href="#Add-Constraints">Add Constraints</a><a id="Add-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Constraints" title="Permalink"></a></h5><p>Users can effortlessly introduce additional constraints into the defined DC optimal power flow model by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> or <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> functions. Specifically, if a user wishes to include a new branch or generator in an already defined <code>PowerSystem</code> and <code>DcOptimalPowerFlow</code> type:</p><pre><code class="language-julia hljs">addBranch!(analysis; label = &quot;Branch 4&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 1)
addGenerator!(analysis; label = &quot;Generator 4&quot;, bus = &quot;Bus 1&quot;, maxActive = 0.2)</code></pre><p>As a result, the flow and capability constraints will be adjusted as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: 33.333333333333336 θ[1] - 33.333333333333336 θ[3] ∈ [-0.12, 0.14]
Branch 3: 100 θ[2] - 100 θ[3] ∈ [-0.12, 0.12]
Branch 4: θ[1] - θ[2] ∈ [-0.12, 0.12]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: P[1] ∈ [0, 0.8]
Generator 2: P[2] ∈ [0, 0.5]
Generator 3: P[3] ∈ [0, 0.4]
Generator 4: P[4] ∈ [0, 0.2]</code></pre><hr/><h5 id="Add-User-Defined-Constraints"><a class="docs-heading-anchor" href="#Add-User-Defined-Constraints">Add User-Defined Constraints</a><a id="Add-User-Defined-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-User-Defined-Constraints" title="Permalink"></a></h5><p>Users also have the option to include their custom constraints within the established DC optimal power flow model by employing the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.@constraint"><code>@constraint</code></a> macro. For example, the addition of a new constraint can be achieved as follows:</p><pre><code class="language-julia hljs">JuMP.@constraint(analysis.method.jump, 0 &lt;= analysis.method.variable.power.active[4] &lt;= 0.3)</code></pre><hr/><h5 id="Delete-Constraints"><a class="docs-heading-anchor" href="#Delete-Constraints">Delete Constraints</a><a id="Delete-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints" title="Permalink"></a></h5><p>To delete a constraint, users can make use of the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.delete"><code>delete</code></a> function from the JuMP package. When handling constraints that have been internally created, users can refer to the constraint references stored in the <code>constraint</code> field of the <code>DcOptimalPowerFlow</code> type.</p><p>For example, if the intention is to eliminate constraints related to the capability of <code>Generator 4</code>, the following code snippet can be employed:</p><pre><code class="language-julia hljs">JuMP.delete(analysis.method.jump, analysis.method.constraint.capability.active[4])</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint. Users should exercise caution when deleting constraints, as this action is considered potentially harmful since it operates independently of power system data.</p></div></div><hr/><h2 id="DCObjectiveFunctionManual"><a class="docs-heading-anchor" href="#DCObjectiveFunctionManual">Objective Function</a><a id="DCObjectiveFunctionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCObjectiveFunctionManual" title="Permalink"></a></h2><p>The objective function of the DC optimal power flow is constructed using polynomial and piecewise linear cost functions of the generators, which are defined using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions. Only polynomial cost functions of up to the second degree are included in the objective. Specifically, if a higher-degree polynomial is provided, JuliaGrid will discard all terms beyond the second degree and still include the resulting truncated polynomial in the objective function.</p><p>In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active power outputs of the generators and the bus voltage angles is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 P[1]² + 500 P[1] + actwise[3] + P[2] + 83</code></pre><p>Additionally, JuliaGrid stores the objective function in a separate variable, allowing users to access it by referencing the variable <code>analysis.objective</code>.</p><hr/><h5 id="Update-Objective-Function"><a class="docs-heading-anchor" href="#Update-Objective-Function">Update Objective Function</a><a id="Update-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Objective-Function" title="Permalink"></a></h5><p>By utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions, users have the flexibility to modify the objective function by adjusting polynomial or piecewise linear cost coefficients or by changing the type of polynomial or piecewise linear function employed. For instance, consider <code>Generator 3</code>, which incorporates a piecewise cost structure with two segments. Now, we can define a polynomial function for this generator and activate it by specifying the keyword <code>active = 2</code> as shown:</p><pre><code class="language-julia hljs">cost!(analysis; generator = &quot;Generator 3&quot;, active = 2, polynomial = [853.4; 257; 40])</code></pre><p>This results in the updated objective function, which can be observed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.objective</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 P[1]² + 853.4 P[3]² + 500 P[1] + P[2] + 257 P[3] + 123</code></pre><hr/><h5 id="User-Defined-Objective-Function"><a class="docs-heading-anchor" href="#User-Defined-Objective-Function">User-Defined Objective Function</a><a id="User-Defined-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined-Objective-Function" title="Permalink"></a></h5><p>Users can modify the objective function using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.set_objective_function"><code>set_objective_function</code></a> function from the JuMP package. This operation is considered destructive because it is independent of power system data; however, in certain scenarios, it may be more straightforward than using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function for updates. Moreover, using this methodology, users can combine a defined function with a newly defined expression. Here is an example of how it can be achieved:</p><pre><code class="language-julia hljs">expr = 100.2 * analysis.method.variable.power.active[1]^2 + 123
JuMP.set_objective_function(analysis.method.jump, analysis.method.objective - expr)</code></pre><p>We can now observe the updated objective function as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1000 P[1]² + 853.4 P[3]² + 500 P[1] + P[2] + 257 P[3]</code></pre><hr/><h2 id="SetupStartingPrimalValuesManual"><a class="docs-heading-anchor" href="#SetupStartingPrimalValuesManual">Setup Initial Values</a><a id="SetupStartingPrimalValuesManual-1"></a><a class="docs-heading-anchor-permalink" href="#SetupStartingPrimalValuesManual" title="Permalink"></a></h2><p>In JuliaGrid, the assignment of initial primal and dual values for optimization variables takes place when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function is executed.</p><hr/><h5 id="Initial-Primal-Values"><a class="docs-heading-anchor" href="#Initial-Primal-Values">Initial Primal Values</a><a id="Initial-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Primal-Values" title="Permalink"></a></h5><p>Initial primal values are determined based on the <code>generator</code> and <code>voltage</code> fields within the <code>DcOptimalPowerFlow</code> type. By default, these values are initially established using the active power outputs of the generators and the initial bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.6
Generator 2: 0.1
Generator 3: 0.2
Generator 4: 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: 0.0
Bus 3: 0.0</code></pre><p>Users have the flexibility to adjust these values according to their specifications, which will then be used as the initial primal values when executing the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function.</p><hr/><h5 id="Using-DC-Power-Flow"><a class="docs-heading-anchor" href="#Using-DC-Power-Flow">Using DC Power Flow</a><a id="Using-DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-DC-Power-Flow" title="Permalink"></a></h5><p>In this perspective, users have the capability to conduct the DC power flow analysis and leverage the resulting solution to configure initial primal values. Here is an illustration of how this can be achieved:</p><pre><code class="language-julia hljs">flow = dcPowerFlow(system)
powerFlow!(flow; power = true)</code></pre><p>After obtaining the solution, we can use the active power outputs of the generators, along with bus voltage angles, to set the initial values:</p><pre><code class="language-julia hljs">setInitialPoint!(analysis, flow)</code></pre><hr/><h5 id="Initial-Dual-Values"><a class="docs-heading-anchor" href="#Initial-Dual-Values">Initial Dual Values</a><a id="Initial-Dual-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Dual-Values" title="Permalink"></a></h5><p>Dual variables, often referred to as Lagrange multipliers or Kuhn-Tucker multipliers, represent the shadow prices or marginal costs associated with constraints. The assignment of initial dual values occurs when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function is executed. Initially, the initial dual values are unknown, but users can access and manually set them. For example:</p><pre><code class="language-julia hljs">analysis.method.dual.balance.active[1] = 0.4</code></pre><hr/><h2 id="DCOptimalPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionManual">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionManual" title="Permalink"></a></h2><p>To establish the DC optimal power flow problem, we utilize the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function. After setting up the problem, we can use the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function to compute the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>By executing this function, we will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.0
Generator 2: 0.0953999999999979
Generator 3: 0.0
Generator 4: 0.14460000000000053</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: -0.10460000000000003
Bus 3: -0.10420000000000001</code></pre><hr/><h5 id="Objective-Value"><a class="docs-heading-anchor" href="#Objective-Value">Objective Value</a><a id="Objective-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Value" title="Permalink"></a></h5><p>To obtain the objective value of the optimal power flow solution, we can use the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.objective_value"><code>objective_value</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_value(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">0.0953999999999979</code></pre><hr/><h5 id="Dual-Variables"><a class="docs-heading-anchor" href="#Dual-Variables">Dual Variables</a><a id="Dual-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-Variables" title="Permalink"></a></h5><p>The values of the dual variables are stored in the <code>dual</code> field of the <code>DcOptimalPowerFlow</code> type. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.dual.balance.active[1]</code><code class="nohighlight hljs ansi" style="display:block;">1.4459900796737201e-8</code></pre><hr/><h5 id="Wrapper-Function"><a class="docs-heading-anchor" href="#Wrapper-Function">Wrapper Function</a><a id="Wrapper-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-Function" title="Permalink"></a></h5><p>JuliaGrid provides a wrapper function for DC optimal power flow analysis and also supports the computation of powers using the <a href="../../api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{DcOptimalPowerFlow}">powerFlow!</a> function:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)
powerFlow!(analysis; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><hr/><h5 id="Print-Results-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL">Print Results in the REPL</a><a id="Print-Results-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL" title="Permalink"></a></h5><p>Users can utilize the functions <a href="../../api/setupPrint/#JuliaGrid.printBusData"><code>printBusData</code></a> and <a href="../../api/setupPrint/#JuliaGrid.printGeneratorData"><code>printGeneratorData</code></a> to display results. Additionally, the functions listed in the <a href="../../api/setupPrint/#PrintConstraintDataAPI">Print Constraint Data</a> section allow users to print constraint data related to buses, branches, or generators in the desired units. For example:</p><pre><code class="language-julia hljs">@power(MW, MVAr)
printBusConstraint(analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|------------------------------|
| Bus Constraint Data          |
|------------------------------|
| Label | Active Power Balance |
|       |                      |
|       | Solution |      Dual |
|       |     [MW] | [$/MW-hr] |
|-------|----------|-----------|
| Bus 1 |   0.0000 |    0.0000 |
| Bus 2 |  14.0000 |    0.0100 |
| Bus 3 |  10.0000 |    0.0101 |
|------------------------------|</code></pre><p>Next, users can easily customize the print results for specific constraint, for example:</p><pre><code class="language-julia hljs">printBusConstraint(analysis; label = &quot;Bus 1&quot;, header = true)
printBusConstraint(analysis; label = &quot;Bus 2&quot;, footer = true)</code></pre><hr/><h5 id="Save-Results-to-a-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-File">Save Results to a File</a><a id="Save-Results-to-a-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-File" title="Permalink"></a></h5><p>Users can also redirect print output to a file. For example, data can be saved in a text file as follows:</p><pre><code class="language-julia hljs">open(&quot;bus.txt&quot;, &quot;w&quot;) do file
    printBusConstraint(analysis, file)
end</code></pre><hr/><h5 id="Save-Results-to-a-CSV-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-CSV-File">Save Results to a CSV File</a><a id="Save-Results-to-a-CSV-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-CSV-File" title="Permalink"></a></h5><p>For CSV output, users should first generate a simple table with <code>style = false</code>, and then save it to a CSV file:</p><pre><code class="language-julia hljs">using CSV

io = IOBuffer()
printBusConstraint(analysis, io; style = false)
CSV.write(&quot;constraint.csv&quot;, CSV.File(take!(io); delim = &quot;|&quot;))</code></pre><hr/><h2 id="Primal-and-Dual-Warm-Start"><a class="docs-heading-anchor" href="#Primal-and-Dual-Warm-Start">Primal and Dual Warm Start</a><a id="Primal-and-Dual-Warm-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-and-Dual-Warm-Start" title="Permalink"></a></h2><p>Utilizing the <code>DcOptimalPowerFlow</code> type and proceeding directly to the solver offers the advantage of a warm start. In this scenario, the initial primal and dual values for the subsequent solving step correspond to the solution obtained from the previous step.</p><hr/><h5 id="Primal-Variables"><a class="docs-heading-anchor" href="#Primal-Variables">Primal Variables</a><a id="Primal-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-Variables" title="Permalink"></a></h5><p>In the previous example, the following solution was obtained, representing the values of the primal variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.0
Generator 2: 0.09539999999999793
Generator 3: 0.0
Generator 4: 0.14460000000000084</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: -0.10460000000000004
Bus 3: -0.10420000000000001</code></pre><hr/><h5 id="Dual-Variables-2"><a class="docs-heading-anchor" href="#Dual-Variables-2">Dual Variables</a><a class="docs-heading-anchor-permalink" href="#Dual-Variables-2" title="Permalink"></a></h5><p>We also obtained all dual values. Here, we list only the dual variables for one type of constraint as an example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.dual.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: -1.0399999941522005
Branch 3: 0.0
Branch 4: 0.0</code></pre><hr/><h5 id="Modify-Optimal-Power-Flow"><a class="docs-heading-anchor" href="#Modify-Optimal-Power-Flow">Modify Optimal Power Flow</a><a id="Modify-Optimal-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Modify-Optimal-Power-Flow" title="Permalink"></a></h5><p>Now, let us introduce changes to the power system from the previous example:</p><pre><code class="language-julia hljs">updateGenerator!(analysis; label = &quot;Generator 2&quot;, maxActive = 0.08)</code></pre><p>Next, we want to solve this modified optimal power flow problem. If we use <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> at this point, the primal and dual initial values will be set to the previously obtained values:</p><pre><code class="language-julia hljs">powerFlow!(analysis)</code></pre><p>As a result, we obtain a new solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.0
Generator 2: 0.0008
Generator 3: 0.0945999999999998
Generator 4: 0.1446000000000005</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: -0.10460000000000003
Bus 3: -0.10420000000000001</code></pre><hr/><h5 id="Reset-Primal-and-Dual-Values"><a class="docs-heading-anchor" href="#Reset-Primal-and-Dual-Values">Reset Primal and Dual Values</a><a id="Reset-Primal-and-Dual-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Reset-Primal-and-Dual-Values" title="Permalink"></a></h5><p>Users retain the flexibility to reset these initial primal values to their default configurations at any juncture. This can be accomplished by utilizing the active power outputs of the generators and the initial bus voltage angles extracted from the <code>PowerSystem</code> type, employing the <a href="../../api/optimalPowerFlow/#JuliaGrid.setInitialPoint!-Tuple{DcOptimalPowerFlow}"><code>setInitialPoint!</code></a> function:</p><pre><code class="language-julia hljs">setInitialPoint!(analysis)</code></pre><p>The primal initial values will now be identical to those that would be obtained if the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function were executed after all the updates have been applied, while all dual variable values will be removed.</p><hr/><h2 id="DCOptimalPowerAnalysisManual"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisManual">Power Analysis</a><a id="DCOptimalPowerAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{DcPowerFlow}"><code>power!</code></a> function. For instance, let us consider the power system for which we obtained the DC optimal power flow solution:</p><pre><code class="language-julia hljs">using HiGHS

system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, minFromBus = -0.12, maxFromBus = 0.12)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)

@generator(minActive = 0.0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, maxActive = 0.5)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.2, maxActive = 0.2)

cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; generator = &quot;Generator 2&quot;, active = 1, piecewise = [10.8 12.3; 14.7 16.8])

analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer)
powerFlow!(analysis)</code></pre><p>Now we can calculate the active powers using the following function:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><p>Finally, to display the active power injections and from-bus active power flows, we can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: 0.09000000000000127
Bus 3: -0.05</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.power.from.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: -0.007142857142858339
Branch 2: 0.007142857142855563
Branch 3: 0.04285714285714726</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{DcPowerFlow}"><code>power!</code></a> function, we suggest referring to the tutorials on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerAnalysisTutorials">DC Optimal Power Flow</a>.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL-2">Print Results in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL-2" title="Permalink"></a></h5><p>Users can utilize any of the print functions outlined in the <a href="../../api/setupPrint/#PrintPowerSystemDataAPI">Print Power System Data</a> or <a href="../../api/setupPrint/#PrintPowerSystemSummaryAPI">Print Power System Summary</a>. For example, to create a bus data with the desired units, users can use the following function:</p><pre><code class="language-julia hljs">@voltage(pu, deg)
@power(MW, MVAr)
printBusData(analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|---------------------------------------------------------------------|
| Bus Data                                                            |
|---------------------------------------------------------------------|
| Label | Voltage | Power Generation | Power Demand | Power Injection |
|       |         |                  |              |                 |
|   Bus |   Angle |           Active |       Active |          Active |
|       |   [deg] |             [MW] |         [MW] |            [MW] |
|-------|---------|------------------|--------------|-----------------|
| Bus 1 |  9.7403 |           0.0000 |       0.0000 |          0.0000 |
| Bus 2 |  9.7607 |          19.0000 |      10.0000 |          9.0000 |
| Bus 3 |  9.7362 |           0.0000 |       5.0000 |         -5.0000 |
|---------------------------------------------------------------------|</code></pre><hr/><h5 id="Active-Power-Injection"><a class="docs-heading-anchor" href="#Active-Power-Injection">Active Power Injection</a><a id="Active-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection" title="Permalink"></a></h5><p>To calculate active power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = injectionPower(analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.09000000000000127</code></pre><hr/><h5 id="Active-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-Power-Injection-from-Generators">Active Power Injection from Generators</a><a id="Active-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate active power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = supplyPower(analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.19000000000000128</code></pre><hr/><h5 id="Active-Power-Flow"><a class="docs-heading-anchor" href="#Active-Power-Flow">Active Power Flow</a><a id="Active-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = fromPower(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.007142857142855563</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = toPower(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-0.007142857142855563</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acOptimalPowerFlow/">« AC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../measurementModel/">Measurement Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Saturday 19 April 2025 12:26">Saturday 19 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
