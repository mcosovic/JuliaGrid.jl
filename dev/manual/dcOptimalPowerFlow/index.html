<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow · JuliaGrid</title><meta name="title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="og:title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="twitter:title" content="DC Optimal Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimalPowerFlowModelManual"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#DCOptimizationVariablesManual"><span>Optimization Variables</span></a></li><li><a class="tocitem" href="#DCConstraintFunctionsManual"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#DCObjectiveFunctionManual"><span>Objective Function</span></a></li><li><a class="tocitem" href="#SetupStartingPrimalValuesManual"><span>Setup Initial Values</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionManual"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#Primal-and-Dual-Warm-Start"><span>Primal and Dual Warm Start</span></a></li><li><a class="tocitem" href="#DcExtendedFormulationManual"><span>Extended Formulation</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisManual"><span>Power Analysis</span></a></li></ul></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/dcOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowManual">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowManual" title="Permalink"></a></h1><p>Similar to <a href="../acOptimalPowerFlow/#ACOptimalPowerFlowManual">AC Optimal Power Flow</a>, JuliaGrid utilizes the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package to construct optimal power flow models, enabling users to manipulate these models using the standard functions provided by JuMP. JuliaGrid supports popular <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> mentioned in the JuMP documentation to solve the optimization problem.</p><p>To perform the DC optimal power flow, we first need to have the <code>PowerSystem</code> type that has been created with the DC model. After that, create the <code>DcOptimalPowerFlow</code> type to establish the DC optimal power flow framework using the function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a>.</li></ul><hr/><p>To solve the DC optimal power flow problem and acquire generator active power outputs and bus voltage angles, users can use of the following function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>After solving the DC optimal power flow, JuliaGrid provides function for computing powers:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{DcPowerFlow}"><code>power!</code></a>.</li></ul><p>Alternatively, instead of using functions responsible for solving optimal power flow and computing powers, users can use the wrapper function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{DcOptimalPowerFlow}"><code>powerFlow!</code></a>.</li></ul><p>Users can also access specialized functions for computing specific types of <a href="../../api/analysis/#DCPowerAnalysisAPI">powers</a> for individual buses, branches, or generators within the power system.</p><hr/><h2 id="DCOptimalPowerFlowModelManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowModelManual">Optimal Power Flow Model</a><a id="DCOptimalPowerFlowModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowModelManual" title="Permalink"></a></h2><p>To set up the DC optimal power flow, we begin by creating the model. To illustrate this, consider the following:</p><pre><code class="language-julia hljs">using JuMP, Ipopt

system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05)

@branch(minDiffAngle = -3.1, maxDiffAngle = 3.1, minFromBus = -0.12, maxFromBus = 0.12)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)

@generator(minActive = 0.0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.6, maxActive = 0.8)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.1, maxActive = 0.3)
addGenerator!(system; label = &quot;Generator 3&quot;, bus = &quot;Bus 2&quot;, active = 0.2, maxActive = 0.4)

cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; generator = &quot;Generator 2&quot;, active = 1, piecewise = [8.0 11.0; 14.0 17.0])
cost!(system; generator = &quot;Generator 3&quot;, active = 1, piecewise = [6 12.3; 8.7 16.8; 11 19])

dcModel!(system)</code></pre><p>Next, the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function is utilized to formulate the DC optimal power flow problem:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>All non-box two-sided constraints are modeled as intervals by default. However, users can choose to represent them as two separate constraints, one for the lower bound and one for the upper bound, by setting:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer; interval = false)</code></pre><p>Although this approach may be less efficient in terms of model creation and could lead to longer execution times depending on the solver, it allows for precise definition of the starting dual values.</p></div></div><hr/><h2 id="DCOptimizationVariablesManual"><a class="docs-heading-anchor" href="#DCOptimizationVariablesManual">Optimization Variables</a><a id="DCOptimizationVariablesManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimizationVariablesManual" title="Permalink"></a></h2><p>In DC optimal power flow, generator active power outputs are linear functions of bus voltage angles. Thus, the model&#39;s variables include generator active power outputs and bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.all_variables(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{VariableRef}:
 angle[1]
 angle[2]
 angle[3]
 active[1]
 active[2]
 active[3]
 actwise[3]</code></pre><p>It is important to highlight that when dealing with piecewise linear cost functions comprising multiple segments, as exemplified in the case of <code>Generator 3</code>, JuliaGrid automatically generates helper optimization variables, such as <code>actwise[3]</code>, and formulates a set of linear constraints to appropriately handle these cost functions.</p><p>However, in instances where a piecewise linear cost function consists of only a single segment, as demonstrated by <code>Generator 2</code>, the function is modelled as a standard linear function, eliminating the necessity for additional helper optimization variables.</p><p>Please note that JuliaGrid keeps references to all variables categorized into three fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.variable.voltage))</code><code class="nohighlight hljs ansi" style="display:block;">(:angle,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.variable.power))</code><code class="nohighlight hljs ansi" style="display:block;">(:active, :actwise)</code></pre><hr/><h5 id="Variable-Names"><a class="docs-heading-anchor" href="#Variable-Names">Variable Names</a><a id="Variable-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Names" title="Permalink"></a></h5><p>Users have the option to define custom variable names for printing equations, which can help present them in a more compact form. For example:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer; active = &quot;P&quot;, angle = &quot;θ&quot;)</code></pre><hr/><h5 id="Add-Variables"><a class="docs-heading-anchor" href="#Add-Variables">Add Variables</a><a id="Add-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variables" title="Permalink"></a></h5><p>Once the <code>DcOptimalPowerFlow</code> type is established, users can add new variables representing generator active power outputs by introducing additional generators. For example:</p><pre><code class="language-julia hljs">addGenerator!(analysis; label = &quot;Generator 4&quot;, bus = &quot;Bus 1&quot;, active = 0.1, maxActive = 0.2)</code></pre><p>This command adds both a new variable and the corresponding box constraint to the optimization model.</p><p>To confirm that the variable has been successfully added, you can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.method.jump, analysis.method.variable.power.active[4])</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><h2 id="DCConstraintFunctionsManual"><a class="docs-heading-anchor" href="#DCConstraintFunctionsManual">Constraint Functions</a><a id="DCConstraintFunctionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCConstraintFunctionsManual" title="Permalink"></a></h2><p>JuliGrid keeps track of all the references to internally formed constraints in the <code>constraint</code> field of the <code>DcOptimalPowerFlow</code> type. These constraints are divided into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.constraint))</code><code class="nohighlight hljs ansi" style="display:block;">(:slack, :capability, :balance, :voltage, :flow, :piecewise)</code></pre><p>They fall into two main categories: box constraints and non-box constraints.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We suggest that readers refer to the tutorial on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowTutorials">DC Optimal Power Flow</a> for insights into the implementation.</p></div></div><hr/><h5 id="Box-Constraints"><a class="docs-heading-anchor" href="#Box-Constraints">Box Constraints</a><a id="Box-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Box-Constraints" title="Permalink"></a></h5><p>The <code>slack</code> constraint is represented as an <code>equality</code> tied to the fixed voltage angle at the slack bus.</p><p>The <code>capability</code> constraints define variable bounds on active power generation and are always implemented as two separate constraints: one for the <code>lower</code> bound and one for the <code>upper</code> bound. If the bounds are equal or the generator is out-of-service, JuliaGrid models the constraint as an <code>equality</code> instead.</p><hr/><h5 id="Non-Box-Constraints"><a class="docs-heading-anchor" href="#Non-Box-Constraints">Non-Box Constraints</a><a id="Non-Box-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Box-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> constraints correspond to active power balance equations defined at each bus and are modeled as <code>equality</code> constraints.</p><p>The <code>voltage</code> constraints are associated with the minimum and maximum voltage angle difference between the from-bus and to-bus ends of each branch and are modeled as <code>interval</code> constraints by default. If the bounds are equal, an <code>equality</code> constraint is used instead.</p><p>The <code>flow</code> constraints, which refer to active power flow limits at the from-bus end of each branch, are also modeled as <code>interval</code> constraints by default. If the bounds are equal, an <code>equality</code> constraint is used.</p><p>If preferred, both <code>voltage</code> and <code>flow</code> constraints can be represented as two separate one-sided constraints, one for the <code>lower</code> and one for the <code>upper</code> bound, by setting the keyword argument <code>interval = false</code> when calling the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function.</p><p>Finally, the <code>piecewise</code> constraints are introduced when piecewise linear cost functions with multiple segments are defined, and they impose only <code>upper</code> bounds.</p><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The <code>slack</code> field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function using the <code>angle</code> keyword:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: θ[1] = 0.17</code></pre><p>Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> function, for example:</p><pre><code class="language-julia hljs">updateBus!(analysis; label = &quot;Bus 1&quot;, angle = -0.1)</code></pre><p>Subsequently, the updated slack constraint can be inspected as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: θ[1] = -0.1</code></pre><hr/><h5 id="Generator-Active-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Generator-Active-Power-Capability-Constraints">Generator Active Power Capability Constraints</a><a id="Generator-Active-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Active-Power-Capability-Constraints" title="Permalink"></a></h5><p>The <code>capability</code> field contains references to the box inequality constraints associated with the minimum and maximum active power outputs of the generators. These limits are specified using the <code>minActive</code> and <code>maxActive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: P[1] ≤ 0.8, P[1] ≥ 0
Generator 2: P[2] ≤ 0.3, P[2] ≥ 0
Generator 3: P[3] ≤ 0.4, P[3] ≥ 0
Generator 4: P[4] ≤ 0.2, P[4] ≥ 0</code></pre><p>Let us now set <code>Generator 2</code> out of service using the <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a> function:</p><pre><code class="language-julia hljs">updateGenerator!(analysis; label = &quot;Generator 2&quot;, status = 0)</code></pre><p>We can now observe that the updated constraints reflect the current state of the system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: P[1] ≤ 0.8, P[1] ≥ 0
Generator 2: P[2] = 0
Generator 3: P[3] ≤ 0.4, P[3] ≥ 0
Generator 4: P[4] ≤ 0.2, P[4] ≥ 0</code></pre><hr/><h5 id="Bus-Active-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Bus-Active-Power-Balance-Constraints">Bus Active Power Balance Constraints</a><a id="Bus-Active-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Active-Power-Balance-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> field contains references to the equality constraints associated with the active power balance equations defined for each bus. The constant terms in these equations are determined by the <code>active</code> and <code>conductance</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. Additionally, if there are phase shift transformers in the system, the constant terms can also be affected by the <code>shiftAngle</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -120 θ[1] + 20 θ[2] + 100 θ[3] + P[1] + P[4] = 0
Bus 2: 20 θ[1] - 120 θ[2] + 100 θ[3] + P[3] = 0.14
Bus 3: 100 θ[1] + 100 θ[2] - 200 θ[3] = 0.05</code></pre><p>During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system, for example:</p><pre><code class="language-julia hljs">updateBus!(analysis; label = &quot;Bus 3&quot;, active = 0.1)
updateGenerator!(analysis; label = &quot;Generator 2&quot;, status = 1)</code></pre><p>Subsequently, the updated set of active power balance constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -120 θ[1] + 20 θ[2] + 100 θ[3] + P[1] + P[4] = 0
Bus 2: 20 θ[1] - 120 θ[2] + 100 θ[3] + P[2] + P[3] = 0.14
Bus 3: 100 θ[1] + 100 θ[2] - 200 θ[3] = 0.1</code></pre><hr/><h5 id="Bus-Voltage-Angle-Difference-Constraints"><a class="docs-heading-anchor" href="#Bus-Voltage-Angle-Difference-Constraints">Bus Voltage Angle Difference Constraints</a><a id="Bus-Voltage-Angle-Difference-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Angle-Difference-Constraints" title="Permalink"></a></h5><p>The <code>voltage</code> field contains references to the inequality constraints associated with the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch. These values are specified using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-3.1, 3.1]
Branch 2: θ[1] - θ[3] ∈ [-3.1, 3.1]
Branch 3: θ[2] - θ[3] ∈ [-3.1, 3.1]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If <code>minDiffAngle = -2π</code> and <code>maxDiffAngle = 2π</code>, or both are set to <code>zero</code> for a given branch, JuliaGrid will skip adding the corresponding inequality constraint.</p></div></div><p>Additionally, by employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, we have the ability to modify these constraints as follows:</p><pre><code class="language-julia hljs">updateBranch!(analysis; label = &quot;Branch 1&quot;, minDiffAngle = -1.7, maxDiffAngle = 1.7)</code></pre><p>Subsequently, the updated set of voltage angle difference constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-1.7, 1.7]
Branch 2: θ[1] - θ[3] ∈ [-3.1, 3.1]
Branch 3: θ[2] - θ[3] ∈ [-3.1, 3.1]</code></pre><hr/><h5 id="Branch-Active-Power-Flow-Constraints"><a class="docs-heading-anchor" href="#Branch-Active-Power-Flow-Constraints">Branch Active Power Flow Constraints</a><a id="Branch-Active-Power-Flow-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Active-Power-Flow-Constraints" title="Permalink"></a></h5><p>The <code>flow</code> field refers to the inequality constraints associated with active power flow limits at the from-bus end of each branch. These limits are set using the <code>minFromBus</code> and <code>maxFromBus</code> keywords in the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: 20 θ[1] - 20 θ[2] ∈ [-0.12, 0.12]
Branch 2: 100 θ[1] - 100 θ[3] ∈ [-0.12, 0.12]
Branch 3: 100 θ[2] - 100 θ[3] ∈ [-0.12, 0.12]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If the branch flow limits are set to <code>minFromBus = 0.0</code> and <code>maxFromBus = 0.0</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p></div></div><p>By employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, we have the ability to modify these specific constraints, for example:</p><pre><code class="language-julia hljs">updateBranch!(analysis; label = &quot;Branch 1&quot;, status = 0)
updateBranch!(analysis; label = &quot;Branch 2&quot;, reactance = 0.03, maxFromBus = 0.14)</code></pre><p>Subsequently, the updated set of active power flow constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: 33.333333333333336 θ[1] - 33.333333333333336 θ[3] ∈ [-0.12, 0.14]
Branch 3: 100 θ[2] - 100 θ[3] ∈ [-0.12, 0.12]</code></pre><hr/><h5 id="Active-Power-Piecewise-Constraints"><a class="docs-heading-anchor" href="#Active-Power-Piecewise-Constraints">Active Power Piecewise Constraints</a><a id="Active-Power-Piecewise-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Piecewise-Constraints" title="Permalink"></a></h5><p>In the context of active power modelling, the <code>piecewise</code> field serves as a reference to the inequality constraints related to linear piecewise cost functions. These constraints are created using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function with <code>active = 1</code> specified when dealing with piecewise linear cost functions comprising multiple segments. JuliaGrid takes care of establishing the appropriate inequality constraints for each segment of the piecewise linear cost:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 3: 1.6666666666666672 P[3] - actwise[3] ≤ -2.299999999999997
Generator 3: 0.9565217391304341 P[3] - actwise[3] ≤ -8.478260869565224</code></pre><p>It is worth noting that these constraints can also be automatically updated using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function, and readers can find more details in the section about the objective function.</p><hr/><h5 id="Add-Constraints"><a class="docs-heading-anchor" href="#Add-Constraints">Add Constraints</a><a id="Add-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Constraints" title="Permalink"></a></h5><p>Users can easily introduce new constraints into the DC optimal power flow by using the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. For example, to add a new branch to an existing <code>PowerSystem</code> and corresponding <code>DcOptimalPowerFlow</code> model:</p><pre><code class="language-julia hljs">addBranch!(analysis; label = &quot;Branch 4&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 1)</code></pre><p>As a result, the flow constraints will be adjusted as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: 33.333333333333336 θ[1] - 33.333333333333336 θ[3] ∈ [-0.12, 0.14]
Branch 3: 100 θ[2] - 100 θ[3] ∈ [-0.12, 0.12]
Branch 4: θ[1] - θ[2] ∈ [-0.12, 0.12]</code></pre><p>Similarly, the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function adds both a new variable and its associated box constraint.</p><hr/><h5 id="Delete-Constraints"><a class="docs-heading-anchor" href="#Delete-Constraints">Delete Constraints</a><a id="Delete-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints" title="Permalink"></a></h5><p>When a branch or generator is taken out-of-service, JuliaGrid automatically adjusts the optimization problem to reflect that action, which may include removing certain constraints.</p><p>In some cases, it may also be useful to remove specific constraints manually. This can be done using the <a href="../../api/optimalPowerFlow/#JuliaGrid.remove!"><code>remove!</code></a> function by specifying the constraint type: <code>:slack</code>, <code>:capability</code>, <code>:balance</code>, <code>:voltage</code>, <code>:flow</code> or <code>:piecewise</code>.</p><p>For example, to delete the constraint associated with the voltage angle difference at <code>Branch 2</code>, use:</p><pre><code class="language-julia hljs">remove!(analysis, :voltage; label = &quot;Branch 2&quot;)</code></pre><p>Alternatively, instead of using a label, constraints can also be deleted by index:</p><pre><code class="language-julia hljs">remove!(analysis, :voltage; index = 4)</code></pre><p>After these operations, the remaining voltage angle difference constraints can be displayed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 3: θ[2] - θ[3] ∈ [-3.1, 3.1]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint.</p></div></div><hr/><h2 id="DCObjectiveFunctionManual"><a class="docs-heading-anchor" href="#DCObjectiveFunctionManual">Objective Function</a><a id="DCObjectiveFunctionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCObjectiveFunctionManual" title="Permalink"></a></h2><p>The objective of the DC optimal power flow is constructed using polynomial and piecewise linear cost functions of the generators, which are defined using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions. Only polynomial cost functions of up to the second degree are included in the objective. Specifically, if a higher-degree polynomial is provided, JuliaGrid will discard all terms beyond the second degree and still include the resulting truncated polynomial in the objective function.</p><p>In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active power outputs of the generators and the bus voltage angles is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 P[1]² + 500 P[1] + actwise[3] + P[2] + 83</code></pre><p>Additionally, JuliaGrid stores the objective function in a separate variable, allowing users to access it by referencing the variable <code>analysis.objective</code>.</p><hr/><h5 id="Update-Objective-Function"><a class="docs-heading-anchor" href="#Update-Objective-Function">Update Objective Function</a><a id="Update-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Objective-Function" title="Permalink"></a></h5><p>By utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions, users have the flexibility to modify the objective function by adjusting polynomial or piecewise linear cost coefficients or by changing the type of polynomial or piecewise linear function employed. For instance, consider <code>Generator 3</code>, which incorporates a piecewise cost structure with two segments. Now, we can define a polynomial function for this generator and activate it by specifying the keyword <code>active = 2</code> as shown:</p><pre><code class="language-julia hljs">cost!(analysis; generator = &quot;Generator 3&quot;, active = 2, polynomial = [853.4; 257; 40])</code></pre><p>This results in the updated objective function, which can be observed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.objective</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 P[1]² + 853.4 P[3]² + 500 P[1] + P[2] + 257 P[3] + 123</code></pre><hr/><h2 id="SetupStartingPrimalValuesManual"><a class="docs-heading-anchor" href="#SetupStartingPrimalValuesManual">Setup Initial Values</a><a id="SetupStartingPrimalValuesManual-1"></a><a class="docs-heading-anchor-permalink" href="#SetupStartingPrimalValuesManual" title="Permalink"></a></h2><p>In JuliaGrid, the assignment of initial primal and dual values for optimization variables takes place when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function is executed.</p><hr/><h5 id="Initial-Primal-Values"><a class="docs-heading-anchor" href="#Initial-Primal-Values">Initial Primal Values</a><a id="Initial-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Primal-Values" title="Permalink"></a></h5><p>Initial primal values are determined based on the <code>generator</code> and <code>voltage</code> fields within the <code>DcOptimalPowerFlow</code> type. By default, these values are initially established using the active power outputs of the generators and the initial bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.6
Generator 2: 0.1
Generator 3: 0.2
Generator 4: 0.1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: 0.0
Bus 3: 0.0</code></pre><p>Users have the flexibility to adjust these values according to their specifications, which will then be used as the initial primal values when executing the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function.</p><hr/><h5 id="Using-DC-Power-Flow"><a class="docs-heading-anchor" href="#Using-DC-Power-Flow">Using DC Power Flow</a><a id="Using-DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-DC-Power-Flow" title="Permalink"></a></h5><p>In this perspective, users have the capability to conduct the DC power flow analysis and leverage the resulting solution to configure initial primal values. Here is an illustration of how this can be achieved:</p><pre><code class="language-julia hljs">flow = dcPowerFlow(system)
powerFlow!(flow; power = true)</code></pre><p>After obtaining the solution, we can use the active power outputs of the generators, along with bus voltage angles, to set the initial values:</p><pre><code class="language-julia hljs">setInitialPoint!(analysis, flow)</code></pre><hr/><h5 id="Initial-Dual-Values"><a class="docs-heading-anchor" href="#Initial-Dual-Values">Initial Dual Values</a><a id="Initial-Dual-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Dual-Values" title="Permalink"></a></h5><p>Dual variables, often referred to as Lagrange multipliers or Kuhn-Tucker multipliers, represent the shadow prices or marginal costs associated with constraints. The assignment of initial dual values occurs when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function is executed. By default, dual values are undefined, but users can manually assign them using the <a href="../../api/optimalPowerFlow/#JuliaGrid.addDual!"><code>addDual!</code></a> function.</p><p>If a constraint is defined as an equality, an interval, or has only a lower or upper bound, it corresponds to a single dual variable. In such cases, an initial value can be set using the <code>dual</code> keyword. For example:</p><pre><code class="language-julia hljs">addDual!(analysis, :balance; label = &quot;Bus 1&quot;, dual = 1e-3)</code></pre><p>For constraints with both lower and upper bounds, users can assign initial dual values separately using the <code>lower</code> and <code>upper</code> keywords. For example:</p><pre><code class="language-julia hljs">addDual!(analysis, :capability; label = &quot;Generator 1&quot;, lower = 500.0, upper = 0.0)</code></pre><p>Alternatively, dual variables can be added by specifying the constraint index instead of a label:</p><pre><code class="language-julia hljs">addDual!(analysis, :capability; index = 1, lower = 500.0, upper = 0.0)</code></pre><hr/><h2 id="DCOptimalPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionManual">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionManual" title="Permalink"></a></h2><p>To establish the DC optimal power flow problem, we utilize the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function. After setting up the problem, we can use the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> function to compute the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>By executing this function, we will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.970032222936603e-9
Generator 2: 0.09540001454629071
Generator 3: -9.941368132382119e-9
Generator 4: 0.144600005365107</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: -0.1045999998228875
Bus 3: -0.10419999986716562</code></pre><hr/><h5 id="Objective-Value"><a class="docs-heading-anchor" href="#Objective-Value">Objective Value</a><a id="Objective-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Value" title="Permalink"></a></h5><p>To obtain the objective value of the optimal power flow solution, we can use the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.objective_value"><code>objective_value</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_value(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">123.09539247459877</code></pre><hr/><h5 id="Dual-Variables"><a class="docs-heading-anchor" href="#Dual-Variables">Dual Variables</a><a id="Dual-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-Variables" title="Permalink"></a></h5><p>The values of the dual variables are stored in the <code>dual</code> field of the <code>DcOptimalPowerFlow</code> type. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.dual.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.670899565213005e-7
Bus 2: 0.99999991627442
Bus 3: 1.0099998200006497</code></pre><hr/><h5 id="Wrapper-Function"><a class="docs-heading-anchor" href="#Wrapper-Function">Wrapper Function</a><a id="Wrapper-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-Function" title="Permalink"></a></h5><p>JuliaGrid provides a wrapper function for DC optimal power flow analysis and also supports the computation of powers using the <a href="../../api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{DcOptimalPowerFlow}">powerFlow!</a> function:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)
powerFlow!(analysis; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><hr/><h5 id="Print-Results-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL">Print Results in the REPL</a><a id="Print-Results-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL" title="Permalink"></a></h5><p>Users can utilize the functions <a href="../../api/setupPrint/#JuliaGrid.printBusData"><code>printBusData</code></a> and <a href="../../api/setupPrint/#JuliaGrid.printGeneratorData"><code>printGeneratorData</code></a> to display results. Additionally, the functions listed in the <a href="../../api/setupPrint/#PrintConstraintDataAPI">Print Constraint Data</a> section allow users to print constraint data related to buses, branches, or generators in the desired units. For example:</p><pre><code class="language-julia hljs">@power(MW, MVAr)
printBusConstraint(analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|------------------------------|
| Bus Constraint Data          |
|------------------------------|
| Label | Active Power Balance |
|       |                      |
|       | Solution |      Dual |
|       |     [MW] | [$/MW-hr] |
|-------|----------|-----------|
| Bus 1 |   0.0000 |    0.0000 |
| Bus 2 |   0.0000 |    0.0100 |
| Bus 3 |  -0.0000 |    0.0101 |
|------------------------------|</code></pre><p>Next, users can easily customize the print results for specific constraint, for example:</p><pre><code class="language-julia hljs">printBusConstraint(analysis; label = &quot;Bus 1&quot;, header = true)
printBusConstraint(analysis; label = &quot;Bus 2&quot;, footer = true)</code></pre><hr/><h5 id="Save-Results-to-a-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-File">Save Results to a File</a><a id="Save-Results-to-a-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-File" title="Permalink"></a></h5><p>Users can also redirect print output to a file. For example, data can be saved in a text file as follows:</p><pre><code class="language-julia hljs">open(&quot;bus.txt&quot;, &quot;w&quot;) do file
    printBusConstraint(analysis, file)
end</code></pre><hr/><h5 id="Save-Results-to-a-CSV-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-CSV-File">Save Results to a CSV File</a><a id="Save-Results-to-a-CSV-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-CSV-File" title="Permalink"></a></h5><p>For CSV output, users should first generate a simple table with <code>style = false</code>, and then save it to a CSV file:</p><pre><code class="language-julia hljs">using CSV

io = IOBuffer()
printBusConstraint(analysis, io; style = false)
CSV.write(&quot;constraint.csv&quot;, CSV.File(take!(io); delim = &quot;|&quot;))</code></pre><hr/><h2 id="Primal-and-Dual-Warm-Start"><a class="docs-heading-anchor" href="#Primal-and-Dual-Warm-Start">Primal and Dual Warm Start</a><a id="Primal-and-Dual-Warm-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-and-Dual-Warm-Start" title="Permalink"></a></h2><p>Utilizing the <code>DcOptimalPowerFlow</code> type and proceeding directly to the solver offers the advantage of a warm start. In this scenario, the initial primal and dual values for the subsequent solving step correspond to the solution obtained from the previous step.</p><hr/><h5 id="Primal-Variables"><a class="docs-heading-anchor" href="#Primal-Variables">Primal Variables</a><a id="Primal-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-Variables" title="Permalink"></a></h5><p>In the previous example, the following solution was obtained, representing the values of the primal variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.909741590248875e-9
Generator 2: 0.09540004530353118
Generator 3: -9.818944909661503e-9
Generator 4: 0.14459997442515446</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: -0.10459999863520819
Bus 3: -0.10419999897640614</code></pre><hr/><h5 id="Dual-Variables-2"><a class="docs-heading-anchor" href="#Dual-Variables-2">Dual Variables</a><a class="docs-heading-anchor-permalink" href="#Dual-Variables-2" title="Permalink"></a></h5><p>We also obtained all dual values. Here, we list only the dual variables for one type of constraint as an example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.dual.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: -1.03999892034497
Branch 3: 2.84066608018304e-7
Branch 4: -2.9169378638623428e-8</code></pre><hr/><h5 id="Modify-Optimal-Power-Flow"><a class="docs-heading-anchor" href="#Modify-Optimal-Power-Flow">Modify Optimal Power Flow</a><a id="Modify-Optimal-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Modify-Optimal-Power-Flow" title="Permalink"></a></h5><p>Now, let us introduce changes to the power system from the previous example:</p><pre><code class="language-julia hljs">updateGenerator!(analysis; label = &quot;Generator 2&quot;, maxActive = 0.08)</code></pre><p>Next, we want to solve this modified optimal power flow problem. If we use <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}"><code>solve!</code></a> at this point, the primal and dual initial values will be set to the previously obtained values:</p><pre><code class="language-julia hljs">powerFlow!(analysis)</code></pre><p>As a result, we obtain a new solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.power.generator.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.974942859089796e-9
Generator 2: 0.000800009969396404
Generator 3: 0.09459997966053971
Generator 4: 0.1446000203450072</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.1
Bus 2: -0.10460000039884865
Bus 3: -0.10420000029913648</code></pre><hr/><h5 id="Reset-Primal-and-Dual-Values"><a class="docs-heading-anchor" href="#Reset-Primal-and-Dual-Values">Reset Primal and Dual Values</a><a id="Reset-Primal-and-Dual-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Reset-Primal-and-Dual-Values" title="Permalink"></a></h5><p>Users retain the flexibility to reset these initial primal values to their default configurations at any juncture. This can be accomplished by utilizing the active power outputs of the generators and the initial bus voltage angles extracted from the <code>PowerSystem</code> type, employing the <a href="../../api/optimalPowerFlow/#JuliaGrid.setInitialPoint!-Tuple{DcOptimalPowerFlow}"><code>setInitialPoint!</code></a> function:</p><pre><code class="language-julia hljs">setInitialPoint!(analysis)</code></pre><p>The primal initial values will now be identical to those that would be obtained if the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function were executed after all the updates have been applied, while all dual variable values will be removed.</p><hr/><h2 id="DcExtendedFormulationManual"><a class="docs-heading-anchor" href="#DcExtendedFormulationManual">Extended Formulation</a><a id="DcExtendedFormulationManual-1"></a><a class="docs-heading-anchor-permalink" href="#DcExtendedFormulationManual" title="Permalink"></a></h2><p>The JuMP model created by JuliaGrid is stored in the <code>method.jump</code> field of the <code>DcOptimalPowerFlow</code> type. This allows users to modify the model directly using JuMP macros and functions as needed. However, when making such modifications, users become responsible for tasks like setting initial values and extracting solutions, since these changes operate outside the standard JuliaGrid workflow.</p><p>Beyond this approach, JuliaGrid also provides a way to extend the standard DC optimal power flow formulation within its own framework. This lets users take advantage of features such as warm start and automatic solution storage, as described below.</p><hr/><h4 id="Add-Variable"><a class="docs-heading-anchor" href="#Add-Variable">Add Variable</a><a id="Add-Variable-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variable" title="Permalink"></a></h4><p>User-defined variables can be added to the DC optimal power flow model using the <a href="../../api/optimalPowerFlow/#JuliaGrid.@addVariable"><code>@addVariable</code></a> macro. It also allows immediate assignment of initial primal and dual values. For example:</p><pre><code class="language-julia hljs">@addVariable(analysis, 0.0 &lt;= y &lt;= 0.2, primal = 0.1, lower = 10.0, upper = 0.0)</code></pre><p>We can also define collections of variables:</p><pre><code class="language-julia hljs">@addVariable(analysis, 0.0 &lt;= x[i = 1:2] &lt;= 0.4, primal = [0.1, 0.2], upper = [0.0; -2.5])</code></pre><hr/><h5 id="Add-Constraints-2"><a class="docs-heading-anchor" href="#Add-Constraints-2">Add Constraints</a><a class="docs-heading-anchor-permalink" href="#Add-Constraints-2" title="Permalink"></a></h5><p>Custom constraints can be added to the DC optimal power flow model using the <a href="../../api/optimalPowerFlow/#JuliaGrid.@addConstraint"><code>@addConstraint</code></a> macro. These constraints are not limited to user-defined variables; any optimization variable defined up to that point can be used. Let us focus on the voltage angle variables:</p><pre><code class="language-julia hljs">θ = analysis.method.variable.voltage.angle</code></pre><p>Next, a new constraint can be defined, and at the same time, an initial dual value can be specified:</p><pre><code class="language-julia hljs">@addConstraint(analysis, 0.1 &lt;= x[1] + 2 * x[2] + y + θ[2] &lt;= 0.2, dual = 0.0)</code></pre><p>Collections of constraints can also be defined:</p><pre><code class="language-julia hljs">@addConstraint(analysis, [i = 1:2], x[i] + 2 * θ[i] &lt;= 0.6, dual = [0.0; 0.5])</code></pre><hr/><h5 id="Delete-Constraints-2"><a class="docs-heading-anchor" href="#Delete-Constraints-2">Delete Constraints</a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints-2" title="Permalink"></a></h5><p>To remove a constraint, use the <a href="../../api/optimalPowerFlow/#JuliaGrid.remove!"><code>remove!</code></a> function with the <code>:constraint</code> symbol. For example, to remove the first added constraint:</p><pre><code class="language-julia hljs">remove!(analysis, :constraint; index = 1)</code></pre><hr/><h5 id="Objective-Function"><a class="docs-heading-anchor" href="#Objective-Function">Objective Function</a><a id="Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function" title="Permalink"></a></h5><p>Users can modify the objective function using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.set_objective_function"><code>set_objective_function</code></a> function from the JuMP package. Here is an example of how it can be achieved:</p><pre><code class="language-julia hljs">expr = 1100.2 * analysis.method.variable.power.active[1]^2 - 50 * x[1] - x[2]^2 + y + 123
JuMP.set_objective_function(analysis.method.jump, analysis.method.objective - expr)</code></pre><p>We can now observe the updated objective function as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">853.4 active[3]² + x[2]² + 500 active[1] + 257 active[3] + active[2] + 50 x[1] - y</code></pre><hr/><h5 id="Optimal-Power-Flow-Solution"><a class="docs-heading-anchor" href="#Optimal-Power-Flow-Solution">Optimal Power Flow Solution</a><a id="Optimal-Power-Flow-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Power-Flow-Solution" title="Permalink"></a></h5><p>Users can now solve the extended formulation using:</p><pre><code class="language-julia hljs">powerFlow!(analysis; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><p>After solving, users can access the optimal values as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -9.970011350911707e-9
  0.0008000099640822899
  0.09459997967174905
  0.14460002033418</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.1
 -0.10460000039862187
 -0.1042000002989664</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.extended.solution</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.19999999500567658
 -9.700113509543211e-9
  0.00017117776009241908</code></pre><hr/><h2 id="DCOptimalPowerAnalysisManual"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisManual">Power Analysis</a><a id="DCOptimalPowerAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{DcPowerFlow}"><code>power!</code></a> function. For instance, let us consider the power system for which we obtained the DC optimal power flow solution:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, minFromBus = -0.12, maxFromBus = 0.12)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)

@generator(minActive = 0.0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, maxActive = 0.5)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.2, maxActive = 0.2)

cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; generator = &quot;Generator 2&quot;, active = 1, piecewise = [10.8 12.3; 14.7 16.8])

analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)
powerFlow!(analysis)</code></pre><p>Now we can calculate the active powers using the following function:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><p>Finally, to display the active power injections and from-bus active power flows, we can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -9.628433161879002e-9
Bus 2: 0.09000000962843388
Bus 3: -0.04999999999999716</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.power.from.active)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: -0.007142859893837783
Branch 2: 0.007142850265404177
Branch 3: 0.04285714973459309</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{DcPowerFlow}"><code>power!</code></a> function, we suggest referring to the tutorials on <a href="../../tutorials/dcOptimalPowerFlow/#DCOptimalPowerAnalysisTutorials">DC Optimal Power Flow</a>.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL-2">Print Results in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL-2" title="Permalink"></a></h5><p>Users can utilize any of the print functions outlined in the <a href="../../api/setupPrint/#PrintPowerSystemDataAPI">Print Power System Data</a> or <a href="../../api/setupPrint/#PrintPowerSystemSummaryAPI">Print Power System Summary</a>. For example, to create a bus data with the desired units, users can use the following function:</p><pre><code class="language-julia hljs">@voltage(pu, deg)
@power(MW, MVAr)
printBusData(analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|---------------------------------------------------------------------|
| Bus Data                                                            |
|---------------------------------------------------------------------|
| Label | Voltage | Power Generation | Power Demand | Power Injection |
|       |         |                  |              |                 |
|   Bus |   Angle |           Active |       Active |          Active |
|       |   [deg] |             [MW] |         [MW] |            [MW] |
|-------|---------|------------------|--------------|-----------------|
| Bus 1 |  9.7403 |          -0.0000 |       0.0000 |         -0.0000 |
| Bus 2 |  9.7607 |          19.0000 |      10.0000 |          9.0000 |
| Bus 3 |  9.7362 |           0.0000 |       5.0000 |         -5.0000 |
|---------------------------------------------------------------------|</code></pre><hr/><h5 id="Active-Power-Injection"><a class="docs-heading-anchor" href="#Active-Power-Injection">Active Power Injection</a><a id="Active-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection" title="Permalink"></a></h5><p>To calculate active power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = injectionPower(analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.09000000962843388</code></pre><hr/><h5 id="Active-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-Power-Injection-from-Generators">Active Power Injection from Generators</a><a id="Active-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate active power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = supplyPower(analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.19000000962843167</code></pre><hr/><h5 id="Active-Power-Flow"><a class="docs-heading-anchor" href="#Active-Power-Flow">Active Power Flow</a><a id="Active-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = fromPower(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">0.007142850265404177</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active = toPower(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-0.007142850265404177</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acOptimalPowerFlow/">« AC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../measurementModel/">Measurement Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Saturday 12 July 2025 09:12">Saturday 12 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
