<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC State Estimation · JuliaGrid</title><meta name="title" content="AC State Estimation · JuliaGrid"/><meta property="og:title" content="AC State Estimation · JuliaGrid"/><meta property="twitter:title" content="AC State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li class="is-active"><a class="tocitem" href>AC State Estimation</a><ul class="internal"><li><a class="tocitem" href="#ACSEBusTypeModificationManual"><span>Bus Type Modification</span></a></li><li><a class="tocitem" href="#ACLSStateEstimationSolutionManual"><span>Weighted Least-Squares Estimator</span></a></li><li><a class="tocitem" href="#PMULAVtateEstimationSolutionManual"><span>Least Absolute Value Estimator</span></a></li><li><a class="tocitem" href="#ACMeasurementsAlterationManual"><span>Measurement Set Update</span></a></li><li><a class="tocitem" href="#ACStateEstimationUpdateManual"><span>State Estimation Update</span></a></li><li><a class="tocitem" href="#ACSEPowerCurrentAnalysisManual"><span>Power and Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>AC State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/acStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACStateEstimationManual"><a class="docs-heading-anchor" href="#ACStateEstimationManual">AC State Estimation</a><a id="ACStateEstimationManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACStateEstimationManual" title="Permalink"></a></h1><p>To perform nonlinear or AC state estimation, the initial requirement is to have the <code>PowerSystem</code> type configured with the AC model, along with the <code>Measurement</code> type storing measurement data. Next, we can develop either the weighted least-squares (WLS) model, utilizing the Gauss-Newton method, or the least absolute value (LAV) model. These models are encapsulated within the <code>ACStateEstimation</code> type:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.acLavStateEstimation"><code>acLavStateEstimation</code></a>.</li></ul><hr/><p>To obtain bus voltages and solve the state estimation problem, users need to implement the Gauss-Newton iterative process for the WLS model using:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.increment!"><code>increment!</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.solve!-Union{Tuple{T}, Tuple{PowerSystem, ACStateEstimation{GaussNewton{T}}}} where T&lt;:Union{Normal, Orthogonal}"><code>solve!</code></a>.</li></ul><p>Alternatively, to obtain the LAV estimator, simply execute the second function.</p><p>After solving the AC state estimation, JuliaGrid provides functions for computing powers and currents:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>Alternatively, instead of designing their own iteration process for the Gauss-Newton method or using the function responsible for solving the LAV model, and computing powers and currents, users can use the wrapper function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{T}, Tuple{PowerSystem, ACStateEstimation{GaussNewton{T}}}} where T&lt;:Union{Normal, Orthogonal}"><code>stateEstimation!</code></a>.</li></ul><p>Users can also access specialized functions for computing specific types of <a href="../../api/analysis/#ACPowerAnalysisAPI">powers</a> or <a href="../../api/analysis/#ACCurrentAnalysisAPI">currents</a> for individual buses, branches, or generators within the power system.</p><hr/><h2 id="ACSEBusTypeModificationManual"><a class="docs-heading-anchor" href="#ACSEBusTypeModificationManual">Bus Type Modification</a><a id="ACSEBusTypeModificationManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACSEBusTypeModificationManual" title="Permalink"></a></h2><p>In AC state estimation, it is necessary to designate a slack bus, where the bus voltage angle is known. Therefore, when establishing the <code>ACStateEstimation</code> type, the initially assigned slack bus is evaluated and may be altered. If the designated slack bus (<code>type = 3</code>) lacks a connected in-service generator, it will be changed to a demand bus (<code>type = 1</code>). Conversely, the first generator bus (<code>type = 2</code>) with an active in-service generator linked to it will be reassigned as the new slack bus (<code>type = 3</code>).</p><hr/><h2 id="ACLSStateEstimationSolutionManual"><a class="docs-heading-anchor" href="#ACLSStateEstimationSolutionManual">Weighted Least-Squares Estimator</a><a id="ACLSStateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACLSStateEstimationSolutionManual" title="Permalink"></a></h2><p>To begin, we will define the <code>PowerSystem</code> and <code>Measurement</code> types:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.6, reactive = 0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, reactive = 0.2)

@branch(resistance = 0.14, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.25)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.35)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.16)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 1.2, reactive = 0.3)

@voltmeter(label = &quot;Voltmeter ? (!)&quot;)
addVoltmeter!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, variance = 1e-5)

@ammeter(label = &quot;Ammeter ? (!)&quot;)
addAmmeter!(system, device; from = &quot;Branch 3&quot;, magnitude = 0.0356, variance = 1e-3)
addAmmeter!(system, device; to = &quot;Branch 2&quot;, magnitude = 0.5892, variance = 1e-3)

@wattmeter(label = &quot;Wattmeter ? (!)&quot;)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 0.7067, variance = 1e-4)
addWattmeter!(system, device; bus = &quot;Bus 2&quot;, active = -0.6, variance = 2e-4)

@varmeter(label = &quot;Varmeter ? (!)&quot;)
addVarmeter!(system, device; from = &quot;Branch 1&quot;, reactive = 0.2125, variance = 1e-4)
addVarmeter!(system, device; bus = &quot;Bus 2&quot;, reactive = -0.1, variance = 1e-5)</code></pre><p>Next, to establish the AC state estimation model, we will utilize the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here, the user triggers LU factorization as the default method for solving the system of linear equations within each iteration of the Gauss-Newton method. However, the user also has the option to select alternative factorization methods such as <code>LDLt</code> or <code>QR</code>:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device, LDLt)</code></pre></div></div><hr/><h5 id="Setup-Initial-Voltages"><a class="docs-heading-anchor" href="#Setup-Initial-Voltages">Setup Initial Voltages</a><a id="Setup-Initial-Voltages-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Initial-Voltages" title="Permalink"></a></h5><p>The initial voltages for the Gauss-Newton method are determined based on the specified initial voltage magnitudes and angles within the buses of the <code>PowerSystem</code> type. These values are then forwarded to the <code>ACStateEstimation</code> during the execution of the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function. Therefore, the initial voltages in this example are as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, 0.0
Bus 2: 1.0, 0.0
Bus 3: 1.0, 0.0</code></pre><p>Users have the flexibility to modify these vectors according to their own requirements in order to adjust the initial voltages. For instance, users can conduct an AC power flow analysis and utilize the obtained solution as the initial voltages for AC state estimation:</p><pre><code class="language-julia hljs">powerFlow = newtonRaphson(system)
for iteration = 1:10
    mismatch!(system, powerFlow)
    solve!(system, powerFlow)
end

setInitialPoint!(powerFlow, analysis)</code></pre><hr/><h5 id="State-Estimator"><a class="docs-heading-anchor" href="#State-Estimator">State Estimator</a><a id="State-Estimator-1"></a><a class="docs-heading-anchor-permalink" href="#State-Estimator" title="Permalink"></a></h5><p>To conduct an iterative process using the Gauss-Newton method, it is essential to include the <a href="../../api/stateEstimation/#JuliaGrid.increment!"><code>increment!</code></a> and <a href="../../api/stateEstimation/#JuliaGrid.solve!-Union{Tuple{T}, Tuple{PowerSystem, ACStateEstimation{GaussNewton{T}}}} where T&lt;:Union{Normal, Orthogonal}"><code>solve!</code></a> functions inside the iteration loop. For example:</p><pre><code class="language-julia hljs">for iteration = 1:20
    increment!(system, analysis)
    solve!(system, analysis)
end</code></pre><p>Once the state estimator is obtained, users can access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.9999999893867697, 0.0
Bus 2: 0.8551739067243623, -0.16932686045421688
Bus 3: 0.8460326304864767, -0.17123533032549176</code></pre><hr/><h5 id="Breaking-the-Iterative-Process"><a class="docs-heading-anchor" href="#Breaking-the-Iterative-Process">Breaking the Iterative Process</a><a id="Breaking-the-Iterative-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Breaking-the-Iterative-Process" title="Permalink"></a></h5><p>The iterative process can be terminated using the <a href="../../api/stateEstimation/#JuliaGrid.increment!"><code>increment!</code></a> function. The following code demonstrates how to utilize this function to break out of the iteration loop:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device)
for iteration = 1:20
    stopping = increment!(system, analysis)
    if stopping &lt; 1e-8
        println(&quot;Solution found in $(analysis.method.iteration) iterations.&quot;)
        break
    end
    solve!(system, analysis)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Solution found in 4 iterations.</code></pre><p>The <a href="../../api/stateEstimation/#JuliaGrid.increment!"><code>increment!</code></a> function returns the maximum absolute values of the state variable increment, which are commonly used as a convergence criterion in the iterative Gauss-Newton algorithm.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Readers can refer to the <a href="../../tutorials/acStateEstimation/#ACStateEstimationTutorials">AC State Estimation</a> tutorial for implementation insights.</p></div></div><hr/><h5 id="Wrapper-Function"><a class="docs-heading-anchor" href="#Wrapper-Function">Wrapper Function</a><a id="Wrapper-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-Function" title="Permalink"></a></h5><p>JuliaGrid provides a wrapper function <a href="../../api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{T}, Tuple{PowerSystem, ACStateEstimation{GaussNewton{T}}}} where T&lt;:Union{Normal, Orthogonal}"><code>stateEstimation!</code></a> for AC state estimation. Hence, it offers a way to solve it using the Gauss-Newton method with reduced implementation effort:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device)
stateEstimation!(system, analysis; verbose = 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number of wattmeters: 2   Number of varmeters: 2   Number of voltmeters: 1
  In-service:         2     In-service:        2     In-service:         1
  Out-of-service:     0     Out-of-service:    0     Out-of-service:     0

Number of ammeters:   2   Number of PMUs:      0   Number of devices:    7
  In-service:         2     In-service:        0     In-service:         7
  Out-of-service:     0     Out-of-service:    0     Out-of-service:     0

Number of entries in the Jacobian matrix: 29
Number of measurement functions:           7
Number of state variables:                 5
Number of buses:                           3
Number of branches:                        3

Iteration   Maximum Increment   Objective Value
        0          2.0358e-01    8.01893670e+03
        1          4.8274e-02    2.97107558e+02
        2          1.8715e-03    2.16194897e-01
        3          2.5886e-06    4.71061964e-06
        4          1.5800e-10    3.54147541e-07

                     Minimum Value   Maximum Value
Magnitude Increment:   -1.0215e-11      1.1398e-10
Angle Increment:       -1.5800e-10     -7.4174e-11

EXIT: The solution was found using the Gauss-Newton method in 4 iterations.</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Users can choose any approach in this section to obtain the WLS estimator based on their needs. Additionally, users can review the <a href="../../tutorials/acStateEstimation/#GaussNewtonAlgorithmTutorials">Gauss-Newton Algorithm</a> used in the wrapper function within the tutorial section.</p></div></div><hr/><h5 id="Inclusion-of-PMUs-in-Rectangular-Coordinates"><a class="docs-heading-anchor" href="#Inclusion-of-PMUs-in-Rectangular-Coordinates">Inclusion of PMUs in Rectangular Coordinates</a><a id="Inclusion-of-PMUs-in-Rectangular-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Inclusion-of-PMUs-in-Rectangular-Coordinates" title="Permalink"></a></h5><p>In the example above, our focus is solely on solving the AC state estimation using SCADA measurements. However, users have the option to also integrate PMUs into the AC state estimation, either in the rectangular or polar coordinate system.</p><p>The default approach is to include PMUs in the rectangular coordinate system:</p><pre><code class="language-julia hljs">@pmu(label = &quot;PMU ? (!)&quot;)
addPmu!(system, device; to = &quot;Branch 1&quot;, magnitude = 0.7466, angle = 2.8011)</code></pre><p>In the case of the rectangular system, inclusion resolves ill-conditioned problems arising in polar coordinates due to small values of current magnitudes. However, this approach&#39;s main disadvantage is related to measurement errors, as measurement errors correspond to polar coordinates. Therefore, the covariance matrix must be transformed from polar to rectangular coordinates [<a href="../../background/bibliography/#zhou2006alternative">3</a>]. As a result, measurement errors of a single PMU are correlated, and the covariance matrix does not have a diagonal form. Despite that, the measurement error covariance matrix is usually considered as a diagonal matrix, affecting the accuracy of the state estimation.</p><p>In the example above, we specifically include PMUs where measurement error correlations are disregarded. This is evident through the precision matrix, which maintains a diagonal form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis = gaussNewton(system, device);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">9×9 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:
 100000.0      ⋅       ⋅        ⋅       ⋅   …        ⋅    ⋅          ⋅
       ⋅   1000.0      ⋅        ⋅       ⋅            ⋅    ⋅          ⋅
       ⋅       ⋅   1000.0       ⋅       ⋅            ⋅    ⋅          ⋅
       ⋅       ⋅       ⋅   10000.0      ⋅            ⋅    ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅   5000.0           ⋅    ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅   …        ⋅    ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅      100000.0   ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅            ⋅   1.05192e8   ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅            ⋅    ⋅         1.64807e8</code></pre><p>Lastly, we incorporate correlation into our model by adding a new PMU with the desired error correlation:</p><pre><code class="language-julia hljs">addPmu!(system, device; bus = &quot;Bus 3&quot;, magnitude = 0.846, angle = -0.1712, correlated = true)</code></pre><p>Now, we can observe the precision matrix that does not hold a diagonal form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis = gaussNewton(system, device);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">11×11 SparseArrays.SparseMatrixCSC{Float64, Int64} with 13 stored entries:
 100000.0      ⋅       ⋅        ⋅   …   ⋅          ⋅          ⋅
       ⋅   1000.0      ⋅        ⋅       ⋅          ⋅          ⋅
       ⋅       ⋅   1000.0       ⋅       ⋅          ⋅          ⋅
       ⋅       ⋅       ⋅   10000.0      ⋅          ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅          ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅   …   ⋅          ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅          ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅          ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅      1.64807e8   ⋅          ⋅
       ⋅       ⋅       ⋅        ⋅       ⋅         1.01153e8  6.66801e6
       ⋅       ⋅       ⋅        ⋅   …   ⋅         6.66801e6  1.38567e8</code></pre><hr/><h5 id="Inclusion-of-PMUs-in-Polar-Coordinates"><a class="docs-heading-anchor" href="#Inclusion-of-PMUs-in-Polar-Coordinates">Inclusion of PMUs in Polar Coordinates</a><a id="Inclusion-of-PMUs-in-Polar-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Inclusion-of-PMUs-in-Polar-Coordinates" title="Permalink"></a></h5><p>The second approach involves incorporating these measurements into the polar coordinate system. For instance:</p><pre><code class="language-julia hljs">addPmu!(system, device; from = &quot;Branch 1&quot;, magnitude = 0.7379, angle = -0.2921, polar = true)</code></pre><p>This inclusion of PMUs provides more accurate state estimates compared to rectangular inclusion, but demands longer computing time. PMUs are handled in the same manner as SCADA measurements. However, this approach is susceptible to ill-conditioned problems arising in polar coordinates due to small values of current magnitudes [<a href="../../background/bibliography/#zhou2006alternative">3</a>, <a href="../../background/bibliography/#korres2012state">4</a>].</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>It is important to note that with each individual phasor measurement, we can set the coordinate system, providing flexibility to include some in polar and some in rectangular systems. This flexibility is particularly valuable because bus voltage phasor measurements are preferably included in a polar coordinate system, while current phasor measurements are best suited to a rectangular coordinate system.</p></div></div><hr/><h5 id="Alternative-Formulation"><a class="docs-heading-anchor" href="#Alternative-Formulation">Alternative Formulation</a><a id="Alternative-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Formulation" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from finding a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal method [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 3.2].</p><p>This approach is suitable when measurement errors are uncorrelated, and the precision matrix remains diagonal. Therefore, as a preliminary step, we need to eliminate the correlation, as we did previously:</p><pre><code class="language-julia hljs">updatePmu!(system, device; label = &quot;PMU 2 (Bus 3)&quot;, correlated = false)</code></pre><p>Subsequently, by specifying the <code>Orthogonal</code> argument in the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function, JuliaGrid implements a more robust approach to obtain the WLS estimator, which proves particularly beneficial when substantial differences exist among measurement variances:</p><pre><code class="language-julia hljs">analysis = gaussNewton(system, device, Orthogonal)
stateEstimation!(system, analysis; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The solution was found using the Gauss-Newton method in 7 iterations.</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Readers can refer to the <a href="../../tutorials/acStateEstimation/#ACAlternativeFormulationTutorials">Alternative Formulation</a> tutorial for implementation insights.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL">Print Results in the REPL</a><a id="Print-Results-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL" title="Permalink"></a></h5><p>Users have the option to print the results in the REPL using any units that have been configured, such as:</p><pre><code class="language-julia hljs">@voltage(pu, deg)
printBusData(system, analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-----------------------------|
| Bus Data                    |
|-----------------------------|
| Label |       Voltage       |
|       |                     |
|   Bus | Magnitude |   Angle |
|       |      [pu] |   [deg] |
|-------|-----------|---------|
| Bus 1 |    0.9999 |  0.0000 |
| Bus 2 |    0.8551 | -9.7028 |
| Bus 3 |    0.8460 | -9.8090 |
|-----------------------------|</code></pre><p>Next, users can easily customize the print results for specific buses, for example:</p><pre><code class="language-julia hljs">printBusData(system, analysis; label = &quot;Bus 1&quot;, header = true)
printBusData(system, analysis; label = &quot;Bus 2&quot;)
printBusData(system, analysis; label = &quot;Bus 3&quot;, footer = true)</code></pre><hr/><h5 id="Save-Results-to-a-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-File">Save Results to a File</a><a id="Save-Results-to-a-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-File" title="Permalink"></a></h5><p>Users can also redirect print output to a file. For example, data can be saved in a text file as follows:</p><pre><code class="language-julia hljs">open(&quot;bus.txt&quot;, &quot;w&quot;) do file
    printBusData(system, analysis, file)
end</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We also provide functions to print or save state estimation results, such as estimated values and residuals. For more details, users can consult the <a href="#ACSEPowerCurrentAnalysisManual">Power and Current Analysis</a> section of this manual.</p></div></div><hr/><h2 id="PMULAVtateEstimationSolutionManual"><a class="docs-heading-anchor" href="#PMULAVtateEstimationSolutionManual">Least Absolute Value Estimator</a><a id="PMULAVtateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMULAVtateEstimationSolutionManual" title="Permalink"></a></h2><p>The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data analysis procedures [<a href="../../background/bibliography/#aburbook">5</a>, Ch. 6]. However, it is important to note that achieving robustness typically involves increased computational complexity.</p><p>To obtain an LAV estimator, users need to employ one of the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> listed in the JuMP documentation. In many common scenarios, the <code>Ipopt</code> solver proves sufficient to obtain a solution:</p><pre><code class="language-julia hljs">using Ipopt

analysis = acLavStateEstimation(system, device, Ipopt.Optimizer; verbose = 1)</code></pre><hr/><h5 id="Setup-Initial-Primal-Values"><a class="docs-heading-anchor" href="#Setup-Initial-Primal-Values">Setup Initial Primal Values</a><a id="Setup-Initial-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Initial-Primal-Values" title="Permalink"></a></h5><p>In JuliaGrid, the assignment of initial primal values for optimization variables takes place when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function is executed. Initial primal values are determined based on the <code>voltage</code> fields within the <code>ACStateEstimation</code> type. By default, these values are established using the initial bus voltage magnitudes and angles from <code>PowerSystem</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, 0.0
Bus 2: 1.0, 0.0
Bus 3: 1.0, 0.0</code></pre><p>Users have the flexibility to customize these values according to their requirements, and they will be utilized as the initial primal values when executing the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a> function. Additionally, the <a href="../../api/stateEstimation/#JuliaGrid.setInitialPoint!-Tuple{PowerSystem, ACStateEstimation}">setInitialPoint!</a> function allows users to configure the initial point as required.</p><hr/><h5 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h5><p>To solve the formulated LAV state estimation model, simply execute the following function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: Solved To Acceptable Level.</code></pre><p>Upon obtaining the solution, access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.9999955872956292, 0.0
Bus 2: 0.8551679159257191, -0.16932741993230138
Bus 3: 0.8460243689616362, -0.17123746785110638</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Readers can refer to the <a href="../../tutorials/acStateEstimation/#ACLAVTutorials">Least Absolute Value Estimation</a> tutorial for implementation insights.</p></div></div><hr/><h2 id="ACMeasurementsAlterationManual"><a class="docs-heading-anchor" href="#ACMeasurementsAlterationManual">Measurement Set Update</a><a id="ACMeasurementsAlterationManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACMeasurementsAlterationManual" title="Permalink"></a></h2><p>After establishing the <code>Measurement</code> type using the <a href="../../api/measurementModel/#JuliaGrid.measurement"><code>measurement</code></a> function, users gain the capability to incorporate new measurement devices or update existing ones.</p><p>Once updates are completed, users can seamlessly progress towards generating the <code>ACStateEstimation</code> type using the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> or <a href="../../api/stateEstimation/#JuliaGrid.acLavStateEstimation"><code>acLavStateEstimation</code></a> function and solving the AC state estimation:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement() # &lt;- Initialize the Measurement instance

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.6, reactive = 0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, reactive = 0.2)

@branch(resistance = 0.14, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.25)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.35)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.16)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 1.2, reactive = 0.3)

@voltmeter(label = &quot;Voltmeter ? (!)&quot;, variance = 1e-3)
addVoltmeter!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0)

@wattmeter(label = &quot;Wattmeter ? (!)&quot;, varianceBus = 1e-2)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 0.7067)
addWattmeter!(system, device; bus = &quot;Bus 2&quot;, active = -0.6)

@varmeter(label = &quot;Varmeter ? (!)&quot;, varianceFrom = 1e-3)
addVarmeter!(system, device; from = &quot;Branch 1&quot;, reactive = 0.2125)
addVarmeter!(system, device; bus = &quot;Bus 2&quot;, reactive = -0.1)

@pmu(label = &quot;PMU ? (!)&quot;)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 0.8552, angle = -0.1693)

analysis = gaussNewton(system, device) # &lt;- Build ACStateEstimation for the defined model
stateEstimation!(system, analysis)

addWattmeter!(system, device; from = &quot;Branch 3&quot;, active = 0.0291)
updateWattmeter!(system, device; label = &quot;Wattmeter 2 (Bus 2)&quot;, variance = 1e-4)

addVarmeter!(system, device; to = &quot;Branch 3&quot;, reactive = -0.037, variance = 1e-5)
updateVarmeter!(system, device; label = &quot;Varmeter 2 (Bus 2)&quot;, reactive = -0.11)

updatePmu!(system, device; label = &quot;PMU 1 (Bus 2)&quot;, polar = false)

analysis = gaussNewton(system, device) # &lt;- Build ACStateEstimation for the updated model
stateEstimation!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to restart and recreate the <code>Measurement</code> type from the beginning when implementing changes to the existing measurement set.</p></div></div><hr/><h2 id="ACStateEstimationUpdateManual"><a class="docs-heading-anchor" href="#ACStateEstimationUpdateManual">State Estimation Update</a><a id="ACStateEstimationUpdateManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACStateEstimationUpdateManual" title="Permalink"></a></h2><p>An advanced methodology involves users establishing the <code>ACStateEstimation</code> type using <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> or <a href="../../api/stateEstimation/#JuliaGrid.acLavStateEstimation"><code>acLavStateEstimation</code></a> just once. After this initial setup, users can seamlessly modify existing measurement devices without the need to recreate the <code>ACStateEstimation</code> type.</p><p>This advancement extends beyond the previous scenario where recreating the <code>Measurement</code> type was unnecessary, to now include the scenario where <code>ACStateEstimation</code> also does not need to be recreated.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The addition of new measurements after the creation of <code>ACStateEstimation</code> is not practical in terms of reusing this type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.</p></div></div><p>We can modify the prior example to achieve the same model without establishing <code>ACStateEstimation</code> twice:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement() # &lt;- Initialize the Measurement instance

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.6, reactive = 0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, reactive = 0.2)

@branch(resistance = 0.14, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.25)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.35)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.16)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 1.2, reactive = 0.3)

@voltmeter(label = &quot;Voltmeter ? (!)&quot;)
addVoltmeter!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0)

@wattmeter(label = &quot;Wattmeter ? (!)&quot;, varianceBus = 1e-2)
addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 0.7067)
addWattmeter!(system, device; bus = &quot;Bus 2&quot;, active = -0.6)
addWattmeter!(system, device; from = &quot;Branch 3&quot;, active = 0.0291, status = 0)

@varmeter(label = &quot;Varmeter ? (!)&quot;, varianceFrom = 1e-3)
addVarmeter!(system, device; from = &quot;Branch 1&quot;, reactive = 0.2125)
addVarmeter!(system, device; bus = &quot;Bus 2&quot;, reactive = -0.1)
addVarmeter!(system, device; to = &quot;Branch 3&quot;, reactive = -0.037, variance = 1e-5, status = 0)

@pmu(label = &quot;PMU ? (!)&quot;)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 0.8552, angle = -0.1693)

analysis = gaussNewton(system, device) # &lt;- Build ACStateEstimation for the defined model
stateEstimation!(system, analysis)

updateWattmeter!(system, device, analysis; label = &quot;Wattmeter 3 (From Branch 3)&quot;, status = 1)
updateWattmeter!(system, device, analysis; label = &quot;Wattmeter 2 (Bus 2)&quot;, variance = 1e-4)

updateVarmeter!(system, device, analysis; label = &quot;Varmeter 3 (To Branch 3)&quot;, status = 1)
updateVarmeter!(system, device, analysis; label = &quot;Varmeter 2 (Bus 2)&quot;, reactive = -0.11)

updatePmu!(system, device, analysis; label = &quot;PMU 1 (Bus 2)&quot;, polar = false)

# &lt;- No need for re-build; we have already updated the existing ACStateEstimation instance
stateEstimation!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to rebuild both the <code>Measurement</code> and the <code>ACStateEstimation</code> from the beginning when implementing changes to the existing measurement set. In the scenario of employing the WLS model, JuliaGrid can reuse the symbolic factorizations of LU or LDLt, provided that the nonzero pattern of the gain matrix remains unchanged.</p></div></div><hr/><h2 id="ACSEPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#ACSEPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="ACSEPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACSEPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the AC state estimation, we can calculate various electrical quantities related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions. For instance, let us consider the model for which we obtained the AC state estimation solution:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, susceptance = 0.002)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1, reactive = 0.01)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 2.5, reactive = 0.2)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.03)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.3)

addWattmeter!(system, device; from = &quot;Branch 1&quot;, active = 1.046, variance = 1e-2)
addWattmeter!(system, device; bus = &quot;Bus 2&quot;, active = -0.1, variance = 1e-3)
addWattmeter!(system, device; from = &quot;Branch 3&quot;, active = 0.924, variance = 1e-3)

addVarmeter!(system, device; from = &quot;Branch 1&quot;, reactive = 0.059, variance = 1e-3)
addVarmeter!(system, device; bus = &quot;Bus 2&quot;, reactive = -0.01, variance = 1e-2)
addVarmeter!(system, device; to = &quot;Branch 3&quot;, reactive = -0.044, variance = 1e-3)

analysis = gaussNewton(system, device)
stateEstimation!(system, analysis; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The solution was found using the Gauss-Newton method in 6 iterations.</code></pre><p>We can now utilize the provided functions to compute powers and currents:</p><pre><code class="language-julia hljs">power!(system, analysis)
current!(system, analysis)</code></pre><p>For instance, if we want to show the active power injections and the from-bus current angles, we can employ the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 2.6951392544228305
Bus 2: -0.09999730840051714
Bus 3: -2.4992878004905723</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.current.from.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: -0.056343895391946154
Branch 2: -0.15413096831549436
Branch 3: -0.08788060834432551</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers and currents associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions, we suggest referring to the tutorials on <a href="../../tutorials/acStateEstimation/#ACStateEstimationTutorials">AC State Estimation</a>.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL-2">Print Results in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL-2" title="Permalink"></a></h5><p>Users can utilize any of the print functions outlined in the <a href="../../api/setupPrint/#setupPrintAPI">Print API</a>. For example, to print state estimation data related to wattmeters, we can use:</p><pre><code class="language-julia hljs">@power(MW, pu)
printWattmeterData(system, device, analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|---------------------------------------------------------------|
| Wattmeter Data                                                |
|---------------------------------------------------------------|
| Label |                     Active Power                      |
|       |                                                       |
|       | Measurement | Variance | Estimate | Residual | Status |
|       |        [MW] |     [MW] |     [MW] |     [MW] |        |
|-------|-------------|----------|----------|----------|--------|
| 1     |    104.6000 | 1.00e+00 | 104.6026 |  -0.0026 |      1 |
| 2     |    -10.0000 | 1.00e-01 |  -9.9997 |  -0.0003 |      1 |
| 3     |     92.4000 | 1.00e-01 |  92.3997 |   0.0003 |      1 |
|---------------------------------------------------------------|</code></pre><hr/><h5 id="Save-Results-to-a-CSV-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-CSV-File">Save Results to a CSV File</a><a id="Save-Results-to-a-CSV-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-CSV-File" title="Permalink"></a></h5><p>For CSV output, users should first generate a simple table with <code>style = false</code>, and then save it to a CSV file:</p><pre><code class="language-julia hljs">using CSV

io = IOBuffer()
printWattmeterData(system, device, analysis, io; style = false)
CSV.write(&quot;bus.csv&quot;, CSV.File(take!(io); delim = &quot;|&quot;))</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection">Active and Reactive Power Injection</a><a id="Active-and-Reactive-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection" title="Permalink"></a></h5><p>To calculate the active and reactive power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = injectionPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(2.6951392544228305, 0.31320449720691024)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection-from-Generators">Active and Reactive Power Injection from Generators</a><a id="Active-and-Reactive-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = supplyPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(2.6951392544228305, 0.31320449720691024)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Shunt-Element"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Shunt-Element">Active and Reactive Power at Shunt Element</a><a id="Active-and-Reactive-Power-at-Shunt-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Shunt-Element" title="Permalink"></a></h5><p>To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = shuntPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, -0.0020066379178127042)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Flow"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Flow">Active and Reactive Power Flow</a><a id="Active-and-Reactive-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6491130619728873, 0.25621149744636623)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-1.5932872124411979, -0.15530958335763043)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Charging-Admittances"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Charging-Admittances">Active and Reactive Power at Charging Admittances</a><a id="Active-and-Reactive-Power-at-Charging-Admittances-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Charging-Admittances" title="Permalink"></a></h5><p>To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = chargingPower(system, analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(9.80036319844151e-5, -0.03920145279376604)</code></pre><p>Active powers indicate active losses within the branch&#39;s charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.</p><hr/><h5 id="Active-and-Reactive-Power-at-Series-Impedance"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Series-Impedance">Active and Reactive Power at Series Impedance</a><a id="Active-and-Reactive-Power-at-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Series-Impedance" title="Permalink"></a></h5><p>To calculate the active and reactive power across the series impedance of the branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = seriesPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.05572979310997467, 0.13932448277493664)</code></pre><p>The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance&#39;s inductive characteristics.</p><hr/><h5 id="Current-Injection"><a class="docs-heading-anchor" href="#Current-Injection">Current Injection</a><a id="Current-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injection" title="Permalink"></a></h5><p>To calculate the current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = injectionCurrent(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(2.7087856562191526, -0.1156919344469013)</code></pre><hr/><h5 id="Current-Flow"><a class="docs-heading-anchor" href="#Current-Flow">Current Flow</a><a id="Current-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow" title="Permalink"></a></h5><p>We can compute the current flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = fromCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6661346814754245, -0.15413096831549436)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = toCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6709804259856276, 2.964170792385997)</code></pre><hr/><h5 id="Current-Through-Series-Impedance"><a class="docs-heading-anchor" href="#Current-Through-Series-Impedance">Current Through Series Impedance</a><a id="Current-Through-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Through-Series-Impedance" title="Permalink"></a></h5><p>To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = seriesCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6692781839761557, -0.1659946761684348)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../observabilityAnalysis/">« Observability Analysis</a><a class="docs-footer-nextpage" href="../pmuStateEstimation/">PMU State Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Wednesday 19 March 2025 14:31">Wednesday 19 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
