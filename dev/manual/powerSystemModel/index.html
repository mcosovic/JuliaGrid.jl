<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power System Model · JuliaGrid</title><meta name="title" content="Power System Model · JuliaGrid"/><meta property="og:title" content="Power System Model · JuliaGrid"/><meta property="twitter:title" content="Power System Model · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Power System Model</a><ul class="internal"><li><a class="tocitem" href="#BuildModelManual"><span>Build Model</span></a></li><li><a class="tocitem" href="#SaveModelManual"><span>Save Model</span></a></li><li><a class="tocitem" href="#AddBusManual"><span>Add Bus</span></a></li><li><a class="tocitem" href="#AddBranchManual"><span>Add Branch</span></a></li><li><a class="tocitem" href="#AddGeneratorManual"><span>Add Generator</span></a></li><li><a class="tocitem" href="#AddTemplatesManual"><span>Add Templates</span></a></li><li><a class="tocitem" href="#LabelsManual"><span>Labels</span></a></li><li><a class="tocitem" href="#ACDCModelManual"><span>AC and DC Model</span></a></li><li><a class="tocitem" href="#UpdateBusManual"><span>Update Bus</span></a></li><li><a class="tocitem" href="#UpdateBranchManual"><span>Update Branch</span></a></li><li><a class="tocitem" href="#UpdateGeneratorManual"><span>Update Generator</span></a></li><li><a class="tocitem" href="#AddUpdateCostsManual"><span>Add and Update Costs</span></a></li></ul></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Power System Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power System Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/powerSystemModel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerSystemModelManual"><a class="docs-heading-anchor" href="#PowerSystemModelManual">Power System Model</a><a id="PowerSystemModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#PowerSystemModelManual" title="Permalink"></a></h1><p>JuliaGrid supports the type <code>PowerSystem</code> to preserve power system data, with the following fields: <code>bus</code>, <code>branch</code>, <code>generator</code>, <code>base</code>, and <code>model</code>. The <code>bus</code>, <code>branch</code>, and <code>generator</code> fields hold data related to buses, branches, and generators, respectively. The <code>base</code> field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes for the base power and line-to-line voltages measured in volts for base voltages. Within the <code>model</code> field, the <code>ac</code> and <code>dc</code> subfields store vectors and matrices pertinent to the power system&#39;s topology and parameters, and these are utilized in either the AC or DC framework.</p><p>The type <code>PowerSystem</code> can be created using a function:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.powerSystem"><code>powerSystem</code></a>.</li></ul><p>JuliaGrid supports three modes for populating the <code>PowerSystem</code> type: using built-in functions, using HDF5 file format, and using <a href="https://matpower.org">Matpower</a> case files.</p><p>It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.savePowerSystem"><code>savePowerSystem</code></a>.</li></ul><p>Upon creation of the <code>PowerSystem</code> type, users can generate vectors and matrices based on the power system topology and parameters using the following functions:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a>.</li></ul><hr/><p>Once the <code>PowerSystem</code> type is created, users can add buses, branches, generators, or manage costs associated with the output powers of the generators, using the following functions:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a>.</li></ul><p>JuliaGrid also provides macros <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.@branch"><code>@branch</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.</p><p>Moreover, it is feasible to modify the parameters of buses, branches, and generators. When these functions are executed, all relevant fields within the <code>PowerSystem</code> type will be automatically updated, encompassing the <code>ac</code> and <code>dc</code> fields as well. These functions include:</p><ul><li><a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a>,</li><li><a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a>.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The functions <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> serve a dual purpose. While their primary function is to modify the <code>PowerSystem</code> type, they are also designed to accept various analysis models like AC or DC power flow models. When feasible, these functions not only modify the <code>PowerSystem</code> type but also adapt the analysis model, often resulting in improved computational efficiency. Detailed instructions on utilizing this feature can be found in dedicated manuals for specific analyses.</p></div></div><hr/><h2 id="BuildModelManual"><a class="docs-heading-anchor" href="#BuildModelManual">Build Model</a><a id="BuildModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#BuildModelManual" title="Permalink"></a></h2><p>The <a href="../../api/powerSystemModel/#JuliaGrid.powerSystem"><code>powerSystem</code></a> function generates the <code>PowerSystem</code> type and requires a string-formatted path to either Matpower cases or HDF5 files as input. Alternatively, the <code>PowerSystem</code> can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.</p><hr/><h5 id="Matpower-File"><a class="docs-heading-anchor" href="#Matpower-File">Matpower File</a><a id="Matpower-File-1"></a><a class="docs-heading-anchor-permalink" href="#Matpower-File" title="Permalink"></a></h5><p>For example, to create the <code>PowerSystem</code> type using the Matpower case file for the IEEE 14-bus test case, which is named <code>case14.m</code> and located in the folder <code>C:\matpower</code>, the following Julia code can be used:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;C:/matpower/case14.m&quot;)</code></pre><hr/><h5 id="HDF5-File"><a class="docs-heading-anchor" href="#HDF5-File">HDF5 File</a><a id="HDF5-File-1"></a><a class="docs-heading-anchor-permalink" href="#HDF5-File" title="Permalink"></a></h5><p>In order to use the HDF5 file as input to create the <code>PowerSystem</code> type, it is necessary to have saved the data using the <a href="../../api/powerSystemModel/#JuliaGrid.savePowerSystem"><code>savePowerSystem</code></a> function beforehand. As an example, let us say we saved the power system as <code>case14.h5</code> in the directory <code>C:\hdf5</code>. In this case, the following Julia code can be used to construct the <code>PowerSystem</code> type:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;C:/hdf5/case14.h5&quot;)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>It is recommended to load the power system from the HDF5 file to reduce the loading time.</p></div></div><hr/><h5 id="Model-from-Scratch"><a class="docs-heading-anchor" href="#Model-from-Scratch">Model from Scratch</a><a id="Model-from-Scratch-1"></a><a class="docs-heading-anchor-permalink" href="#Model-from-Scratch" title="Permalink"></a></h5><p>Alternatively, the model can be built from scratch using built-in functions, for example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1, base = 345e3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, base = 345e3)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)</code></pre><hr/><h5 id="Internal-Unit-System"><a class="docs-heading-anchor" href="#Internal-Unit-System">Internal Unit System</a><a id="Internal-Unit-System-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Unit-System" title="Permalink"></a></h5><p>The <code>PowerSystem</code> type stores all electrical quantities in per-units and radians, except for the base values of power and voltages. The base power value is expressed in volt-amperes, while the base voltages are given in volts.</p><hr/><h5 id="Change-Base-Unit-Prefixes"><a class="docs-heading-anchor" href="#Change-Base-Unit-Prefixes">Change Base Unit Prefixes</a><a id="Change-Base-Unit-Prefixes-1"></a><a class="docs-heading-anchor-permalink" href="#Change-Base-Unit-Prefixes" title="Permalink"></a></h5><p>The user can retrieve the base power and base voltage values along with their respective units:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.power.value, system.base.power.unit</code><code class="nohighlight hljs ansi" style="display:block;">(1.0e8, &quot;VA&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([345000.0, 345000.0], &quot;V&quot;)</code></pre><p>By using the <a href="../../api/setupPrint/#JuliaGrid.@base"><code>@base</code></a> macro, users can change the prefixes of the base units. For instance, if users wish to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following macro:</p><pre><code class="language-julia hljs">@base(system, MVA, kV)</code></pre><p>After executing the macro, the base power and voltage values and their units will be modified accordingly:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.power.value, system.base.power.unit</code><code class="nohighlight hljs ansi" style="display:block;">(100.0, &quot;MVA&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([345.0, 345.0], &quot;kV&quot;)</code></pre><hr/><h2 id="SaveModelManual"><a class="docs-heading-anchor" href="#SaveModelManual">Save Model</a><a id="SaveModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#SaveModelManual" title="Permalink"></a></h2><p>Once the <code>PowerSystem</code> type has been created using one of the methods outlined in <a href="#BuildModelManual">Build Model</a>, the data can be stored in the HDF5 file by using the <a href="../../api/powerSystemModel/#JuliaGrid.savePowerSystem"><code>savePowerSystem</code></a> function:</p><pre><code class="language-julia hljs">savePowerSystem(system; path = &quot;C:/matpower/case14.h5&quot;, reference = &quot;IEEE 14-bus test case&quot;)</code></pre><p>All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. Note that even if the user modifies the base units using the <a href="../../api/setupPrint/#JuliaGrid.@base"><code>@base</code></a> macro, the units will still be saved with the default settings.</p><hr/><h2 id="AddBusManual"><a class="docs-heading-anchor" href="#AddBusManual">Add Bus</a><a id="AddBusManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddBusManual" title="Permalink"></a></h2><p>The buses can be added both to the loaded power system, or to the one created from scratch. As an illustration, we can initiate the <code>PowerSystem</code> type and then incorporate two buses by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1, base = 345e3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, angle = -0.034907, base = 345e3)</code></pre><p>In this case, we have created two buses where the active power demanded by the consumer at <code>Bus 1</code> is specified in per-units, which are the same units used to store electrical quantities:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.0</code></pre><p>It is worth noting that the <code>base</code> keyword is used to specify the base voltages, and its default input unit is in volts (V):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([345000.0, 345000.0], &quot;V&quot;)</code></pre><p>Also, we have defined the bus voltage angle in radians for <code>Bus 2</code> as its initial value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  0.0
 -0.034907</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend reading the documentation for the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, where we have provided a list of all the keywords that can be used.</p></div></div><hr/><h5 id="Customizing-Input-Units"><a class="docs-heading-anchor" href="#Customizing-Input-Units">Customizing Input Units</a><a id="Customizing-Input-Units-1"></a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units" title="Permalink"></a></h5><p>Typically, all keywords associated with electrical quantities are expected to be provided in per-units and radians by default, with the exception of base voltages, which should be specified in volts. However, users can choose to use different units than the default per-units and radians or modify the prefix of the base voltage unit by using macros such as the following:</p><pre><code class="language-julia hljs">@power(MW, MVAr, pu)
@voltage(pu, deg, kV)</code></pre><p>This practical example showcases the customization approach. For keywords tied to active powers, the unit is set as megawatts (MW), while reactive powers employ megavolt-amperes reactive (MVAr). Apparent power, on the other hand, employs per-units (pu). As for keywords concerning voltage magnitude, per-units (pu) remain the choice, but voltage angle mandates degrees (deg). Lastly, the input unit for base voltage is elected to be kilovolts (kV).</p><p>Now we can create identical two buses as before using new system of units as follows:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 10.0, base = 345.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, angle = -2.0, base = 345.0)</code></pre><p>As can be observed, electrical quantities will continue to be stored in per-units and radians format:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  0.0
 -0.03490658503988659</code></pre><p>The base voltage values will still be stored in volts (V) since we only changed the input unit prefix, and did not modify the internal unit prefix, as shown below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([345000.0, 345000.0], &quot;V&quot;)</code></pre><p>To modify the internal unit prefix, the following macro can be used:</p><pre><code class="language-julia hljs">@base(system, VA, kV)</code></pre><p>After executing this macro, the base voltage values will be stored in kilovolts (kV):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.base.voltage.value, system.base.voltage.unit</code><code class="nohighlight hljs ansi" style="display:block;">([345.0, 345.0], &quot;kV&quot;)</code></pre><hr/><h2 id="AddBranchManual"><a class="docs-heading-anchor" href="#AddBranchManual">Add Branch</a><a id="AddBranchManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddBranchManual" title="Permalink"></a></h2><p>The branch connecting two buses can be added once those buses are defined, and <code>from</code> and <code>to</code> keywords must correspond to labels of those buses. For example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, angle = -0.2)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)</code></pre><p>Here, we created the branch from <code>Bus 1</code> to <code>Bus 2</code> with following parameter:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.12</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is recommended to consult the documentation for the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function, where we have provided a list of all the keywords that can be used.</p></div></div><hr/><h5 id="Customizing-Input-Units-2"><a class="docs-heading-anchor" href="#Customizing-Input-Units-2">Customizing Input Units</a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-2" title="Permalink"></a></h5><p>To use units other than per-units and radians, macros can be employed to change the input units. For example, if there is a need to use ohms (Ω), the macros below can be employed:</p><pre><code class="language-julia hljs">@parameter(Ω, pu)

system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, angle = -0.2)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 22.8528)</code></pre><p>Still, all electrical quantities are stored in per-units, and the same branch as before is created:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.11999999999999998</code></pre><p>It is important to note that, when working with impedance and admittance values in ohms (Ω) and siemens (S) that are related to a transformer, the assignment must be based on the primary side of the transformer.</p><hr/><h2 id="AddGeneratorManual"><a class="docs-heading-anchor" href="#AddGeneratorManual">Add Generator</a><a id="AddGeneratorManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddGeneratorManual" title="Permalink"></a></h2><p>The generator connected to a bus can be added once the bus is defined. Each generator must have a unique label, and the <code>bus</code> keyword should correspond to the unique label of the bus it is connected to. For instance:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 2&quot;, active = 0.5, reactive = 0.1)</code></pre><p>In the above code, we add the generator to the <code>Bus 2</code>, with active and reactive power outputs set to:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.active</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.output.reactive</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.1</code></pre><p>Similar to buses and branches, the input units can be changed to units other than per-units using different macros.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is recommended to refer to the documentation for the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function, where we have provided a list of all the keywords that can be used.</p></div></div><hr/><h2 id="AddTemplatesManual"><a class="docs-heading-anchor" href="#AddTemplatesManual">Add Templates</a><a id="AddTemplatesManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddTemplatesManual" title="Permalink"></a></h2><p>The functions <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> are used to add bus, branch, and generator to the power system, respectively. If certain keywords are not specified, default values are assigned to parameters.</p><hr/><h5 id="Default-Keyword-Values"><a class="docs-heading-anchor" href="#Default-Keyword-Values">Default Keyword Values</a><a id="Default-Keyword-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Keyword-Values" title="Permalink"></a></h5><p>Regarding the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, the bus type is automatically configured as a demand bus with <code>type = 1</code>. The initial bus voltage magnitude is set to <code>magnitude = 1.0</code> per-unit, while the base voltage is established as <code>base = 138e3</code> volts. Additionally, the minimum and maximum bus voltage magnitudes are set to <code>minMagnitude = 0.9</code> per-unit and <code>maxMagnitude = 1.1</code> per-unit, respectively.</p><p>Transitioning to the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function, the default operational status is <code>status = 1</code>, indicating that the branch is in-service. The off-nominal turns ratio for the transformer is specified as <code>turnsRatio = 1.0</code>, and the phase shift angle is set to <code>shiftAngle = 0.0</code>, collectively defining the line configuration with these standard settings. The flow rating is also configured as <code>type = 3</code>. Moreover, the minimum and maximum voltage angle differences between the from-bus and to-bus ends are set to <code>minDiffAngle = -2pi</code> and <code>maxDiffAngle = 2pi</code>, respectively.</p><p>Similarly, the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function designates an operational generator by employing <code>status = 1</code>, and it sets <code>magnitude = 1.0</code> per-unit, denoting the desired voltage magnitude setpoint.</p><p>The remaining parameters are initialized with default values of zero.</p><hr/><h5 id="Change-Default-Keyword-Values"><a class="docs-heading-anchor" href="#Change-Default-Keyword-Values">Change Default Keyword Values</a><a id="Change-Default-Keyword-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Change-Default-Keyword-Values" title="Permalink"></a></h5><p>In JuliaGrid, users have the flexibility to adjust default values and assign customized values using the <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.@branch"><code>@branch</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> macros. These macros create bus, branch, and generator templates that are used every time the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a>, and <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> functions are called. For instance, the code block shows an example of creating bus, branch, and generator templates with customized default values:</p><pre><code class="language-julia hljs">system = powerSystem()

@bus(type = 2, active = 0.1)
addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.5)

@branch(reactance = 0.12)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.06)

@generator(magnitude = 1.1)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.6)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 1&quot;, active = 0.2)</code></pre><p>This code example involves two uses of the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> functions. In the first use, the functions rely on the default values set by the templates created with the <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.@branch"><code>@branch</code></a> macros. In contrast, the second use passes specific values that match the keywords used in the templates. As a result, the templates are ignored:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.layout.type</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int8}:
 2
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.12
 0.06</code></pre><p>In the given example, the <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> macro is utilized instead of repeatedly specifying the <code>magnitude</code> keyword in the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. This macro creates a generator template with a default value for <code>magnitude</code>, which is automatically applied every time the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function is called. Therefore, it eliminates the requirement to set the magnitude value for each individual generator:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.1
 1.1</code></pre><hr/><h5 id="Customizing-Input-Units-3"><a class="docs-heading-anchor" href="#Customizing-Input-Units-3">Customizing Input Units</a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-3" title="Permalink"></a></h5><p>Templates can also be defined using a custom unit system, for example:</p><pre><code class="language-julia hljs">system = powerSystem()

@power(MW, MVAr)
@bus(active = 100, reactive = 200)
addBus!(system; label = &quot;Bus 1&quot;)</code></pre><p>In this example, we create the bus template and one bus using SI power units. The resulting power values are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.demand.reactive</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 2.0</code></pre><hr/><h5 id="Multiple-Templates"><a class="docs-heading-anchor" href="#Multiple-Templates">Multiple Templates</a><a id="Multiple-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Templates" title="Permalink"></a></h5><p>In the case of calling the <a href="../../api/powerSystemModel/#JuliaGrid.@bus"><code>@bus</code></a>, <a href="../../api/powerSystemModel/#JuliaGrid.@branch"><code>@branch</code></a>, or <a href="../../api/powerSystemModel/#JuliaGrid.@generator"><code>@generator</code></a> macros multiple times, the provided keywords and values will be combined into a single template for the corresponding component (bus, branch, or generator), which will be used for generating the component.</p><hr/><h5 id="Reset-Templates"><a class="docs-heading-anchor" href="#Reset-Templates">Reset Templates</a><a id="Reset-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Reset-Templates" title="Permalink"></a></h5><p>To reset the bus, branch, and generator templates to their default settings, users can utilize the following macros:</p><pre><code class="language-julia hljs">@default(bus)
@default(branch)
@default(generator)</code></pre><p>Additionally, users can reset all templates using the macro:</p><pre><code class="language-julia hljs">@default(template)</code></pre><hr/><h2 id="LabelsManual"><a class="docs-heading-anchor" href="#LabelsManual">Labels</a><a id="LabelsManual-1"></a><a class="docs-heading-anchor-permalink" href="#LabelsManual" title="Permalink"></a></h2><p>As we have shown, JuliaGrid mandates a distinctive label for every bus, branch, or generator. These labels are stored in ordered dictionaries, functioning as pairs of strings and integers. The string signifies the exclusive label for the specific component, whereas the integer maintains an internal numbering of buses, branches, or generators.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>String labels improve readability, but in larger models, the overhead from using strings can become substantial. To reduce memory usage, users can configure ordered dictionaries to accept and store integers as labels:</p><pre><code class="language-julia hljs">@config(label = Integer)</code></pre></div></div><hr/><h5 id="Integer-Based-Labeling"><a class="docs-heading-anchor" href="#Integer-Based-Labeling">Integer-Based Labeling</a><a id="Integer-Based-Labeling-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-Based-Labeling" title="Permalink"></a></h5><p>Let us take a look at the following illustration:</p><pre><code class="language-julia hljs">@config(label = Integer)

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.1)
addBus!(system; label = 2, type = 1, angle = -0.2)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)

addGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)</code></pre><p>In this example, we use the macro <a href="../../api/setupPrint/#JuliaGrid.@config"><code>@config</code></a> to specify that labels will be stored as integers. It is essential to run this macro; otherwise, even if integers are used in subsequent functions, they will be stored as strings.</p><p>Here, two buses are created with labels <code>1</code> and <code>2</code>. A branch connects these two buses, assigned a unique label of <code>1</code>. Finally, a generator is connected to bus <code>2</code>, with its own label set to <code>1</code>.</p><hr/><h5 id="Automated-Labeling"><a class="docs-heading-anchor" href="#Automated-Labeling">Automated Labeling</a><a id="Automated-Labeling-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-Labeling" title="Permalink"></a></h5><p>Users also possess the option to omit the <code>label</code> keyword, allowing JuliaGrid to independently allocate unique labels for buses, branches, or generators. In such instances, JuliaGrid employs an ordered set of incremental integers for labeling components. To illustrate, consider the subsequent example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; type = 3, active = 0.1)
addBus!(system; type = 1, angle = -0.2)

addBranch!(system; from = 1, to = 2, reactance = 0.12)

addGenerator!(system; bus = 2, active = 0.5, reactive = 0.1)</code></pre><p>This example models the same power system as before. In the previous case, we manually assigned labels using incremental integers. Here, we rely on the automatic labeling behavior, but since the macro <a href="../../api/setupPrint/#JuliaGrid.@config"><code>@config</code></a> is not used, the labels will be stored as strings.</p><hr/><h5 id="Automated-Labeling-Using-Templates"><a class="docs-heading-anchor" href="#Automated-Labeling-Using-Templates">Automated Labeling Using Templates</a><a id="Automated-Labeling-Using-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-Labeling-Using-Templates" title="Permalink"></a></h5><p>Additionally, users have the ability to generate labels through templates and employ the symbol <code>?</code> to insert an incremental set of integers at any location. For instance:</p><pre><code class="language-julia hljs">system = powerSystem()

@bus(label = &quot;Bus ? HV&quot;)
addBus!(system; type = 3, active = 0.1)
addBus!(system; type = 1, angle = -0.2)

@branch(label = &quot;Branch ?&quot;)
addBranch!(system; from = &quot;Bus 1 HV&quot;, to = &quot;Bus 2 HV&quot;, reactance = 0.12)

@generator(label = &quot;Generator ?&quot;)
addGenerator!(system; bus = &quot;Bus 2 HV&quot;, active = 0.5, reactive = 0.1)</code></pre><p>In this example, two buses are generated and labeled as <code>Bus 1 HV</code> and <code>Bus 2 HV</code>, along with one branch and one generator labeled as <code>Branch 1</code> and <code>Generator 1</code>, respectively.</p><hr/><h5 id="Retrieving-Labels"><a class="docs-heading-anchor" href="#Retrieving-Labels">Retrieving Labels</a><a id="Retrieving-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-Labels" title="Permalink"></a></h5><p>Finally, we will outline how users can retrieve stored labels. Let us consider the following power system:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 2&quot;)
addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 3&quot;)

addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 1&quot;, reactance = 0.8)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.5)

addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 1&quot;)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 3&quot;)</code></pre><p>For instance, the bus labels can be accessed using the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 3 entries:
  &quot;Bus 2&quot; =&gt; 1
  &quot;Bus 1&quot; =&gt; 2
  &quot;Bus 3&quot; =&gt; 3</code></pre><p>If the objective is to obtain only labels, users can utilize the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;Bus 2&quot;
 &quot;Bus 1&quot;
 &quot;Bus 3&quot;</code></pre><p>This approach can also be extended to branch and generator labels by making use of the variables present within the <code>PowerSystem</code> type, namely <code>system.branch.label</code> or <code>system.generator.label</code>.</p><p>Moreover, the <code>from</code> and <code>to</code> keywords associated with branches are stored based on internally assigned numerical values linked to bus labels. These values are stored in variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [system.branch.layout.from system.branch.layout.to]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 1  2
 1  3</code></pre><p>To recover the original <code>from</code> and <code>to</code> labels, we can utilize:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [label[system.branch.layout.from] label[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{String}:
 &quot;Bus 2&quot;  &quot;Bus 1&quot;
 &quot;Bus 2&quot;  &quot;Bus 3&quot;</code></pre><p>Similarly, the <code>bus</code> keywords related to generators are saved based on internally assigned numerical values corresponding to bus labels and can be accessed using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.layout.bus</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 2
 3</code></pre><p>To recover the original <code>bus</code> labels, we can utilize:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label[system.generator.layout.bus]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;Bus 1&quot;
 &quot;Bus 3&quot;</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>JuliaGrid offers the capability to print labels alongside various types of data, such as power system parameters, voltages, powers, currents, or constraints used in optimal power flow analyses. For instance:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, system.branch.parameter.reactance)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 2: 0.8
Branch 1: 0.5</code></pre></div></div><hr/><h5 id="Loading-and-Saving-Labels"><a class="docs-heading-anchor" href="#Loading-and-Saving-Labels">Loading and Saving Labels</a><a id="Loading-and-Saving-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-and-Saving-Labels" title="Permalink"></a></h5><p>When a user loads a power system from a Matpower file, the default behavior is to store labels as strings. However, this can be overridden by using the <a href="../../api/setupPrint/#JuliaGrid.@config"><code>@config</code></a> macro to store labels as integers.</p><p>When saving the power system to an HDF5 file, the label type (strings or integers) will match the type chosen during system setup. Likewise, when loading data from an HDF5 file, the label type will be preserved as saved, regardless of what is set by the <a href="../../api/setupPrint/#JuliaGrid.@config"><code>@config</code></a> macro.</p><hr/><h2 id="ACDCModelManual"><a class="docs-heading-anchor" href="#ACDCModelManual">AC and DC Model</a><a id="ACDCModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACDCModelManual" title="Permalink"></a></h2><p>When we constructed the power system, we can create an AC and/or DC model, which include vectors and matrices related to the power system&#39;s topology and parameters. The following code snippet demonstrates this:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, susceptance = 0.05)

addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, resistance = 0.008, reactance = 0.05)

acModel!(system)
dcModel!(system)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In many instances throughout the JuliaGrid documentation, we explicitly mention these functions by their names, although it is not mandatory. If a user begins any of the various AC or DC analyses without having previously established the AC or DC model using the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> or <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a> function, the respective function for setting the analysis will automatically create the AC or DC model.</p></div></div><p>The nodal matrices are one of the components of both the AC and DC models and are stored in the variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.ac.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
    0.0-8.33333im   -1.4468+8.20678im           ⋅
 1.4468+8.20678im   3.12012-27.8341im  -3.12012+19.5008im
        ⋅          -3.12012+19.5008im   3.12012-19.4508im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.dc.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
  8.33333   -8.33333     ⋅
 -8.33333   28.3333   -20.0
   ⋅       -20.0       20.0</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The AC model is used for performing AC power flow, AC optimal power flow, AC state estimation, or state estimation with PMUs, whereas the DC model is essential for various DC or linear analyses. Consequently, once these models are developed, they can be applied to various types of simulations. We recommend that the reader refers to the tutorial on <a href="../../tutorials/powerSystemModel/#ACDCModelTutorials">AC and DC models</a>.</p></div></div><hr/><h5 id="New-Branch-Triggers-Model-Update"><a class="docs-heading-anchor" href="#New-Branch-Triggers-Model-Update">New Branch Triggers Model Update</a><a id="New-Branch-Triggers-Model-Update-1"></a><a class="docs-heading-anchor-permalink" href="#New-Branch-Triggers-Model-Update" title="Permalink"></a></h5><p>We can execute the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a> functions after defining the final number of buses, and each new branch added will trigger an update of the AC and DC matrices and vectors. Here is an example:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, susceptance = 0.05)

acModel!(system)
dcModel!(system)

addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12, shiftAngle = 0.1745)
addBranch!(system; from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, resistance = 0.008, reactance = 0.05)</code></pre><p>For example, the nodal matrix in the DC framework has the same values as before:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.dc.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
  8.33333   -8.33333     ⋅
 -8.33333   28.3333   -20.0
   ⋅       -20.0       20.0</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>It is not fully recommended to create AC and DC models before adding a large number of branches if the execution time of functions is important. Instead, triggering updates to the AC and DC models using the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function is useful for power systems that require the addition of several branches. This update avoids the need to recreate vectors and matrices from scratch.</p></div></div><hr/><h5 id="New-Bus-Triggers-Model-Erasure"><a class="docs-heading-anchor" href="#New-Bus-Triggers-Model-Erasure">New Bus Triggers Model Erasure</a><a id="New-Bus-Triggers-Model-Erasure-1"></a><a class="docs-heading-anchor-permalink" href="#New-Bus-Triggers-Model-Erasure" title="Permalink"></a></h5><p>The AC and DC models must be defined once a finite number of buses has been defined, otherwise, adding a new bus will delete them. For example, if we attempt to add a new bus to the <code>PowerSystem</code> type that was previously created, the current AC and DC models will be completely erased:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; addBus!(system; label = &quot;Bus 4&quot;, type = 2)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">[ Info: </span></span>The AC model has been completely erased.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>The DC model has been completely erased.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.ac.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">0×0 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 0 stored entries</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.dc.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">0×0 SparseArrays.SparseMatrixCSC{Float64, Int64} with 0 stored entries</code></pre><hr/><h2 id="UpdateBusManual"><a class="docs-heading-anchor" href="#UpdateBusManual">Update Bus</a><a id="UpdateBusManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateBusManual" title="Permalink"></a></h2><p>Once a bus has been added to the <code>PowerSystem</code> type, users have the flexibility to modify all parameters defined within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. This means that when the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> function is used, the <code>PowerSystem</code> type within AC and DC models that have been created is updated. This eliminates the need to recreate the AC and DC models from scratch.</p><p>To illustrate, let us consider the following power system:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1, conductance = 0.01)
addBus!(system; label = &quot;Bus 2&quot;, type = 2, reactive = 0.05)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, susceptance = 0.05)

addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.05)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.5)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 1&quot;, active = 0.2)

acModel!(system)
dcModel!(system)</code></pre><p>For instance, the nodal matrix in the AC framework has the following form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.ac.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
 0.01-8.33333im  -0.0+8.33333im       ⋅
  0.0+8.33333im   0.0-28.3333im  -0.0+20.0im
      ⋅           0.0+20.0im      0.0-19.95im</code></pre><p>Now, let us add a shunt element to <code>Bus 2</code>:</p><pre><code class="language-julia hljs">updateBus!(system; label = &quot;Bus 2&quot;, conductance = 0.4, susceptance = 0.5)</code></pre><p>As we can observe, executing the function triggers an update of the AC nodal matrix:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.ac.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
 0.01-8.33333im  -0.0+8.33333im       ⋅
  0.0+8.33333im   0.4-27.8333im  -0.0+20.0im
      ⋅           0.0+20.0im      0.0-19.95im</code></pre><hr/><h2 id="UpdateBranchManual"><a class="docs-heading-anchor" href="#UpdateBranchManual">Update Branch</a><a id="UpdateBranchManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateBranchManual" title="Permalink"></a></h2><p>Once a branch has been added to the <code>PowerSystem</code> type, users have the flexibility to modify all parameters defined within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. This means that when the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function is used, the <code>PowerSystem</code> type within AC and DC models that have been created is updated. This eliminates the need to recreate the AC and DC models from scratch.</p><p>To illustrate, let us continue with the previous example and modify the parameters of <code>Branch 1</code> as follows:</p><pre><code class="language-julia hljs">updateBranch!(system; label = &quot;Branch 1&quot;, resistance = 0.012, reactance = 0.3)</code></pre><p>We can observe the update in the AC nodal matrix:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.ac.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
  0.14312-3.32801im  -0.13312+3.32801im       ⋅
 -0.13312+3.32801im   0.53312-22.828im   -0.0+20.0im
          ⋅               0.0+20.0im      0.0-19.95im</code></pre><p>Next, let us switch the status of <code>Branch 2</code> from in-service to out-of-service:</p><pre><code class="language-julia hljs">updateBranch!(system; label = &quot;Branch 2&quot;, status = 0)</code></pre><p>As before, the updated AC nodal matrix takes the following form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.model.ac.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
  0.14312-3.32801im  -0.13312+3.32801im      ⋅
 -0.13312+3.32801im   0.53312-2.82801im  0.0+0.0im
          ⋅               0.0+0.0im      0.0+0.05im</code></pre><hr/><h5 id="Drop-Zeros"><a class="docs-heading-anchor" href="#Drop-Zeros">Drop Zeros</a><a id="Drop-Zeros-1"></a><a class="docs-heading-anchor-permalink" href="#Drop-Zeros" title="Permalink"></a></h5><p>After the last execution of the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, the nodal matrices will contain zeros, as demonstrated in the code example. If needed, the user can remove these zeros using the <code>dropZeros!</code> function, as shown below:</p><pre><code class="language-julia hljs">dropZeros!(system.model.ac)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is worth mentioning that in simulations conducted with the JuliaGrid package, the precision of the outcomes remains unaffected even if zero entries are retained. However, we recommend users utilize this function instead of <code>dropzeros!</code> from the SuiteSparse package to ensure seamless functioning of all JuliaGrid functionalities.</p></div></div><hr/><h2 id="UpdateGeneratorManual"><a class="docs-heading-anchor" href="#UpdateGeneratorManual">Update Generator</a><a id="UpdateGeneratorManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateGeneratorManual" title="Permalink"></a></h2><p>Finally, users can update all generator parameters defined within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function using the <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a> function. The execution of this function will affect all variables within the <code>PowerSystem</code> type.</p><p>In short, in addition to the <code>generator</code> field, JuliaGrid also retains variables associated with generators within the <code>bus</code> field. As an example, let us examine one of these variables and its values derived from a previous example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.7
 0.0
 0.0</code></pre><p>Next, we will change the active output power of <code>Generator 1</code>:</p><pre><code class="language-julia hljs">updateGenerator!(system; label = &quot;Generator 1&quot;, active = 0.9)</code></pre><p>As we can see, executing the function triggers an update of the observed variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.1
 0.0
 0.0</code></pre><p>Hence, this function ensures the adjustment of generator parameters and updates all fields of the <code>PowerSystem</code> type affected by them.</p><hr/><h2 id="AddUpdateCostsManual"><a class="docs-heading-anchor" href="#AddUpdateCostsManual">Add and Update Costs</a><a id="AddUpdateCostsManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddUpdateCostsManual" title="Permalink"></a></h2><p>The <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function is responsible for adding and updating costs associated with the active or reactive power produced by the corresponding generator. These costs are added only if the corresponding generator is defined.</p><p>To start, let us create an example of a power system using the following code:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 2&quot;)</code></pre><hr/><h5 id="Polynomial-Cost"><a class="docs-heading-anchor" href="#Polynomial-Cost">Polynomial Cost</a><a id="Polynomial-Cost-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Cost" title="Permalink"></a></h5><p>Let us define a quadratic polynomial cost function for the active power produced by the <code>Generator 1</code>:</p><pre><code class="language-julia hljs">cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [1100.0; 500.0; 150.0])</code></pre><p>In essence, what we have accomplished is the establishment of a cost function depicted as <span>$f(P_{\text{g}1}) = 1100 P_{\text{g}1}^2 + 500 P_{\text{g}1} + 150$</span> through the code provided. In general, when constructing a polynomial cost function, the coefficients must be ordered from the highest degree to the lowest.</p><p>The default input units are in per-units, with coefficients of the cost function having units of currency/pu²-hr for 1100, currency/pu-hr for 500, and currency/hr for 150. Therefore, the coefficients are stored exactly as entered:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.active.polynomial[1]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1100.0
  500.0
  150.0</code></pre><p>By setting <code>active = 2</code> within the function, we express our intent to specify the active power cost using the <code>active</code> key. By using a value of <code>2</code>, we signify our preference for employing a polynomial cost model for the associated generator. This flexibility is neccessary when we have also previously defined a piecewise linear cost function for the same generator. In such cases, we can set <code>active = 1</code> to utilize the piecewise linear cost function to represent the cost of the corresponding generators. Thus, we retain the freedom to choose between these two cost functions according to the requirements of our simulation. Additionally, users have the option to define both piecewise and polynomial costs within a single function call, further enhancing the versatility of the implementation.</p><hr/><h5 id="Piecewise-Linear-Cost"><a class="docs-heading-anchor" href="#Piecewise-Linear-Cost">Piecewise Linear Cost</a><a id="Piecewise-Linear-Cost-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-Linear-Cost" title="Permalink"></a></h5><p>We can also create a piecewise linear cost function, for example, let us create the reactive power cost function for the same generator using the following code:</p><pre><code class="language-julia hljs">cost!(system; generator = &quot;Generator 1&quot;, reactive = 1, piecewise = [0.11 12.3; 0.15 16.8])</code></pre><p>The first column denotes the generator&#39;s output reactive powers in per-units, while the second column specifies the corresponding costs for the specified reactive power in currency/hr. Thus, the data is stored exactly as entered:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.reactive.piecewise[1]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.11  12.3
 0.15  16.8</code></pre><hr/><h5 id="Customizing-Input-Units-4"><a class="docs-heading-anchor" href="#Customizing-Input-Units-4">Customizing Input Units</a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-4" title="Permalink"></a></h5><p>Changing input units from per-units can be particularly useful since cost functions are usually related to SI units. Let us set active powers in megawatts (MW) and reactive powers in megavolt-amperes reactive (MVAr):</p><pre><code class="language-julia hljs">@power(MW, MVAr)</code></pre><p>Now, we can add the quadratic polynomial function using megawatts:</p><pre><code class="language-julia hljs">cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [0.11; 5.0; 150.0])</code></pre><p>After inspecting the resulting cost data, we can see that it is the same as before:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.active.polynomial[1]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1100.0
  500.0
  150.0</code></pre><p>Similarly, we can define the linear piecewise cost using megavolt-amperes reactive:</p><pre><code class="language-julia hljs">cost!(system; generator = &quot;Generator 1&quot;, reactive = 1, piecewise = [11.0 12.3; 15.0 16.8])</code></pre><p>Upon inspection, we can see that the stored data is the same as before:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.generator.cost.reactive.piecewise[1]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.11  12.3
 0.15  16.8</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function not only adds costs but also allows users to update previously defined cost functions. This functionality is particularly valuable in optimal power flow analyses, as it allows users to modify generator power costs without the need to recreate models from scratch.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><a class="docs-footer-nextpage" href="../acPowerFlow/">AC Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Sunday 23 March 2025 12:00">Sunday 23 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
