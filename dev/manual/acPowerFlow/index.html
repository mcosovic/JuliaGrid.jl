<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC Power Flow · JuliaGrid</title><meta name="title" content="AC Power Flow · JuliaGrid"/><meta property="og:title" content="AC Power Flow · JuliaGrid"/><meta property="twitter:title" content="AC Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li class="is-active"><a class="tocitem" href>AC Power Flow</a><ul class="internal"><li><a class="tocitem" href="#BusTypeModificationManual"><span>Bus Type Modification</span></a></li><li><a class="tocitem" href="#SetupStartingVoltagesManual"><span>Setup Starting Voltages</span></a></li><li><a class="tocitem" href="#ACPowerFlowSolutionManual"><span>Power Flow Solution</span></a></li><li><a class="tocitem" href="#ACPowerSystemAlterationManual"><span>Power System Update</span></a></li><li><a class="tocitem" href="#ACPowerFlowUpdateManual"><span>Power Flow Update</span></a></li><li><a class="tocitem" href="#ACPowerCurrentAnalysisManual"><span>Power and Current Analysis</span></a></li><li><a class="tocitem" href="#GeneratorReactivePowerLimitsManual"><span>Generator Reactive Power Limits</span></a></li></ul></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>AC Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/acPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACPowerFlowManual"><a class="docs-heading-anchor" href="#ACPowerFlowManual">AC Power Flow</a><a id="ACPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerFlowManual" title="Permalink"></a></h1><p>To perform the AC power flow analysis, we will first need the <code>PowerSystem</code> type that has been created with the AC model. Following that, we can construct the power flow model encapsulated within the <code>ACPowerFlow</code> type by employing one of the following functions:</p><ul><li><a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>.</li></ul><p>These functions will set up the AC power flow framework. To obtain bus voltages and solve the power flow problem, we can use the following functions:</p><ul><li><a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a>,</li><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>Additionally, the package provides two functions for reactive power limit validation of generators and adjusting the voltage angles to match an arbitrary bus angle:</p><ul><li><a href="../../api/powerFlow/#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a>,</li><li><a href="../../api/powerFlow/#JuliaGrid.adjustAngle!"><code>adjustAngle!</code></a>.</li></ul><hr/><p>After obtaining the AC power flow solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses, branches, or generators:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>Additionally, specialized functions are available for calculating specific types of <a href="../../api/analysis/#ACPowerAnalysisAPI">powers</a> or <a href="../../api/analysis/#ACCurrentAnalysisAPI">currents</a> for individual buses, branches, or generators.</p><hr/><h2 id="BusTypeModificationManual"><a class="docs-heading-anchor" href="#BusTypeModificationManual">Bus Type Modification</a><a id="BusTypeModificationManual-1"></a><a class="docs-heading-anchor-permalink" href="#BusTypeModificationManual" title="Permalink"></a></h2><p>Depending on how the system is constructed, the types of buses that are initially set are checked and can be changed during the construction of the <code>ACPowerFlow</code> type.</p><p>Assuming the Newton-Raphson method has been chosen, to explain the details, we can observe a power system:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 2)
addBus!(system; label = &quot;Bus 3&quot;, type = 2)

addGenerator!(system; bus = &quot;Bus 2&quot;)

analysis = newtonRaphson(system)</code></pre><p>Initially, <code>Bus 1</code> is set as the slack bus (<code>type = 3</code>), and <code>Bus 2</code> and <code>Bus 3</code> are generator buses (<code>type = 2</code>). However, <code>Bus 3</code> does not have a generator, and JuliaGrid considers this a mistake and changes the corresponding bus to a demand bus (<code>type = 1</code>).</p><p>After this step, JuliaGrid verifies the slack bus. Initially, the slack bus (<code>type = 3</code>) corresponds to <code>Bus 1</code>, but since it does not have an in-service generator connected to it, JuliaGrid recognizes it as another mistake. Therefore, JuliaGrid assigns a new slack bus from the available generator buses (<code>type = 2</code>) that have connected in-service generators. In this specific example, <code>Bus 2</code> becomes the new slack bus.</p><p>As a result, we can observe the updated array of bus types:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, system.bus.layout.type)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1
Bus 2: 3
Bus 3: 1</code></pre><p>Note that, if a bus is initially defined as the demand bus (<code>type = 1</code>) and later a generator is added to it, the bus type will not be changed to the generator bus (<code>type = 2</code>). Instead, it will remain as a demand bus.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Only the type of these buses that are defined as generator buses (<code>type = 2</code>) but do not have a connected in-service generator will be changed to demand buses (<code>type = 1</code>).</p><p>The bus that is defined as the slack bus (<code>type = 3</code>) but lacks a connected in-service generator will have its type changed to the demand bus (<code>type = 1</code>). Meanwhile, the first generator bus (<code>type = 2</code>) with an in-service generator connected to it will be assigned as the new slack bus (<code>type = 3</code>).</p></div></div><hr/><h2 id="SetupStartingVoltagesManual"><a class="docs-heading-anchor" href="#SetupStartingVoltagesManual">Setup Starting Voltages</a><a id="SetupStartingVoltagesManual-1"></a><a class="docs-heading-anchor-permalink" href="#SetupStartingVoltagesManual" title="Permalink"></a></h2><p>To begin analyzing the AC power flow in JuliaGrid, we must first establish the <code>PowerSystem</code> type. Once the power system is set up, we can select one of the available methods for solving the AC power flow problem, such as <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>.</p><p>Assuming we have selected the Newton-Raphson method, we can use the following code snippet:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, magnitude = 1.0, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, magnitude = 0.9, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 2, magnitude = 0.8, angle = -0.2)

addGenerator!(system; bus = &quot;Bus 1&quot;, magnitude = 1.3)
addGenerator!(system; bus = &quot;Bus 2&quot;, magnitude = 1.1)
addGenerator!(system; bus = &quot;Bus 3&quot;, magnitude = 1.2)

acModel!(system)
analysis = newtonRaphson(system)</code></pre><p>Here, the function <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a> generates starting voltage vectors in polar coordinates.</p><p>The starting voltage magnitudes are set to:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.3
Bus 2: 0.9
Bus 3: 1.2</code></pre><p>This vector is created based on the bus types by selecting voltage magnitude values from the <code>PowerSystem</code> type, using the vectors:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [system.bus.voltage.magnitude system.generator.voltage.magnitude]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.0  1.3
 0.9  1.1
 0.8  1.2</code></pre><p>The starting voltage angles are set to:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: -0.1
Bus 3: -0.2</code></pre><p>This vector is derived from the voltage angle values in the <code>PowerSystem</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.1
 -0.2</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The rule governing the specification of starting voltage magnitudes is simple. If a bus has an in-service generator and is declared the generator bus (<code>type = 2</code>), then the starting voltage magnitudes are specified using the setpoint provided within the generator. This is because the generator bus has known values of voltage magnitude that are specified within the generator.</p><p>On the other hand, the slack bus (<code>type = 3</code>) always requires an in-service generator. The starting value of the voltage magnitude at the slack bus is determined exclusively by the setpoints provided within the generators connected to it. This is a result of the slack bus having a known voltage magnitude that must be maintained.</p><p>If there are multiple generators connected to the generator or slack bus, the initial voltage magnitude will align with the magnitude setpoint specified for the first in-service generator in the list.</p></div></div><hr/><h5 id="Custom-Starting-Voltages"><a class="docs-heading-anchor" href="#Custom-Starting-Voltages">Custom Starting Voltages</a><a id="Custom-Starting-Voltages-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Starting-Voltages" title="Permalink"></a></h5><p>This method of specifying starting values has a significant advantage in that it allows the user to easily change the starting voltage magnitudes and angles, which play a crucial role in iterative methods. For instance, suppose we define our power system as follows:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, magnitude = 1.0, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, magnitude = 0.9, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 2, magnitude = 0.8, angle = -0.2)

addGenerator!(system; bus = &quot;Bus 1&quot;, magnitude = 1.1)
addGenerator!(system; bus = &quot;Bus 3&quot;, magnitude = 1.2)

acModel!(system)</code></pre><p>Now, the user can initiate a &quot;flat start&quot;, this can be easily done as follows:</p><pre><code class="language-julia hljs">for i = 1:system.bus.number
    system.bus.voltage.magnitude[i] = 1.0
    system.bus.voltage.angle[i] = 0.0
end

analysis = newtonRaphson(system)</code></pre><p>The starting voltage values are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.1, 0.0
Bus 2: 1.0, 0.0
Bus 3: 1.2, 0.0</code></pre><p>Consequently, the iteration begins with a fixed set of voltage magnitude values that remain constant throughout the iteration process. The remaining values are initialized as part of the &quot;flat start&quot; approach.</p><hr/><h2 id="ACPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#ACPowerFlowSolutionManual">Power Flow Solution</a><a id="ACPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerFlowSolutionManual" title="Permalink"></a></h2><p>To start, we will create a power system and define the AC model by invoking the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)

@generator(active = 3.2)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, magnitude = 1.1)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, magnitude = 1.2)

acModel!(system)</code></pre><p>Once the AC model is defined, we can choose the method to solve the power flow problem. JuliaGrid provides four methods: <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, and <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>.</p><p>For example, to use the Newton-Raphson method to solve the power flow problem, we can use:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>By default, the user activates LU factorization to solve the system of linear equations within each iteration of the Newton-Raphson method. However, users can specifically opt for the <code>QR</code> factorization method:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system, QR)</code></pre><p>The capability to change the factorization method is exclusively available for the Newton-Raphson and fast Newton-Raphson methods.</p></div></div><p>This function sets up the desired method for an iterative process based on two functions: <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> and <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>solve!</code></a>. The <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function calculates the active and reactive power injection mismatches using the given voltage magnitudes and angles, while <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>solve!</code></a> computes the voltage magnitudes and angles.</p><p>To perform an iterative process with the Newton-Raphson or fast Newton-Raphson methods in JuliaGrid, the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function must be included inside the iteration loop. For instance:</p><pre><code class="language-julia hljs">for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><p>Upon completion of the AC power flow analysis, the solution is conveyed through the bus voltage magnitudes and angles. Here are the values corresponding to the buses:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.1, 0.0
Bus 2: 1.1312984943545519, 0.022034582385283743
Bus 3: 1.123144964293639, 0.005894335154140862</code></pre><p>In contrast, the iterative loop of the Gauss-Seidel method does not require the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function:</p><pre><code class="language-julia hljs">analysis = gaussSeidel(system)
for iteration = 1:100
    solve!(system, analysis)
end</code></pre><p>In these examples, the algorithms run until the specified number of iterations is reached.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that the reader refer to the tutorial on <a href="../../tutorials/acPowerFlow/#ACPowerFlowTutorials">AC Power Flow Analysis</a>, where we explain the implementation of the methods and algorithm structures in detail.</p></div></div><hr/><h5 id="Breaking-the-Iterative-Process"><a class="docs-heading-anchor" href="#Breaking-the-Iterative-Process">Breaking the Iterative Process</a><a id="Breaking-the-Iterative-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Breaking-the-Iterative-Process" title="Permalink"></a></h5><p>We can terminate the iterative process using the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function. The following code shows an example of how to use the function to break out of the iteration loop:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        println(&quot;Solution Found.&quot;)
        break
    end
    solve!(system, analysis)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Solution Found.</code></pre><p>The <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function returns the maximum absolute values of active and reactive power injection mismatches, which are commonly used as a convergence criterion in iterative AC power flow algorithms. Note that the function can also be used to terminate the loop when using the Gauss-Seidel method, even though it is not required.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To ensure an accurate count of iterations, the user should place the iteration counter after the condition expressions within the if construct.</p></div></div><hr/><h5 id="Combining-Methods"><a class="docs-heading-anchor" href="#Combining-Methods">Combining Methods</a><a id="Combining-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Methods" title="Permalink"></a></h5><p>The <code>PowerSystem</code> type, once created, can be shared among different methods, offering several advantages.</p><p>For instance, while the Gauss-Seidel method is commonly used to swiftly derive an approximate solution, the Newton-Raphson method is favored for obtaining precise final solutions. Hence, a strategy involves employing the Gauss-Seidel method for a limited number of iterations, followed by initializing the Newton-Raphson method with the voltages obtained from the Gauss-Seidel method, leveraging it as a starting point for further refinement:</p><pre><code class="language-julia hljs">gs = gaussSeidel(system)
for iteration = 1:5
    solve!(system, gs)
end</code></pre><p>Next, we can initialize the Newton-Raphson method with the voltages obtained from the Gauss-Seidel method and start the algorithm from that point:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system)

for i = 1:system.bus.number
    analysis.voltage.magnitude[i] = gs.voltage.magnitude[i]
    analysis.voltage.angle[i] = gs.voltage.angle[i]
end

for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The functions <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a> only modify the <code>PowerSystem</code> type to eliminate mistakes in the bus types as explained in the section <a href="#BusTypeModificationManual">Bus Type Modification</a>. Further, the functions <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> and <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>solve!</code></a> do not modify the <code>PowerSystem</code> type at all. Therefore, it is safe to use the same <code>PowerSystem</code> type for multiple analyses once it has been created.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL">Print Results in the REPL</a><a id="Print-Results-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL" title="Permalink"></a></h5><p>Users have the option to print the results in the REPL using any units that have been configured, such as:</p><pre><code class="language-julia hljs">@voltage(pu, deg, V)
printBusData(system, analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|----------------------------|
| Bus Data                   |
|----------------------------|
| Label |      Voltage       |
|       |                    |
|   Bus | Magnitude |  Angle |
|       |      [pu] |  [deg] |
|-------|-----------|--------|
| Bus 1 |    1.1000 | 0.0000 |
| Bus 2 |    1.1313 | 1.2625 |
| Bus 3 |    1.1231 | 0.3377 |
|----------------------------|</code></pre><p>Next, users can easily customize the print results for specific buses, for example:</p><pre><code class="language-julia hljs">printBusData(system, analysis; label = &quot;Bus 1&quot;, header = true)
printBusData(system, analysis; label = &quot;Bus 2&quot;)
printBusData(system, analysis; label = &quot;Bus 3&quot;, footer = true)</code></pre><hr/><h5 id="Save-Results-to-a-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-File">Save Results to a File</a><a id="Save-Results-to-a-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-File" title="Permalink"></a></h5><p>Users can also redirect print output to a file. For example, data can be saved in a text file as follows:</p><pre><code class="language-julia hljs">open(&quot;bus.txt&quot;, &quot;w&quot;) do file
    printBusData(system, analysis, file)
end</code></pre><hr/><h5 id="Save-Results-to-a-CSV-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-CSV-File">Save Results to a CSV File</a><a id="Save-Results-to-a-CSV-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-CSV-File" title="Permalink"></a></h5><p>For CSV output, users should first generate a simple table with <code>style = false</code>, and then save it to a CSV file:</p><pre><code class="language-julia hljs">using CSV

io = IOBuffer()
printBusData(system, analysis, io; style = false)
CSV.write(&quot;bus.csv&quot;, CSV.File(take!(io); delim = &quot;|&quot;))</code></pre><hr/><h2 id="ACPowerSystemAlterationManual"><a class="docs-heading-anchor" href="#ACPowerSystemAlterationManual">Power System Update</a><a id="ACPowerSystemAlterationManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerSystemAlterationManual" title="Permalink"></a></h2><p>After establishing the <code>PowerSystem</code> type using the <a href="../../api/powerSystemModel/#JuliaGrid.powerSystem"><code>powerSystem</code></a> function and configuring the AC model with <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a>, users gain the capability to incorporate new branches and generators. Furthermore, they can adjust buses, branches, and generators.</p><p>Once updates are done, users can progress towards generating the <code>ACPowerFlow</code> type using the <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a> function. Ultimately, resolving the AC power flow is achieved through the utilization of the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> and <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>solve!</code></a> functions:</p><pre><code class="language-julia hljs">system = powerSystem() # &lt;- Initialize the PowerSystem instance

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, magnitude = 1.1, active = 3.2)

acModel!(system)
analysis = newtonRaphson(system) # &lt;- Build ACPowerFlow for the defined power system
for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end

updateBus!(system; label = &quot;Bus 2&quot;, active = 0.2)

addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 1)
updateBranch!(system; label = &quot;Branch 1&quot;, status = 0)

addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 1&quot;, active = 0.2)
updateGenerator!(system; label = &quot;Generator 1&quot;, active = 0.3)

analysis = newtonRaphson(system) # &lt;- Build ACPowerFlow for the updated power system
for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to restart and recreate the <code>PowerSystem</code> within the <code>ac</code> field from the beginning when implementing changes to the existing power system.</p></div></div><hr/><h2 id="ACPowerFlowUpdateManual"><a class="docs-heading-anchor" href="#ACPowerFlowUpdateManual">Power Flow Update</a><a id="ACPowerFlowUpdateManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerFlowUpdateManual" title="Permalink"></a></h2><p>An advanced methodology involves users establishing the <code>ACPowerFlow</code> type using <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a> just once. After this initial setup, users can integrate new branches and generators, and also have the capability to modify buses, branches, and generators, all without the need to recreate the <code>ACPowerFlow</code> type.</p><p>This advancement extends beyond the previous scenario where recreating the <code>PowerSystem</code> and AC model was unnecessary, to now include the scenario where <code>ACPowerFlow</code> also does not need to be recreated. Such efficiency proves particularly beneficial in cases where JuliaGrid can reuse established Jacobian matrices or even factorizations, especially when users choose the fast Newton-Raphson method.</p><p>By modifying the previous example, we observe that we now create the <code>ACPowerFlow</code> type only once using the <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a> function. This approach allows us to circumvent the need for reinitializing the Jacobian matrix, enabling us to proceed directly with iterations:</p><pre><code class="language-julia hljs">system = powerSystem() # &lt;- Initialize the PowerSystem instance

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, magnitude = 1.1, active = 3.2)

acModel!(system)
analysis = newtonRaphson(system) # &lt;- Build ACPowerFlow for the defined power system
for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end

updateBus!(system, analysis; label = &quot;Bus 2&quot;, active = 0.2)

addBranch!(system, analysis; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 1)
updateBranch!(system, analysis; label = &quot;Branch 1&quot;, status = 0)

addGenerator!(system, analysis; label = &quot;Generator 2&quot;, bus = &quot;Bus 1&quot;, active = 0.2)
updateGenerator!(system, analysis; label = &quot;Generator 1&quot;, active = 0.3)

# &lt;- No need for re-build; we have already updated the existing ACPowerFlow instance
for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to restart and recreate both the <code>PowerSystem</code> within the <code>ac</code> field and the <code>ACPowerFlow</code> from the beginning when implementing changes to the existing power system.</p></div></div><hr/><h5 id="Fast-Newton-Raphson:-Reusing-Jacobian-Matrices-Factorizations"><a class="docs-heading-anchor" href="#Fast-Newton-Raphson:-Reusing-Jacobian-Matrices-Factorizations">Fast Newton-Raphson: Reusing Jacobian Matrices Factorizations</a><a id="Fast-Newton-Raphson:-Reusing-Jacobian-Matrices-Factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Newton-Raphson:-Reusing-Jacobian-Matrices-Factorizations" title="Permalink"></a></h5><p>An intriguing scenario unfolds when employing the fast Newton-Raphson method. Continuing from the previous example, let us now initialize the fast Newton-Raphson method and proceed with iterations as outlined below:</p><pre><code class="language-julia hljs">analysis = fastNewtonRaphsonBX(system)
for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><p>Throughout this process, JuliaGrid will factorize the constant Jacobian matrices that govern the fast Newton-Raphson method.</p><p>Now, let us make changes to the power system and proceed directly to the iteration step:</p><pre><code class="language-julia hljs">updateBus!(system, analysis; label = &quot;Bus 2&quot;, reactive = 0.02)
updateGenerator!(system, analysis; label = &quot;Generator 1&quot;, reactive = 0.1)

for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In this scenario, JuliaGrid identifies cases where the user has not altered parameters that impact the Jacobian matrices. Consequently, JuliaGrid efficiently utilizes the previously performed factorizations, leading to a notably faster solution compared to recomputing the factorization process.</p></div></div><hr/><h5 id="Warm-Start"><a class="docs-heading-anchor" href="#Warm-Start">Warm Start</a><a id="Warm-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Start" title="Permalink"></a></h5><p>In these scenarios, users leverage the previously created <code>PowerSystem</code> type with the AC model and also reuse the <code>ACPowerFlow</code> type, proceeding directly to the iterations. This approach offers the advantage of a &quot;warm start&quot;, wherein the initial voltages for the subsequent iteration step align with the solution from the previous iteration step. This alignment facilitates an efficient continuation of the power flow analysis.</p><p>Let us now make another alteration to the power system:</p><pre><code class="language-julia hljs">updateBus!(system, analysis; label = &quot;Bus 1&quot;, active = 0.1, magnitude = 0.95, angle = -0.07)
updateGenerator!(system, analysis; label = &quot;Generator 2&quot;, reactive = 0.2, magnitude = 1.1)</code></pre><p>With these modifications we are not only altering the power system, but also starting voltages. For the next uses of one of the methods, these values now are:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.1, -0.07
Bus 2: 1.0839300986879146, -0.16864600045398928</code></pre><p>Therefore, users possess the flexibility to adjust these initial values as needed by employing the <code>magnitude</code> and <code>angle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a> functions.</p><p>If users prefer to set starting voltages according to the typical scenario, they can accomplish this through the <a href="../../api/powerFlow/#JuliaGrid.startingVoltage!"><code>startingVoltage!</code></a> function:</p><pre><code class="language-julia hljs">startingVoltage!(system, analysis)</code></pre><p>Now, we have starting voltages defined exclusively according to the <code>PowerSystem</code>. These values are exactly the same as if we executed the <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a> function after all the updates we performed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.1, -0.07
Bus 2: 1.1, -0.1</code></pre><hr/><h5 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h5><p>The <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a> function oversees bus type validations, as outlined in the <a href="#BusTypeModificationManual">Bus Type Modification</a> section. Consequently, attempting to change bus types or leaving generator buses without a generator and then proceeding directly to the iteration process is not viable.</p><p>In such scenarios, JuliaGrid will raise an error:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; updateBus!(system, analysis; label = &quot;Bus 2&quot;, type = 2)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: The power flow model cannot be reused due to required bus type conversion.</code></pre><p>In this scenario, the user must execute the <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, or <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a> function instead of trying to reuse them, for example:</p><pre><code class="language-julia hljs">updateBus!(system; label = &quot;Bus 2&quot;, type = 2)

analysis = fastNewtonRaphsonBX(system)
for iteration = 1:100
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>After creating the <code>PowerSystem</code> and <code>ACPowerFlow</code> types, users can add or modify buses, branches, and generators before directly proceeding to iterations. JuliaGrid automatically executes the necessary functions when adjustments lead to a valid solution. However, if modifications are incompatible, like altering bus types, JuliaGrid raises an error to prevent misleading outcomes, ensuring accuracy.</p></div></div><hr/><h2 id="ACPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#ACPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="ACPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the AC power flow, we can calculate various electrical quantities related to buses, branches, and generators using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions. For instance, let us consider the power system for which we obtained the AC power flow solution:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.6)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.1, susceptance = 0.03)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, conductance = 0.02)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.5)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.1)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.4)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 1.0, reactive = 0.2)

analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre><p>We can now utilize the provided functions to compute powers and currents:</p><pre><code class="language-julia hljs">power!(system, analysis)
current!(system, analysis)</code></pre><p>For instance, if we want to show the active power injections and the to-bus current angles, we can employ the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -0.9645033643807599
Bus 2: 1.0000000022772795
Bus 3: -4.359533802980213e-10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.current.to.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: -0.15017765586673948
Branch 2: -0.08939059735692804
Branch 3: -3.073480808526896</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers and currents associated with buses, branches, and generators that are obtained by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions, we suggest referring to the tutorials on <a href="../../tutorials/acPowerFlow/#ACPowerFlowTutorials">AC Power Flow Analysis</a>.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL-2">Print Results in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL-2" title="Permalink"></a></h5><p>Users can utilize any of the print functions outlined in the <a href="../../api/setupPrint/#PrintPowerSystemDataAPI">Print Power System Data</a> or <a href="../../api/setupPrint/#PrintPowerSystemSummaryAPI">Print Power System Summary</a>. For example, to create a bus summary with the desired units, users can use the following function:</p><pre><code class="language-julia hljs">@voltage(pu, deg, V)
@power(MW, MVAr, pu)
printBusSummary(system, analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|----------------------------------------------------------------------------|
| Bus Summary                                                                |
|----------------------------------------------------------------------------|
|       Type        |     Minimum      |     Maximum      | In-Use |  Total  |
|                   |                  |                  |        |         |
|                   | Label |    Value | Label |    Value |        |         |
|-------------------|-------|----------|-------|----------|--------|---------|
| Voltage           |       |          |       |          |      3 |         |
|  Magnitude [pu]   | Bus 1 |   1.0000 | Bus 3 |   1.0362 |        |         |
|  Angle [deg]      | Bus 1 |   0.0000 | Bus 2 |   4.3886 |        |         |
|-------------------|-------|----------|-------|----------|--------|---------|
| Power Generation  |       |          |       |          |      1 |         |
|  Active [MW]      | Bus 3 |   0.0000 | Bus 3 |   0.0000 |        |  0.0000 |
|  Reactive [MVAr]  | Bus 3 |   0.0000 | Bus 3 |   0.0000 |        |  0.0000 |
|-------------------|-------|----------|-------|----------|--------|---------|
| Power Demand      |       |          |       |          |      2 |         |
|  Active [MW]      | Bus 2 |   0.0000 | Bus 1 |  60.0000 |        | 60.0000 |
|  Reactive [MVAr]  | Bus 1 |   0.0000 | Bus 2 |  10.0000 |        | 10.0000 |
|-------------------|-------|----------|-------|----------|--------|---------|
| Power Injection   |       |          |       |          |      3 |         |
|  Active [MW]      | Bus 1 | -96.4503 | Bus 2 | 100.0000 |        |  3.5497 |
|  Reactive [MVAr]  | Bus 1 | -17.6931 | Bus 2 |  10.0000 |        | -7.6931 |
|-------------------|-------|----------|-------|----------|--------|---------|
| Shunt Power       |       |          |       |          |      2 |         |
|  Active [MW]      | Bus 2 |   0.0000 | Bus 3 |   2.1475 |        |  2.1475 |
|  Reactive [MVAr]  | Bus 2 |  -3.1727 | Bus 3 |  -0.0000 |        | -3.1727 |
|-------------------|-------|----------|-------|----------|--------|---------|
| Current Injection |       |          |       |          |      3 |         |
|  Magnitude [pu]   | Bus 3 |   0.0000 | Bus 1 |   0.9806 |        |         |
|  Angle [rad]      | Bus 3 |  -2.7799 | Bus 1 |   2.9602 |        |         |
|----------------------------------------------------------------------------|</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection">Active and Reactive Power Injection</a><a id="Active-and-Reactive-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection" title="Permalink"></a></h5><p>To calculate the active and reactive power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = injectionPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.9645033643807599, -0.17693071258892878)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection-from-Generators">Active and Reactive Power Injection from Generators</a><a id="Active-and-Reactive-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = supplyPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.3645033643807599, -0.17693071258892878)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Shunt-Element"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Shunt-Element">Active and Reactive Power at Shunt Element</a><a id="Active-and-Reactive-Power-at-Shunt-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Shunt-Element" title="Permalink"></a></h5><p>To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = shuntPower(system, analysis; label = &quot;Bus 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.021474952575336232, -0.0)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Flow"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Flow">Active and Reactive Power Flow</a><a id="Active-and-Reactive-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the functions provided below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.8053928587014492, -0.11256618205670144)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.8186418709823436, 0.13714551291797428)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Charging-Admittances"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Charging-Admittances">Active and Reactive Power at Charging Admittances</a><a id="Active-and-Reactive-Power-at-Charging-Admittances-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Charging-Admittances" title="Permalink"></a></h5><p>To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = chargingPower(system, analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.00010287834702025066, -0.04115133880810026)</code></pre><p>Active powers indicate active losses within the branch&#39;s charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature.</p><hr/><h5 id="Active-and-Reactive-Power-at-Series-Impedance"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Series-Impedance">Active and Reactive Power at Series Impedance</a><a id="Active-and-Reactive-Power-at-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Series-Impedance" title="Permalink"></a></h5><p>To calculate the active and reactive power across the series impedance of the branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = seriesPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.013146133933874347, 0.06573066966937174)</code></pre><p>The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance&#39;s inductive characteristics.</p><hr/><h5 id="Generator-Active-and-Reactive-Power-Output"><a class="docs-heading-anchor" href="#Generator-Active-and-Reactive-Power-Output">Generator Active and Reactive Power Output</a><a id="Generator-Active-and-Reactive-Power-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Active-and-Reactive-Power-Output" title="Permalink"></a></h5><p>We can compute the active and reactive power output of a particular generator using the function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = generatorPower(system, analysis; label = &quot;Generator 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.3645033643807599, -0.17693071258892878)</code></pre><hr/><h5 id="Current-Injection"><a class="docs-heading-anchor" href="#Current-Injection">Current Injection</a><a id="Current-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injection" title="Permalink"></a></h5><p>To calculate the current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = injectionCurrent(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.9805973776015471, 2.9601674608926722)</code></pre><hr/><h5 id="Current-Flow"><a class="docs-heading-anchor" href="#Current-Flow">Current Flow</a><a id="Current-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow" title="Permalink"></a></h5><p>We can compute the current flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = fromCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.8132212504540907, 3.0027266550776193)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = toCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.807142930926126, -0.08939059735692804)</code></pre><hr/><h5 id="Current-Through-Series-Impedance"><a class="docs-heading-anchor" href="#Current-Through-Series-Impedance">Current Through Series Impedance</a><a id="Current-Through-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Through-Series-Impedance" title="Permalink"></a></h5><p>To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = seriesCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.8107445323242811, 3.027168837917323)</code></pre><hr/><h2 id="GeneratorReactivePowerLimitsManual"><a class="docs-heading-anchor" href="#GeneratorReactivePowerLimitsManual">Generator Reactive Power Limits</a><a id="GeneratorReactivePowerLimitsManual-1"></a><a class="docs-heading-anchor-permalink" href="#GeneratorReactivePowerLimitsManual" title="Permalink"></a></h2><p>The function <a href="../../api/powerFlow/#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a> can be used to check if the generators&#39; output of reactive power is within the defined limits after obtaining the solution from the AC power flow analysis:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.5)
addBus!(system; label = &quot;Bus 3&quot;, type = 2, reactive = 0.05)
addBus!(system; label = &quot;Bus 4&quot;, type = 2, reactive = 0.05)

@branch(resistance = 0.015)
addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)
addBranch!(system; from = &quot;Bus 2&quot;, to = &quot;Bus 4&quot;, reactance = 0.004)

@generator(minReactive = -0.4, maxReactive = 0.1)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 3&quot;, reactive = 0.8)
addGenerator!(system; label = &quot;Generator 3&quot;, bus = &quot;Bus 4&quot;, reactive = 0.9)

analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end

violate = reactiveLimit!(system, analysis)</code></pre><p>The output reactive power of the observed generators is subject to limits which are defined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [system.generator.capability.minReactive system.generator.capability.maxReactive]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 -0.4  0.1
 -0.4  0.1
 -0.4  0.1</code></pre><p>After obtaining the solution of the AC power flow analysis, the <a href="../../api/powerFlow/#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a> function is used to internally calculate the output powers of the generators and verify if these values exceed the defined limits. Consequently, the variable <code>violate</code> indicates whether there is a violation of limits.</p><p>In the provided example, it can be observed that the <code>Generator 2</code> and <code>Generator 3</code> violate the maximum limit:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, violate)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0
Generator 2: 1
Generator 3: 1</code></pre><p>Due to these violations of limits, the <code>PowerSystem</code> type undergoes modifications, and the output reactive power at the limit-violating generators is adjusted as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, system.generator.output.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.0
Generator 2: 0.1
Generator 3: 0.1</code></pre><p>To ensure that these values stay within the limits, the bus type must be changed from the generator bus (<code>type = 2</code>) to the demand bus (<code>type = 1</code>), as shown below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, system.bus.layout.type)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 3
Bus 2: 1
Bus 3: 1
Bus 4: 1</code></pre><p>After modifying the <code>PowerSystem</code> type as described earlier, we can run the simulation again with the following code:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre><p>Once the simulation is complete, we can verify that all generator reactive power outputs now satisfy the limits by checking the violate variable again:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; violate = reactiveLimit!(system, analysis)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 0
 0
 0</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The <a href="../../api/powerFlow/#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a> function changes the <code>PowerSystem</code> type deliberately because it is intended to help users create the power system where all reactive power outputs of the generators are within limits.</p></div></div><hr/><h5 id="New-Slack-Bus"><a class="docs-heading-anchor" href="#New-Slack-Bus">New Slack Bus</a><a id="New-Slack-Bus-1"></a><a class="docs-heading-anchor-permalink" href="#New-Slack-Bus" title="Permalink"></a></h5><p>Looking at the following code example, we can see that the output limits of the generator are set only for <code>Generator 1</code> that is connected to the slack bus:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5, reactive = 0.05)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.5)
addBus!(system; label = &quot;Bus 3&quot;, type = 2)
addBus!(system; label = &quot;Bus 4&quot;, type = 2)

@branch(resistance = 0.01)
addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.01)
addBranch!(system; from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)
addBranch!(system; from = &quot;Bus 2&quot;, to = &quot;Bus 4&quot;, reactance = 0.004)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, maxReactive = 0.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 4&quot;, reactive = 0.3)

analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre><p>Upon checking the limits, we can observe that the slack bus has been transformed by executing the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; violate = reactiveLimit!(system, analysis)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">[ Info: </span></span>The slack bus labeled Bus 1 is converted to generator bus. The bus labeled Bus 4 is the new slack bus.
2-element Vector{Int64}:
 -1
  0</code></pre><p>Here, the generator connected to the slack bus is violating the minimum reactive power limit, which indicates the need to convert the slack bus. It is important to note that the new slack bus can be created only from the generator bus (<code>type = 2</code>). We will now perform another AC power flow analysis on the modified system using the following:</p><pre><code class="language-julia hljs">analysis = newtonRaphson(system)
for iteration = 1:100
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre><p>After examining the bus voltages, we will focus on the angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.013581064245677444
Bus 2: 0.0005651921742472857
Bus 3: 0.01069570666159161
Bus 4: 0.0</code></pre><p>We can observe that the angles have been calculated based on the new slack bus. JuliaGrid offers the function to adjust these angles to match the original slack bus as follows:</p><pre><code class="language-julia hljs">adjustAngle!(system, analysis; slack = &quot;Bus 1&quot;)</code></pre><p>After executing the above code, the updated results can be viewed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: -0.013015872071430158
Bus 3: -0.0028853575840858334
Bus 4: -0.013581064245677444</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerSystemModel/">« Power System Model</a><a class="docs-footer-nextpage" href="../dcPowerFlow/">DC Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 23 January 2025 12:35">Thursday 23 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
