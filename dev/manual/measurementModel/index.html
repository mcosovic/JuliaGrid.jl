<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measurement Model · JuliaGrid</title><meta name="title" content="Measurement Model · JuliaGrid"/><meta property="og:title" content="Measurement Model · JuliaGrid"/><meta property="twitter:title" content="Measurement Model · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>Measurement Model</a><ul class="internal"><li><a class="tocitem" href="#BuildMeasurementModelManual"><span>Build Model</span></a></li><li><a class="tocitem" href="#SaveMeasurementModelManual"><span>Save Model</span></a></li><li><a class="tocitem" href="#AddVoltmeterManual"><span>Add Voltmeter</span></a></li><li><a class="tocitem" href="#AddAmmeterManual"><span>Add Ammeter</span></a></li><li><a class="tocitem" href="#AddWattmeterManual"><span>Add Wattmeter</span></a></li><li><a class="tocitem" href="#AddVarmeterManual"><span>Add Varmeter</span></a></li><li><a class="tocitem" href="#AddPMUManual"><span>Add PMU</span></a></li><li><a class="tocitem" href="#AddTemplatesMeasurementManual"><span>Add Templates</span></a></li><li><a class="tocitem" href="#LabelsMeasurementManual"><span>Labels</span></a></li><li><a class="tocitem" href="#AddDeviceGroupsManual"><span>Add Multiple Devices</span></a></li><li><a class="tocitem" href="#UpdateMeasurementDevicesManual"><span>Update Devices</span></a></li><li><a class="tocitem" href="#MeasurementSetManual"><span>Measurement Set</span></a></li></ul></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Measurement Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measurement Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/measurementModel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MeasurementModelManual"><a class="docs-heading-anchor" href="#MeasurementModelManual">Measurement Model</a><a id="MeasurementModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#MeasurementModelManual" title="Permalink"></a></h1><p>The JuliaGrid supports the type <code>Measurement</code> to preserve measurement data, with the following fields: <code>voltmeter</code>, <code>ammeter</code>, <code>wattmeter</code>, <code>varmeter</code>, and <code>pmu</code>. These fields contain information pertaining to measurements such as bus voltage magnitude, branch current magnitude, active power flow and injection, reactive power flow and injection measurements, and measurements of bus voltage and branch current phasors.</p><p>The type <code>Measurement</code> can be created using a function:</p><ul><li><a href="../../api/measurementModel/#JuliaGrid.measurement"><code>measurement</code></a>.</li></ul><p>Additionally, the user can create both the <code>PowerSystem</code> and <code>Measurement</code> types using the wrapper function:</p><ul><li><a href="../../api/measurementModel/#JuliaGrid.ems"><code>ems</code></a>.</li></ul><p>JuliaGrid supports two modes for populating the <code>Measurement</code> type: using built-in functions or using HDF5 files.</p><p>To work with HDF5 files, JuliaGrid provides the function:</p><ul><li><a href="../../api/measurementModel/#JuliaGrid.saveMeasurement"><code>saveMeasurement</code></a>.</li></ul><hr/><p>Once the <code>Measurement</code> type has been established, we can incorporate voltmeters, ammeters, wattmeters, varmeters, and phasor measurement units (PMUs) using the following functions:</p><ul><li><a href="../../api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement}"><code>addVoltmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement}"><code>addAmmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}"><code>addWattmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement}"><code>addVarmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement}"><code>addPmu!</code></a>.</li></ul><p>Also, JuliaGrid provides macros <a href="../../api/measurementModel/#JuliaGrid.@voltmeter"><code>@voltmeter</code></a>, <a href="../../api/measurementModel/#JuliaGrid.@ammeter"><code>@ammeter</code></a>, <a href="../../api/measurementModel/#JuliaGrid.@wattmeter"><code>@wattmeter</code></a>, <a href="../../api/measurementModel/#JuliaGrid.@varmeter"><code>@varmeter</code></a>, and <a href="../../api/measurementModel/#JuliaGrid.@pmu"><code>@pmu</code></a> to define templates that aid in creating measurement devices. These templates help avoid entering the same parameters repeatedly.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is important to note that measurement devices associated with branches can only be incorporated if the branch is in-service. This reflects JuliaGrid&#39;s approach to mimic a network topology processor, where logical data analysis configures the energized components of the power system.</p></div></div><p>Moreover, it is feasible to modify the parameters of measurement devices. When these functions are executed, all relevant fields within the <code>Measurement</code> type will be automatically updated. These functions include:</p><ul><li><a href="../../api/measurementModel/#JuliaGrid.updateVoltmeter!"><code>updateVoltmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.updateAmmeter!"><code>updateAmmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.updateWattmeter!"><code>updateWattmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.updateVarmeter!"><code>updateVarmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.updatePmu!"><code>updatePmu!</code></a>.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The functions for updating measurement devices serve a dual purpose. While their primary function is to modify the <code>Measurement</code> type, they are also designed to accept various analysis models like AC or DC state estimation models. When feasible, these functions not only modify the <code>Measurement</code> type but also adapt the analysis model, often resulting in improved computational efficiency. Detailed instructions on utilizing this feature can be found in dedicated manuals for specific analyses.</p></div></div><hr/><p>Finally, the user has the capability to randomly alter the measurement set by activating or deactivating devices through the following function:</p><ul><li><a href="../../api/measurementModel/#JuliaGrid.status!"><code>status!</code></a>.</li></ul><p>Furthermore, we provide users with the ability to modify each specific measurement set by utilizing the functions:</p><ul><li><a href="../../api/measurementModel/#JuliaGrid.statusVoltmeter!"><code>statusVoltmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.statusAmmeter!"><code>statusAmmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.statusWattmeter!"><code>statusWattmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.statusVarmeter!"><code>statusVarmeter!</code></a>,</li><li><a href="../../api/measurementModel/#JuliaGrid.statusPmu!"><code>statusPmu!</code></a>.</li></ul><hr/><h2 id="BuildMeasurementModelManual"><a class="docs-heading-anchor" href="#BuildMeasurementModelManual">Build Model</a><a id="BuildMeasurementModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#BuildMeasurementModelManual" title="Permalink"></a></h2><p>The <a href="../../api/measurementModel/#JuliaGrid.measurement"><code>measurement</code></a> function generates the <code>Measurement</code> type and requires a string-formatted path to HDF5 files as input. Alternatively, the <code>Measurement</code> can be created without any initial data by initializing it as empty, allowing the user to construct the measurements from scratch.</p><hr/><h5 id="HDF5-File"><a class="docs-heading-anchor" href="#HDF5-File">HDF5 File</a><a id="HDF5-File-1"></a><a class="docs-heading-anchor-permalink" href="#HDF5-File" title="Permalink"></a></h5><p>In order to use the HDF5 file as input to create the <code>Measurement</code> type, it is necessary to have saved the data using the <a href="../../api/measurementModel/#JuliaGrid.saveMeasurement"><code>saveMeasurement</code></a> function beforehand. Let us say we saved the measurements as <code>measurements14.h5</code> in the directory <code>C:\hdf5</code>. Then, the following code can be used to construct the <code>Measurement</code> type:</p><pre><code class="language-julia hljs">monitoring = measurement(&quot;C:/hdf5/measurements14.h5&quot;)</code></pre><hr/><h5 id="Model-from-Scratch"><a class="docs-heading-anchor" href="#Model-from-Scratch">Model from Scratch</a><a id="Model-from-Scratch-1"></a><a class="docs-heading-anchor-permalink" href="#Model-from-Scratch" title="Permalink"></a></h5><p>To start building a model from the ground up, the initial step involves constructing a power system, which facilitates the addition of measurement devices to buses or branches. As an illustration:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addVoltmeter!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 1.0, variance = 1e-3)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 0.2, variance = 1e-4, noise = true)</code></pre><p>In this context, we have created the voltmeter responsible for measuring the bus voltage magnitude at <code>Bus 1</code>, with associated mean and variance values expressed in per-units:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.voltmeter.magnitude.mean monitoring.voltmeter.magnitude.variance]</code><code class="nohighlight hljs ansi" style="display:block;">1×2 Matrix{Float64}:
 1.0  0.001</code></pre><p>Furthermore, we have established the wattmeter to measure the active power flow at the from-bus end of <code>Branch 1</code>, with corresponding mean and variance values also expressed in per-units:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.wattmeter.active.mean monitoring.wattmeter.active.variance]</code><code class="nohighlight hljs ansi" style="display:block;">1×2 Matrix{Float64}:
 0.203376  0.0001</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The measurement values (i.e., means) can be generated by adding white Gaussian noise with specified <code>variance</code> values to perturb the original values. This can be achieved by setting <code>noise = true</code> within the functions used for adding devices.</p></div></div><hr/><h2 id="SaveMeasurementModelManual"><a class="docs-heading-anchor" href="#SaveMeasurementModelManual">Save Model</a><a id="SaveMeasurementModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#SaveMeasurementModelManual" title="Permalink"></a></h2><p>Once the <code>Measurement</code> type has been created using one of the methods outlined in <a href="#BuildMeasurementModelManual">Build Model</a>, the current data can be stored in the HDF5 file by using <a href="../../api/measurementModel/#JuliaGrid.saveMeasurement"><code>saveMeasurement</code></a> function:</p><pre><code class="language-julia hljs">saveMeasurement(monitoring; path = &quot;C:/hdf5/measurement.h5&quot;)</code></pre><p>All electrical quantities saved in the HDF5 file are in per-units and radians.</p><hr/><h2 id="AddVoltmeterManual"><a class="docs-heading-anchor" href="#AddVoltmeterManual">Add Voltmeter</a><a id="AddVoltmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddVoltmeterManual" title="Permalink"></a></h2><p>We have the option to add voltmeters to a loaded measurement type or to one created from scratch. As an example, we can initiate the <code>Measurement</code> type and then incorporate voltmeters by utilizing the <a href="../../api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement}"><code>addVoltmeter!</code></a> function:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)

addVoltmeter!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 0.9, variance = 1e-4)
addVoltmeter!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 1.0, variance = 1e-3, noise = true)</code></pre><p>In this example, we have established two voltmeters designed to measure the bus voltage magnitude at <code>Bus 1</code>. In the case of the second voltmeter, the measurement value is generated internally by introducing white Gaussian noise with the <code>variance</code> added to the <code>magnitude</code> value. As a result, we obtain the following data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.voltmeter.magnitude.mean monitoring.voltmeter.magnitude.variance]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.9      0.0001
 1.00532  0.001</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend reading the documentation for the <a href="../../api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement}"><code>addVoltmeter!</code></a> function, where we have provided a list of the keywords that can be used.</p></div></div><hr/><h5 id="Customizing-Input-Units-for-Keywords"><a class="docs-heading-anchor" href="#Customizing-Input-Units-for-Keywords">Customizing Input Units for Keywords</a><a id="Customizing-Input-Units-for-Keywords-1"></a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-for-Keywords" title="Permalink"></a></h5><p>By default, the <code>magnitude</code> and <code>variance</code> keywords are expected to be provided in per-units. However, users have the flexibility to specify these values in volts if they prefer. For instance, consider the following example:</p><pre><code class="language-julia hljs">@voltage(kV, rad, V)

system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, base = sqrt(3) * 135e3)

addVoltmeter!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 121.5, variance = 0.0135)
addVoltmeter!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 135, variance = 0.135, noise = true)</code></pre><p>In this example, we have chosen to specify <code>magnitude</code> and <code>variance</code> in kilovolts (kV). It is important to note that even though we have used kilovolts as the input units, these keywords will still be stored in the per-units:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.voltmeter.magnitude.mean monitoring.voltmeter.magnitude.variance]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.9      0.0001
 0.98626  0.001</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>When users choose to input data in volts, measurement values and variances are related to line-to-neutral voltages, while the base values are defined for line-to-line voltages. Therefore, a conversion using <span>$\sqrt{3}$</span> is necessary. For more information, refer to the <a href="../../tutorials/perunit/#PerUnitSystem">Per-Unit System</a> section.</p></div></div><hr/><h5 id="Print-Data-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Data-in-the-REPL">Print Data in the REPL</a><a id="Print-Data-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Data-in-the-REPL" title="Permalink"></a></h5><p>Users have the option to print the voltmeter data in the REPL using any units that have been configured:</p><pre><code class="language-julia hljs">printVoltmeterData(monitoring)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-----------------------------------------|
| Voltmeter Data                          |
|-----------------------------------------|
| Label |        Voltage Magnitude        |
|       |                                 |
|       | Measurement | Variance | Status |
|       |        [kV] |     [kV] |        |
|-------|-------------|----------|--------|
| 1     |    121.5000 | 1.35e-02 |      1 |
| 2     |    133.1451 | 1.35e-01 |      1 |
|-----------------------------------------|</code></pre><hr/><h2 id="AddAmmeterManual"><a class="docs-heading-anchor" href="#AddAmmeterManual">Add Ammeter</a><a id="AddAmmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddAmmeterManual" title="Permalink"></a></h2><p>Users can introduce ammeters into either an existing measurement type or one that they create from the ground up by making use of the <a href="../../api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement}"><code>addAmmeter!</code></a> function, as demonstrated in the following example:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addAmmeter!(monitoring; from = &quot;Branch 1&quot;, magnitude = 0.8, variance = 0.1, noise = true)
addAmmeter!(monitoring; to = &quot;Branch 1&quot;, magnitude = 0.9, variance = 1e-3, square = true)</code></pre><p>In this scenario, we have established one ammeter to measure the branch current magnitude at the from-bus end of <code>Branch 1</code>, as indicated by the use of the <code>from</code> keyword. Similarly, we have added an ammeter to measure the branch current magnitude at the to-bus end of the branch by utilizing the <code>to</code> keyword.</p><p>For the first ammeter, the measurement value is generated by adding white Gaussian noise with the <code>variance</code> to the <code>magnitude</code> value. In contrast, for the second ammeter, we assume that the measurement value is already known, defined by the <code>magnitude</code>. These actions result in the following outcomes:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.ammeter.magnitude.mean monitoring.ammeter.magnitude.variance]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.569584  0.1
 0.9       0.001</code></pre><p>The <code>square</code> keyword is used for the second ammeter to indicate that the measurement will be included in AC state estimation in squared form. This means the corresponding equation is introduced without a square root, while the measurement mean is squared, and the variance is doubled. This approach enhances the robustness of state estimation when handling such measurements.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend reading the documentation for the <a href="../../api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement}"><code>addAmmeter!</code></a> function, where we have provided a list of the keywords that can be used.</p></div></div><hr/><h5 id="Customizing-Input-Units-for-Keywords-2"><a class="docs-heading-anchor" href="#Customizing-Input-Units-for-Keywords-2">Customizing Input Units for Keywords</a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-for-Keywords-2" title="Permalink"></a></h5><p>By default, the <code>magnitude</code> and <code>variance</code> keywords are expected to be provided in per-unit. However, users have the flexibility to express these values in amperes (A) if they prefer. Take a look at the following example:</p><pre><code class="language-julia hljs">@current(A, rad)

system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, base = 135e3)
addBus!(system; label = &quot;Bus 2&quot;, base = 135e3)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addAmmeter!(monitoring; from = &quot;Branch 1&quot;, magnitude = 342, variance = 43, noise = true)
addAmmeter!(monitoring; to = &quot;Branch 1&quot;, magnitude = 385, variance = 0.43, square = true)</code></pre><p>In this example, we have opted to specify the <code>magnitude</code> and <code>variance</code> in amperes. It is worth noting that, despite using amperes as the input units, these keywords will still be stored in the per-unit system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.ammeter.magnitude.mean monitoring.ammeter.magnitude.variance]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 1.24809   0.100546
 0.900233  0.00100546</code></pre><hr/><h5 id="Print-Data-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Data-in-the-REPL-2">Print Data in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Data-in-the-REPL-2" title="Permalink"></a></h5><p>Users have the option to print the ammeter data in the REPL using any units that have been configured:</p><pre><code class="language-julia hljs">printAmmeterData(monitoring)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-----------------------------------------|
| Ammeter Data                            |
|-----------------------------------------|
| Label |        Current Magnitude        |
|       |                                 |
|       | Measurement | Variance | Status |
|       |         [A] |      [A] |        |
|-------|-------------|----------|--------|
| 1     |    533.7668 | 4.30e+01 |      1 |
| 2     |    385.0000 | 4.30e-01 |      1 |
|-----------------------------------------|</code></pre><hr/><h2 id="AddWattmeterManual"><a class="docs-heading-anchor" href="#AddWattmeterManual">Add Wattmeter</a><a id="AddWattmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddWattmeterManual" title="Permalink"></a></h2><p>Users can include wattmeters in either an existing measurement type or one that they create from scratch by utilizing the <a href="../../api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}"><code>addWattmeter!</code></a> function, as demonstrated in the following example:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addWattmeter!(monitoring; bus = &quot;Bus 1&quot;, active = 0.6, variance = 1e-3)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 0.3, variance = 1e-2)
addWattmeter!(monitoring; to = &quot;Branch 1&quot;, active = 0.1, variance = 1e-3, noise = true)</code></pre><p>In this scenario, one wattmeter has been added to measure the active power injection at <code>Bus 1</code>, as indicated by the use of the <code>bus</code> keyword. Additionally, two wattmeters have been introduced to measure the active power flow on both sides of <code>Branch 1</code> using the <code>from</code> and <code>to</code> keywords.</p><p>For the first and second wattmeters, we assume that the measurement values are already known, defined by the <code>active</code>. In contrast, for the third wattmeter, the measurement value is generated by adding white Gaussian noise with the <code>variance</code> to the <code>active</code> value. As a result, the measurement data is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.wattmeter.active.mean monitoring.wattmeter.active.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 0.6       0.001
 0.3       0.01
 0.165009  0.001</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend reading the documentation for the <a href="../../api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}"><code>addWattmeter!</code></a> function, where we have provided a list of the keywords that can be used.</p></div></div><hr/><h5 id="Customizing-Input-Units-for-Keywords-3"><a class="docs-heading-anchor" href="#Customizing-Input-Units-for-Keywords-3">Customizing Input Units for Keywords</a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-for-Keywords-3" title="Permalink"></a></h5><p>By default, the <code>active</code> and <code>variance</code> keywords are expected to be provided in per-unit values. However, users have the option to express these values in watts if they prefer, as demonstrated in the following example:</p><pre><code class="language-julia hljs">@power(MW, pu)

system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addWattmeter!(monitoring; bus = &quot;Bus 1&quot;, active = 60, variance = 1e-1)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 30, variance = 1)
addWattmeter!(monitoring; to = &quot;Branch 1&quot;, active = 10, variance = 1e-1, noise = true)</code></pre><p>In this example, we have chosen to specify the <code>active</code> and <code>variance</code> in megawatts (MW), but even though we have used megawatts as the input units, these keywords will still be stored in the per-unit system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.wattmeter.active.mean monitoring.wattmeter.active.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 0.6       0.001
 0.3       0.01
 0.129606  0.001</code></pre><hr/><h5 id="Print-Data-in-the-REPL-3"><a class="docs-heading-anchor" href="#Print-Data-in-the-REPL-3">Print Data in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Data-in-the-REPL-3" title="Permalink"></a></h5><p>Users have the option to print the wattmeter data in the REPL using any units that have been configured:</p><pre><code class="language-julia hljs">printWattmeterData(monitoring)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-----------------------------------------|
| Wattmeter Data                          |
|-----------------------------------------|
| Label |          Active Power           |
|       |                                 |
|       | Measurement | Variance | Status |
|       |        [MW] |     [MW] |        |
|-------|-------------|----------|--------|
| 1     |     60.0000 | 1.00e-01 |      1 |
| 2     |     30.0000 | 1.00e+00 |      1 |
| 3     |     12.9606 | 1.00e-01 |      1 |
|-----------------------------------------|</code></pre><hr/><h2 id="AddVarmeterManual"><a class="docs-heading-anchor" href="#AddVarmeterManual">Add Varmeter</a><a id="AddVarmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddVarmeterManual" title="Permalink"></a></h2><p>To include varmeters, the same approach as described in the <a href="#AddWattmeterManual">Add Wattmeter</a> section can be applied, but here, we make use of the <a href="../../api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement}"><code>addVarmeter!</code></a> function, as demonstrated in the following example:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addVarmeter!(monitoring; bus = &quot;Bus 1&quot;, reactive = 0.2, variance = 1e-3)
addVarmeter!(monitoring; from = &quot;Branch 1&quot;, reactive = 0.1, variance = 1e-2)
addVarmeter!(monitoring; to = &quot;Branch 1&quot;, reactive = 0.05, variance = 1e-3, noise = true)</code></pre><p>In this context, one varmeter has been added to measure the reactive power injection at <code>Bus 1</code>, as indicated by the use of the <code>bus</code> keyword. Additionally, two varmeters have been introduced to measure the reactive power flow on both sides of <code>Branch 1</code> using the <code>from</code> and <code>to</code> keywords. As a result, the following outcomes are observed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.varmeter.reactive.mean monitoring.varmeter.reactive.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 0.2        0.001
 0.1        0.01
 0.0138548  0.001</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend reading the documentation for the <a href="../../api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement}"><code>addVarmeter!</code></a> function, where we have provided a list of the keywords that can be used.</p></div></div><hr/><h5 id="Customizing-Input-Units-for-Keywords-4"><a class="docs-heading-anchor" href="#Customizing-Input-Units-for-Keywords-4">Customizing Input Units for Keywords</a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-for-Keywords-4" title="Permalink"></a></h5><p>Just as we explained for the previous device, users have the flexibility to select units different from per-units. In this case, they can opt for megavolt-ampere reactive (MVAr), as illustrated in the following example:</p><pre><code class="language-julia hljs">@power(pu, MVAr)

system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addVarmeter!(monitoring; bus = &quot;Bus 1&quot;, reactive = 20, variance = 1e-1)
addVarmeter!(monitoring; from = &quot;Branch 1&quot;, reactive = 10, variance = 1)
addVarmeter!(monitoring; to = &quot;Branch 1&quot;, reactive = 5, variance = 1e-1, noise = true)</code></pre><p>JuliaGrid will still store the values in the per-unit system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.varmeter.reactive.mean monitoring.varmeter.reactive.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
  0.2        0.001
  0.1        0.01
 -0.0323024  0.001</code></pre><hr/><h5 id="Print-Data-in-the-REPL-4"><a class="docs-heading-anchor" href="#Print-Data-in-the-REPL-4">Print Data in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Data-in-the-REPL-4" title="Permalink"></a></h5><p>Users have the option to print the varmeter data in the REPL using any units that have been configured:</p><pre><code class="language-julia hljs">printVarmeterData(monitoring)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-----------------------------------------|
| Varmeter Data                           |
|-----------------------------------------|
| Label |         Reactive Power          |
|       |                                 |
|       | Measurement | Variance | Status |
|       |      [MVAr] |   [MVAr] |        |
|-------|-------------|----------|--------|
| 1     |     20.0000 | 1.00e-01 |      1 |
| 2     |     10.0000 | 1.00e+00 |      1 |
| 3     |     -3.2302 | 1.00e-01 |      1 |
|-----------------------------------------|</code></pre><hr/><h2 id="AddPMUManual"><a class="docs-heading-anchor" href="#AddPMUManual">Add PMU</a><a id="AddPMUManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddPMUManual" title="Permalink"></a></h2><p>Users have the capability to incorporate PMUs into either an existing measurement type or create one from scratch by utilizing the <a href="../../api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement}"><code>addPmu!</code></a> function, as demonstrated in the following example:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addPmu!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 1.1, angle = 0.1, varianceMagnitude = 0.1)
addPmu!(monitoring; from = &quot;Branch 1&quot;, magnitude = 1.0, angle = -0.2, noise = true)
addPmu!(monitoring; to = &quot;Branch 1&quot;, magnitude = 0.9, angle = 0.0, varianceAngle = 0.001)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>While the typical understanding of a PMU encompasses a device that measures the bus voltage phasor and all branch current phasors incident to the bus, we have chosen to deconstruct this concept to offer users increased flexibility. As a result, our approach yields PMUs that measure individual phasors, each described with magnitude and angle, along with corresponding variances, all presented in the polar coordinate system.</p></div></div><p>In this context, one PMU has been added to measure the bus voltage phasor at <code>Bus 1</code>, as indicated by the use of the <code>bus</code> keyword. Additionally, two PMUs have been introduced to measure the branch current phasors on both sides of <code>Branch 1</code> using the <code>from</code> and <code>to</code> keywords.</p><p>For the first and third PMUs, we assume that the measurement values are already known, defined by the <code>magnitude</code> and <code>angle</code> keywords. However, for the second PMU, we generate the measurement value by adding white Gaussian noise with <code>varianceMagnitude</code> and <code>varianceAngle</code> to the <code>magnitude</code> and <code>angle</code> values, respectively. It is important to note that when we omit specifying variance values, we rely on their default settings, both of which are equal to <code>1e-8</code>. As a result, we observe the following outcomes:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.pmu.magnitude.mean monitoring.pmu.magnitude.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.1       0.1
 0.999978  1.0e-8
 0.9       1.0e-8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.pmu.angle.mean monitoring.pmu.angle.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
  0.1       1.0e-8
 -0.199904  1.0e-8
  0.0       0.001</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend reading the documentation for the <a href="../../api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement}"><code>addPmu!</code></a> function, where we have provided a list of the keywords that can be used.</p></div></div><hr/><h5 id="PMU-State-Estimation-and-Coordinate-System"><a class="docs-heading-anchor" href="#PMU-State-Estimation-and-Coordinate-System">PMU State Estimation and Coordinate System</a><a id="PMU-State-Estimation-and-Coordinate-System-1"></a><a class="docs-heading-anchor-permalink" href="#PMU-State-Estimation-and-Coordinate-System" title="Permalink"></a></h5><p>When users add PMUs and create a <code>PmuStateEstimation</code> type, they specify that the estimation model should rely only on PMUs. In this case, phasor measurements are always incorporated in the rectangular coordinate system. Here, the real and imaginary components of the phasor measurements become correlated, but these correlations are typically ignored [<a href="../../background/bibliography/#gomez2011use">1</a>]. To account for them, users can set the keyword <code>correlated = true</code>. For example:</p><pre><code class="language-julia hljs">addPmu!(monitoring; bus = &quot;Bus 2&quot;, magnitude = 1, angle = 0)
addPmu!(monitoring; from = &quot;Branch 1&quot;, magnitude = 0.9, angle = -0.3, correlated = true)</code></pre><p>For the first phasor measurement, correlation is neglected, whereas for the second, it is considered.</p><hr/><h5 id="AC-State-Estimation-and-Coordinate-Systems"><a class="docs-heading-anchor" href="#AC-State-Estimation-and-Coordinate-Systems">AC State Estimation and Coordinate Systems</a><a id="AC-State-Estimation-and-Coordinate-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#AC-State-Estimation-and-Coordinate-Systems" title="Permalink"></a></h5><p>In AC state estimation, when users create an <code>AcStateEstimation</code> type, PMUs are by default integrated into the rectangular coordinate system, where correlations are neglected. Users can also set <code>correlated = true</code> to account for the correlation between the real and imaginary components of the phasor measurements. Additionally, in the AC state estimation model, users have the flexibility to incorporate phasor measurements in the polar coordinate system by specifying <code>polar = true</code>.</p><p>For example, let us add PMUs:</p><pre><code class="language-julia hljs">addPmu!(monitoring; bus = &quot;Bus 2&quot;, magnitude = 1, angle = 0, polar = true, square = true)
addPmu!(monitoring; from = &quot;Branch 1&quot;, magnitude = 0.9, angle = -0.3, correlated = true)</code></pre><p>The first phasor measurement will be incorporated into the AC state estimation model using the polar coordinate system. Additionally, by setting <code>square = true</code>, the current magnitude measurement will be included in its squared form. The second PMU will be integrated into the rectangular coordinate system, where a correlation exists between the real and imaginary components.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>It is noteworthy that expressing current phasor measurements in polar coordinates can lead to ill-conditioned problems due to small current magnitudes, whereas using rectangular representation can resolve this issue.</p></div></div><hr/><h5 id="Customizing-Input-Units-for-Keywords-5"><a class="docs-heading-anchor" href="#Customizing-Input-Units-for-Keywords-5">Customizing Input Units for Keywords</a><a class="docs-heading-anchor-permalink" href="#Customizing-Input-Units-for-Keywords-5" title="Permalink"></a></h5><p>By default, the <code>magnitude</code> and <code>varianceMagnitude</code> keywords are expected to be provided in per-unit, while the <code>angle</code> and <code>varianceAngle</code> keywords are expected to be provided in radians. However, users have the flexibility to express these values in different units, such as volts (V) and degrees (deg) if the PMU is set to a bus, or amperes (A) and degrees (deg) if the PMU is set to a branch. This flexibility is demonstrated in the following:</p><pre><code class="language-julia hljs">@voltage(kV, deg, V)
@current(A, deg)

system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, base = 135e3)
addBus!(system; label = &quot;Bus 2&quot;, base = 135e3)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

addPmu!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 85.74, angle = 5.73, varianceAngle = 0.06)
addPmu!(monitoring; from = &quot;Branch 1&quot;, magnitude = 427.67, angle = -11.46, noise = true)
addPmu!(monitoring; to = &quot;Branch 1&quot;, magnitude = 384.91, angle = 0.0)</code></pre><p>In this example, we have opted to specify kilovolts (kV) and degrees (deg) for the PMU located at <code>Bus 1</code>, and amperes (A) and degrees (deg) for the PMUs located at <code>Branch 1</code>. It is important to note that regardless of the units used, the values will still be stored in per-units and radians:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.pmu.magnitude.mean monitoring.pmu.magnitude.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 1.10004   1.0e-8
 1.00005   1.0e-8
 0.900023  1.0e-8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [monitoring.pmu.angle.mean monitoring.pmu.angle.variance]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
  0.100007  0.0010472
 -0.200043  1.0e-8
  0.0       1.0e-8</code></pre><hr/><h5 id="Print-Data-in-the-REPL-5"><a class="docs-heading-anchor" href="#Print-Data-in-the-REPL-5">Print Data in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Data-in-the-REPL-5" title="Permalink"></a></h5><p>Users have the option to print the PMU data in the REPL using any units that have been configured:</p><pre><code class="language-julia hljs">printPmuData(monitoring)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|---------------------------------------------------------------------------|
| PMU Data                                                                  |
|---------------------------------------------------------------------------|
| Label |        Voltage Magnitude        |          Voltage Angle          |
|       |                                 |                                 |
|       | Measurement | Variance | Status | Measurement | Variance | Status |
|       |        [kV] |     [kV] |        |       [deg] |    [deg] |        |
|-------|-------------|----------|--------|-------------|----------|--------|
| 1     |     85.7400 | 7.79e-07 |      1 |      5.7300 | 6.00e-02 |      1 |
|---------------------------------------------------------------------------|
|---------------------------------------------------------------------------|
| PMU Data                                                                  |
|---------------------------------------------------------------------------|
| Label |        Current Magnitude        |          Current Angle          |
|       |                                 |                                 |
|       | Measurement | Variance | Status | Measurement | Variance | Status |
|       |         [A] |      [A] |        |       [deg] |    [deg] |        |
|-------|-------------|----------|--------|-------------|----------|--------|
| 2     |    427.6877 | 4.28e-06 |      1 |    -11.4616 | 5.73e-07 |      1 |
| 3     |    384.9100 | 4.28e-06 |      1 |      0.0000 | 5.73e-07 |      1 |
|---------------------------------------------------------------------------|</code></pre><hr/><h2 id="AddTemplatesMeasurementManual"><a class="docs-heading-anchor" href="#AddTemplatesMeasurementManual">Add Templates</a><a id="AddTemplatesMeasurementManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddTemplatesMeasurementManual" title="Permalink"></a></h2><p>The functions <a href="../../api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement}"><code>addVoltmeter!</code></a>, <a href="../../api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement}"><code>addAmmeter!</code></a>, <a href="../../api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}"><code>addWattmeter!</code></a>, <a href="../../api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement}"><code>addVarmeter!</code></a>, and <a href="../../api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement}"><code>addPmu!</code></a> are employed to introduce measurement devices. In cases where specific keywords are not explicitly defined, default values are automatically assigned to certain parameters.</p><hr/><h5 id="Default-Keyword-Values"><a class="docs-heading-anchor" href="#Default-Keyword-Values">Default Keyword Values</a><a id="Default-Keyword-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Keyword-Values" title="Permalink"></a></h5><p>When utilizing the <a href="../../api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement}"><code>addVoltmeter!</code></a> function, the default variance is set to <code>variance = 1e-4</code> per-unit, and the voltmeter&#39;s operational status is automatically assumed to be in-service, as indicated by the setting of <code>status = 1</code>.</p><p>Similarly, for the <a href="../../api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement}"><code>addAmmeter!</code></a> function, the default variances are established at <code>variance = 1e-4</code> per-unit, and the operational statuses are configured to <code>status = 1</code>. This means that if a user places an ammeter at either the from-bus or to-bus end of a branch, the default settings are identical. However, as we will explain in the following subsection, users have the flexibility to fine-tune these default values, differentiating between the two locations.</p><p>In alignment with ammeters, the <a href="../../api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}"><code>addWattmeter!</code></a> and <a href="../../api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement}"><code>addVarmeter!</code></a> functions feature default variances set at <code>variance = 1e-4</code> per-unit, and statuses are automatically assigned as <code>status = 1</code>, regardless of whether the wattmeter or varmeter is placed at the bus, the from-bus end, or the to-bus end. Users have the ability to customize these default values, making distinctions between the three positions of the measurement devices.</p><p>For the <a href="../../api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement}"><code>addPmu!</code></a> function, variances for both magnitude and angle measurements are standardized to <code>varianceMagnitude = 1e-8</code> and <code>varianceAngle = 1e-8</code> in per-units. Likewise, operational status is uniformly set to <code>status = 1</code>, regardless of whether the PMU is positioned on the bus, the from-bus end, or the to-bus end. Once more, users retain the option to tailor these default values to their specific needs, allowing for distinctions between these three locations of the measurement devices. Additionally, the coordinate system utilized for AC state estimation is consistently configured with <code>polar = false</code>, while correlation in the rectangular system is disabled with <code>correlated = false</code>.</p><p>Across all measurement devices, the method for generating measurement means is established as <code>noise = false</code>.</p><hr/><h5 id="ChangeKeywordsMeasurementManual"><a class="docs-heading-anchor" href="#ChangeKeywordsMeasurementManual">Change Default Keyword Values</a><a id="ChangeKeywordsMeasurementManual-1"></a><a class="docs-heading-anchor-permalink" href="#ChangeKeywordsMeasurementManual" title="Permalink"></a></h5><p>In JuliaGrid, users have the flexibility to customize default values and assign personalized settings using the <a href="../../api/measurementModel/#JuliaGrid.@voltmeter"><code>@voltmeter</code></a>, <a href="../../api/measurementModel/#JuliaGrid.@ammeter"><code>@ammeter</code></a>, <a href="../../api/measurementModel/#JuliaGrid.@wattmeter"><code>@wattmeter</code></a>, <a href="../../api/measurementModel/#JuliaGrid.@varmeter"><code>@varmeter</code></a>, and <a href="../../api/measurementModel/#JuliaGrid.@pmu"><code>@pmu</code></a> macros. These macros create voltmeter, ammeter, wattmeter, varmeter, and pmu templates that are employed each time functions for adding measurement devices are called. Here is an example of creating these templates with tailored default values:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

@voltmeter(variance = 1e-4, noise = true)
addVoltmeter!(monitoring; label = &quot;Voltmeter 1&quot;, bus = &quot;Bus 1&quot;, magnitude = 1.0)

@ammeter(varianceFrom = 1e-3, varianceTo = 1e-4, statusTo = 0)
addAmmeter!(monitoring; label = &quot;Ammeter 1&quot;, from = &quot;Branch 1&quot;, magnitude = 1.1)
addAmmeter!(monitoring; label = &quot;Ammeter 2&quot;, to = &quot;Branch 1&quot;, magnitude = 0.9)

@wattmeter(varianceBus = 1e-3, statusFrom = 0, noise = true)
addWattmeter!(monitoring; label = &quot;Wattmeter 1&quot;, bus = &quot;Bus 1&quot;, active = 0.6)
addWattmeter!(monitoring; label = &quot;Wattmeter 2&quot;, from = &quot;Branch 1&quot;, active = 0.3)
addWattmeter!(monitoring; label = &quot;Wattmeter 3&quot;, to = &quot;Branch 1&quot;, active = 0.1)

@varmeter(varianceFrom = 1e-3, varianceTo = 1e-3, statusBus = 0)
addVarmeter!(monitoring; label = &quot;Varmeter 1&quot;, bus = &quot;Bus 1&quot;, reactive = 0.2)
addVarmeter!(monitoring; label = &quot;Varmeter 2&quot;, from = &quot;Branch 1&quot;, reactive = 0.1)
addVarmeter!(monitoring; label = &quot;Varmeter 3&quot;, to = &quot;Branch 1&quot;, reactive = 0.05)

@pmu(varianceMagnitudeBus = 1e-4, statusBus = 0, varianceAngleFrom = 1e-3)
addPmu!(monitoring; label = &quot;PMU 1&quot;, bus = &quot;Bus 1&quot;, magnitude = 1.1, angle = -0.1)
addPmu!(monitoring; label = &quot;PMU 2&quot;, from = &quot;Branch 1&quot;, magnitude = 1.0, angle = -0.2)
addPmu!(monitoring; label = &quot;PMU 3&quot;, to = &quot;Branch 1&quot;, magnitude = 0.9, angle = 0.0)</code></pre><p>For instance, when adding a wattmeter to the bus, the <code>varianceBus = 1e-3</code> will be applied, or if it is added to the from-bus end of the branch, these wattmeters will be set as out-of-service according to <code>statusFrom = 0</code>.</p><p>It is important to note that changing input units will also impact the templates accordingly.</p><hr/><h5 id="Multiple-Templates"><a class="docs-heading-anchor" href="#Multiple-Templates">Multiple Templates</a><a id="Multiple-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Templates" title="Permalink"></a></h5><p>In the case of calling the macros multiple times, the provided keywords and values will be combined into a single template for the corresponding measurement device.</p><hr/><h5 id="Reset-Templates"><a class="docs-heading-anchor" href="#Reset-Templates">Reset Templates</a><a id="Reset-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Reset-Templates" title="Permalink"></a></h5><p>To reset the measurement device templates to their default settings, users can utilize the following macros:</p><pre><code class="language-julia hljs">@default(voltmeter)
@default(ammeter)
@default(wattmeter)
@default(varmeter)
@default(pmu)</code></pre><p>Additionally, users can reset all templates using the macro:</p><pre><code class="language-julia hljs">@default(template)</code></pre><hr/><h2 id="LabelsMeasurementManual"><a class="docs-heading-anchor" href="#LabelsMeasurementManual">Labels</a><a id="LabelsMeasurementManual-1"></a><a class="docs-heading-anchor-permalink" href="#LabelsMeasurementManual" title="Permalink"></a></h2><p>JuliaGrid necessitates a unique label for each voltmeter, ammeter, wattmeter, varmeter, or pmu. These labels are stored in order dictionaries, functioning as pairs of strings and integers. The string signifies the distinct label for the particular device, while the integer tracks the internal numbering of measurement devices.</p><p>In all the previous examples, with the exception of the last one, we relied on automatic labeling by omitting the <code>label</code> keyword. This allowed JuliaGrid to independently assign unique labels to measurement devices. In such cases, JuliaGrid utilizes a sequential set of increasing integers for labeling the devices. The <a href="#ChangeKeywordsMeasurementManual">last example</a> demonstrates the user labeling approach.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>String labels improve readability, but in larger models, the overhead from using strings can become substantial. To reduce memory usage, users can configure ordered dictionaries to accept and store integers as labels:</p><pre><code class="language-julia hljs">@config(label = Integer)</code></pre></div></div><hr/><h5 id="Integer-Based-Labeling"><a class="docs-heading-anchor" href="#Integer-Based-Labeling">Integer-Based Labeling</a><a id="Integer-Based-Labeling-1"></a><a class="docs-heading-anchor-permalink" href="#Integer-Based-Labeling" title="Permalink"></a></h5><p>Let us take a look at the following illustration:</p><pre><code class="language-julia hljs">@config(label = Integer)

system, monitoring = ems()

addBus!(system; label = 1)
addBus!(system; label = 2)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)

addVoltmeter!(monitoring; label = 1, bus = 1, magnitude = 1.0)

addAmmeter!(monitoring; label = 1, from = 1, magnitude = 1.1)
addAmmeter!(monitoring; label = 2, to = 1, magnitude = 0.9)</code></pre><p>In this example, we use the macro <a href="../../api/setupPrint/#JuliaGrid.@config"><code>@config</code></a> to specify that labels will be stored as integers. It is essential to run this macro; otherwise, even if integers are used in subsequent functions, they will be stored as strings.</p><hr/><h5 id="Automated-Labeling-Using-Templates"><a class="docs-heading-anchor" href="#Automated-Labeling-Using-Templates">Automated Labeling Using Templates</a><a id="Automated-Labeling-Using-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-Labeling-Using-Templates" title="Permalink"></a></h5><p>Furthermore, users can create labels using templates and include the symbol <code>?</code> to insert an incremental set of integers at any position. In addition, users have the option to use the symbol <code>!</code> to insert the location of the measurement device into the label. For example:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)

@voltmeter(label = &quot;Voltmeter ?&quot;)
addVoltmeter!(monitoring; bus = &quot;Bus 1&quot;, magnitude = 1.0)
addVoltmeter!(monitoring; bus = &quot;Bus 2&quot;, magnitude = 0.9)

@ammeter(label = &quot;!&quot;)
addAmmeter!(monitoring; from = &quot;Branch 1&quot;, magnitude = 1.1)
addAmmeter!(monitoring; to = &quot;Branch 1&quot;, magnitude = 0.9)

@wattmeter(label = &quot;Wattmeter ?: !&quot;)
addWattmeter!(monitoring; bus = &quot;Bus 1&quot;, active = 0.6)
addWattmeter!(monitoring; from = &quot;Branch 1&quot;, active = 0.3)</code></pre><p>To illustrate, the voltmeter labels are defined with incremental integers as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.voltmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 2 entries:
  &quot;Voltmeter 1&quot; =&gt; 1
  &quot;Voltmeter 2&quot; =&gt; 2</code></pre><p>Moreover, for ammeter labels, location information is employed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.ammeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 2 entries:
  &quot;From Branch 1&quot; =&gt; 1
  &quot;To Branch 1&quot;   =&gt; 2</code></pre><p>Lastly, for wattmeters, a combination of both approaches is used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.wattmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 2 entries:
  &quot;Wattmeter 1: Bus 1&quot;         =&gt; 1
  &quot;Wattmeter 2: From Branch 1&quot; =&gt; 2</code></pre><hr/><h5 id="Retrieving-Labels"><a class="docs-heading-anchor" href="#Retrieving-Labels">Retrieving Labels</a><a id="Retrieving-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-Labels" title="Permalink"></a></h5><p>Let us explore how to retrieve stored labels. Consider the following model:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.12)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 1&quot;, reactance = 0.14)

addWattmeter!(monitoring; label = &quot;Wattmeter 2&quot;, bus = &quot;Bus 2&quot;, active = 0.6)
addWattmeter!(monitoring; label = &quot;Wattmeter 1&quot;, bus = &quot;Bus 1&quot;, active = 0.2)
addWattmeter!(monitoring; label = &quot;Wattmeter 4&quot;, from = &quot;Branch 1&quot;, active = 0.3)
addWattmeter!(monitoring; label = &quot;Wattmeter 3&quot;, to = &quot;Branch 1&quot;, active = 0.1)
addWattmeter!(monitoring; label = &quot;Wattmeter 5&quot;, from = &quot;Branch 2&quot;, active = 0.1)</code></pre><p>To access the wattmeter labels, we can use the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.wattmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 5 entries:
  &quot;Wattmeter 2&quot; =&gt; 1
  &quot;Wattmeter 1&quot; =&gt; 2
  &quot;Wattmeter 4&quot; =&gt; 3
  &quot;Wattmeter 3&quot; =&gt; 4
  &quot;Wattmeter 5&quot; =&gt; 5</code></pre><p>If we need to obtain only labels, we can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(monitoring.wattmeter.label))</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{String}:
 &quot;Wattmeter 2&quot;
 &quot;Wattmeter 1&quot;
 &quot;Wattmeter 4&quot;
 &quot;Wattmeter 3&quot;
 &quot;Wattmeter 5&quot;</code></pre><p>To isolate the wattmeters positioned either at the buses or at the ends of branches (from-bus or to-bus), users can achieve this using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label[monitoring.wattmeter.layout.bus]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;Wattmeter 2&quot;
 &quot;Wattmeter 1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; label[monitoring.wattmeter.layout.from]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;Wattmeter 4&quot;
 &quot;Wattmeter 5&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; label[monitoring.wattmeter.layout.to]</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;Wattmeter 3&quot;</code></pre><p>Furthermore, when using the <a href="../../api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}"><code>addWattmeter!</code></a> function, the labels for the keywords <code>bus</code>, <code>from</code>, and <code>to</code> are stored internally as numerical values. To retrieve bus labels, we can follow this procedure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(system.bus.label));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; label[monitoring.wattmeter.layout.index[monitoring.wattmeter.layout.bus]]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;Bus 2&quot;
 &quot;Bus 1&quot;</code></pre><p>Similarly, to obtain labels for branches, we can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; label = collect(keys(system.branch.label));</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; label[monitoring.wattmeter.layout.index[monitoring.wattmeter.layout.from]]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;Branch 1&quot;
 &quot;Branch 2&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; label[monitoring.wattmeter.layout.index[monitoring.wattmeter.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;Branch 1&quot;</code></pre><p>This procedure is applicable to all measurement devices, including voltmeters, ammeters, varmeters, and PMUs.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>JuliaGrid offers the capability to print labels alongside various types of data. For instance, users can use the following code to print labels in combination with specific data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(monitoring.wattmeter.label, monitoring.wattmeter.active.mean)</code><code class="nohighlight hljs ansi" style="display:block;">Wattmeter 2: 0.6
Wattmeter 1: 0.2
Wattmeter 4: 0.3
Wattmeter 3: 0.1
Wattmeter 5: 0.1</code></pre></div></div><hr/><h5 id="Loading-and-Saving-Labels"><a class="docs-heading-anchor" href="#Loading-and-Saving-Labels">Loading and Saving Labels</a><a id="Loading-and-Saving-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-and-Saving-Labels" title="Permalink"></a></h5><p>When saving the measurements to an HDF5 file, the label type (strings or integers) will match the type chosen during system setup. Likewise, when loading data from an HDF5 file, the label type will be preserved as saved, regardless of what is set by the <a href="../../api/setupPrint/#JuliaGrid.@config"><code>@config</code></a> macro.</p><hr/><h2 id="AddDeviceGroupsManual"><a class="docs-heading-anchor" href="#AddDeviceGroupsManual">Add Multiple Devices</a><a id="AddDeviceGroupsManual-1"></a><a class="docs-heading-anchor-permalink" href="#AddDeviceGroupsManual" title="Permalink"></a></h2><p>Users have the option to add measurement devices with data generated from one of the AC analyses, specifically, using results obtained from either AC power flow or AC optimal power flow. To do this, users simply need to provide the <code>AC</code> type as an argument to one of the functions responsible for adding measurement devices:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)

@branch(resistance = 0.03, susceptance = 0.02)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.5)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.1)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.2)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 1.2)

analysis = newtonRaphson(system)
powerFlow!(analysis; power = true, current = true)

@voltmeter(label = &quot;!&quot;, noise = true)
addVoltmeter!(monitoring, analysis; variance = 1e-3)

@ammeter(label = &quot;!&quot;)
addAmmeter!(monitoring, analysis; varianceFrom = 1e-3, statusTo = 0, noise = true)

@wattmeter(label = &quot;!&quot;)
addWattmeter!(monitoring, analysis; varianceBus = 1e-3, statusFrom = 0)

@varmeter(label = &quot;!&quot;)
addVarmeter!(monitoring, analysis; varianceFrom = 1e-3, statusBus = 0)

@pmu(label = &quot;!&quot;, polar = true)
addPmu!(monitoring, analysis; varianceMagnitudeBus = 1e-3)</code></pre><p>In this example, we incorporate voltmeters to all buses and ammeters to all branches on both ends of each branch. We set <code>noise = true</code> once in the template and once directly in the function, which means that measurement values are generated by adding white Gaussian noise with specified variances to perturb the values obtained from the AC power flow analysis.</p><p>For wattmeters, varmeters, and PMUs added to all buses and branches, we rely on the default setting of <code>noise = false</code> to obtain measurement values that match precisely with those obtained from the AC power flow analysis. Additionally, when including PMUs in the AC state estimation model, we opt for the polar coordinate system by setting <code>polar = true</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is important to note that JuliaGrid follows a specific order: it first adds bus measurements, then branch measurements. For branches, it adds measurement located at the from-bus end, and immediately after, measurement at the to-bus end. This process is repeated for all in-service branches.</p></div></div><hr/><p>Users have the option to employ an alternative method for adding groups of measurements, utilizing functions that add measurements individually. This approach may offer a more straightforward process. For example, to add wattmeters similarly to the procedure outlined above, we can employ the following:</p><pre><code class="language-julia hljs">Pᵢ = analysis.power.injection.active
for (label, idx) in system.bus.label
    addWattmeter!(monitoring; bus = label, active = Pᵢ[idx], variance = 1e-3)
end

Pᵢⱼ = analysis.power.from.active
Pⱼᵢ = analysis.power.to.active
for (label, idx) in system.branch.label
    addWattmeter!(monitoring; from = label, active = Pᵢⱼ[idx], status = 0)
    addWattmeter!(monitoring; to = label, active = Pⱼᵢ[idx])
end</code></pre><hr/><h2 id="UpdateMeasurementDevicesManual"><a class="docs-heading-anchor" href="#UpdateMeasurementDevicesManual">Update Devices</a><a id="UpdateMeasurementDevicesManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateMeasurementDevicesManual" title="Permalink"></a></h2><p>After the addition of measurement devices to the <code>Measurement</code> type, users possess the flexibility to modify all parameters as defined in the function that added these measurement devices.</p><hr/><h5 id="UpdateVoltmeterManual"><a class="docs-heading-anchor" href="#UpdateVoltmeterManual">Update Voltmeter</a><a id="UpdateVoltmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateVoltmeterManual" title="Permalink"></a></h5><p>Users have the flexibility to modify all parameters as defined within the <a href="../../api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement}"><code>addVoltmeter!</code></a> function. For illustration, let us continue with the example from the <a href="#AddDeviceGroupsManual">Add Device Groups</a> section:</p><pre><code class="language-julia hljs">updateVoltmeter!(monitoring; label = &quot;Bus 2&quot;, magnitude = 0.9, noise = false)</code></pre><p>In this example, we update the measurement value of the voltmeter located at <code>Bus 2</code>, and this measurement is now generated without the inclusion of white Gaussian noise.</p><hr/><h5 id="UpdateAmmeterManual"><a class="docs-heading-anchor" href="#UpdateAmmeterManual">Update Ammeter</a><a id="UpdateAmmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateAmmeterManual" title="Permalink"></a></h5><p>Similarly, users have the flexibility to modify all parameters defined within the <a href="../../api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement}"><code>addAmmeter!</code></a> function. Using the same example from the <a href="#AddDeviceGroupsManual">Add Device Groups</a> section, for example, we have:</p><pre><code class="language-julia hljs">updateAmmeter!(monitoring; label = &quot;From Branch 2&quot;, magnitude = 1.2, variance = 1e-4)
updateAmmeter!(monitoring; label = &quot;To Branch 2&quot;, status = 0)</code></pre><p>In this example, we make adjustments to the measurement and variance values of the ammeter located at <code>Branch 2</code>, specifically at the from-bus end. Next, we deactivate the ammeter at the same branch on the to-bus end.</p><hr/><h5 id="UpdateWattmeterManual"><a class="docs-heading-anchor" href="#UpdateWattmeterManual">Update Wattmeter</a><a id="UpdateWattmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateWattmeterManual" title="Permalink"></a></h5><p>Following the same logic, users can modify all parameters defined within the <a href="../../api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}"><code>addWattmeter!</code></a> function:</p><pre><code class="language-julia hljs">updateWattmeter!(monitoring; label = &quot;Bus 1&quot;, active = 1.2, variance = 1e-4)
updateWattmeter!(monitoring; label = &quot;To Branch 1&quot;, variance = 1e-6)</code></pre><p>In this case, we modify the measurement and variance values for the wattmeter located at <code>Bus 1</code>. The wattmeter at <code>Branch 1</code> on the to-bus end retains its measurement value, while only the measurement variance is adjusted.</p><hr/><h5 id="UpdateVarmeterManual"><a class="docs-heading-anchor" href="#UpdateVarmeterManual">Update Varmeter</a><a id="UpdateVarmeterManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdateVarmeterManual" title="Permalink"></a></h5><p>Following the same logic, users can modify all parameters defined within the <a href="../../api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement}"><code>addVarmeter!</code></a> function:</p><pre><code class="language-julia hljs">updateVarmeter!(monitoring; label = &quot;Bus 1&quot;, reactive = 1.2)
updateVarmeter!(monitoring; label = &quot;Bus 2&quot;, status = 0)</code></pre><p>In this instance, we make adjustments to the measurement value of the varmeter located at <code>Bus 1</code>, while utilizing a previously defined variance. Furthermore, we deactivate the varmeter at <code>Bus 2</code> and designate it as out-of-service.</p><hr/><h5 id="UpdatePMUrManual"><a class="docs-heading-anchor" href="#UpdatePMUrManual">Update PMU</a><a id="UpdatePMUrManual-1"></a><a class="docs-heading-anchor-permalink" href="#UpdatePMUrManual" title="Permalink"></a></h5><p>Finally, users can modify all PMU parameters defined within the <a href="../../api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement}"><code>addPmu!</code></a> function:</p><pre><code class="language-julia hljs">updatePmu!(monitoring; label = &quot;Bus 1&quot;, magnitude = 1.05, noise = true)
updatePmu!(monitoring; label = &quot;From Branch 1&quot;, varianceAngle = 1e-6, polar = false)</code></pre><p>In this example, we adjust the magnitude measurement value of the PMU located at <code>Bus 1</code>. Now, this measurement is generated by adding white Gaussian noise with specified variance value to perturb the <code>magnitude</code> value, while keeping the bus angle voltage value unchanged. For the PMU placed at <code>Branch 1</code> on the from-bus end, we retain the existing measurement values and only adjust the variance of the angle measurement. Additionally, we choose to include this measurement in the rectangular coordinate system for the AC state estimation.</p><hr/><h2 id="MeasurementSetManual"><a class="docs-heading-anchor" href="#MeasurementSetManual">Measurement Set</a><a id="MeasurementSetManual-1"></a><a class="docs-heading-anchor-permalink" href="#MeasurementSetManual" title="Permalink"></a></h2><p>Once measurement devices are integrated into the <code>Measurement</code> type, we empower users to create measurement sets in a randomized manner. To be more precise, users can manipulate the status of devices, activating or deactivating them according to specific settings. To illustrate this feature, let us first create a measurement set using the following example:</p><pre><code class="language-julia hljs">system, monitoring = ems()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)

@branch(resistance = 0.03, susceptance = 0.02)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.5)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.1)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.2)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 1.2)

analysis = newtonRaphson(system)
powerFlow!(analysis; power = true, current = true)

addVoltmeter!(monitoring, analysis)
addAmmeter!(monitoring, analysis)
addPmu!(monitoring, analysis)</code></pre><hr/><h5 id="Activating-Devices"><a class="docs-heading-anchor" href="#Activating-Devices">Activating Devices</a><a id="Activating-Devices-1"></a><a class="docs-heading-anchor-permalink" href="#Activating-Devices" title="Permalink"></a></h5><p>As a starting point, we create the measurement set where all devices are set to in-service mode based on default settings. In this instance, we generate the measurement set comprising 3 voltmeters, 6 ammeters, and 9 PMUs.</p><p>Subsequently, we offer users the ability to manipulate the status of in-service devices using the <a href="../../api/measurementModel/#JuliaGrid.status!"><code>status!</code></a> function. For example, within this set, if we wish to have only 12 out of the total 18 devices in-service while the rest are out-of-service, we can accomplish this as follows:</p><pre><code class="language-julia hljs">status!(monitoring; inservice = 12)</code></pre><p>Upon executing this function, 12 devices will be randomly selected to be in-service, while the remaining 6 will be set to out-of-service.</p><p>Furthermore, users can fine-tune the manipulation of specific measurements. Let us say we want to activate only 2 ammeters while deactivating the remaining ammeters:</p><pre><code class="language-julia hljs">statusAmmeter!(monitoring; inservice = 2)</code></pre><p>This action will result in 2 ammeters being in-service and 4 being out-of-service.</p><p>Users also have the option to further refine these actions by specifying devices at particular locations within the power system. For instance, we can enable 3 PMUs at buses to measure bus voltage phasors while deactivating all PMUs at branches that measure current phasors:</p><pre><code class="language-julia hljs">statusPmu!(monitoring; inserviceBus = 3, inserviceFrom = 0, inserviceTo = 0)</code></pre><p>The outcome will be that 3 PMUs are set to in-service at buses for voltage phasor measurements, while all PMUs at branches measuring current phasors will be in out-of-service mode.</p><hr/><h5 id="Deactivating-Devices"><a class="docs-heading-anchor" href="#Deactivating-Devices">Deactivating Devices</a><a id="Deactivating-Devices-1"></a><a class="docs-heading-anchor-permalink" href="#Deactivating-Devices" title="Permalink"></a></h5><p>Likewise, we empower users to specify the number of devices to be set as out-of-service rather than defining the number of in-service devices. For instance, if the intention is to deactivate just 2 devices from the total measurement set, it can be achieved as follows:</p><pre><code class="language-julia hljs">status!(monitoring; outservice = 2)</code></pre><p>In this scenario 2 devices will be randomly deactivated, while the rest will remain in in-service status. Similar to the previous approach, users can apply this to specific devices or employ fine-tuning as needed.</p><hr/><h5 id="Activating-Devices-Using-Redundancy"><a class="docs-heading-anchor" href="#Activating-Devices-Using-Redundancy">Activating Devices Using Redundancy</a><a id="Activating-Devices-Using-Redundancy-1"></a><a class="docs-heading-anchor-permalink" href="#Activating-Devices-Using-Redundancy" title="Permalink"></a></h5><p>Furthermore, users can take advantage of redundancy, which represents the ratio between measurement devices and state variables. For example, if we wish to have the number of measurement devices be 1.2 times greater than the number of state variables, we can utilize the following command:</p><pre><code class="language-julia hljs">status!(monitoring; redundancy = 1.2)</code></pre><p>Considering that the number of state variables is 5 (excluding the voltage angle related to the slack bus), using a redundancy value of 1.2 will result in 6 devices being set to in-service, while the remainder will be deactivated. As before, users can target specific devices or adjust settings as needed.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcOptimalPowerFlow/">« DC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../observabilityAnalysis/">Observability Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Saturday 19 April 2025 11:26">Saturday 19 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
