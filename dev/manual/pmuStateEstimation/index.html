<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PMU State Estimation ¬∑ JuliaGrid</title><meta name="title" content="PMU State Estimation ¬∑ JuliaGrid"/><meta property="og:title" content="PMU State Estimation ¬∑ JuliaGrid"/><meta property="twitter:title" content="PMU State Estimation ¬∑ JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/acdcModel/">AC and DC Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>PMU State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PMU State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/pmuStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PMUStateEstimationManual"><a class="docs-heading-anchor" href="#PMUStateEstimationManual">PMU State Estimation</a><a id="PMUStateEstimationManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUStateEstimationManual" title="Permalink"></a></h1><p>To perform linear state estimation solely based on PMU data, the initial requirement is to have the <code>PowerSystem</code> composite type configured with the <code>ac</code> model, along with the <code>Measurement</code> composite type storing measurement data. Subsequently, we can formulate the PMU state estimation model encapsulated within the abstract type <code>PMUStateEstimation</code> using the subsequent function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a>.</li></ul><p>For resolving the PMU state estimation problem employing either the weighted least-squares (WLS) or the least absolute value (LAV) approach and obtaining bus voltage magnitudes and angles, utilize the following function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>solve!</code></a>.</li></ul><p>After executing the function <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>solve!</code></a>, where the user employs the WLS method, the user has the ability to check if the measurement set contains outliers throughout bad data analysis and remove those measurements using:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.residualTest!"><code>residualTest!</code></a>.</li></ul><p>Moreover, before executing the <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> function, users can initiate an optimal PMU placement algorithm to determine the minimal set of PMUs required for an observable system: </p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.pmuPlacement"><code>pmuPlacement</code></a>.</li></ul><hr/><p>After obtaining the PMU state estimation solution, JuliaGrid offers post-processing analysis functions for calculating powers and currents associated with buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>Furthermore, there are specialized functions dedicated to calculating specific types of powers related to particular buses and branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionPower-Tuple{PowerSystem, AC}"><code>injectionPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.supplyPower-Tuple{PowerSystem, ACPowerFlow}"><code>supplyPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.shuntPower-Tuple{PowerSystem, AC}"><code>shuntPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromPower-Tuple{PowerSystem, AC}"><code>fromPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toPower-Tuple{PowerSystem, AC}"><code>toPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesPower-Tuple{PowerSystem, AC}"><code>seriesPower</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.chargingPower-Tuple{PowerSystem, AC}"><code>chargingPower</code></a>,</li></ul><p>Likewise, there are specialized functions dedicated to calculating specific types of currents related to particular buses or branches:</p><ul><li><a href="../../api/analysis/#JuliaGrid.injectionCurrent-Tuple{PowerSystem, AC}"><code>injectionCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.fromCurrent-Tuple{PowerSystem, AC}"><code>fromCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.toCurrent-Tuple{PowerSystem, AC}"><code>toCurrent</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.seriesCurrent-Tuple{PowerSystem, AC}"><code>seriesCurrent</code></a>.</li></ul><hr/><h2 id="OptimalPMUPlacementManual"><a class="docs-heading-anchor" href="#OptimalPMUPlacementManual">Optimal PMU Placement</a><a id="OptimalPMUPlacementManual-1"></a><a class="docs-heading-anchor-permalink" href="#OptimalPMUPlacementManual" title="Permalink"></a></h2><p>Let us define the <code>PowerSystem</code> composite type and perform an AC power flow analysis solely for generating data to artificially create measurement values later:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 3.2)
acModel!(system)

analysis = newtonRaphson(system)
for iteration = 1:10
    mismatch!(system, analysis)
    solve!(system, analysis)
end</code></pre><p>As a result, we have obtained bus voltage magnitudes and angles, which we will utilize to artificially define measurement values for the corresponding power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêï = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 0.9992459238997272
 0.9990453701566157</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõâ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.022518882689040867
 0.00248332409248796</code></pre><hr/><h5 id="Optimal-Solution"><a class="docs-heading-anchor" href="#Optimal-Solution">Optimal Solution</a><a id="Optimal-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Solution" title="Permalink"></a></h5><p>Upon defining the <code>PowerSystem</code> composite type, JuliaGrid provides the possibility to determine the minimal number of PMUs required for system observability using the <a href="../../api/stateEstimation/#JuliaGrid.pmuPlacement"><code>pmuPlacement</code></a> function:</p><pre><code class="language-julia hljs">using GLPK

placement = pmuPlacement(system, GLPK.Optimizer)</code></pre><p>The <code>placement</code> variable contains data regarding the optimal placement of measurements. In this instance, installing a PMU at <code>Bus 2</code> renders the system observable:  </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; placement.bus</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 1 entry:
  &quot;Bus 2&quot; =&gt; 2</code></pre><p>This PMU installed at <code>Bus 2</code> will measure the bus voltage phasor at the corresponding bus and all current phasors at the branches incident to <code>Bus 2</code> located at the &quot;from&quot; or &quot;to&quot; bus ends:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; placement.from</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 1 entry:
  &quot;Branch 3&quot; =&gt; 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; placement.to</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 2 entries:
  &quot;Branch 1&quot; =&gt; 1
  &quot;Branch 2&quot; =&gt; 2</code></pre><hr/><h5 id="Measurement-Data"><a class="docs-heading-anchor" href="#Measurement-Data">Measurement Data</a><a id="Measurement-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Data" title="Permalink"></a></h5><p>Based on the obtained placement of PMUs and using data from the AC power flow, we can construct the <code>Measurement</code> composite type:</p><pre><code class="language-julia hljs">device = measurement()

@pmu(label = &quot;PMU ?&quot;)
for (bus, k) in placement.bus
    addPmu!(system, device; bus = bus, magnitude = ùêï[k], angle = ùõâ[k], noise = false)
end
for branch in keys(placement.from)
    I·µ¢‚±º, œà·µ¢‚±º = fromCurrent(system, analysis; label = branch)
    addPmu!(system, device; from = branch, magnitude = I·µ¢‚±º, angle = œà·µ¢‚±º, noise = false)
end
for branch in keys(placement.to)
    I‚±º·µ¢, œà‚±º·µ¢ = toCurrent(system, analysis; label = branch)
    addPmu!(system, device; to = branch, magnitude = I‚±º·µ¢, angle = œà‚±º·µ¢, noise = false)
end</code></pre><p>For example, we can observe the obtained set of measurement values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(device.pmu.label, device.pmu.magnitude.mean)</code><code class="nohighlight hljs ansi" style="display:block;">PMU 1: 0.9992459238997272
PMU 2: 0.5004777710161624
PMU 3: 0.45045084242019723
PMU 4: 2.252254212100986</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(device.pmu.label, device.pmu.angle.mean)</code><code class="nohighlight hljs ansi" style="display:block;">PMU 1: 0.022518882689040867
PMU 2: 0.0024833240924833086
PMU 3: 0.044744525990189826
PMU 4: 0.044744525990186676</code></pre><hr/><h2 id="PMUWLSStateEstimationSolutionManual"><a class="docs-heading-anchor" href="#PMUWLSStateEstimationSolutionManual">WLS State Estimation Solution</a><a id="PMUWLSStateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUWLSStateEstimationSolutionManual" title="Permalink"></a></h2><p>Let us continius previus example, where we defined <code>PowerSystem</code> and  <code>Measurement</code> types. The <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> function serves to establish the PMU state estimation problem:    </p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here, the user triggers LU factorization as the default method for solving the PMU state estimation problem. However, the user also has the option to select alternative factorization methods such as <code>LDLt</code> or <code>QR</code>.</p></div></div><p>To obtain the bus voltage magnitudes and angles, the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>solve!</code></a> function can be invoked as shown:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Upon obtaining the solution, access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.9999999999995042, 4.095335182088077e-14
Bus 2: 0.9992459238992325, 0.022518882689093005
Bus 3: 0.9990453701561199, 0.0024833240925301813</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on [PMU State Estimation] for insights into the implementation.</p></div></div><hr/><h5 id="Correlated-Measurement-Errors"><a class="docs-heading-anchor" href="#Correlated-Measurement-Errors">Correlated Measurement Errors</a><a id="Correlated-Measurement-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Correlated-Measurement-Errors" title="Permalink"></a></h5><p>In the above approach, we assume that measurement errors from a single PMU are uncorrelated. This assumption leads to the covariance matrix and its inverse matrix (i.e., precision matrix) maintaining a diagonal form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">8√ó8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
 1.0e5   ‚ãÖ          ‚ãÖ      ‚ãÖ          ‚ãÖ         ‚ãÖ              ‚ãÖ        ‚ãÖ
  ‚ãÖ     1.00151e5   ‚ãÖ      ‚ãÖ          ‚ãÖ         ‚ãÖ              ‚ãÖ        ‚ãÖ
  ‚ãÖ      ‚ãÖ         1.0e5   ‚ãÖ          ‚ãÖ         ‚ãÖ              ‚ãÖ        ‚ãÖ
  ‚ãÖ      ‚ãÖ          ‚ãÖ     3.99229e5   ‚ãÖ         ‚ãÖ              ‚ãÖ        ‚ãÖ
  ‚ãÖ      ‚ãÖ          ‚ãÖ      ‚ãÖ         1.0016e5   ‚ãÖ              ‚ãÖ        ‚ãÖ
  ‚ãÖ      ‚ãÖ          ‚ãÖ      ‚ãÖ          ‚ãÖ        4.88996e5       ‚ãÖ        ‚ãÖ
  ‚ãÖ      ‚ãÖ          ‚ãÖ      ‚ãÖ          ‚ãÖ         ‚ãÖ         99191.8       ‚ãÖ
  ‚ãÖ      ‚ãÖ          ‚ãÖ      ‚ãÖ          ‚ãÖ         ‚ãÖ              ‚ãÖ   19745.3</code></pre><p>While this approach is suitable for many scenarios, linear PMU state estimation relies on transforming from polar to rectangular coordinate systems. Consequently, measurement errors from a single PMU become correlated due to this transformation. This correlation results in the covariance matrix, and hence the precision matrix, no longer maintaining a diagonal form but instead becoming a block diagonal matrix. To account for this, the user can execute the WLS state estimation model as follows:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device; correlated = true)</code></pre><p>Now, we observe that the precision matrix no longer maintains a diagonal form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">8√ó8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
  1.0e5    -3.39889        ‚ãÖ         ‚Ä¶        ‚ãÖ              ‚ãÖ         ‚ãÖ
 -3.39889   1.00151e5      ‚ãÖ                  ‚ãÖ              ‚ãÖ         ‚ãÖ
   ‚ãÖ         ‚ãÖ            1.00002e5           ‚ãÖ              ‚ãÖ         ‚ãÖ
   ‚ãÖ         ‚ãÖ         -743.099               ‚ãÖ              ‚ãÖ         ‚ãÖ
   ‚ãÖ         ‚ãÖ             ‚ãÖ            -17553.9             ‚ãÖ         ‚ãÖ
   ‚ãÖ         ‚ãÖ             ‚ãÖ         ‚Ä¶       4.92053e5       ‚ãÖ         ‚ãÖ
   ‚ãÖ         ‚ãÖ             ‚ãÖ                  ‚ãÖ         99839.4    3587.59
   ‚ãÖ         ‚ãÖ             ‚ãÖ                  ‚ãÖ          3587.59  19874.2</code></pre><p>Subsequently, we can address this new scenario and observe that the impact on the solution is nearly negligible for our measurement dataset:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve!(system, analysis)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0000000000004496, 3.4462211485578514e-14
Bus 2: 0.9992459239001775, 0.022518882689065205
Bus 3: 0.9990453701570653, 0.0024833240925213277</code></pre><hr/><h5 id="Alternative-Formulation"><a class="docs-heading-anchor" href="#Alternative-Formulation">Alternative Formulation</a><a id="Alternative-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Formulation" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from finding a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal factorization <a href="#PMUStateEstimationReferenceManual">[1, Sec. 3.2]</a>.</p><p>Specifically, by specifying the <code>Orthogonal</code> argument in the <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> function, JuliaGrid implements a more robust approach to obtain the WLS estimator, which proves particularly beneficial when substantial differences exist among measurement variances:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device, Orthogonal)
solve!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This method is applicable when measurement errors are uncorrelated and the precision matrix remains diagonal.</p></div></div><hr/><h2 id="PMUBadDataDetectionManual"><a class="docs-heading-anchor" href="#PMUBadDataDetectionManual">Bad Data Detection</a><a id="PMUBadDataDetectionManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUBadDataDetectionManual" title="Permalink"></a></h2><p>After acquiring the WLS solution using the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>solve!</code></a> function, users can conduct bad data analysis employing the largest normalized residual test. Continuing with our defined power system and measurement set, let us introduce a new phasor measurement. Upon proceeding to find the solution for this updated state:</p><pre><code class="language-julia hljs">addPmu!(system, device; bus = &quot;Bus 3&quot;, magnitude = 3.2, angle = 0.0, noise = false)

analysis = pmuStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Following the solution acquisition, we can verify the presence of erroneous data. Detection of such data is determined by the <code>threshold</code> keyword. If the largest normalized residual&#39;s value exceeds the threshold, the measurement will be identified as bad data and consequently removed from the DC state estimation model:</p><pre><code class="language-julia hljs">residualTest!(system, device, analysis; threshold = 4.0)</code></pre><p>Users can examine the data obtained from the bad data analysis:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.outlier.detect</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.outlier.maxNormalizedResidual</code><code class="nohighlight hljs ansi" style="display:block;">492.09989710163666</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.outlier.label</code><code class="nohighlight hljs ansi" style="display:block;">&quot;PMU 5&quot;</code></pre><p>Hence, upon detecting bad data, the <code>detect</code> variable will hold <code>true</code>. The <code>maxNormalizedResidual</code> variable retains the value of the largest normalized residual, while the <code>label</code> contains the label of the measurement identified as bad data. JuliaGrid will mark the respective phasor measurement as out-of-service within the <code>Measurement</code> type.</p><p>Moreover, JuliaGrid will adjust the coefficient matrix and mean vector within the <code>PMUStateEstimation</code> type based on measurements now designated as out-of-service. To optimize the algorithm&#39;s efficiency, JuliaGrid resets non-zero elements to zero in the coefficient matrix and mean vector. Here&#39;s an illustration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.mean</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Float64}:
 0.9989925757633135
 0.0225
 0.5004762278191357
 0.001242847229097066
 0.44999999999999996
 0.02014848473373121
 2.2499999999999996
 0.10074242366864894
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.coefficient</code><code class="nohighlight hljs ansi" style="display:block;">10√ó6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 28 stored entries:
    ‚ãÖ      1.0    ‚ãÖ       ‚ãÖ      ‚ãÖ      ‚ãÖ
    ‚ãÖ       ‚ãÖ     ‚ãÖ       ‚ãÖ     1.0     ‚ãÖ
    ‚ãÖ      0.0  -0.0      ‚ãÖ    25.0  -25.0
    ‚ãÖ    -25.0  25.0      ‚ãÖ     0.0   -0.0
  -0.0     0.0    ‚ãÖ    -20.0   20.0     ‚ãÖ
  20.0   -20.0    ‚ãÖ     -0.0    0.0     ‚ãÖ
  -0.0     0.0    ‚ãÖ   -100.0  100.0     ‚ãÖ
 100.0  -100.0    ‚ãÖ     -0.0    0.0     ‚ãÖ
    ‚ãÖ       ‚ãÖ    0.0      ‚ãÖ      ‚ãÖ      ‚ãÖ
    ‚ãÖ       ‚ãÖ     ‚ãÖ       ‚ãÖ      ‚ãÖ     0.0</code></pre><p>Hence, after removing bad data, a new estimate can be computed without considering this specific phasor measurement:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><hr/><h2 id="PMULAVtateEstimationSolutionManual"><a class="docs-heading-anchor" href="#PMULAVtateEstimationSolutionManual">LAV State Estimation Solution</a><a id="PMULAVtateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMULAVtateEstimationSolutionManual" title="Permalink"></a></h2><p>The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data processing procedures <a href="#PMUStateEstimationReferenceManual">[1, Ch. 6]</a>. However, it is important to note that achieving robustness typically involves increased computational complexity.</p><p>To obtain an LAV estimator, users need to employ one of the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:</p><pre><code class="language-julia hljs">using Ipopt

analysis = pmuStateEstimation(system, device, Ipopt.Optimizer)</code></pre><hr/><h5 id="Setup-Starting-Primal-Values"><a class="docs-heading-anchor" href="#Setup-Starting-Primal-Values">Setup Starting Primal Values</a><a id="Setup-Starting-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Starting-Primal-Values" title="Permalink"></a></h5><p>In JuliaGrid, the assignment of starting primal values for optimization variables takes place when the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>solve!</code></a> function is executed. Starting primal values are determined based on the <code>voltage</code> fields within the <code>PMUStateEstimation</code> type. By default, these values are initially established using the the initial bus voltage magnitudes and angles from <code>PowerSystem</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0
Bus 2: 1.0
Bus 3: 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.0
Bus 2: 0.0
Bus 3: 0.0</code></pre><p>Users have the flexibility to customize these values according to their requirements, and they will be utilized as the starting primal values when executing the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, DCStateEstimationWLS{LinearWLS}}"><code>solve!</code></a> function. It is important to note that JuliaGrid utilizes the provided data to set starting primal values in the rectangular coordinate system.</p><hr/><h5 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h5><p>To solve the formulated LAV state estimation model, simply execute the following function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Upon obtaining the solution, access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.9999999999854481, 0.0
Bus 2: 0.9992459239056364, 0.022518882695316975
Bus 3: 0.9990453701558077, 0.002483324081150812</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><hr/><h2 id="PMUMeasurementsAlterationManual"><a class="docs-heading-anchor" href="#PMUMeasurementsAlterationManual">Measurement Set Update</a><a id="PMUMeasurementsAlterationManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUMeasurementsAlterationManual" title="Permalink"></a></h2><p>After establishing the <code>Measurement</code> composite type using the <a href="../../api/measurementModel/#JuliaGrid.measurement"><code>measurement</code></a> function, users gain the capability to incorporate new measurement devices or update existing ones. </p><p>Once updates are completed, users can seamlessly progress towards generating the <code>PMUStateEstimation</code> type using the <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> function. Ultimately, resolving the PMU state estimation is achieved through the utilization of the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimationWLS{LinearWLS}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">system = powerSystem()
addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)
acModel!(system)

device = measurement()
@pmu(label = &quot;PMU ?&quot;)
addPmu!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, angle = 0.0, noise = false)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 0.98, angle = -0.023)
addPmu!(system, device; from = &quot;Branch 2&quot;, magnitude = 0.5, angle = -0.05)

analysis = pmuStateEstimation(system, device)
solve!(system, analysis)

addPmu!(system, device; to = &quot;Branch 2&quot;, magnitude = 0.5, angle = 3.1)
updatePmu!(system, device; label = &quot;PMU 1&quot;, varianceMagnitude = 1e-8, varianceAngle = 1e-8)
updatePmu!(system, device; label = &quot;PMU 3&quot;, statusMagnitude = 0, statusAngle = 0)

analysis = pmuStateEstimation(system, device)
solve!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This method removes the need to restart and recreate the <code>Measurement</code> type from the beginning when implementing changes to the existing measurement set.</p></div></div><hr/><h2 id="PMUStateEstimationUpdateManual"><a class="docs-heading-anchor" href="#PMUStateEstimationUpdateManual">State Estimation Update</a><a id="PMUStateEstimationUpdateManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUStateEstimationUpdateManual" title="Permalink"></a></h2><p>An advanced methodology involves users establishing the <code>PMUStateEstimation</code> composite type using <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> just once. After this initial setup, users can seamlessly modify existing measurement devices without the need to recreate the <code>PMUStateEstimation</code> type. </p><p>This advancement extends beyond the previous scenario where recreating the <code>Measurement</code> type was unnecessary, to now include the scenario where <code>PMUStateEstimation</code> also does not need to be recreated. </p><p>The addition of new measurements after the creation of <code>PMUStateEstimation</code> is not practical in terms of reusing the <code>PMUStateEstimation</code> type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This method removes the need to restart and recreate both the <code>Measurement</code> and the <code>PMUStateEstimation</code> from the beginning when implementing changes to the existing measurement set.</p></div></div><hr/><p>Continious previus example, we demonstrated the approche where we reuse <code>PMUStateEstimation</code> type:</p><pre><code class="language-julia hljs">updatePmu!(system, device, analysis; label = &quot;PMU 2&quot;, magnitude = 0.99, angle = 3.05)
updatePmu!(system, device, analysis; label = &quot;PMU 3&quot;, statusMagnitude = 1, statusAngle = 1)

solve!(system, analysis)</code></pre><hr/><h5 id="LAV-State-Estimation"><a class="docs-heading-anchor" href="#LAV-State-Estimation">LAV State Estimation</a><a id="LAV-State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#LAV-State-Estimation" title="Permalink"></a></h5><p>When a user creates an optimization problem using the LAV method, they can update measurement devices without the need to recreate the model from scratch, similar to the explanation provided for the WLS state estimation. This streamlined process allows for efficient modifications while retaining the existing optimization framework:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem()
addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)
acModel!(system)

device = measurement()
@pmu(label = &quot;PMU ?&quot;)
addPmu!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, angle = 0.0, noise = false)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 0.98, angle = -0.023)
addPmu!(system, device; from = &quot;Branch 2&quot;, magnitude = 0.5, angle = -0.05)

analysis = pmuStateEstimation(system, device, Ipopt.Optimizer)
solve!(system, analysis)

updatePmu!(system, device, analysis; label = &quot;PMU 2&quot;, magnitude = 0.99, angle = 3.05)
updatePmu!(system, device, analysis; label = &quot;PMU 3&quot;, statusMagnitude = 1, statusAngle = 1)

solve!(system, analysis)</code></pre><hr/><h2 id="PMUSEPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#PMUSEPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="PMUSEPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUSEPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the PMU state estimation, we can calculate various electrical quantities related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions. For instance, To illustrate this with a continuation of our previous example, we can compute powers and currents using the following functions:</p><pre><code class="language-julia hljs">power!(system, analysis)
current!(system, analysis)</code></pre><p>For instance, if we want to show the active power injections at each bus and the current flow angles at each &quot;to&quot; bus end of the branch, we can employ the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -1.7129317363535088
Bus 2: 1.2195533528445228
Bus 3: 0.4933783835089863</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.current.to.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: 1.5276790447647537
Branch 2: 3.095183785113218</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers and currents associated with buses and generators that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions, we suggest referring to the tutorials on [PMU State Estimation].</p></div></div><p>To compute specific quantities for particular components, rather than calculating powers or currents for all components, users can utilize one of the provided functions below.</p><hr/><h5 id="Active-and-Reactive-Power-Injection"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection">Active and Reactive Power Injection</a><a id="Active-and-Reactive-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection" title="Permalink"></a></h5><p>To calculate the active and reactive power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = injectionPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-1.7129317363535088, 39.70264405275206)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection-from-Generators">Active and Reactive Power Injection from Generators</a><a id="Active-and-Reactive-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = supplyPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-1.2129317363535088, 39.70264405275206)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Shunt-Element"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Shunt-Element">Active and Reactive Power at Shunt Element</a><a id="Active-and-Reactive-Power-at-Shunt-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Shunt-Element" title="Permalink"></a></h5><p>To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = shuntPower(system, analysis; label = &quot;Bus 3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, -0.0)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Flow"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Flow">Active and Reactive Power Flow</a><a id="Active-and-Reactive-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.4933783835089865, 0.019899978277023826)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.4933783835089865, -0.009926034592495737)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Charging-Admittances"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Charging-Admittances">Active and Reactive Power at Charging Admittances</a><a id="Active-and-Reactive-Power-at-Charging-Admittances-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Charging-Admittances" title="Permalink"></a></h5><p>To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = chargingPower(system, analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, -0.0)</code></pre><p>Active powers indicate active losses within the branch&#39;s charging or shunt admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.</p><hr/><h5 id="Active-and-Reactive-Power-at-Series-Impedance"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Series-Impedance">Active and Reactive Power at Series Impedance</a><a id="Active-and-Reactive-Power-at-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Series-Impedance" title="Permalink"></a></h5><p>To calculate the active and reactive power across the series impedance of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = seriesPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, 0.009973943684528086)</code></pre><p>The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance&#39;s inductive characteristics.</p><hr/><h5 id="Current-Injection"><a class="docs-heading-anchor" href="#Current-Injection">Current Injection</a><a id="Current-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injection" title="Permalink"></a></h5><p>To calculate the current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = injectionCurrent(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(39.739578255348114, -1.6139136088250396)</code></pre><hr/><h5 id="Current-Flow"><a class="docs-heading-anchor" href="#Current-Flow">Current Flow</a><a id="Current-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow" title="Permalink"></a></h5><p>We can compute the current flow at both the &quot;from&quot; and &quot;to&quot; bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = fromCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.4993481672272385, -0.04640886847657505)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = toCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.4993481672272385, 3.095183785113218)</code></pre><hr/><h5 id="Current-Through-Series-Impedance"><a class="docs-heading-anchor" href="#Current-Through-Series-Impedance">Current Through Series Impedance</a><a id="Current-Through-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Through-Series-Impedance" title="Permalink"></a></h5><p>To calculate the current passing through the series impedance of the branch in the direction from the &quot;from&quot; bus end to the &quot;to&quot; bus end, you can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = seriesCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.49934816722723846, -0.04640886847657327)</code></pre><hr/><h2 id="PMUStateEstimationReferenceManual"><a class="docs-heading-anchor" href="#PMUStateEstimationReferenceManual">References</a><a id="PMUStateEstimationReferenceManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUStateEstimationReferenceManual" title="Permalink"></a></h2><p>[1] A. Abur and A. Exposito, <em>Power System State Estimation: Theory and Implementation</em>, ser. Power Engineering. Taylor &amp; Francis, 2004.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 4 March 2024 15:33">Monday 4 March 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
