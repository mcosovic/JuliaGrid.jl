<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PMU State Estimation · JuliaGrid</title><meta name="title" content="PMU State Estimation · JuliaGrid"/><meta property="og:title" content="PMU State Estimation · JuliaGrid"/><meta property="twitter:title" content="PMU State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li class="is-active"><a class="tocitem" href>PMU State Estimation</a><ul class="internal"><li><a class="tocitem" href="#PhasorMeasurementsManual"><span>Phasor Measurements</span></a></li><li><a class="tocitem" href="#PMUWLSStateEstimationSolutionManual"><span>Weighted Least-Squares Estimator</span></a></li><li><a class="tocitem" href="#PMULAVtateEstimationSolutionManual"><span>Least Absolute Value Estimator</span></a></li><li><a class="tocitem" href="#PMUMeasurementsAlterationManual"><span>Measurement Set Update</span></a></li><li><a class="tocitem" href="#PMUStateEstimationUpdateManual"><span>State Estimation Update</span></a></li><li><a class="tocitem" href="#PMUSEPowerCurrentAnalysisManual"><span>Power and Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>PMU State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PMU State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/pmuStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PMUStateEstimationManual"><a class="docs-heading-anchor" href="#PMUStateEstimationManual">PMU State Estimation</a><a id="PMUStateEstimationManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUStateEstimationManual" title="Permalink"></a></h1><p>To perform linear state estimation solely based on PMU data, the initial requirement is to have the <code>PowerSystem</code> type configured with the AC model, along with the <code>Measurement</code> type storing measurement data. Subsequently, we can formulate either the weighted least-squares (WLS) or the least absolute value (LAV) PMU state estimation model encapsulated within the type <code>PMUStateEstimation</code> using:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a>,</li><li><a href="../../api/stateEstimation/#JuliaGrid.pmuLavStateEstimation"><code>pmuLavStateEstimation</code></a>.</li></ul><hr/><p>To obtain bus voltages and solve the PMU state estimation problem, users can use the wrapper function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{WLS{Normal}}}"><code>solve!</code></a>.</li></ul><p>After solving the PMU state estimation, JuliaGrid provides functions for computing powers and currents:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>Alternatively, instead of using functions responsible for solving state estimation and computing powers and currents, users can use the wrapper function:</p><ul><li><a href="../../api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{T}, Tuple{PowerSystem, PMUStateEstimation{WLS{T}}}} where T&lt;:Union{Normal, Orthogonal}"><code>stateEstimation!</code></a>.</li></ul><p>Users can also access specialized functions for computing specific types of <a href="../../api/analysis/#ACPowerAnalysisAPI">powers</a> or <a href="../../api/analysis/#ACCurrentAnalysisAPI">currents</a> for individual buses, branches, or generators within the power system.</p><hr/><h2 id="PhasorMeasurementsManual"><a class="docs-heading-anchor" href="#PhasorMeasurementsManual">Phasor Measurements</a><a id="PhasorMeasurementsManual-1"></a><a class="docs-heading-anchor-permalink" href="#PhasorMeasurementsManual" title="Permalink"></a></h2><p>Let us define the <code>PowerSystem</code> type and perform the AC power flow analysis solely for generating data to artificially create measurement values:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.5)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, reactive = 0.05)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 0.5)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.01)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.04)

@generator(reactive = 0.1)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 2.1)

analysis = newtonRaphson(system)
powerFlow!(system, analysis)</code></pre><hr/><h5 id="Optimal-PMU-Placment"><a class="docs-heading-anchor" href="#Optimal-PMU-Placment">Optimal PMU Placment</a><a id="Optimal-PMU-Placment-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-PMU-Placment" title="Permalink"></a></h5><p>After defining the <code>PowerSystem</code> type, the next step is to define the <code>Measurement</code> type:</p><pre><code class="language-julia hljs">device = measurement()</code></pre><p>JuliaGrid allows users to determine the minimum number of PMUs needed for observability while also generating phasor measurements based on results from AC power flow through the <a href="../../api/stateEstimation/#JuliaGrid.pmuPlacement!"><code>pmuPlacement!</code></a> function:</p><pre><code class="language-julia hljs">using HiGHS

@pmu(label = &quot;PMU ? (!)&quot;)
placement = pmuPlacement!(system, device, analysis, HiGHS.Optimizer)</code></pre><p>Note that users can also generate phasor measurements using results from AC optimal power flow.</p><p>The <code>placement</code> variable contains data regarding the optimal placement of measurements. In this instance, installing a PMU at <code>Bus 2</code> renders the system observable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.bus)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{String, Int64} with 1 entry. Keys:
  &quot;Bus 2&quot;</code></pre><p>This PMU installed at <code>Bus 2</code> will measure the bus voltage phasor at the corresponding bus and all current phasors at the branches incident to <code>Bus 2</code> located at the from-bus or to-bus ends:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.from)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{String, Int64} with 1 entry. Keys:
  &quot;Branch 3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.to)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{String, Int64} with 2 entries. Keys:
  &quot;Branch 1&quot;
  &quot;Branch 2&quot;</code></pre><p>Finally, we can observe the obtained set of measurement values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(device.pmu.label, device.pmu.magnitude.mean, device.pmu.angle.mean)</code><code class="nohighlight hljs ansi" style="display:block;">PMU 1 (Bus 2): 1.0215628522075866, 0.014634612107772262
PMU 2 (From Branch 3): 0.49529892193563957, 0.07710792493557296
PMU 3 (To Branch 1): 0.4744352810029824, -0.545987706954647
PMU 4 (To Branch 2): 1.172275987225155, 0.16223095481110425</code></pre><hr/><h2 id="PMUWLSStateEstimationSolutionManual"><a class="docs-heading-anchor" href="#PMUWLSStateEstimationSolutionManual">Weighted Least-Squares Estimator</a><a id="PMUWLSStateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUWLSStateEstimationSolutionManual" title="Permalink"></a></h2><p>Let us continue with the previous example, where we defined the <code>PowerSystem</code> and <code>Measurement</code> types. To establish the PMU state estimation model, we will use the <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> function:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here, the user triggers LU factorization as the default method for solving the PMU state estimation problem. However, the user also has the option to select alternative factorization methods such as <code>LDLt</code> or <code>QR</code>:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device, QR)</code></pre></div></div><p>To obtain the bus voltage magnitudes and angles, the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function can be invoked as shown:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Upon obtaining the solution, access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.00000000000074, 1.324710038975461e-13
Bus 2: 1.0215628522083289, 0.014634612107890924
Bus 3: 1.012294100414869, -0.005105099385215231</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We recommend that readers refer to the tutorial on <a href="../../tutorials/pmuStateEstimation/#PMUStateEstimationTutorials">PMU State Estimation</a> for insights into the implementation.</p></div></div><hr/><h5 id="Correlated-Measurement-Errors"><a class="docs-heading-anchor" href="#Correlated-Measurement-Errors">Correlated Measurement Errors</a><a id="Correlated-Measurement-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Correlated-Measurement-Errors" title="Permalink"></a></h5><p>In the above approach, we assume that measurement errors from a single PMU are uncorrelated. This assumption leads to the covariance matrix and its inverse matrix (i.e., precision matrix) maintaining a diagonal form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
 9.99991e7   ⋅          ⋅        …   ⋅          ⋅          ⋅
  ⋅         9.58239e7   ⋅            ⋅          ⋅          ⋅
  ⋅          ⋅         1.0045e8      ⋅          ⋅          ⋅
  ⋅          ⋅          ⋅            ⋅          ⋅          ⋅
  ⋅          ⋅          ⋅            ⋅          ⋅          ⋅
  ⋅          ⋅          ⋅        …  2.30398e8   ⋅          ⋅
  ⋅          ⋅          ⋅            ⋅         9.90331e7   ⋅
  ⋅          ⋅          ⋅            ⋅          ⋅         7.32887e7</code></pre><p>While this approach is suitable for many scenarios, linear PMU state estimation relies on transforming from polar to rectangular coordinate systems. Consequently, measurement errors from a single PMU become correlated due to this transformation. This correlation results in the covariance matrix, and hence the precision matrix, no longer maintaining a diagonal form but instead becoming a block diagonal matrix.</p><p>To accommodate this, users have the option to consider correlation when adding each PMU to the <code>Measurement</code> type. For instance, let us add a new PMU while considering correlation:</p><pre><code class="language-julia hljs">addPmu!(system, device; bus = &quot;Bus 3&quot;, magnitude = 1.01, angle = -0.005, correlated = true)</code></pre><p>Following this, we recreate the WLS state estimation model:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device)</code></pre><p>Upon inspection, it becomes evident that the precision matrix no longer maintains a diagonal structure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">10×10 SparseArrays.SparseMatrixCSC{Float64, Int64} with 12 stored entries:
 9.99991e7   ⋅          ⋅        …   ⋅              ⋅          ⋅
  ⋅         9.58239e7   ⋅            ⋅              ⋅          ⋅
  ⋅          ⋅         1.0045e8      ⋅              ⋅          ⋅
  ⋅          ⋅          ⋅            ⋅              ⋅          ⋅
  ⋅          ⋅          ⋅            ⋅              ⋅          ⋅
  ⋅          ⋅          ⋅        …   ⋅              ⋅          ⋅
  ⋅          ⋅          ⋅            ⋅              ⋅          ⋅
  ⋅          ⋅          ⋅           7.32887e7       ⋅          ⋅
  ⋅          ⋅          ⋅            ⋅             1.0e8  -9851.81
  ⋅          ⋅          ⋅            ⋅         -9851.81       9.80297e7</code></pre><p>Subsequently, we can address this new scenario and observe the solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve!(system, analysis)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.9988543535974568, 5.9920242181893276e-5
Bus 2: 1.020417744428146, 0.014710234393803864
Bus 3: 1.011147706933703, -0.0050522361923871885</code></pre><hr/><h5 id="Alternative-Formulation"><a class="docs-heading-anchor" href="#Alternative-Formulation">Alternative Formulation</a><a id="Alternative-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Formulation" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from finding a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal factorization [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 3.2].</p><p>This approach is suitable when measurement errors are uncorrelated, and the precision matrix remains diagonal. Therefore, as a preliminary step, we need to eliminate the correlation, as we did previously:</p><pre><code class="language-julia hljs">updatePmu!(system, device; label = &quot;PMU 5 (Bus 3)&quot;, correlated = false)</code></pre><p>Subsequently, by specifying the <code>Orthogonal</code> argument in the <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> function, JuliaGrid implements a more robust approach to obtain the WLS estimator, which proves particularly beneficial when substantial differences exist among measurement variances:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device, Orthogonal)
solve!(system, analysis)</code></pre><hr/><h5 id="Print-Results-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL">Print Results in the REPL</a><a id="Print-Results-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL" title="Permalink"></a></h5><p>Users have the option to print the results in the REPL using any units that have been configured, such as:</p><pre><code class="language-julia hljs">@voltage(pu, deg)
printBusData(system, analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-----------------------------|
| Bus Data                    |
|-----------------------------|
| Label |       Voltage       |
|       |                     |
|   Bus | Magnitude |   Angle |
|       |      [pu] |   [deg] |
|-------|-----------|---------|
| Bus 1 |    0.9989 |  0.0034 |
| Bus 2 |    1.0204 |  0.8428 |
| Bus 3 |    1.0111 | -0.2895 |
|-----------------------------|</code></pre><p>Next, users can easily customize the print results for specific buses, for example:</p><pre><code class="language-julia hljs">printBusData(system, analysis; label = &quot;Bus 1&quot;, header = true)
printBusData(system, analysis; label = &quot;Bus 2&quot;)
printBusData(system, analysis; label = &quot;Bus 3&quot;, footer = true)</code></pre><hr/><h5 id="Save-Results-to-a-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-File">Save Results to a File</a><a id="Save-Results-to-a-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-File" title="Permalink"></a></h5><p>Users can also redirect print output to a file. For example, data can be saved in a text file as follows:</p><pre><code class="language-julia hljs">open(&quot;bus.txt&quot;, &quot;w&quot;) do file
    printBusData(system, analysis, file)
end</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We also provide functions to print or save state estimation results, such as estimated values and residuals. For more details, users can consult the <a href="#PMUSEPowerCurrentAnalysisManual">Power and Current Analysis</a> section of this manual.</p></div></div><hr/><h2 id="PMULAVtateEstimationSolutionManual"><a class="docs-heading-anchor" href="#PMULAVtateEstimationSolutionManual">Least Absolute Value Estimator</a><a id="PMULAVtateEstimationSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMULAVtateEstimationSolutionManual" title="Permalink"></a></h2><p>The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data analysis procedures [<a href="../../background/bibliography/#aburbook">5</a>, Ch. 6]. However, it is important to note that achieving robustness typically involves increased computational complexity.</p><p>To obtain an LAV estimator, users need to employ one of the <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:</p><pre><code class="language-julia hljs">using Ipopt

analysis = pmuLavStateEstimation(system, device, Ipopt.Optimizer; verbose = 1)</code></pre><hr/><h5 id="Setup-Initial-Primal-Values"><a class="docs-heading-anchor" href="#Setup-Initial-Primal-Values">Setup Initial Primal Values</a><a id="Setup-Initial-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Initial-Primal-Values" title="Permalink"></a></h5><p>In JuliaGrid, the assignment of initial primal values for optimization variables takes place when the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function is executed. Initial primal values are determined based on the <code>voltage</code> fields within the <code>PMUStateEstimation</code> type. By default, these values are initially established using the initial bus voltage magnitudes and angles from <code>PowerSystem</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, 0.0
Bus 2: 1.0, 0.0
Bus 3: 1.0, 0.0</code></pre><p>Users have the flexibility to customize these values according to their requirements, and they will be utilized as the initial primal values when executing the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function. It is important to note that JuliaGrid utilizes the provided data to set initial primal values in the rectangular coordinate system. Additionally, the <a href="../../api/stateEstimation/#JuliaGrid.setInitialPoint!-Tuple{PowerSystem, ACStateEstimation}">setInitialPoint!</a> function allows users to configure the initial point as required.</p><hr/><h5 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h5><p>To solve the formulated LAV state estimation model, simply execute the following function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><p>Upon obtaining the solution, access the bus voltage magnitudes and angles using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 0.9999996764805238, 1.3766060255396282e-7
Bus 2: 1.0215625307060963, 0.014634751648961514
Bus 3: 1.0122937763557676, -0.005104965089210977</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Readers can refer to the <a href="../../tutorials/pmuStateEstimation/#PMUSELAVTutorials">Least Absolute Value Estimation</a> tutorial for implementation insights.</p></div></div><hr/><h2 id="PMUMeasurementsAlterationManual"><a class="docs-heading-anchor" href="#PMUMeasurementsAlterationManual">Measurement Set Update</a><a id="PMUMeasurementsAlterationManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUMeasurementsAlterationManual" title="Permalink"></a></h2><p>After establishing the <code>Measurement</code> type using the <a href="../../api/measurementModel/#JuliaGrid.measurement"><code>measurement</code></a> function, users gain the capability to incorporate new measurement devices or update existing ones.</p><p>Once updates are completed, users can seamlessly progress towards generating the <code>PMUStateEstimation</code> type using the <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> or <a href="../../api/stateEstimation/#JuliaGrid.pmuLavStateEstimation"><code>pmuLavStateEstimation</code></a> function. Ultimately, resolving the PMU state estimation is achieved through the utilization of the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement() # &lt;- Initialize the Measurement instance

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1, reactive = 0.01)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 2.5, reactive = 0.2)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.03)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.3)

@pmu(label = &quot;PMU ?&quot;)
addPmu!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, angle = 0.0)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 0.98, angle = -0.023)
addPmu!(system, device; from = &quot;Branch 2&quot;, magnitude = 0.5, angle = -0.05)

analysis = pmuStateEstimation(system, device) # &lt;- Build PMUStateEstimation for the model
solve!(system, analysis)

addPmu!(system, device; to = &quot;Branch 2&quot;, magnitude = 0.5, angle = 3.1)
updatePmu!(system, device; label = &quot;PMU 1&quot;, varianceMagnitude = 1e-8)
updatePmu!(system, device; label = &quot;PMU 3&quot;, status = 0)

analysis = pmuStateEstimation(system, device) # &lt;- Build PMUStateEstimation for new model
solve!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to restart and recreate the <code>Measurement</code> type from the beginning when implementing changes to the existing measurement set.</p></div></div><hr/><h2 id="PMUStateEstimationUpdateManual"><a class="docs-heading-anchor" href="#PMUStateEstimationUpdateManual">State Estimation Update</a><a id="PMUStateEstimationUpdateManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUStateEstimationUpdateManual" title="Permalink"></a></h2><p>An advanced methodology involves users establishing the <code>PMUStateEstimation</code> type using <a href="../../api/stateEstimation/#JuliaGrid.pmuStateEstimation"><code>pmuStateEstimation</code></a> or <a href="../../api/stateEstimation/#JuliaGrid.pmuLavStateEstimation"><code>pmuLavStateEstimation</code></a> just once. After this initial setup, users can seamlessly modify existing measurement devices without the need to recreate the <code>PMUStateEstimation</code> type.</p><p>This advancement extends beyond the previous scenario where recreating the <code>Measurement</code> type was unnecessary, to now include the scenario where <code>PMUStateEstimation</code> also does not need to be recreated.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The addition of new measurements after the creation of <code>PMUStateEstimation</code> is not practical in terms of reusing the <code>PMUStateEstimation</code> type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.</p></div></div><p>We can modify the prior example to achieve the same model without establishing <code>PMUStateEstimation</code> twice:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement() # &lt;- Initialize the Measurement instance

addBus!(system; label = &quot;Bus 1&quot;, type = 3)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1, reactive = 0.01)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 2.5, reactive = 0.2)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.03)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.3)

@pmu(label = &quot;PMU ?&quot;)
addPmu!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, angle = 0.0)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 0.98, angle = -0.023)
addPmu!(system, device; from = &quot;Branch 2&quot;, magnitude = 0.5, angle = -0.05)
addPmu!(system, device; to = &quot;Branch 2&quot;, magnitude = 0.5, angle = 3.1, status = 0)

analysis = pmuStateEstimation(system, device) # &lt;- Build PMUStateEstimation for the model
solve!(system, analysis)

updatePmu!(system, device, analysis; label = &quot;PMU 1&quot;, varianceMagnitude = 1e-8)
updatePmu!(system, device, analysis; label = &quot;PMU 3&quot;, status = 0)
updatePmu!(system, device, analysis; label = &quot;PMU 4&quot;, status = 1)

# &lt;- No need for re-build; we have already updated the existing PMUStateEstimation instance
solve!(system, analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This concept removes the need to rebuild both the <code>Measurement</code> and the <code>PMUStateEstimation</code> from the beginning when implementing changes to the existing measurement set. In the scenario of employing the WLS model, JuliaGrid can reuse the symbolic factorizations of LU or LDLt, provided that the nonzero pattern of the gain matrix remains unchanged.</p></div></div><hr/><h2 id="PMUSEPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#PMUSEPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="PMUSEPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUSEPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the PMU state estimation, we can calculate various electrical quantities related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions. For instance, let us consider the model for which we obtained the PMU state estimation solution:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = &quot;Bus 1&quot;, type = 3, susceptance = 0.002)
addBus!(system; label = &quot;Bus 2&quot;, type = 1, active = 0.1, reactive = 0.01)
addBus!(system; label = &quot;Bus 3&quot;, type = 1, active = 2.5, reactive = 0.2)

@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, reactance = 0.05)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, reactance = 0.03)

addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.3)

addPmu!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.0, angle = 0.0)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 0.97, angle = -0.051)
addPmu!(system, device; from = &quot;Branch 2&quot;, magnitude = 1.66, angle = -0.15)
addPmu!(system, device; to = &quot;Branch 2&quot;, magnitude = 1.67, angle = 2.96)

analysis = pmuStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>We can now utilize the provided functions to compute powers and currents:</p><pre><code class="language-julia hljs">power!(system, analysis)
current!(system, analysis)</code></pre><p>For instance, if we want to show the active power injections and the from-bus current magnitudes, we can employ the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 2.7128789695735662
Bus 2: -0.2156411013050359
Bus 3: -2.4028824415317627</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.current.from.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: 1.0848042244961928
Branch 2: 1.6624663614086033
Branch 3: 0.8658336251367414</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers and currents associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> functions, we suggest referring to the tutorials on <a href="../../tutorials/pmuStateEstimation/#PMUPowerAnalysisTutorials">PMU State Estimation</a>.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL-2">Print Results in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL-2" title="Permalink"></a></h5><p>Users can utilize any of the print functions outlined in the <a href="../../api/setupPrint/#setupPrintAPI">Print API</a>. For example, to print state estimation data related to PMUs, we can use:</p><pre><code class="language-julia hljs">@voltage(pu, deg)
show = Dict(&quot;Voltage Angle&quot; =&gt; false, &quot;Current Angle&quot; =&gt; false)
printPmuData(system, device, analysis; show)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|---------------------------------------------------------------|
| PMU Data                                                      |
|---------------------------------------------------------------|
| Label |                   Voltage Magnitude                   |
|       |                                                       |
|       | Measurement | Variance | Estimate | Residual | Status |
|       |        [pu] |     [pu] |     [pu] |     [pu] |        |
|-------|-------------|----------|----------|----------|--------|
| 1     |      1.0000 | 1.00e-08 |   1.0001 |  -0.0001 |      1 |
| 2     |      0.9700 | 1.00e-08 |   0.9700 |   0.0000 |      1 |
|---------------------------------------------------------------|
|---------------------------------------------------------------|
| PMU Data                                                      |
|---------------------------------------------------------------|
| Label |                   Current Magnitude                   |
|       |                                                       |
|       | Measurement | Variance | Estimate | Residual | Status |
|       |        [pu] |     [pu] |     [pu] |     [pu] |        |
|-------|-------------|----------|----------|----------|--------|
| 3     |      1.6600 | 1.00e-08 |   1.6625 |  -0.0025 |      1 |
| 4     |      1.6700 | 1.00e-08 |   1.6673 |   0.0027 |      1 |
|---------------------------------------------------------------|</code></pre><hr/><h5 id="Save-Results-to-a-CSV-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-CSV-File">Save Results to a CSV File</a><a id="Save-Results-to-a-CSV-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-CSV-File" title="Permalink"></a></h5><p>For CSV output, users should first generate a simple table with <code>style = false</code>, and then save it to a CSV file:</p><pre><code class="language-julia hljs">using CSV

io = IOBuffer()
printPmuData(system, device, analysis, io; style = false)
CSV.write(&quot;bus.csv&quot;, CSV.File(take!(io); delim = &quot;|&quot;))</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection">Active and Reactive Power Injection</a><a id="Active-and-Reactive-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection" title="Permalink"></a></h5><p>To calculate the active and reactive power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = injectionPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(2.7128789695735662, 0.4328846046307191)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection-from-Generators">Active and Reactive Power Injection from Generators</a><a id="Active-and-Reactive-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = supplyPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(2.7128789695735662, 0.4328846046307191)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Shunt-Element"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Shunt-Element">Active and Reactive Power at Shunt Element</a><a id="Active-and-Reactive-Power-at-Shunt-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Shunt-Element" title="Permalink"></a></h5><p>To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = shuntPower(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0, -0.002000424255766844)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Flow"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Flow">Active and Reactive Power Flow</a><a id="Active-and-Reactive-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = fromPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6429108157160377, 0.25539133163697453)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = toPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-1.5873301378900675, -0.1549833506017298)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Charging-Admittances"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Charging-Admittances">Active and Reactive Power at Charging Admittances</a><a id="Active-and-Reactive-Power-at-Charging-Admittances-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Charging-Admittances" title="Permalink"></a></h5><p>To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = chargingPower(system, analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(9.705560639417111e-5, -0.03882224255766844)</code></pre><p>Active powers indicate active losses within the branch&#39;s charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.</p><hr/><h5 id="Active-and-Reactive-Power-at-Series-Impedance"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Series-Impedance">Active and Reactive Power at Series Impedance</a><a id="Active-and-Reactive-Power-at-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Series-Impedance" title="Permalink"></a></h5><p>To calculate the active and reactive power across the series impedance of the branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = seriesPower(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.05548491704701507, 0.13871229261753767)</code></pre><p>The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance&#39;s inductive characteristics.</p><hr/><h5 id="Current-Injection"><a class="docs-heading-anchor" href="#Current-Injection">Current Injection</a><a id="Current-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injection" title="Permalink"></a></h5><p>To calculate the current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = injectionCurrent(system, analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(2.7469074926856223, -0.15817873160544943)</code></pre><hr/><h5 id="Current-Flow"><a class="docs-heading-anchor" href="#Current-Flow">Current Flow</a><a id="Current-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow" title="Permalink"></a></h5><p>We can compute the current flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = fromCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6624663614086033, -0.15416239142972446)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = toCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6673093443308689, 2.964124299788867)</code></pre><hr/><h5 id="Current-Through-Series-Impedance"><a class="docs-heading-anchor" href="#Current-Through-Series-Impedance">Current Through Series Impedance</a><a id="Current-Through-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Through-Series-Impedance" title="Permalink"></a></h5><p>To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = seriesCurrent(system, analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(1.6656067520128373, -0.16603367260017346)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acStateEstimation/">« AC State Estimation</a><a class="docs-footer-nextpage" href="../dcStateEstimation/">DC State Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Sunday 23 March 2025 19:13">Sunday 23 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
