<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC Optimal Power Flow · JuliaGrid</title><meta name="title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="og:title" content="DC Optimal Power Flow · JuliaGrid"/><meta property="twitter:title" content="DC Optimal Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../manual/badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>DC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#DCOptimalPowerFlowModelTutorials"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#Objective-Function"><span>Objective Function</span></a></li><li><a class="tocitem" href="#Constraint-Functions"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#DCOptimalPowerFlowSolutionTutorials"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#DCOptimalPowerAnalysisTutorials"><span>Power Analysis</span></a></li></ul></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/dcOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCOptimalPowerFlowTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowTutorials">DC Optimal Power Flow</a><a id="DCOptimalPowerFlowTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowTutorials" title="Permalink"></a></h1><p>To begin, let us generate the <code>PowerSystem</code>  type, as illustrated by the following example:</p><pre><code class="language-julia hljs">using JuMP, HiGHS

@config(label = Integer)

system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.17)
addBus!(system; label = 2, type = 2, active = 0.1, conductance = 0.04)
addBus!(system; label = 3, type = 1, active = 0.05)

@branch(minDiffAngle = -pi, maxDiffAngle = pi)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, maxFromBus = 0.15)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, maxFromBus = 0.10)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, maxFromBus = 0.25)

@generator(minActive = 0.0)
addGenerator!(system; label = 1, bus = 1, active = 3.2, maxActive = 0.5)
addGenerator!(system; label = 2, bus = 2, active = 0.2, maxActive = 0.3)

cost!(system; generator = 1, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; generator = 2, active = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒩 = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Int64}:
 1  2
 1  3
 2  3</code></pre><p>Moreover, we identify the set of generators as <span>$\mathcal{S} = \{1, \dots, n_\text{g}\}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒮 = collect(keys(system.generator.label))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Here, when referring to a vector <span>$\mathbf a$</span>, we use the notation <span>$\mathbf a = [a_i]$</span> or <span>$\mathbf a = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element related with bus <span>$i \in \mathcal N$</span> or generator <span>$i \in \mathcal S$</span>, while <span>$a_{ij}$</span> denotes the element related with branch <span>$(i,j) \in \mathcal E$</span>.</p></div></div><hr/><h2 id="DCOptimalPowerFlowModelTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowModelTutorials">Optimal Power Flow Model</a><a id="DCOptimalPowerFlowModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowModelTutorials" title="Permalink"></a></h2><p>In the DC optimal power flow, the active power outputs of the generators <span>$\mathbf P_\mathrm{g} = [P_{\mathrm{g}i}]$</span>, <span>$i \in \mathcal S$</span>, are represented as linear functions of the bus voltage angles <span>$\bm \Theta = [\theta_i]$</span>, <span>$i \in \mathcal N$</span>. Thus, the optimization variables in this model are the active power outputs of the generators and the bus voltage angles.</p><p>The DC optimal power flow model has the form:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{minimize} &amp; &amp;  \sum_{i \in \mathcal S} f_i(P_{\mathrm{g}i})  \\[10pt]
    &amp; \text{subject to} &amp; &amp; \\[-4pt]
    &amp; &amp; &amp;  \left.
    \begin{aligned}
        &amp; \theta_i - \theta_\mathrm{s} = 0
    \end{aligned}
    \phantom{\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\,}
    \right\} i \in \mathcal{N_\mathrm{sb}} \\[-1pt]
    &amp; &amp; &amp; \left.
    \begin{aligned}
        &amp; h_{P_i}(\mathbf P_\mathrm{g}, \bm \Theta) = 0
    \end{aligned}
    \phantom{\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;}
    \right\} i \in \mathcal N \\[-1pt]
    &amp; &amp; &amp;  \left.
    \begin{aligned}
        &amp; \theta_{ij}^\mathrm{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\mathrm{max}  \\
        &amp; P_{ij}^{\mathrm{min}} \leq h_{P_{ij}}(\theta_i, \theta_j) \leq P_{ij}^{\mathrm{max}}
    \end{aligned}
    \phantom{\;\;}
    \right\} (i,j) \in \mathcal E \\[8pt]
    &amp; &amp; &amp;  \left.
    \begin{aligned}
        &amp; P_{\mathrm{g}i}^\mathrm{min} \leq P_{\mathrm{g}i} \leq P_{\mathrm{g}i}^\mathrm{max}
    \end{aligned}
    \phantom{\;\;\;\;\;\;\;\;\;\;\;\;\;}
    \right\} i \in \mathcal S
\end{aligned}\]</p><p>Essentially, the DC optimal power flow is focused on the minimization of the objective function related to the costs associated with the active power output of generators, all while ensuring the satisfaction of various constraints. This optimization task holds a crucial role in the efficient and timely management of electrical power systems. However, it is important to note that the solutions provided by the DC optimal power flow are approximate in nature.</p><hr/><h5 id="Build-Optimal-Power-Flow-Model"><a class="docs-heading-anchor" href="#Build-Optimal-Power-Flow-Model">Build Optimal Power Flow Model</a><a id="Build-Optimal-Power-Flow-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Optimal-Power-Flow-Model" title="Permalink"></a></h5><p>To build the DC optimal power flow model, we must first load the power system and establish the DC model using:</p><pre><code class="language-julia hljs">dcModel!(system)</code></pre><p>Afterward, the DC optimal power flow model is created using the <a href="../../api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow"><code>dcOptimalPowerFlow</code></a> function:</p><pre><code class="language-julia hljs">analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer; active = &quot;Pg&quot;, angle = &quot;θ&quot;)</code></pre><hr/><h5 id="Optimization-Variables"><a class="docs-heading-anchor" href="#Optimization-Variables">Optimization Variables</a><a id="Optimization-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Variables" title="Permalink"></a></h5><p>Hence, the variables in this model encompass the active power outputs of the generators denoted as <span>$\mathbf P_\mathrm{g} = [P_{\mathrm{g}i}]$</span>, where <span>$i \in \mathcal S$</span>, and the bus voltage angles represented by <span>$\bm \Theta = [\theta_i]$</span>, where <span>$i \in \mathcal N$</span>. Users can access these variables using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = analysis.method.variable.power.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{VariableRef}:
 Pg[1]
 Pg[2]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.method.variable.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{VariableRef}:
 θ[1]
 θ[2]
 θ[3]</code></pre><hr/><h2 id="Objective-Function"><a class="docs-heading-anchor" href="#Objective-Function">Objective Function</a><a id="Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function" title="Permalink"></a></h2><p>The objective function represents the sum of the active power cost functions <span>$f_i(P_{\mathrm{g}i})$</span>, <span>$i \in \mathcal S$</span>, for each generator, where these cost functions can be polynomial or piecewise linear functions. Only polynomial cost functions of up to the second degree are included in the objective. Specifically, if a higher-degree polynomial is provided, JuliaGrid will discard all terms beyond the second degree and still include the resulting truncated polynomial in the objective function.</p><hr/><h5 id="Polynomial-Active-Power-Cost-Function"><a class="docs-heading-anchor" href="#Polynomial-Active-Power-Cost-Function">Polynomial Active Power Cost Function</a><a id="Polynomial-Active-Power-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Active-Power-Cost-Function" title="Permalink"></a></h5><p>The DC optimal power flow in JuliaGrid allows the cost function <span>$f_i(P_{\mathrm{g}i})$</span> to be represented as a polynomial of up to the second degree, making it possible to express the cost function as linear or quadratic. The possible representations are as follows:</p><p class="math-container">\[\begin{aligned}
    f_i(P_{\mathrm{g}i}) &amp;= a_1 P_{\mathrm{g}i} + a_0 \\
    f_i(P_{\mathrm{g}i}) &amp;= a_2 P_{\mathrm{g}i}^2 + a_1 P_{\mathrm{g}i} + a_0.
\end{aligned}\]</p><p>Furthermore, it is worth noting that the function can be given simply as a constant with only the coefficient <span>$a_0$</span>, which implies that the cost of the generator remains constant regardless of the active power outputs. In conclusion, as illustrated in Figure 1, typical scenarios involve linear or quadratic cost functions, resulting in a best-case scenario for a linear optimization problem and a worst-case scenario for a quadratic optimization problem.</p><div class="image-container">
    <div class="image-item">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_linear.svg" width="65%" class="my-svg"/>
        <p>(a) The linear function.</p>
    </div>
    <div class="image-item">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_quadratic.svg" width="65%" class="my-svg"/>
        <p>(b) The quadratic function.</p>
    </div>
    <p style="text-align: center; margin-top: -5px;">
    Figure 1: Different types of polynomial cost functions that are typically used.
    </p>
</div>
&nbsp;<p>When utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function within JuliaGrid, employing the <code>polynomial</code> keyword results in the polynomial being constructed with coefficients ordered from the highest degree to the lowest. For instance, in the provided case study, we created a quadratic polynomial represented as:</p><p class="math-container">\[\begin{aligned}
    f_1(P_{\mathrm{g}1}) &amp;= 1100.2 P_{\mathrm{g}1}^2 + 500 P_{\mathrm{g}1} + 80.
\end{aligned}\]</p><p>To access these coefficients, users can utilize the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f₁ = system.generator.cost.active.polynomial[1]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1100.2
  500.0
   80.0</code></pre><hr/><h5 id="Piecewise-Linear-Active-Power-Cost-Function"><a class="docs-heading-anchor" href="#Piecewise-Linear-Active-Power-Cost-Function">Piecewise Linear Active Power Cost Function</a><a id="Piecewise-Linear-Active-Power-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-Linear-Active-Power-Cost-Function" title="Permalink"></a></h5><p>The DC optimal power flow in JuliaGrid offers another option for defining cost functions by using piecewise linear functions as approximations of the polynomial functions, as depicted in Figure 2.</p><div class="image-container">
    <div class="image-item">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_one.svg" width="65%" class="my-svg"/>
        <p>(a) One-segment function.</p>
    </div>
    <div class="image-item">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_two.svg" width="65%" class="my-svg"/>
        <p>(b) Two-segment function.</p>
    </div>
    <p style="text-align: center; margin-top: -5px;">
    Figure 2: Different types of piecewise linear cost functions that are typically used.
    </p>
</div>
&nbsp;<p>To define piecewise linear functions in JuliaGrid, users can utilize the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function with the <code>piecewise</code> keyword. The piecewise linear function is constructed using a matrix where each row defines a single point. The first column holds the generator&#39;s active power output, while the second column corresponds to the associated cost value. For example, in the provided case study, a piecewise linear function is created and can be accessed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f₂ = system.generator.cost.active.piecewise[2]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 10.85  12.3
 14.77  16.8
 18.0   18.1</code></pre><p>Similar to how convex piecewise linear functions are treated in the <a href="../acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a>, JuliaGrid adopts a constrained cost variable method for the piecewise linear functions. In this method, the piecewise linear cost function is converted into a series of linear inequality constraints for each segment, which are defined by two adjacent points along the line, along with a helper variable specific to the piecewise function. However, for piecewise linear functions that have only one segment defined by two points, JuliaGrid simplifies it into a standard linear function without requiring a helper variable.</p><p>Consequently, for a piecewise cost function denoted as <span>$f_i(P_{\mathrm{g}i})$</span> with <span>$k$</span> segments (where <span>$k &gt; 1$</span>), the <span>$j$</span>-th segment, defined by the points <span>$[P_{\mathrm{g}i,j}, f_i(P_{\mathrm{g}i,j})]$</span> and <span>$[P_{\mathrm{g}i,j+1}, f_i(P_{\mathrm{g}i,j+1})]$</span>, is characterized by the following inequality constraints:</p><p class="math-container">\[\cfrac{f_i(P_{\mathrm{g}i,j+1}) - f_i(P_{\mathrm{g}i,j})}{P_{\mathrm{g}i,j+1} - P_{\mathrm{g}i,j}}
(P_{\mathrm{g}i} - P_{\mathrm{g}i,j}) + f_i(P_{\mathrm{g}i,j}) \leq H_i, \;\;\; i \in \mathcal S, \;\;\; j = 1, \dots, k,\]</p><p>where <span>$H_i$</span> represents the helper variable. To finalize this method, we simply need to include the helper variable <span>$H_i$</span> in the objective function. This approach efficiently handles piecewise linear cost functions, providing the flexibility to capture nonlinear characteristics while still benefiting from the advantages of linear optimization techniques.</p><p>As an example, in the provided case study, the helper variable is defined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; H₂ = analysis.method.variable.power.actwise[2]</code><code class="nohighlight hljs ansi" style="display:block;">actwise[2]</code></pre><p>Lastly, the set of constraints introduced by the piecewise linear cost function is displayed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">1.1479591836734695 Pg[2] - actwise[2] ≤ 0.15535714285714342
0.40247678018575866 Pg[2] - actwise[2] ≤ -10.855417956656346</code></pre><hr/><h5 id="Objective-Function-2"><a class="docs-heading-anchor" href="#Objective-Function-2">Objective Function</a><a class="docs-heading-anchor-permalink" href="#Objective-Function-2" title="Permalink"></a></h5><p>As previously explained, the objective function relies on the defined polynomial or piecewise linear cost functions and represents the sum of these costs. In the provided example, the objective function that must be minimized to obtain the optimal values for the active power output of the generators and the bus voltage angles can be accessed using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">1100.2 Pg[1]² + 500 Pg[1] + actwise[2] + 80</code></pre><hr/><h2 id="Constraint-Functions"><a class="docs-heading-anchor" href="#Constraint-Functions">Constraint Functions</a><a id="Constraint-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Functions" title="Permalink"></a></h2><p>In the following section, we will examine the various constraints defined within the DC optimal power flow model.</p><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as <span>$\theta_i$</span> is fixed to a constant value <span>$\theta_\mathrm{s}$</span>. It can be expressed as follows:</p><p class="math-container">\[\theta_i - \theta_{\mathrm{s}} = 0,\;\;\; i \in \mathcal N_\mathrm{sb},\]</p><p>where the set <span>$\mathcal N_\mathrm{sb}$</span> contains the index of the slack bus. To access the equality constraint from the model, we can utilize the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">θ[1] = 0.17</code></pre><hr/><h5 id="Bus-Active-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Bus-Active-Power-Balance-Constraints">Bus Active Power Balance Constraints</a><a id="Bus-Active-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Active-Power-Balance-Constraints" title="Permalink"></a></h5><p>The second equality constraint in the optimization problem is associated with the active power balance equation:</p><p class="math-container">\[h_{P_i}(\mathbf P_\mathrm{g}, \bm \Theta) = 0,\;\;\; i \in \mathcal N.\]</p><p>As elaborated in the <a href="../powerSystemModel/#DCNodalNetworkEquationsTutorials">Nodal Network Equations</a> section, we can express the equation as follows:</p><p class="math-container">\[h_{P_i}(\mathbf P_\mathrm{g}, \bm \Theta) = \sum_{k \in \mathcal S_i} P_{\mathrm{g}k} - \sum_{k = 1}^n B_{ik} \theta_k - P_{\mathrm{d}i} - P_{\mathrm{sh}i} - P_{\mathrm{tr}i}.\]</p><p>In this equation, the set <span>$\mathcal{S}_i \subseteq \mathcal S$</span> encompasses all generators connected to bus <span>$i \in \mathcal N$</span>, and <span>$P_{\mathrm{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator within the set <span>$\mathcal{S}_i$</span>. More precisely, the variable <span>$P_{\mathrm{g}k}$</span> represents the optimization variable, as well as the bus voltage angle <span>$\theta_k$</span>.</p><p>The constant terms in these equations are determined by the active power demand at bus <span>$P_{\mathrm{d}i}$</span>, the active power demanded by the shunt element <span>$P_{\mathrm{sh}i}$</span>, and power related to the shift angle of the phase transformers <span>$P_{\mathrm{tr}i}$</span>. The values representing these constant terms <span>$\mathbf P_\mathrm{d} = [P_{\mathrm{d}i}]$</span>, <span>$\mathbf P_\mathrm{sh} = [P_{\mathrm{sh}i}]$</span>, and <span>$\mathbf P_\mathrm{tr} = [P_{\mathrm{tr}i}]$</span>, <span>$i, \in \mathcal N$</span>, can be accessed:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.1
 0.05</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛₕ = system.bus.shunt.conductance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.04
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₜᵣ = system.model.dc.shiftPower</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">-120 θ[1] + 20 θ[2] + 100 θ[3] + Pg[1] = 0
20 θ[1] - 120 θ[2] + 100 θ[3] + Pg[2] = 0.14
100 θ[1] + 100 θ[2] - 200 θ[3] = 0.05</code></pre><hr/><h5 id="Bus-Voltage-Angle-Difference-Constraints"><a class="docs-heading-anchor" href="#Bus-Voltage-Angle-Difference-Constraints">Bus Voltage Angle Difference Constraints</a><a id="Bus-Voltage-Angle-Difference-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Angle-Difference-Constraints" title="Permalink"></a></h5><p>The inequality constraint related to the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch is defined as follows:</p><p class="math-container">\[\theta_{ij}^\mathrm{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\mathrm{max},\;\;\; (i,j) \in \mathcal E,\]</p><p>where <span>$\theta_{ij}^\mathrm{min}$</span> represents the minimum, while <span>$\theta_{ij}^\mathrm{max}$</span> represents the maximum of the angle difference between adjacent buses. The values representing the voltage angle difference, denoted as <span>$\bm{\Theta}_{\mathrm{lm}} = [\theta_{ij}^\mathrm{min}, \theta_{ij}^\mathrm{max}]$</span>, <span>$(i,j) \in \mathcal E$</span>, are provided as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯ₗₘ = [system.branch.voltage.minDiffAngle system.branch.voltage.maxDiffAngle]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 -3.14159  3.14159
 -3.14159  3.14159
 -3.14159  3.14159</code></pre><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">θ[1] - θ[2] ∈ [-3.141592653589793, 3.141592653589793]
θ[1] - θ[3] ∈ [-3.141592653589793, 3.141592653589793]
θ[2] - θ[3] ∈ [-3.141592653589793, 3.141592653589793]</code></pre><hr/><h5 id="Branch-Active-Power-Flow-Constraints"><a class="docs-heading-anchor" href="#Branch-Active-Power-Flow-Constraints">Branch Active Power Flow Constraints</a><a id="Branch-Active-Power-Flow-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Active-Power-Flow-Constraints" title="Permalink"></a></h5><p>The inequality constraint related to active power flow is used to represent thermal limits on power transmission. This constraint is defined as follows:</p><p class="math-container">\[P_{ij}^{\mathrm{min}} \leq h_{P_{ij}}(\theta_i, \theta_j) \leq P_{ij}^{\mathrm{max}}, \;\;\; (i,j) \in \mathcal E.\]</p><p>The branch flow limits at the from-bus, denoted as <span>$\mathbf P_\mathrm{f} = [P_{ij}^\mathrm{min}, P_{ij}^\mathrm{max}]$</span> , can be retrieved as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = [system.branch.flow.minFromBus system.branch.flow.maxFromBus]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 0.0  0.15
 0.0  0.1
 0.0  0.25</code></pre><p>The active power flow at branch <span>$(i,j) \in \mathcal E$</span> can be derived using the <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">Branch Network Equations</a> and is given by:</p><p class="math-container">\[h_{P_{ij}}(\theta_i, \theta_j) = \frac{1}{\tau_{ij} x_{ij} }(\theta_i - \theta_j - \phi_{ij}).\]</p><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.flow.active)</code><code class="nohighlight hljs ansi" style="display:block;">20 θ[1] - 20 θ[2] ∈ [0, 0.15]
100 θ[1] - 100 θ[3] ∈ [0, 0.1]
100 θ[2] - 100 θ[3] ∈ [0, 0.25]</code></pre><hr/><h5 id="Generator-Active-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Generator-Active-Power-Capability-Constraints">Generator Active Power Capability Constraints</a><a id="Generator-Active-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Active-Power-Capability-Constraints" title="Permalink"></a></h5><p>The inequality constraints associated with the minimum and maximum active power outputs of the generators are defined as follows:</p><p class="math-container">\[P_{\mathrm{g}i}^\mathrm{min} \leq P_{\mathrm{g}i} \leq P_{\mathrm{g}i}^\mathrm{max}, \;\;\;  i \in \mathcal{S}.\]</p><p>In this representation, the lower and upper bounds are determined by the vector <span>$\mathbf P_\mathrm{m} = [P_{\mathrm{g}i}^\mathrm{min}, P_{\mathrm{g}i}^\mathrm{max}]$</span>, <span>$i \in \mathcal{S}$</span>. We can access these bounds using the following variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₘ = [system.generator.capability.minActive system.generator.capability.maxActive]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.0  0.5
 0.0  0.3</code></pre><p>To retrieve constraints from the model, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Pg[1] ∈ [0, 0.5]
Pg[2] ∈ [0, 0.3]</code></pre><hr/><h2 id="DCOptimalPowerFlowSolutionTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerFlowSolutionTutorials">Optimal Power Flow Solution</a><a id="DCOptimalPowerFlowSolutionTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerFlowSolutionTutorials" title="Permalink"></a></h2><p>To acquire the output active power of generators and the bus voltage angles, the user must invoke the function:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>Therefore, to get the vector of output active power of generators <span>$\mathbf P_\mathrm{g} = [P_{\mathrm{g}i}]$</span>, <span>$i \in \mathcal S$</span>, we can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = analysis.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.02499999999999991
 0.1650000000000027</code></pre><p>Further, the resulting bus voltage angles <span>$\bm \Theta = [\theta_i]$</span>, <span>$i \in \mathcal N$</span>, are saved in the vector as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.17
 0.17000000000000004
 0.16975</code></pre><hr/><h2 id="DCOptimalPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#DCOptimalPowerAnalysisTutorials">Power Analysis</a><a id="DCOptimalPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCOptimalPowerAnalysisTutorials" title="Permalink"></a></h2><p>After obtaining the solution from the DC optimal power flow, we can calculate the powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../powerSystemModel/#DCBusInjectionTutorials">Active power injections</a> are stored as the vector <span>$\mathbf P = [P_i]$</span>, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏 = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.02499999999999991
  0.0650000000000027
 -0.05</code></pre><hr/><h5 id="Generator-Power-Injections"><a class="docs-heading-anchor" href="#Generator-Power-Injections">Generator Power Injections</a><a id="Generator-Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Power-Injections" title="Permalink"></a></h5><p>The active power supplied by generators to the buses can be calculated by summing the active power outputs of the generators obtained from the optimal DC power flow. This can be expressed as:</p><p class="math-container">\[    P_{\mathrm{p}i} = \sum_{k=1}^{n_{\mathrm{g}i}} P_{\mathrm{g}k},\;\;\; i \in \mathcal N.\]</p><p>Here, <span>$P_{\mathrm{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator connected to bus <span>$i \in \mathcal{N}$</span>, and <span>$n_{\mathrm{g}i}$</span> denotes the total number of generators connected to the same bus. We can obtain the vector of active powers injected by generators into the buses, denoted as <span>$\mathbf P_\mathrm{p} = [P_{\mathrm{p}i}]$</span>, using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₚ = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.02499999999999991
 0.1650000000000027
 0.0</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">from-bus active power flows</a> are stored as the vector <span>$\mathbf P_\mathrm{i} = [P_{ij}]$</span>, which can be retrieved using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ᵢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -5.551115123125783e-16
  0.025000000000000022
  0.025000000000002798</code></pre><p>Similarly, the resulting <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">to-bus active power flows</a> are stored as the vector <span>$\mathbf P_\mathrm{j} = [P_{ji}]$</span>, which can be retrieved using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ⱼ = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  5.551115123125783e-16
 -0.025000000000000022
 -0.025000000000002798</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acOptimalPowerFlow/">« AC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../measurementModel/">Measurement Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 16 April 2025 12:40">Wednesday 16 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
