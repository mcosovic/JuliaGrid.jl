<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measurement Model ¬∑ JuliaGrid</title><meta name="title" content="Measurement Model ¬∑ JuliaGrid"/><meta property="og:title" content="Measurement Model ¬∑ JuliaGrid"/><meta property="twitter:title" content="Measurement Model ¬∑ JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>Measurement Model</a><ul class="internal"><li><a class="tocitem" href="#Power-System-Monitoring"><span>Power System Monitoring</span></a></li><li><a class="tocitem" href="#State-Estimation"><span>State Estimation</span></a></li><li><a class="tocitem" href="#MeasurementModelReferenceTutorials"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/configuration/">Configuration Setup</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Measurement Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measurement Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/measurementModel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MeasurementModelTutorials"><a class="docs-heading-anchor" href="#MeasurementModelTutorials">Measurement Model</a><a id="MeasurementModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#MeasurementModelTutorials" title="Permalink"></a></h1><p>Let us begin by examining a power system. To do that, we will construct one as shown below:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = &quot;Bus 1&quot;)
addBus!(system; label = &quot;Bus 2&quot;)
addBus!(system; label = &quot;Bus 3&quot;)

@branch(reactance = 0.03)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;)</code></pre><p>Our goal is to monitor the power system, and this process involves collecting measurement data for various electrical quantities distributed throughout the power system.</p><hr/><h2 id="Power-System-Monitoring"><a class="docs-heading-anchor" href="#Power-System-Monitoring">Power System Monitoring</a><a id="Power-System-Monitoring-1"></a><a class="docs-heading-anchor-permalink" href="#Power-System-Monitoring" title="Permalink"></a></h2><p>Measurement data is obtained through two main technologies: SCADA (Supervisory Control and Data Acquisition) and WAMS (Wide Area Measurement System). These technologies enable the collection of a wide range of measurements distributed throughout the power system. This extensive dataset allows us to employ state estimation algorithms to obtain the present state of the power system, in contrast to power flow algorithms, which are typically used for offline analyses. To commence, we will represent the entire set of measurements as <span>$\mathcal{M}$</span>.</p><hr/><h5 id="SCADA-Measurements"><a class="docs-heading-anchor" href="#SCADA-Measurements">SCADA Measurements</a><a id="SCADA-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#SCADA-Measurements" title="Permalink"></a></h5><p>SCADA provides legacy measurements with low sampling rates, making them unsuitable for capturing real-time system dynamics. It provides a snapshot of the power system&#39;s state, with delays measured in seconds and minutes. These legacy measurements, which are subsets of the measurement set <span>$\mathcal{M}$</span>, encompass:</p><ul><li>set of bus voltage magnitude measurements <span>$\mathcal{V}$</span> provided by voltmeters,</li><li>set of branch current magnitude measurements <span>$\mathcal{I}$</span> provided by ammeters,</li><li>set of active power injection and branch flow measurements <span>$\mathcal{P}$</span> provided by wattmeters,</li><li>set of reactive power injection and branch flow measurements <span>$\mathcal{Q}$</span> provided by varmeters.</li></ul><hr/><h5 id="WAMS-Measurements"><a class="docs-heading-anchor" href="#WAMS-Measurements">WAMS Measurements</a><a id="WAMS-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#WAMS-Measurements" title="Permalink"></a></h5><p>In contrast, WAMS technology utilizes PMUs (Phasor Measurement Units) to provide data with high sampling rates, typically ranging between 10 ms and 20 ms. This capability facilitates real-time monitoring of the system, as PMUs measure both bus voltage and branch current phasors.</p><p>Each phasor measurement is represented by a pair of measurements within the polar coordinate system. To be specific, a PMU&#39;s phasor measurement comprises a magnitude, equal to the effective or root mean square value of the signal, and a phase angle <a href="#MeasurementModelReferenceTutorials">[1, Sec. 5.6]</a>. Measurement errors are associated with both the magnitude and angle of the phasor.  Consequently, PMUs deliver phasor measurements in polar coordinates. In this context, phasor measurement extends the measurement set <span>$\mathcal{M}$</span> in the following manner:</p><ul><li>set of bus voltage and branch current magnitude measurements <span>$\bar{\mathcal{P}}_M$</span>,</li><li>set of bus voltage and branch current angle measurements <span>$\bar{\mathcal{P}}_A$</span>.</li></ul><p>Additionally, PMU outputs can be observed in rectangular coordinates, encompassing the real and imaginary components of the bus voltage and branch current phasors. However, in this scenario, both measurements may be influenced by correlated measurement errors <a href="#MeasurementModelReferenceTutorials">[1, Sec. 7.3]</a>. Nevertheless, in most cases, these measurements are also viewed as uncorrelated. In this case, phasor measurement extends the measurement set <span>$\mathcal{M}$</span> as follows:</p><ul><li>set of real components of bus voltage and branch current phasor measurements <span>$\bar{\mathcal{P}}_R$</span>,</li><li>set of imaginary components of bus voltage and branch current phasor measurements <span>$\bar{\mathcal{P}}_I$</span>.</li></ul><hr/><h5 id="Measurement-Model"><a class="docs-heading-anchor" href="#Measurement-Model">Measurement Model</a><a id="Measurement-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Model" title="Permalink"></a></h5><p>The measurement model, as defined by the measurement set <span>$\mathcal{M}$</span>, can be expressed as a system of equations <a href="#MeasurementModelReferenceTutorials">[2]</a>: </p><p class="math-container">\[  \mathbf{z}=\mathbf{h}(\mathbf{x})+\mathbf{u},\]</p><p>where <span>$\mathbf {x}=[x_1,\dots,x_{n}]^{T}$</span> is the vector of the state variables, <span>$\mathbf{h}(\mathbf{x})=$</span> <span>$[h_1(\mathbf{x})$</span>, <span>$\dots$</span>, <span>$h_k(\mathbf{x})]^{{T}}$</span> is the vector of measurement functions, <span>$\mathbf{z} = [z_1,\dots,z_k]^{\mathrm{T}}$</span> is the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{\mathrm{T}}$</span> is the vector of uncorrelated measurement errors. In the context of transmission grids, this model is often an overdetermined system of equations <span>$(k&gt;s)$</span> <a href="#MeasurementModelReferenceTutorials">[3, Sec. 2.1]</a>. </p><p>Each legacy measurement and each magnitude or angle measurement from PMUs is associated with a measured value <span>$z_i$</span>, a measurement error <span>$u_i$</span>, and a measurement function <span>$h_i(\mathbf{x})$</span>. Assuming that measurement errors <span>$u_i$</span> follow a zero-mean Gaussian distribution, the probability density function associated with the <span>$i$</span>-th measurement is proportional to:</p><p class="math-container">\[  \mathcal{N}(z_i|\mathbf{x},v_i) \propto \exp\Bigg\{\cfrac{[z_i-h_i(\mathbf{x})]^2}{2v_i}\Bigg\},\]</p><p>where <span>$v_i$</span> is the measurement variance defined by the measurement error <span>$u_i$</span>, and the measurement function <span>$h_i(\mathbf{x})$</span> connects the vector of state variables <span>$\mathbf{x}$</span> to the value of the <span>$i$</span>-th measurement. </p><p>When defining the system of equations, it is essential to have measurement values represented by <span>$\mathbf{z}$</span>. In JuliaGrid, users have the option to either directly specify measurement values or artificially generate the vector <span>$[z_1,\dots,z_k]$</span>. This generation process involves introducing white Gaussian noise with variances <span>$[v_1, \dots, v_k]$</span> and adding it to the provided values <span>$[e_1, \dots, e_k]$</span>, typically representing the exact values of the respective electrical quantities:</p><p class="math-container">\[  \epsilon_i \sim \mathcal{N}(0,\,v_i) \\[5pt]
  z_i = e_i + \epsilon_i.\]</p><hr/><h5 id="Voltmeters"><a class="docs-heading-anchor" href="#Voltmeters">Voltmeters</a><a id="Voltmeters-1"></a><a class="docs-heading-anchor-permalink" href="#Voltmeters" title="Permalink"></a></h5><p>To begin, we introduce the set of bus voltage magnitude measurements <span>$\mathcal{V} \subset \mathcal{M}$</span> provided by voltmeters:</p><pre><code class="language-julia hljs">addVoltmeter!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.1)
addVoltmeter!(system, device; bus = &quot;Bus 3&quot;, magnitude = 1.0)</code></pre><p>The vectors of measurement values <span>$\mathbf{z}_\mathcal{V}$</span> and variances <span>$\mathbf{v}_\mathcal{V}$</span> are stored in the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥·µ• = device.voltmeter.magnitude.mean</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.1292558724179482
 1.1576727408034948</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ·µ• = device.voltmeter.magnitude.variance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.01
 0.01</code></pre><hr/><h5 id="Ammeters"><a class="docs-heading-anchor" href="#Ammeters">Ammeters</a><a id="Ammeters-1"></a><a class="docs-heading-anchor-permalink" href="#Ammeters" title="Permalink"></a></h5><p>Subsequently, we incorporate the set of branch current magnitude measurements <span>$\mathcal{I} \subset \mathcal{M}$</span> provided by ammeters:</p><pre><code class="language-julia hljs">addAmmeter!(system, device; from = &quot;Branch 1&quot;, magnitude = 0.3, noise = false)
addAmmeter!(system, device; to = &quot;Branch 2&quot;, magnitude = 0.2, variance = 1e-3)</code></pre><p>The vectors of measurement values <span>$\mathbf{z}_\mathcal{I}$</span> and variances <span>$\mathbf{v}_\mathcal{I}$</span> are stored in the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥·µ¢ = device.ammeter.magnitude.mean</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.3
 0.24854516446739927</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ·µ¢ = device.ammeter.magnitude.variance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.01
 0.001</code></pre><hr/><h5 id="Wattmeters"><a class="docs-heading-anchor" href="#Wattmeters">Wattmeters</a><a id="Wattmeters-1"></a><a class="docs-heading-anchor-permalink" href="#Wattmeters" title="Permalink"></a></h5><p>Subsequently, users have the option to incorporate wattmeters, which measure active power injections at buses and active power flows at branches, thus forming the set <span>$\mathcal{P} \subset \mathcal{M}$</span>:</p><pre><code class="language-julia hljs">addWattmeter!(system, device; bus = &quot;Bus 1&quot;, active = 0.1, variance = 1e-4)
addWattmeter!(system, device; to = &quot;Branch 2&quot;, active = 0.2, variance = 1e-3)
addWattmeter!(system, device; from = &quot;Branch 3&quot;, active = 0.4, variance = 1e-3, noise = false)</code></pre><p>The vectors of measurement values <span>$\mathbf{z}_\mathcal{P}$</span> and variances <span>$\mathbf{v}_\mathcal{P}$</span> are stored in the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çö = device.wattmeter.active.mean</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.11026602070950395
 0.2054782835195266
 0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çö = device.wattmeter.active.variance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0001
 0.001
 0.001</code></pre><hr/><h5 id="Varmeters"><a class="docs-heading-anchor" href="#Varmeters">Varmeters</a><a id="Varmeters-1"></a><a class="docs-heading-anchor-permalink" href="#Varmeters" title="Permalink"></a></h5><p>In a similar fashion, users have the option to incorporate varmeters, which measure reactive power injections at buses and reactive power flows at branches, thus forming the set <span>$\mathcal{Q} \subset \mathcal{M}$</span>:</p><pre><code class="language-julia hljs">addVarmeter!(system, device; bus = &quot;Bus 3&quot;, reactive = 0.2, variance = 1e-4)
addVarmeter!(system, device; from = &quot;Branch 2&quot;, reactive = 0.03, variance = 1e-3)
addVarmeter!(system, device; to = &quot;Branch 1&quot;, reactive = 0.04, variance = 1e-3, noise = false)</code></pre><p>The vectors of measurement values <span>$\mathbf{z}_\mathcal{Q}$</span> and variances <span>$\mathbf{v}_\mathcal{Q}$</span> are stored in the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çí = device.varmeter.reactive.mean</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.205188718722458
 -0.022319807879141104
  0.04</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çí = device.varmeter.reactive.variance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0001
 0.001
 0.001</code></pre><hr/><h5 id="PMUs"><a class="docs-heading-anchor" href="#PMUs">PMUs</a><a id="PMUs-1"></a><a class="docs-heading-anchor-permalink" href="#PMUs" title="Permalink"></a></h5><p>The PMUs are responsible for measuring voltage and current phasors in the polar coordinate system, or they can be represented by magnitude and angle with corresponding variances for these two quantities. When PMUs are installed on buses, they measure bus voltage phasors, and when installed on branches, they measure current voltage phasors. Let us incorporate PMUs:</p><pre><code class="language-julia hljs">addPmu!(system, device; bus = &quot;Bus 1&quot;, magnitude = 1.1, angle = 0.0)
addPmu!(system, device; bus = &quot;Bus 2&quot;, magnitude = 1.2, angle = 0.1, varianceMagnitude = 1e-6)
addPmu!(system, device; from = &quot;Branch 2&quot;, magnitude = 0.2, angle = 0.2, varianceAngle = 1e-4)
addPmu!(system, device; to = &quot;Branch 3&quot;, magnitude = 0.1, angle = -0.3, noise = false)</code></pre><p>The magnitude measurements constitute the set <span>$\bar{\mathcal{P}}_M \subset \mathcal{M}$</span>, where the vectors of measurement values <span>$\mathbf{z}_{\bar{\mathcal{P}}_M}$</span> and variances <span>$\mathbf{v}_{\bar{\mathcal{P}}_M}$</span> are stored in the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çö‚Çò = device.pmu.magnitude.mean</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.1028954359947578
 1.199844973643663
 0.2000957763891969
 0.1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çö‚Çò = device.pmu.magnitude.variance</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0e-5
 1.0e-6
 1.0e-5
 1.0e-5</code></pre><p>Subsequently, angle measurements form the set <span>$\bar{\mathcal{P}}_A \subset \mathcal{M}$</span>, with the vectors of measurement values <span>$\mathbf{z}_{\bar{\mathcal{P}}_A}$</span> and variances <span>$\mathbf{v}_{\bar{\mathcal{P}}_A}$</span> stored in the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çö‚Çê = device.pmu.angle.mean</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.004015401469724757
  0.09321105365729443
  0.2049081723205177
 -0.3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çö‚Çê = device.pmu.angle.variance</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0e-5
 1.0e-5
 0.0001
 1.0e-5</code></pre><hr/><h2 id="State-Estimation"><a class="docs-heading-anchor" href="#State-Estimation">State Estimation</a><a id="State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#State-Estimation" title="Permalink"></a></h2><p>After establishing the measurement model, which includes specifying measurement values, variances, the locations of measurement devices, and known power system network parameters, the subsequent step involves the process of state estimation. State estimation is a component of energy management systems and typically encompasses network topology processing, observability analysis, state estimation algorithms, and bad data analysis.</p><p>The primary goal of state estimation algorithms is to determine state variables, often associated with bus voltages. Therefore, by representing the vector of state variables as <span>$\mathbf{x}$</span> and the vector of noisy measurement values as <span>$\mathbf{z}$</span>, we can effectively describe the state estimation problem using the following conditional probability equation: </p><p class="math-container">\[ 		p(\mathbf{x}|\mathbf{z})= \cfrac{p(\mathbf{z}|\mathbf{x})p(\mathbf{x})}{p(\mathbf{z})}.\]</p><p>If we assume that the prior probability distribution <span>$p(\mathbf{x})$</span> is uniform and that <span>$p(\mathbf{z})$</span> does not depend on <span>$\mathbf{x}$</span>, the maximum a posteriori solution simplifies to the maximum likelihood solution, as shown below <a href="#MeasurementModelReferenceTutorials">[4]</a>:</p><p class="math-container">\[	\hat{\mathbf{x}} = \mathrm{arg}\max_{\mathbf{x}}p(\mathbf{x}|\mathbf{z}) =
	\mathrm{arg}\max_{\mathbf{x}}p(\mathbf{z}|\mathbf{x}) = \mathrm{arg}\max_{\mathbf{x}}\mathcal{L}(\mathbf{z}|\mathbf{x}).\]</p><p>We can find this solution by maximizing the likelihood function <span>$\mathcal{L}(\mathbf{z}|\mathbf{x})$</span>, which is defined based on the likelihoods of <span>$k$</span> independent measurements:</p><p class="math-container">\[	\hat{\mathbf x} = \mathrm{arg} \max_{\mathbf{x}}\mathcal{L}(\mathbf{z}|\mathbf{x})=
	\mathrm{arg} \max_{\mathbf{x}} \prod_{i=1}^k \mathcal{N}(z_i|\mathbf{x},v_i).\]</p><p>It can be demonstrated that the solution to the maximum a posteriori problem can be obtained by solving the following optimization problem, commonly referred to as the weighted least-squares problem <a href="#MeasurementModelReferenceTutorials">[5, Sec. 9.3]</a>:</p><p class="math-container">\[	\hat{\mathbf x} = \mathrm{arg}\min_{\mathbf{x}} \sum_{i=1}^k\cfrac{[z_i-h_i(\mathbf x)]^2}{v_i}.\]</p><p>The state estimate, denoted as <span>$\hat{\mathbf x}$</span>, resulting from the solution to the above optimization problem, is known as the weighted least-squares estimator. Both the maximum likelihood and weighted least-squares estimators are equivalent to the maximum a posteriori solution <a href="#MeasurementModelReferenceTutorials">[4, Sec. 8.6]</a>.</p><hr/><h2 id="MeasurementModelReferenceTutorials"><a class="docs-heading-anchor" href="#MeasurementModelReferenceTutorials">References</a><a id="MeasurementModelReferenceTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#MeasurementModelReferenceTutorials" title="Permalink"></a></h2><p>[1] A. G. Phadke and J. S. Thorp, <em>Synchronized phasor measurements and their applications</em>, Springer, 2008, vol. 1.</p><p>[2] F. C. Schweppe and D. B. Rom, &quot;Power system static-state estimation, part II: Approximate model,&quot; <em>IEEE Trans. Power Syst.</em>, vol. PAS-89, no. 1, pp. 125-130, Jan. 1970.</p><p>[3] A. Monticelli, <em>State Estimation in Electric Power Systems: A Generalized Approach</em>, ser. Kluwer international series in engineering and computer science. Springer US, 1999.</p><p>[4] D. Barber, <em>Bayesian Reasoning and Machine Learning</em>, Cambridge University Press, 2012.</p><p>[5] A. Wood and B. Wollenberg, <em>Power Generation, Operation, and Control</em>, Wiley, 1996.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcOptimalPowerFlow/">¬´ DC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../pmuStateEstimation/">PMU State Estimation ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 7 March 2024 13:28">Thursday 7 March 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
