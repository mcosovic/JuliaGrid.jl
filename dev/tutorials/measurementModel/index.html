<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measurement Model ¬∑ JuliaGrid</title><meta name="title" content="Measurement Model ¬∑ JuliaGrid"/><meta property="og:title" content="Measurement Model ¬∑ JuliaGrid"/><meta property="twitter:title" content="Measurement Model ¬∑ JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li class="is-active"><a class="tocitem" href>Measurement Model</a><ul class="internal"><li><a class="tocitem" href="#Power-System-Monitoring"><span>Power System Monitoring</span></a></li><li><a class="tocitem" href="#Voltmeters"><span>Voltmeters</span></a></li><li><a class="tocitem" href="#Ammeters"><span>Ammeters</span></a></li><li><a class="tocitem" href="#Wattmeters"><span>Wattmeters</span></a></li><li><a class="tocitem" href="#Varmeters"><span>Varmeters</span></a></li><li><a class="tocitem" href="#PMUs"><span>PMUs</span></a></li><li><a class="tocitem" href="#State-Estimation"><span>State Estimation</span></a></li></ul></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Measurement Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measurement Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/measurementModel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MeasurementModelTutorials"><a class="docs-heading-anchor" href="#MeasurementModelTutorials">Measurement Model</a><a id="MeasurementModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#MeasurementModelTutorials" title="Permalink"></a></h1><p>Let us begin by examining a power system. To do that, we will construct one as shown below:</p><pre><code class="language-julia hljs">system = powerSystem()
device = measurement()

addBus!(system; label = 1)
addBus!(system; label = 2)
addBus!(system; label = 3)

@branch(reactance = 0.03)
addBranch!(system; label = 1, from = 1, to = 2)
addBranch!(system; label = 2, from = 1, to = 3)
addBranch!(system; label = 3, from = 2, to = 3)</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí© = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ∞ = [ùí©[system.branch.layout.from] ùí©[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{String}:
 &quot;1&quot;  &quot;2&quot;
 &quot;1&quot;  &quot;3&quot;
 &quot;2&quot;  &quot;3&quot;</code></pre><p>Our goal is to monitor the power system, and this process involves collecting measurement data for various electrical quantities distributed throughout the power system.</p><hr/><h2 id="Power-System-Monitoring"><a class="docs-heading-anchor" href="#Power-System-Monitoring">Power System Monitoring</a><a id="Power-System-Monitoring-1"></a><a class="docs-heading-anchor-permalink" href="#Power-System-Monitoring" title="Permalink"></a></h2><p>Measurement data is obtained through two main technologies: SCADA (Supervisory Control and Data Acquisition) and WAMS (Wide Area Measurement System). These technologies enable the collection of a wide range of measurements distributed throughout the power system. This extensive dataset allows us to employ state estimation algorithms to obtain the present state of the power system, in contrast to power flow algorithms, which are typically used for offline analyses. To commence, we will represent the entire set of measurement devices as <span>$\mathcal{M}$</span>.</p><p>SCADA provides legacy measurements with low sampling rates, making them unsuitable for capturing real-time system dynamics. It provides a snapshot of the power system&#39;s state, with delays measured in seconds and minutes. These legacy measurement devices, subsets of the set <span>$\mathcal{M}$</span>, include:</p><ul><li>a set of voltmeters <span>$\mathcal{V}$</span> for measuring bus voltage magnitudes,</li><li>a set of ammeters <span>$\mathcal{I}$</span> for measuring branch current magnitudes,</li><li>a set of wattmeters <span>$\mathcal{P}$</span> for active power injection and flow measurements,</li><li>a set of varmeters <span>$\mathcal{Q}$</span> for reactive power injection and flow measurements.</li></ul><p>In contrast, WAMS technology utilizes PMUs (Phasor Measurement Units) to provide data with high sampling rates, typically ranging between 10 and 20 ms, facilitating real-time monitoring of the system. Therefore, PMUs expand the set <span>$\mathcal{M}$</span> as follows:</p><ul><li>a set of PMUs <span>$\bar{\mathcal{P}}$</span> for bus voltage and branch current phasor measurements.</li></ul><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>In this section, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span>, where <span>$a_i$</span> represents the element associated measurement <span>$i \in \mathcal{M}$</span>.</p></div></div><hr/><h5 id="Measurement-Model"><a class="docs-heading-anchor" href="#Measurement-Model">Measurement Model</a><a id="Measurement-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Model" title="Permalink"></a></h5><p>The measurement model, as defined by the set <span>$\mathcal{M}$</span>, can be expressed as a system of equations [<a href="../../bibliography/#schweppe1970power">12</a>]:</p><p class="math-container">\[    \mathbf{z}=\mathbf{h}(\mathbf {x}) + \mathbf{u},\]</p><p>where <span>$\mathbf {x}=[x_1,\dots,x_{n}]^{T}$</span> is the vector of state variables, <span>$\mathbf{h}(\mathbf{x})=$</span> <span>$[h_1(\mathbf{x})$</span>, <span>$\dots$</span>, <span>$h_k(\mathbf{x})]^{{T}}$</span> is the vector of measurement functions, <span>$\mathbf{z} = [z_1,\dots,z_k]^{\mathrm{T}}$</span> is the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{\mathrm{T}}$</span> is the vector of measurement errors. In the context of transmission grids, this model is often an overdetermined system of equations <span>$(k&gt;s)$</span> [<a href="../../bibliography/#monticellibook">13</a>, Sec. 2.1].</p><p>These errors are assumed to follow a Gaussian distribution with a zero-mean and covariance matrix <span>$\bm \Sigma$</span>. The diagonal elements of <span>$\bm \Sigma$</span> correspond to the measurement variances <span>$\mathbf{v} = [v_1,\dots,v_k]^T$</span>, while the off-diagonal elements represent the covariances between the measurement errors <span>$\mathbf{w} = [w_1,\dots,w_k]^{T}$</span>. These covariances exist only if PMUs are observed in rectangular coordinates and correlation is required.</p><hr/><h5 id="Gaussian-Probability-Density-Function"><a class="docs-heading-anchor" href="#Gaussian-Probability-Density-Function">Gaussian Probability Density Function</a><a id="Gaussian-Probability-Density-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Probability-Density-Function" title="Permalink"></a></h5><p>Each legacy measurement and each magnitude or angle measurement from PMUs is associated with a measured value <span>$z_i$</span>, a measurement error <span>$u_i$</span>, and a measurement function <span>$h_i(\mathbf{x})$</span>. Assuming that measurement errors <span>$u_i$</span> follow a zero mean Gaussian distribution, the probability density function associated with the <span>$i$</span>-th measurement is proportional to:</p><p class="math-container">\[  \mathcal{N}(z_i|\mathbf{x},v_i) \propto \exp\Bigg\{\cfrac{[z_i-h_i(\mathbf{x})]^2}{2v_i}\Bigg\},\]</p><p>where <span>$v_i$</span> is the measurement variance defined by the measurement error <span>$u_i$</span>, and the measurement function <span>$h_i(\mathbf{x})$</span> connects the vector of state variables <span>$\mathbf{x}$</span> to the value of the <span>$i$</span>-th measurement.</p><hr/><h5 id="Artificial-Generation-of-Measurement-Values"><a class="docs-heading-anchor" href="#Artificial-Generation-of-Measurement-Values">Artificial Generation of Measurement Values</a><a id="Artificial-Generation-of-Measurement-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Artificial-Generation-of-Measurement-Values" title="Permalink"></a></h5><p>When defining the system of equations, it is essential to have measurement values represented by <span>$\mathbf{z}$</span>. In JuliaGrid, users have the option to either directly specify measurement values or artificially generate the vector <span>$\mathbf{z}$</span>. The artificial generation process involves setting the keyword <code>noise = true</code>, which introduces white Gaussian noise with variances <span>$[v_1, \dots, v_k]$</span> added to the provided values <span>$[e_1, \dots, e_k]$</span>, typically representing the exact values of the respective electrical quantities:</p><p class="math-container">\[  \epsilon_i \sim \mathcal{N}(0,\,v_i) \\[5pt]
  z_i = e_i + \epsilon_i.\]</p><hr/><h2 id="Voltmeters"><a class="docs-heading-anchor" href="#Voltmeters">Voltmeters</a><a id="Voltmeters-1"></a><a class="docs-heading-anchor-permalink" href="#Voltmeters" title="Permalink"></a></h2><p>A voltmeter <span>$V_i \in \mathcal{V}$</span> measures the bus voltage magnitude at bus <span>$i \in \mathcal{N}$</span>. Let us introduce two voltmeters that measure voltage magnitudes at the first and third bus. For the first voltmeter, we directly pass the measurement value, while for the second voltmeter, we generate the measurement value artificially:</p><pre><code class="language-julia hljs">addVoltmeter!(system, device; label = &quot;V‚ÇÅ&quot;, bus = 1, magnitude = 1.1, variance = 1e-3)
addVoltmeter!(system, device; label = &quot;V‚ÇÉ&quot;, bus = 3, magnitude = 1.0, noise = true)</code></pre><p>Consequently, we establish the set of voltmeters <span>$\mathcal{V} \subset \mathcal{M}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí± = collect(keys(device.voltmeter.label))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;V‚ÇÅ&quot;
 &quot;V‚ÇÉ&quot;</code></pre><p>This set of voltmeters defines vectors of measurement values denoted as <span>$\mathbf{z}_\mathcal{V} = [z_i]$</span> and variances denoted as <span>$\mathbf{v}_\mathcal{V} = [v_i]$</span>, where <span>$i \in \mathcal{V}$</span>, and can be accessed through the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥·µ• = device.voltmeter.magnitude.mean</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.1
 0.9797157913892697</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ·µ• = device.voltmeter.magnitude.variance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.001
 0.01</code></pre><hr/><h2 id="Ammeters"><a class="docs-heading-anchor" href="#Ammeters">Ammeters</a><a id="Ammeters-1"></a><a class="docs-heading-anchor-permalink" href="#Ammeters" title="Permalink"></a></h2><p>An ammeter <span>$I_{ij} \in \mathcal{I}$</span> measures the magnitude of branch current at the from-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>. Let us add this type of ammeter at the first branch between buses <code>1</code> and <code>2</code>:</p><pre><code class="language-julia hljs">addAmmeter!(system, device; label = &quot;I‚ÇÅ‚ÇÇ&quot;, from = 1, magnitude = 0.3, variance = 1e-3)</code></pre><p>Additionally, an ammeter can measure the branch current magnitude at the to-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>, denoted as <span>$I_{ji} \in \mathcal{I}$</span>. For example, we can include this type of ammeter at the same branch:</p><pre><code class="language-julia hljs">addAmmeter!(system, device; label = &quot;I‚ÇÇ‚ÇÅ&quot;, to = 1, magnitude = 0.2, variance = 1e-3)</code></pre><p>Consequently, we establish the set of ammeters <span>$\mathcal{I} \subset \mathcal{M}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñê = collect(keys(device.ammeter.label))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;I‚ÇÅ‚ÇÇ&quot;
 &quot;I‚ÇÇ‚ÇÅ&quot;</code></pre><p>This set of ammeters defines vectors of measurement values denoted as <span>$\mathbf{z}_\mathcal{I} = [z_i]$</span> and variances denoted as <span>$\mathbf{v}_\mathcal{I} = [v_i]$</span>, where <span>$i \in \mathcal{I}$</span>, and can be accessed through the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çí = device.ammeter.magnitude.mean</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.3
 0.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çí = device.ammeter.magnitude.variance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.001
 0.001</code></pre><hr/><h2 id="Wattmeters"><a class="docs-heading-anchor" href="#Wattmeters">Wattmeters</a><a id="Wattmeters-1"></a><a class="docs-heading-anchor-permalink" href="#Wattmeters" title="Permalink"></a></h2><p>A wattmeter <span>$P_{i} \in \mathcal{P}$</span> measures the active power injection at bus <span>$i \in \mathcal{N}$</span>. Hence, let us add it to the second bus:</p><pre><code class="language-julia hljs">addWattmeter!(system, device; label = &quot;P‚ÇÇ&quot;, bus = 2, active = 0.1, variance = 1e-4)</code></pre><p>Next, a wattmeter denoted as <span>$P_{ij} \in \mathcal{P}$</span> measures the active power flow at the from-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>. Let us add this type of wattmeter at the second branch:</p><pre><code class="language-julia hljs">addWattmeter!(system, device; label = &quot;P‚ÇÅ‚ÇÉ&quot;, from = 2, active = 0.2, variance = 1e-3)</code></pre><p>Moreover, a wattmeter can also measure the active power flow at the to-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>, denoted as <span>$P_{ji} \in \mathcal{P}$</span>. For example, we can include this type of wattmeter at the same branch:</p><pre><code class="language-julia hljs">addWattmeter!(system, device; label = &quot;P‚ÇÉ‚ÇÅ&quot;, to = 2, active = 0.3, variance = 1e-3)</code></pre><p>Consequently, we establish the set of wattmeters <span>$\mathcal{P} \subset \mathcal{M}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí´ = collect(keys(device.wattmeter.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;P‚ÇÇ&quot;
 &quot;P‚ÇÅ‚ÇÉ&quot;
 &quot;P‚ÇÉ‚ÇÅ&quot;</code></pre><p>This set of wattmeters defines vectors of measurement values denoted as <span>$\mathbf{z}_\mathcal{P} = [z_i]$</span> and variances denoted as <span>$\mathbf{v}_\mathcal{P} = [v_i]$</span>, where <span>$i \in \mathcal{P}$</span>, and can be accessed through the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çö = device.wattmeter.active.mean</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.1
 0.2
 0.3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çö = device.wattmeter.active.variance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0001
 0.001
 0.001</code></pre><hr/><h2 id="Varmeters"><a class="docs-heading-anchor" href="#Varmeters">Varmeters</a><a id="Varmeters-1"></a><a class="docs-heading-anchor-permalink" href="#Varmeters" title="Permalink"></a></h2><p>A varmeter <span>$Q_{i} \in \mathcal{Q}$</span> measures the reactive power injection at bus <span>$i \in \mathcal{N}$</span>. Hence, let us add it to the first bus:</p><pre><code class="language-julia hljs">addVarmeter!(system, device; label = &quot;Q‚ÇÅ&quot;, bus = 1, reactive = 0.01, variance = 1e-2)</code></pre><p>Next, a varmeter denoted as <span>$Q_{ij} \in \mathcal{Q}$</span> measures the reactive power flow at the from-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>. Let us add this type of varmeter at the first branch:</p><pre><code class="language-julia hljs">addVarmeter!(system, device; label = &quot;Q‚ÇÅ‚ÇÇ&quot;, from = 1, reactive = 0.02, variance = 1e-3)</code></pre><p>Moreover, a varmeter can also measure the reactive power flow at the to-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>, denoted as <span>$Q_{ji} \in \mathcal{Q}$</span>. For example, we can include this type of varmeter at the same branch:</p><pre><code class="language-julia hljs">addVarmeter!(system, device; label = &quot;Q‚ÇÇ‚ÇÅ&quot;, to = 1, reactive = 0.03, noise = true)</code></pre><p>Consequently, we establish the set of varmeters <span>$\mathcal{Q} \subset \mathcal{M}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí¨ = collect(keys(device.varmeter.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;Q‚ÇÅ&quot;
 &quot;Q‚ÇÅ‚ÇÇ&quot;
 &quot;Q‚ÇÇ‚ÇÅ&quot;</code></pre><p>This set of varmeters defines vectors of measurement values denoted as <span>$\mathbf{z}_\mathcal{Q} = [z_i]$</span> and variances denoted as <span>$\mathbf{v}_\mathcal{Q} = [v_i]$</span>, where <span>$i \in \mathcal{Q}$</span>, and can be accessed through the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çí = device.varmeter.reactive.mean</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.01
  0.02
 -0.026701543478464096</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çí = device.varmeter.reactive.variance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.01
 0.001
 0.01</code></pre><hr/><h2 id="PMUs"><a class="docs-heading-anchor" href="#PMUs">PMUs</a><a id="PMUs-1"></a><a class="docs-heading-anchor-permalink" href="#PMUs" title="Permalink"></a></h2><p>PMUs measure voltage and current phasors in the polar coordinate system, thus each PMU output is represented by magnitude and angle along with corresponding variances [<a href="../../bibliography/#phadkebook">14</a>, Sec. 5.6]. When installed on buses, they measure bus voltage phasors, while on branches, they measure current phasors.</p><p>A PMU <span>$(V_i, \theta_i) \in \bar{\mathcal{P}}$</span> measures the voltage phasor at bus <span>$i \in \mathcal{N}$</span>. Let us integrate this type of PMU at the first bus:</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;V‚ÇÅ, Œ∏‚ÇÅ&quot;, bus = 1, magnitude = 1, angle = 0, noise = true)</code></pre><p>Next, a PMU <span>$(I_{ij}, \psi_{ij}) \in \bar{\mathcal{P}}$</span> measures the branch current magnitude at the from-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>. Let us add this type of PMU at the first branch:</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;I‚ÇÅ‚ÇÇ, œà‚ÇÅ‚ÇÇ&quot;, from = 1, magnitude = 0.2, angle = -0.1)</code></pre><p>Moreover, a PMU can measure the branch current magnitude at the to-bus end of the branch <span>$(i,j) \in \mathcal{E}$</span>, denoted as <span>$(I_{ji}, \psi_{ji}) \in \bar{\mathcal{P}}$</span>. For example, let us include this type of PMU at the same branch:</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;I‚ÇÇ‚ÇÅ, œà‚ÇÇ‚ÇÅ&quot;, to = 1, magnitude = 0.3, angle = -0.2)</code></pre><p>Consequently, we establish the set of PMUs <span>$\bar{\mathcal{P}} \subset \mathcal{M}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí´ÃÑ = collect(keys(device.pmu.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;V‚ÇÅ, Œ∏‚ÇÅ&quot;
 &quot;I‚ÇÅ‚ÇÇ, œà‚ÇÅ‚ÇÇ&quot;
 &quot;I‚ÇÇ‚ÇÅ, œà‚ÇÇ‚ÇÅ&quot;</code></pre><p>This set of PMUs establishes vectors representing measurement magnitudes and angles <span>$\mathbf{z}_{\bar{\mathcal{P}}} = [z_i, z_j]$</span>, along with their corresponding variances <span>$\mathbf{v}_{\bar{\mathcal{P}}} = [v_i, v_j]$</span>, where <span>$(i, j) \in \bar{\mathcal{P}}$</span>. These values can be accessed as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pmu = device.pmu;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥‚Çö = collect(Iterators.flatten(zip(pmu.magnitude.mean, pmu.angle.mean)))</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
  0.9970672512666734
 -0.004058583118455491
  0.2
 -0.1
  0.3
 -0.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêØ‚Çö = collect(Iterators.flatten(zip(pmu.magnitude.variance, pmu.angle.variance)))</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>PMUs can be handled in state estimation algorithms according to our definition in polar coordinate systems. However, they can also be processed in rectangular coordinates, where we observe the real and imaginary parts of the phasor measurements rather than magnitude and angle. Further details can be found in tutorials that describe specific state estimation analyses.</p></div></div><hr/><h2 id="State-Estimation"><a class="docs-heading-anchor" href="#State-Estimation">State Estimation</a><a id="State-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#State-Estimation" title="Permalink"></a></h2><p>After establishing the measurement model, which includes specifying measurement values, variances, the locations of measurement devices, and known power system network parameters, the subsequent step involves the process of state estimation. State estimation is a component of energy management systems and typically encompasses network topology processing, observability analysis, state estimation algorithms, and bad data analysis.</p><p>The primary goal of state estimation algorithms is to determine state variables, often associated with bus voltages. Therefore, by representing the vector of state variables as <span>$\mathbf{x}$</span> and the vector of noisy measurement values as <span>$\mathbf{z}$</span>, we can effectively describe the state estimation problem using the following conditional probability equation:</p><p class="math-container">\[ 		p(\mathbf{x}|\mathbf{z})= \cfrac{p(\mathbf{z}|\mathbf{x})p(\mathbf{x})}{p(\mathbf{z})}.\]</p><p>If we assume that the prior probability distribution <span>$p(\mathbf{x})$</span> is uniform and that <span>$p(\mathbf{z})$</span> does not depend on <span>$\mathbf{x}$</span>, the maximum a posteriori solution simplifies to the maximum likelihood solution, as shown below [<a href="../../bibliography/#barberbook">15</a>]:</p><p class="math-container">\[	\hat{\mathbf{x}} = \mathrm{arg}\max_{\mathbf{x}}p(\mathbf{x}|\mathbf{z}) =
	\mathrm{arg}\max_{\mathbf{x}}p(\mathbf{z}|\mathbf{x}) = \mathrm{arg}\max_{\mathbf{x}}\mathcal{L}(\mathbf{z}|\mathbf{x}).\]</p><p>We can find this solution by maximizing the likelihood function <span>$\mathcal{L}(\mathbf{z}|\mathbf{x})$</span>, which is defined based on the likelihoods of <span>$k$</span> independent measurements:</p><p class="math-container">\[	\hat{\mathbf x} = \mathrm{arg} \max_{\mathbf{x}}\mathcal{L}(\mathbf{z}|\mathbf{x})=
	\mathrm{arg} \max_{\mathbf{x}} \prod_{i=1}^k \mathcal{N}(z_i|\mathbf{x},v_i).\]</p><p>It can be demonstrated that the solution to the maximum a posteriori problem can be obtained by solving the following optimization problem, commonly referred to as the weighted least-squares problem [<a href="../../bibliography/#wood2013power">9</a>, Sec. 9.3]:</p><p class="math-container">\[	\hat{\mathbf x} = \mathrm{arg}\min_{\mathbf{x}} \sum_{i=1}^k\cfrac{[z_i-h_i(\mathbf x)]^2}{v_i}.\]</p><p>The state estimate, denoted as <span>$\hat{\mathbf x}$</span>, resulting from the solution to the above optimization problem, is known as the weighted least-squares estimator. Both the maximum likelihood and weighted least-squares estimators are equivalent to the maximum a posteriori solution [<a href="../../bibliography/#barberbook">15</a>, Sec. 8.6].</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcOptimalPowerFlow/">¬´ DC Optimal Power Flow</a><a class="docs-footer-nextpage" href="../acStateEstimation/">AC State Estimation ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 12 October 2024 14:36">Saturday 12 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
