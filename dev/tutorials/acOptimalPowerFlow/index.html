<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC Optimal Power Flow · JuliaGrid</title><meta name="title" content="AC Optimal Power Flow · JuliaGrid"/><meta property="og:title" content="AC Optimal Power Flow · JuliaGrid"/><meta property="twitter:title" content="AC Optimal Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../manual/badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li class="is-active"><a class="tocitem" href>AC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#ACOptimalPowerFlowModelTutorials"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#Objective-Function"><span>Objective Function</span></a></li><li><a class="tocitem" href="#Constraint-Functions"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#ACOptimalPowerFlowSolutionTutorials"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#ACOptimalPowerAnalysisTutorials"><span>Power Analysis</span></a></li><li><a class="tocitem" href="#Current-Analysis"><span>Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/acOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACOptimalPowerFlowTutorials"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a><a id="ACOptimalPowerFlowTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowTutorials" title="Permalink"></a></h1><p>To begin, let us generate the <code>PowerSystem</code> type, as illustrated by the following example:</p><pre><code class="language-julia hljs">using JuMP, Ipopt

@config(label = Integer)

system = powerSystem()

@bus(minMagnitude = 0.95, maxMagnitude = 1.05)
addBus!(system; label = 1, type = 3, active = 0.1, angle = -0.1)
addBus!(system; label = 2, reactive = 0.01, magnitude = 1.1)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, reactance = 0.5, type = 1)
addBranch!(system; label = 1, from = 1, to = 2, maxFromBus = 0.15, maxToBus = 0.15)

@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1)
addGenerator!(system; label = 1, bus = 1, active = 0.4, reactive = 0.2)
addGenerator!(system; label = 2, bus = 2, active = 0.2, reactive = 0.1)

cost!(system; generator = 1, active = 2, polynomial = [900.0; 500.0; 80.0; 5.0])
cost!(system; generator = 2, active = 1, piecewise =  [10.8 12.3; 14.7 16.8; 18 18.1])

cost!(system; generator = 1, reactive = 1, piecewise = [10.0 20.0; 20.0 40.0])
cost!(system; generator = 2, reactive = 2, polynomial = [2.0])</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒩 = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">1×2 Matrix{Int64}:
 1  2</code></pre><p>Moreover, we identify the set of generators as <span>$\mathcal{S} = \{1, \dots, n_\mathrm{g}\}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒮 = collect(keys(system.generator.label))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Here, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element related with bus <span>$i \in \mathcal{N}$</span> or generator <span>$i \in \mathcal{S}$</span>, while <span>$a_{ij}$</span> denotes the element related with branch <span>$(i,j) \in \mathcal{E}$</span>.</p></div></div><hr/><h2 id="ACOptimalPowerFlowModelTutorials"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowModelTutorials">Optimal Power Flow Model</a><a id="ACOptimalPowerFlowModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowModelTutorials" title="Permalink"></a></h2><p>In the AC optimal power flow model, the active and reactive power outputs of the generators, denoted as <span>$\mathbf P_{\mathrm{g}} = [P_{\mathrm{g}i}]$</span> and <span>$\mathbf Q_{\mathrm{g}} = [Q_{\mathrm{g}i}]$</span>, where <span>$i \in \mathcal S$</span>, are expressed as nonlinear functions of the bus voltage magnitudes and angles, denoted as <span>$\mathbf V = [V_i]$</span> and <span>$\bm{\Theta} = [\theta_i]$</span>, where <span>$i \in \mathcal N$</span>. Consequently, the optimization variables encompass the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles.</p><p>The AC optimal power flow problem can be formulated as follows:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{minimize} &amp; &amp;  \sum_{i \in \mathcal S} \left[f_i(P_{\mathrm{g}i}) + f_i(Q_{\mathrm{g}i}) \right] \\[10pt]
    &amp; \text{subject to} &amp; &amp; \\[-4pt]
    &amp; &amp; &amp;  \left.
    \begin{aligned}
        &amp; \theta_i - \theta_\mathrm{s} = 0
    \end{aligned}
    \phantom{\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;}
    \right\} i \in \mathcal{N_\mathrm{sb}} \\[-1pt]
    &amp; &amp; &amp; \left.
    \begin{aligned}
        &amp; h_{P_i}(\mathbf P_\mathrm{g}, \mathbf V, \bm \Theta) = 0  \\
        &amp; h_{Q_i}(\mathbf Q_\mathrm{g}, \mathbf V, \bm \Theta) = 0  \\
        &amp; V_{i}^\mathrm{min} \leq V_i \leq V_{i}^\mathrm{max}
    \end{aligned}
    \phantom{\;\;\;\;\;\;\;\;\;\;\;\;\;}
    \right\} i \in \mathcal N \\[8pt]
    &amp; &amp; &amp;  \left.
    \begin{aligned}
        &amp; \theta_{ij}^\mathrm{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\mathrm{max}  \\
        &amp; F_{ij}^{\mathrm{min}} \leq h_{ij}(\mathbf V, \bm \Theta) \leq F_{ij}^{\mathrm{max}}  \\
        &amp; F_{ji}^{\mathrm{min}} \leq h_{ji}(\mathbf V, \bm \Theta) \leq F_{ji}^{\mathrm{max}}
    \end{aligned}
    \phantom{\;\;}
    \right\} (i,j) \in \mathcal E \\[8pt]
    &amp; &amp; &amp;  \left.
    \begin{aligned}
        &amp; P_{\mathrm{g}i}^\mathrm{min} \leq P_{\mathrm{g}i} \leq P_{\mathrm{g}i}^\mathrm{max}  \\
        &amp; Q_{\mathrm{g}i}^\mathrm{min} \leq Q_{\mathrm{g}i} \leq Q_{\mathrm{g}i}^\mathrm{max}
    \end{aligned}
    \phantom{\;\;\;\;\;\;\;\;\;\;\;\;}
    \right\} i \in \mathcal S
\end{aligned}\]</p><p>In essence, the AC optimal power flow aims to minimize the objective function associated with the costs of generator&#39;s active and reactive power output while ensuring the fulfillment of all constraints. This optimization task plays a pivotal role in effectively managing electrical power systems. By striking a balance between cost reduction and constraint adherence, the AC optimal power flow contributes to efficient and reliable electricity supply in complex grid environments.</p><hr/><h5 id="Build-Optimal-Power-Flow-Model"><a class="docs-heading-anchor" href="#Build-Optimal-Power-Flow-Model">Build Optimal Power Flow Model</a><a id="Build-Optimal-Power-Flow-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Optimal-Power-Flow-Model" title="Permalink"></a></h5><p>To build the AC optimal power flow model, we must first load the power system and establish the AC model:</p><pre><code class="language-julia hljs">acModel!(system)</code></pre><p>Afterward, the AC optimal power flow model is created using the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function:</p><pre><code class="language-julia hljs">analysis = acOptimalPowerFlow(
  system, Ipopt.Optimizer; active = &quot;Pg&quot;, reactive = &quot;Qg&quot;, magnitude = &quot;V&quot;, angle = &quot;θ&quot;
)</code></pre><hr/><h5 id="Optimization-Variables"><a class="docs-heading-anchor" href="#Optimization-Variables">Optimization Variables</a><a id="Optimization-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Variables" title="Permalink"></a></h5><p>The variables within this model encompass the active and reactive power outputs of the generators, denoted as <span>$\mathbf P_\mathrm{g} = [P_{\mathrm{g}i}]$</span> and <span>$\mathbf Q_\mathrm{g} = [Q_{\mathrm{g}i}]$</span>, where <span>$i \in \mathcal S$</span>, and the bus voltage magnitudes and angles represented by <span>$\mathbf V = [V_i]$</span> and <span>$\bm \Theta = [\theta_i]$</span>, where <span>$i \in \mathcal N$</span>. We can access these variables using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = analysis.method.variable.power.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{VariableRef}:
 Pg[1]
 Pg[2]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₒ = analysis.method.variable.power.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{VariableRef}:
 Qg[1]
 Qg[2]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.method.variable.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{VariableRef}:
 V[1]
 V[2]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.method.variable.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{VariableRef}:
 θ[1]
 θ[2]</code></pre><hr/><h2 id="Objective-Function"><a class="docs-heading-anchor" href="#Objective-Function">Objective Function</a><a id="Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function" title="Permalink"></a></h2><p>The objective function represents the sum of the active and reactive power cost functions <span>$f_i(P_{\mathrm{g}i})$</span> and <span>$f_i(Q_{\mathrm{g}i})$</span>, where <span>$i \in \mathcal S$</span>, for each generator, where these cost functions can be polynomial or piecewise linear. Typically, the AC optimal power flow focuses on minimizing the cost of active power outputs only, but for comprehensive analysis, we also consider the costs associated with reactive power outputs.</p><hr/><h5 id="Polynomial-Cost-Function"><a class="docs-heading-anchor" href="#Polynomial-Cost-Function">Polynomial Cost Function</a><a id="Polynomial-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Cost-Function" title="Permalink"></a></h5><p>In the following analysis, we will focus on the cost function of generating active power, denoted as <span>$f_i(P_{\mathrm{g}i})$</span>. However, please note that the same analysis can be applied to the cost function <span>$f_i(Q_{\mathrm{g}i})$</span> for reactive power.</p><p>In the AC optimal power flow, the cost function <span>$f_i(P_{\mathrm{g}i})$</span> can be represented as an <span>$m$</span>-th degree polynomial:</p><p class="math-container">\[f_i(P_{\mathrm{g}i}) = \sum_{k=0}^m a_k P_{\mathrm{g}i}^k.\]</p><p>Typically, cost functions are represented as linear, quadratic, or cubic, as shown in Figure 1:</p><p class="math-container">\[\begin{aligned}
  f_i(P_{\mathrm{g}i}) &amp;= a_1 P_{\mathrm{g}i} + a_0 \\
  f_i(P_{\mathrm{g}i}) &amp;= a_2 P_{\mathrm{g}i}^2 + a_1 P_{\mathrm{g}i} + a_0 \\
  f_i(P_{\mathrm{g}i}) &amp;= a_3 P_{\mathrm{g}i}^3 + a_2 P_{\mathrm{g}i}^2 + a_1P_{\mathrm{g}i} + a_0. \\
\end{aligned}\]</p><div class="image-container">
    <div class="image-item-three">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_linear.svg" width="85%" class="my-svg"/>
        <p>(a) The linear function.</p>
    </div>
    <div class="image-item-three">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_quadratic.svg" width="85%" class="my-svg"/>
        <p>(b) The quadratic function.</p>
    </div>
    <div class="image-item-three">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_cubic.svg" width="85%" class="my-svg"/>
        <p>(c) The cubic function.</p>
    </div>
    <p style="text-align: center; margin-top: -5px;">
    Figure 1: Different types of polynomial cost functions that are typically used.
    </p>
</div>
&nbsp;<p>When using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function in JuliaGrid and specifying the <code>polynomial</code> keyword, the polynomial is constructed with coefficients arranged in descending order of their degrees, from the highest degree to the lowest. For example, in the case study provided, we generated a cubic polynomial cost function for the active output power of <code>Generator 1</code>, which is represented as:</p><p class="math-container">\[\begin{aligned}
  f_1(P_{\mathrm{g}1}) &amp;= 900 P_{\mathrm{g}1}^3 + 500 P_{\mathrm{g}1}^2 + 80 P_{\mathrm{g}1} + 5.
\end{aligned}\]</p><p>To access these coefficients, users can utilize the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f₁ = system.generator.cost.active.polynomial[1]</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 900.0
 500.0
  80.0
   5.0</code></pre><hr/><h5 id="Piecewise-Linear-Cost-Function"><a class="docs-heading-anchor" href="#Piecewise-Linear-Cost-Function">Piecewise Linear Cost Function</a><a id="Piecewise-Linear-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise-Linear-Cost-Function" title="Permalink"></a></h5><p>The second option for defining cost functions in the AC optimal power flow is to use piecewise linear functions as approximations of the polynomial functions, as illustrated in Figure 2.</p><div class="image-container">
    <div class="image-item-three">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_one.svg" width="85%" class="my-svg"/>
        <p>(a) One-segment function.</p>
    </div>
    <div class="image-item-three">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_two.svg" width="85%" class="my-svg"/>
        <p>(b) Two-segment function.</p>
    </div>
    <div class="image-item-three">
        <img src="../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_three.svg" width="85%" class="my-svg"/>
        <p>(c) Three-segment function.</p>
    </div>
    <p style="text-align: center; margin-top: -5px;">
    Figure 2: Different types of piecewise linear cost functions that are typically used.
    </p>
</div>
&nbsp;<p>To define piecewise linear functions in JuliaGrid, users can utilize the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function with the <code>piecewise</code> keyword. The piecewise linear function is constructed using a matrix where each row defines a single point. The first column holds the generator&#39;s active or reactive power output, while the second column corresponds to the associated cost value. For example, in the provided case study, a piecewise linear function is created and can be accessed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f₂ = system.generator.cost.active.piecewise[2]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Float64}:
 10.8  12.3
 14.7  16.8
 18.0  18.1</code></pre><p>JuliaGrid handles convex piecewise linear functions using a constrained cost variable method. In this approach, the piecewise linear cost function is replaced by a helper variable and a set of linear inequality constraints for each segment of the function defined by two neighboring points along the line. However, for piecewise linear functions that have only one segment defined by two points, JuliaGrid transforms it into a standard linear function without introducing a helper variable.</p><p>Hence, for a piecewise cost function denoted as <span>$f_i(P_{\mathrm{g}i})$</span> with <span>$k$</span> segments (where <span>$k &gt; 1$</span>), the <span>$j$</span>-th segment, defined by the points <span>$[P_{\mathrm{g}i,j}, f_i(P_{\mathrm{g}i,j})]$</span> and <span>$[P_{\mathrm{g}i,j+1}, f_i(P_{\mathrm{g}i,j+1})]$</span>, is characterized by the following inequality constraints:</p><p class="math-container">\[\cfrac{f_i(P_{\mathrm{g}i,j+1}) - f_i(P_{\mathrm{g}i,j})}{P_{\mathrm{g}i,j+1} - P_{\mathrm{g}i,j}}(P_{\mathrm{g}i} - P_{\mathrm{g}i,j}) + f_i(P_{\mathrm{g}i,j}) \leq H_i, \;\;\; i \in \mathcal{S}, \;\;\; j = 1,\dots,k,\]</p><p>where <span>$H_i$</span> represents the helper variable. To finalize this method, we simply need to include the helper variable <span>$H_i$</span> in the objective function. This approach efficiently handles piecewise linear cost functions, providing the flexibility to capture nonlinear characteristics while still benefiting from the advantages of linear optimization techniques.</p><p>As an example, in the provided case study, the helper variable is defined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; H₂ = analysis.method.variable.power.actwise[2]</code><code class="nohighlight hljs ansi" style="display:block;">actwise[2]</code></pre><p>Lastly, the set of constraints introduced by the piecewise linear cost function is displayed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">1.1538461538461542 Pg[2] - actwise[2] ≤ 0.16153846153846452
0.3939393939393941 Pg[2] - actwise[2] ≤ -11.009090909090908</code></pre><hr/><h5 id="Objective-Function-2"><a class="docs-heading-anchor" href="#Objective-Function-2">Objective Function</a><a class="docs-heading-anchor-permalink" href="#Objective-Function-2" title="Permalink"></a></h5><p>As previously explained, the objective function relies on the defined polynomial or piecewise linear cost functions and represents the sum of these costs. In the provided example, the objective function that must be minimized to obtain the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes and angles can be accessed using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">(500 Pg[1]² + 80 Pg[1] + 2 Qg[1] + actwise[2] + 7) + (900.0 * (Pg[1] ^ 3.0))</code></pre><hr/><h2 id="Constraint-Functions"><a class="docs-heading-anchor" href="#Constraint-Functions">Constraint Functions</a><a id="Constraint-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Functions" title="Permalink"></a></h2><p>In the following section, we will examine the various constraints defined within the AC optimal power flow model.</p><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as <span>$\theta_i$</span> is fixed to a constant value <span>$\theta_\mathrm{s}$</span>. It can be expressed as follows:</p><p class="math-container">\[\theta_i - \theta_\mathrm{s} = 0,\;\;\; i \in \mathcal{N_{\mathrm{sb}}},\]</p><p>where the set <span>$\mathcal{N}_{\mathrm{sb}}$</span> contains the index of the slack bus. To access the equality constraint from the model, we can utilize the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">θ[1] = -0.1</code></pre><hr/><h5 id="Bus-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Bus-Power-Balance-Constraints">Bus Power Balance Constraints</a><a id="Bus-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Power-Balance-Constraints" title="Permalink"></a></h5><p>The second equality constraint in the optimization problem is associated with the active power balance equation:</p><p class="math-container">\[\begin{aligned}
h_{P_i}(\mathbf P_{\mathrm{g}}, \mathbf V, \bm \Theta) = 0,\;\;\;  i \in \mathcal N.
\end{aligned}\]</p><p>As elaborated in the <a href="../powerSystemModel/#BusInjectionsTutorials">Bus Injections</a> section, we can express the equation as follows:</p><p class="math-container">\[h_{P_i}(\mathbf P_\mathrm{g}, \mathbf V, \bm \Theta) = V_i \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) V_j - \sum_{k \in \mathcal{S}_i} P_{\mathrm{g}k} + P_{\mathrm{d}i}.\]</p><p>In this equation, the set <span>$\mathcal{S}_i \subseteq \mathcal S$</span> encompasses all generators connected to bus <span>$i \in \mathcal N$</span>, and <span>$P_{\mathrm{g}k}$</span> represents the active power output of the <span>$k$</span>-th generator within the set <span>$\mathcal{S}_i$</span>. More precisely, the variable <span>$P_{\mathrm{g}k}$</span> represents the optimization variable, along with the bus voltage angles <span>$\theta_{ij} = \theta_i - \theta_j$</span> and the bus voltage magnitudes <span>$V_i$</span> and <span>$V_j$</span>.</p><p>The constant term is determined by the active power demand <span>$P_{\mathrm{d}i}$</span> at bus <span>$i \in \mathcal{N}$</span>. The values representing this constant term, denoted as <span>$\mathbf{P}_{\mathrm{d}} = [P_{\mathrm{d}i}]$</span> can be accessed using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.1
 0.0</code></pre><p>We can access the references to the active power balance constraints using the following snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Pg[1] - (V[1] * ((V[2] * ((2.0 * sin(θ[1] - θ[2])))))) - 0.1 = 0
Pg[2] - (V[2] * ((V[1] * ((2.0 * sin(-θ[1] + θ[2])))))) - 0.0 = 0</code></pre><hr/><p>Similarly, the next constraint in the optimization problem is associated with the reactive power balance equation:</p><p class="math-container">\[\begin{aligned}
h_{Q_i}(\mathbf Q_\mathrm{g}, \mathbf V, \bm \Theta) = 0,\;\;\; i \in \mathcal N.
\end{aligned}\]</p><p>As elaborated in the <a href="../powerSystemModel/#BusInjectionsTutorials">Bus Injections</a> section, we can express the equation as follows:</p><p class="math-container">\[h_{Q_i}(\mathbf Q_\mathrm{g}, \mathbf V, \bm \Theta ) = V_i \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_j - \sum_{k \in \mathcal{S}_i} Q_{\mathrm{g}k} + Q_{\mathrm{d}i}.\]</p><p>As mentioned earlier for active power, <span>$Q_{\mathrm{g}k}$</span> represents the reactive power output of the <span>$k$</span>-th generator within the set <span>$\mathcal{S}_i$</span>. The variable <span>$Q_{\mathrm{g}k}$</span> serves as an optimization variable, as well as the bus voltage angles <span>$\theta_{ij} = \theta_i - \theta_j$</span>, and the bus voltage magnitudes <span>$V_i$</span> and <span>$V_j$</span>.</p><p>The constant term is determined by the reactive power demand <span>$Q_{\mathrm{d}i}$</span> at bus <span>$i \in \mathcal{N}$</span>. The values representing this constant term, denoted as <span>$\mathbf{Q}_{\mathrm{d}} = [Q_{\mathrm{d}i}]$</span> can be accessed using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₒ = system.bus.demand.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.01</code></pre><p>We can access the references to the reactive power balance constraints using the following snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.balance.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Qg[1] - (V[1] * ((2 V[1]) + (V[2] * ( - (2.0 * cos(θ[1] - θ[2])))))) - 0.0 = 0
Qg[2] - (V[2] * ((2 V[2]) + (V[1] * ( - (2.0 * cos(-θ[1] + θ[2])))))) - 0.01 = 0</code></pre><hr/><h5 id="Bus-Voltage-Constraints"><a class="docs-heading-anchor" href="#Bus-Voltage-Constraints">Bus Voltage Constraints</a><a id="Bus-Voltage-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Constraints" title="Permalink"></a></h5><p>The inequality constraints associated with the voltage magnitude ensure that the bus voltage magnitudes are within specified limits:</p><p class="math-container">\[V_i^\mathrm{min} \leq V_i \leq V_i^\mathrm{max},\;\;\; i \in \mathcal N,\]</p><p>where <span>$V_i^\mathrm{min}$</span> represents the minimum voltage magnitude, and <span>$V_i^\mathrm{max}$</span> represents the maximum voltage magnitude for bus <span>$i \in \mathcal N$</span>. The values representing these voltage magnitude limits, denoted as <span>$\mathbf V_\mathrm{lm} = [V_i^\mathrm{min}, V_i^\mathrm{max}]$</span> can be accessed using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕ₗₘ = [system.bus.voltage.minMagnitude system.bus.voltage.maxMagnitude]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.95  1.05
 0.95  1.05</code></pre><p>To retrieve this inequality constraint from the model, we can use the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.voltage.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">V[1] ∈ [0.95, 1.05]
V[2] ∈ [0.95, 1.05]</code></pre><hr/><p>The inequality constraint related to the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch is defined as follows:</p><p class="math-container">\[\theta_{ij}^\mathrm{min} \leq \theta_i - \theta_j \leq \theta_{ij}^\mathrm{max},\;\;\; (i,j) \in \mathcal{E},\]</p><p>where <span>$\theta_{ij}^\mathrm{min}$</span> represents the minimum, while <span>$\theta_{ij}^\mathrm{max}$</span> represents the maximum of the angle difference between adjacent buses of the branch <span>$(i,j) \in \mathcal{E}$</span>. The values representing the voltage angle difference, denoted as <span>$\bm \Theta_\mathrm{lm} = [\theta_{ij}^\mathrm{min}, \theta_{ij}^\mathrm{max}]$</span>, are provided as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯ₗₘ = [system.branch.voltage.minDiffAngle system.branch.voltage.maxDiffAngle]</code><code class="nohighlight hljs ansi" style="display:block;">1×2 Matrix{Float64}:
 -3.14159  3.14159</code></pre><p>To retrieve this inequality constraint from the model, we can use the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">θ[1] - θ[2] ∈ [-3.141592653589793, 3.141592653589793]</code></pre><hr/><h5 id="Branch-Flow-Constraints"><a class="docs-heading-anchor" href="#Branch-Flow-Constraints">Branch Flow Constraints</a><a id="Branch-Flow-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Flow-Constraints" title="Permalink"></a></h5><p>The inequality constraints related to the branch flows can be associated with the limits on apparent power flow, active power flow, or current magnitude at the from-bus and to-bus ends of each branch. The type of constraint applied is determined by the <code>type</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function.</p><p>The <code>type</code> value defines the constraint as follows: <code>type = 1</code> applies to active power flow; <code>type = 2</code> and <code>type = 3</code> apply to apparent power flow; and <code>type = 4</code> and <code>type = 5</code> apply to current magnitude. When <code>type = 3</code> or <code>type = 5</code> is selected, squared inequality constraints are used. These constraints typically provide a more numerically robust optimization problem but often result in slower convergence compared to the non-squared versions.</p><p>These constraints are mathematically expressed through the equations <span>$h_{ij}(\mathbf V, \bm \Theta)$</span> and <span>$h_{ji}(\mathbf V, \bm \Theta)$</span>, representing the flow constraints at the from-bus and to-bus ends of each branch, respectively:</p><p class="math-container">\[\begin{aligned}
    F_{ij}^{\mathrm{min}} \leq h_{ij}(\mathbf V, \bm \Theta) \leq F_{ij}^{\mathrm{max}},\;\;\; (i,j) \in \mathcal{E} \\
    F_{ji}^{\mathrm{min}} \leq h_{ji}(\mathbf V, \bm \Theta) \leq F_{ji}^{\mathrm{max}},\;\;\; (i,j) \in \mathcal{E}.
\end{aligned}\]</p><p>The branch flow limits at the from-bus and to-bus ends of the branch <span>$(i,j) \in \mathcal{E}$</span>, denoted as <span>$\mathbf{F}_{\mathrm{f}} = [F_{ij}^\mathrm{min}, F_{ij}^\mathrm{max}]$</span> and <span>$\mathbf{F}_{\mathrm{t}} = [F_{ji}^\mathrm{min}, F_{ji}^\mathrm{max}]$</span>, can be retrieved as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐅ₒ = [system.branch.flow.minFromBus system.branch.flow.maxFromBus]</code><code class="nohighlight hljs ansi" style="display:block;">1×2 Matrix{Float64}:
 0.0  0.15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐅ₜ = [system.branch.flow.minToBus system.branch.flow.maxToBus]</code><code class="nohighlight hljs ansi" style="display:block;">1×2 Matrix{Float64}:
 0.0  0.15</code></pre><hr/><p>The first option is to define the limit keywords for active power flow constraints (<code>type = 1</code>) at the from-bus and to-bus ends of each branch:</p><p class="math-container">\[  \begin{aligned}
    h_{ij}(\mathbf V, \bm \Theta) &amp;= \cfrac{g_{ij} + g_{\mathrm{s}ij}}{\tau_{ij}^2} V_i^2 -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) + b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_i V_j \\
    h_{ji}(\mathbf V, \bm{\Theta}) &amp;= (g_{ij} + g_{\mathrm{s}ij}) V_j^2 -
    \cfrac{1}{\tau_{ij}} \left[g_{ij} \cos(\theta_{ij} - \phi_{ij}) - b_{ij} \sin(\theta_{ij}- \phi_{ij})\right] V_i V_j.
  \end{aligned}\]</p><p>In our example, we have chosen to utilize this type of flow constraints. To access the flow constraints of branches at the from-bus end, users can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.flow.from)</code><code class="nohighlight hljs ansi" style="display:block;"> - ((V[1]*V[2]) * ((-2.0 * sin(θ[1] - θ[2])))) ∈ [0, 0.15]</code></pre><p>Similarly, to access the to-bus end flow constraints of branches users can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.flow.to)</code><code class="nohighlight hljs ansi" style="display:block;"> - ((V[1]*V[2]) * ( - (-2.0 * sin(θ[1] - θ[2])))) ∈ [0, 0.15]</code></pre><hr/><p>The second option applies constraints to the apparent power flow (<code>type = 2</code>). This constraint at the from-bus is specified as:</p><p class="math-container">\[    h_{ij}(\mathbf V, \bm \Theta) =
    \sqrt{A_{ij} V_i^4 + B_{ij} V_i^2 V_j^2 - 2 [C_{ij} \cos(\theta_{ij} - \phi_{ij}) - D_{ij} \sin(\theta_{ij} - \phi_{ij})] V_i^3 V_j},\]</p><p>where:</p><p class="math-container">\[  \begin{gathered}
    A_{ij} = \cfrac{(g_{ij} + g_{\mathrm{s}i})^2 + (b_{ij} + b_{\mathrm{s}i})^2}{\tau_{ij}^4}, \;\;\;
    B_{ij} = \cfrac{g_{ij}^2 + b_{ij}^2}{\tau_{ij}^2} \\
    C_{ij} = \cfrac{g_{ij}(g_{ij} + g_{\mathrm{s}i}) + b_{ij}(b_{ij} + b_{\mathrm{s}i})}{\tau_{ij}^3}, \;\;\;
    D_{ij} = \cfrac{g_{ij}b_{\mathrm{s}i} - b_{ij}g_{\mathrm{s}i}}{\tau_{ij}^3}.
  \end{gathered}\]</p><p>Furthermore, this constraint at the to-bus is specified as:</p><p class="math-container">\[    h_{ji}(\mathbf {V}, \bm{\Theta}) =
    \sqrt{A_{ji} V_j^4 + B_{ji} V_i^2 V_j^2 - 2 [C_{ji} \cos(\theta_{ij} - \phi_{ij}) + D_{ji} \sin(\theta_{ij} - \phi_{ij})] V_i V_j^3  },\]</p><p>where:</p><p class="math-container">\[  \begin{gathered}
    A_{ji} = (g_{ij} + g_{\mathrm{s}i})^2 + (b_{ij} + b_{\mathrm{s}i})^2, \;\;\;
    B_{ji} = \cfrac{g_{ij}^2 + b_{ij}^2}{\tau_{ij}^2} \\
    C_{ji} = \cfrac{g_{ij}(g_{ij} + g_{\mathrm{s}i}) + b_{ij}(b_{ij} + b_{\mathrm{s}i})}{\tau_{ij}}, \;\;\;
    D_{ji} = \cfrac{g_{ij}b_{\mathrm{s}i} - b_{ij}g_{\mathrm{s}i}}{\tau_{ij}}.
  \end{gathered}\]</p><p>If users choose <code>type = 3</code>, it means that the equations are squared (i.e., the square root is omitted), and the limit values will also be squared accordingly.</p><hr/><p>The last option involves defining the limit keywords for current magnitude constraints (<code>type = 4</code>) at the from-bus and to-bus ends of each branch. In this case, the constraints are implemented as follows:</p><p class="math-container">\[  \begin{aligned}
    h_{ij}(\mathbf V, \bm \Theta) &amp;= \sqrt{A_{ij}V_i^2 + B_{ij}V_j^2 - 2[C_{ij} \cos(\theta_{ij} - \phi_{ij}) - D_{ij}\sin(\theta_{ij} - \phi_{ij})] V_iV_j} \\
    h_{ji}(\mathbf V, \bm \Theta) &amp;= \sqrt{A_{ji}V_j^2 + B_{ji}V_i^2 - 2[C_{ji} \cos(\theta_{ij} - \phi_{ij}) + D_{ji}\sin(\theta_{ij} - \phi_{ij})] V_iV_j}.
  \end{aligned}\]</p><p>If users choose <code>type = 5</code>, it means that the equations are squared (i.e., the square root is omitted), and the limit values will also be squared accordingly.</p><hr/><h5 id="ACPowerCapabilityConstraintsTutorials"><a class="docs-heading-anchor" href="#ACPowerCapabilityConstraintsTutorials">Generator Power Capability Constraints</a><a id="ACPowerCapabilityConstraintsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerCapabilityConstraintsTutorials" title="Permalink"></a></h5><p>The next set of constraints pertains to the minimum and maximum limits of active and reactive power outputs of the generators. These constraints ensure that the power outputs of the generators remain within specified bounds:</p><p class="math-container">\[P_{\mathrm{g}i}^\mathrm{min} \leq P_{\mathrm{g}i} \leq P_{\mathrm{g}i}^\mathrm{max} ,\;\;\; i \in \mathcal{S}.\]</p><p>In this representation, the lower and upper limits are determined by the vector <span>$\mathbf P_\mathrm{m} = [P_{\mathrm{g}i}^\mathrm{min}, P_{\mathrm{g}i}^\mathrm{max}]$</span>, <span>$i \in \mathcal{S}$</span>. We can access these bounds using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₘ = [system.generator.capability.minActive, system.generator.capability.maxActive]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{Float64}}:
 [0.0, 0.0]
 [0.5, 0.5]</code></pre><p>To access these constraints, you can utilize the following snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Pg[1] ∈ [0, 0.5]
Pg[2] ∈ [0, 0.5]</code></pre><hr/><p>Similarly, constraints related to the minimum and maximum limits of reactive power outputs of the generators ensure that the reactive powers remain within specified boundaries:</p><p class="math-container">\[Q_{\mathrm{g}i}^\mathrm{min} \leq Q_{\mathrm{g}i} \leq Q_{\mathrm{g}i}^\mathrm{max} ,\;\;\; i \in \mathcal{S}.\]</p><p>Thus, the lower and upper limits are determined by the vector <span>$\mathbf Q_\mathrm{m} = [Q_{\mathrm{g}i}^\mathrm{min}, Q_{\mathrm{g}i}^\mathrm{max}]$</span>, <span>$i \in \mathcal S$</span>. We can access these bounds using the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₘ = [system.generator.capability.minReactive system.generator.capability.maxReactive]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 -0.1  0.1
 -0.1  0.1</code></pre><p>To access these constraints, you can use the following snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(analysis.method.constraint.capability.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Qg[1] ∈ [-0.1, 0.1]
Qg[2] ∈ [-0.1, 0.1]</code></pre><hr/><p>These capability limits of the generators define the feasible region, represented as a gray area in Figure 3, which forms the solution space for the active and reactive output powers of the generators.</p><div style="text-align: center;">
    <img src="../../assets/tutorials/acOptimalPowerFlow/pq_curve.svg" width="350" class="my-svg"/>
    <p>Figure 3: Feasible region defined by power capability constraints.</p>
</div>
&nbsp;<p>However, this representation might not be the most accurate depiction of the generator&#39;s output power behavior. In reality, there exists a tradeoff between the active and reactive power outputs of the generators [<a href="../../background/bibliography/#zimmerman2016matpower">8</a>]. Specifically, when a generator operates at its maximum active power <span>$P_{\mathrm{g}i}^\mathrm{max}$</span>, it may not be able to produce the maximum <span>$Q_{\mathrm{g}i}^\mathrm{max}$</span> or minimum <span>$Q_{\mathrm{g}i}^\mathrm{min}$</span> reactive power. To capture this tradeoff, we introduce the ability to include additional upper and lower constraints on the feasible region, leading to its reduction as shown in Figure 4.</p><div style="text-align: center;">
    <img src="../../assets/tutorials/acOptimalPowerFlow/pq_curve_sloped.svg" width="350" class="my-svg"/>
    <p>Figure 4: Feasible region defined by power capability and boundary constraints.</p>
</div>
&nbsp;<p>If a user wishes to incorporate the tradeoff between active and reactive power outputs into the optimization model, they can define the points shown in Figure 4 within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function using the following keywords:</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Coordinate</th></tr><tr><td style="text-align: left"><code>lowActive</code></td><td style="text-align: left"><span>$P_{\mathrm{g}i}^\mathrm{low}$</span></td></tr><tr><td style="text-align: left"><code>minLowReactive</code></td><td style="text-align: left"><span>$Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{min}$</span></td></tr><tr><td style="text-align: left"><code>maxLowReactive</code></td><td style="text-align: left"><span>$Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{max}$</span></td></tr><tr><td style="text-align: left"><code>upActive</code></td><td style="text-align: left"><span>$P_{\mathrm{g}i}^\mathrm{up}$</span></td></tr><tr><td style="text-align: left"><code>minUpReactive</code></td><td style="text-align: left"><span>$Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{min}$</span></td></tr><tr><td style="text-align: left"><code>maxUpReactive</code></td><td style="text-align: left"><span>$Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{max}$</span></td></tr></table><p>When using these points, JuliaGrid constructs two additional capability constraints per generator as follows:</p><p class="math-container">\[\begin{aligned}
    (Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{max} - Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{max})P_{\mathrm{g}i} +
    (P_{\mathrm{g}i}^\mathrm{up} - P_{\mathrm{g}i}^\mathrm{low})Q_{\mathrm{g}i}
    \leq (Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{max} - Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{max})P_{\mathrm{g}i}^\mathrm{low} +
    (P_{\mathrm{g}i}^\mathrm{up} - P_{\mathrm{g}i}^\mathrm{low})Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{max} \\
    (Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{min} - Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{min})P_{\mathrm{g}i} +
    (P_{\mathrm{g}i}^\mathrm{low} - P_{\mathrm{g}i}^\mathrm{up})Q_{\mathrm{g}i}
    \leq (Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{min} - Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{min})P_{\mathrm{g}i}^\mathrm{low} +
    (P_{\mathrm{g}i}^\mathrm{low} - P_{\mathrm{g}i}^\mathrm{up})Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{min}.
\end{aligned}\]</p><p>To ensure numerical stability, these constraints are normalized by introducing two scaling factors:</p><p class="math-container">\[\begin{aligned}
    s_1 = \sqrt{(Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{max} - Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{max})^2 +
    (P_{\mathrm{g}i}^\mathrm{up} - P_{\mathrm{g}i}^\mathrm{low})^2}\\
    s_2 = \sqrt{(Q_{\mathrm{g}i,\mathrm{up}}^\mathrm{min} - Q_{\mathrm{g}i,\mathrm{low}}^\mathrm{min})^2 +
    (P_{\mathrm{g}i}^\mathrm{low} - P_{\mathrm{g}i}^\mathrm{up})^2}.
\end{aligned}\]</p><p>When these constraints exist in the system, users can access them using the following variables:</p><pre><code class="language-julia hljs">analysis.method.constraint.capability.upper
analysis.method.constraint.capability.lower</code></pre><p>These additional capability constraints allow us to accurately represent the tradeoff between active and reactive power outputs of the generators while maintaining numerical stability.</p><hr/><h2 id="ACOptimalPowerFlowSolutionTutorials"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowSolutionTutorials">Optimal Power Flow Solution</a><a id="ACOptimalPowerFlowSolutionTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowSolutionTutorials" title="Permalink"></a></h2><p>To obtain the optimal values of active and reactive power outputs for generators and the bus voltage magnitudes and angles, the user needs to invoke the following function:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>After solving the AC optimal power flow problem, you can retrieve the vectors of output active and reactive power for generators, denoted as <span>$\mathbf P_\mathrm{g} = [P_{\mathrm{g}i}]$</span> and <span>$\mathbf Q_\mathrm{g} = [Q_{\mathrm{g}i}]$</span>, where <span>$i \in \mathcal S$</span>, using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = analysis.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.09999999002060665
 9.979393361456854e-9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₒ = analysis.power.generator.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.0863265171095855
  0.09999999755725082</code></pre><p>Similarly, the resulting bus voltage magnitudes and angles, represented by <span>$\mathbf V = [V_i]$</span> and <span>$\bm \Theta = [\theta_i]$</span>, where <span>$i \in \mathcal N$</span>, are stored in the vectors as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.0071411833198654
 1.0499983906951869</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.1
 -0.0999999952815312</code></pre><p>By accessing these vectors, you can analyze and utilize the optimal power flow solution for further studies or operational decision-making in the power system.</p><hr/><h2 id="ACOptimalPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#ACOptimalPowerAnalysisTutorials">Power Analysis</a><a id="ACOptimalPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerAnalysisTutorials" title="Permalink"></a></h2><p>Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function, which enables the calculation of powers associated with buses and branches. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><p>The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses and branches:</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Power</th><th style="text-align: left">Active</th><th style="text-align: left">Reactive</th></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf P = [P_i]$</span></td><td style="text-align: left"><span>$\mathbf Q = [Q_i]$</span></td></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="#OptGeneratorPowerInjectionsManual">Generator injections</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{p} = [P_{\mathrm{p}i}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{p} = [Q_{\mathrm{p}i}]$</span></td></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusShuntElementTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{sh} = [P_{\mathrm{sh}i}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{sh} = [Q_{\mathrm{sh}i}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{i} = [P_{ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{i} = [Q_{ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{j} = [P_{ji}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{j} = [Q_{ji}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchShuntElementsTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{s} = [P_{\mathrm{s}ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{s} = [Q_{\mathrm{s}ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{l} = [P_{\mathrm{l}ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{l} = [Q_{\mathrm{l}ij}]$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusInjectionsTutorials">Active and reactive power injections</a> are stored as the vectors <span>$\mathbf P = [P_i]$</span> and <span>$\mathbf Q = [Q_i]$</span>, respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏 = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -9.979529558626354e-9
  9.979529558626354e-9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐 = analysis.power.injection.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.08632651709953175
  0.08999999754755438</code></pre><hr/><h5 id="OptGeneratorPowerInjectionsManual"><a class="docs-heading-anchor" href="#OptGeneratorPowerInjectionsManual">Generator Power Injections</a><a id="OptGeneratorPowerInjectionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#OptGeneratorPowerInjectionsManual" title="Permalink"></a></h5><p>The <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function in JuliaGrid also provides the computation of active and reactive power injections from the generators at each bus. To calculate the active power supplied by generators to the buses, one can simply sum the active power outputs of the generators obtained from the AC optimal power flow. This can be represented as:</p><p class="math-container">\[    P_{\mathrm{p}i} = \sum_{k \in \mathcal S_i} P_{\mathrm{g}k},\;\;\; i \in \mathcal N,\]</p><p>where the set <span>$\mathcal{S}_i \subseteq \mathcal S$</span> encompasses all generators connected to bus <span>$i \in \mathcal N$</span>. The active power injections from the generators at each bus are stored as a vector denoted by <span>$\mathbf P_\mathrm{p} = [P_{\mathrm{p}i}]$</span>, and can be obtained using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₚ = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.09999999002060665
 9.979393361456854e-9</code></pre><p>Similarly, we can obtain the reactive power supplied by generators to the buses:</p><p class="math-container">\[    Q_{\mathrm{p}i} = \sum_{k \in \mathcal S_i} Q_{\mathrm{g}k},\;\;\; i \in \mathcal N.\]</p><p>The vector of these reactive power injections by the generators to the buses, denoted by <span>$\mathbf Q_\mathrm{p} = [Q_{\mathrm{p}i}]$</span>, can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₚ = analysis.power.supply.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.0863265171095855
  0.09999999755725082</code></pre><hr/><h5 id="Power-at-Bus-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Bus-Shunt-Elements">Power at Bus Shunt Elements</a><a id="Power-at-Bus-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Bus-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusShuntElementTutorials">Active and reactive powers</a> associated with the shunt elements at each bus are represented by the vectors <span>$\mathbf P_\mathrm{sh} = [P_{\mathrm{sh}i}]$</span> and <span>$\mathbf Q_\mathrm{sh} = [Q_{\mathrm{sh}i}]$</span>. To retrieve these powers in JuliaGrid, use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛₕ = analysis.power.shunt.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₛₕ = analysis.power.shunt.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.0
 -0.0</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at each from-bus end are stored as the vectors <span>$\mathbf P_\mathrm{i} = [P_{ij}]$</span> and <span>$\mathbf Q_\mathrm{i} = [Q_{ij}],$</span> respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ᵢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 -9.979529558626354e-9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ᵢ = analysis.power.from.reactive</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 -0.08632651709953175</code></pre><p>Similarly, the vectors of <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at each to-bus end are stored as <span>$\mathbf P_\mathrm{j} = [P_{ji}]$</span> and <span>$\mathbf Q_\mathrm{j} = [Q_{ji}]$</span>, respectively, and can be retrieved using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ⱼ = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 9.979529558626354e-9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ⱼ = analysis.power.to.reactive</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.08999999754755438</code></pre><hr/><h5 id="Power-at-Branch-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Shunt-Elements">Power at Branch Shunt Elements</a><a id="Power-at-Branch-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchShuntElementsTutorials">Active and reactive powers</a> associated with the branch shunt elements at each branch are represented by the vectors <span>$\mathbf P_\mathrm{s} = [P_{\mathrm{s}ij}]$</span> and <span>$\mathbf Q_\mathrm{s} = [Q_{\mathrm{s}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛ = analysis.power.charging.active</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₛ = analysis.power.charging.reactive</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 -0.0</code></pre><hr/><h5 id="Power-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Series-Elements">Power at Branch Series Elements</a><a id="Power-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Series-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchSeriesElementTutorials">Active and reactive powers</a> associated with the branch series element at each branch are represented by the vectors <span>$\mathbf P_\mathrm{l} = [P_{\mathrm{l}ij}]$</span> and <span>$\mathbf Q_\mathrm{l} = [Q_{\mathrm{l}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₗ = analysis.power.series.active</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₗ = analysis.power.series.reactive</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.003673480448022624</code></pre><hr/><h2 id="Current-Analysis"><a class="docs-heading-anchor" href="#Current-Analysis">Current Analysis</a><a id="Current-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Analysis" title="Permalink"></a></h2><p>JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.current!-Tuple{AC}"><code>current!</code></a> function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">current!(analysis)</code></pre><p>The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Current</th><th style="text-align: left">Magnitude</th><th style="text-align: left">Angle</th></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf I = [I_i]$</span></td><td style="text-align: left"><span>$\bm \psi = [\psi_i]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{i} = [I_{ij}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{i} = [\psi_{ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{j} = [I_{ji}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{j} = [\psi_{ji}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{l} = [I_{\mathrm{l}ij}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{l} = [\psi_{\mathrm{l}ij}]$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Current-Injections"><a class="docs-heading-anchor" href="#Current-Injections">Current Injections</a><a id="Current-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injections" title="Permalink"></a></h5><p>In JuliaGrid, <a href="../powerSystemModel/#BusInjectionsTutorials">complex current injections</a> are stored in the vector of magnitudes denoted as <span>$\mathbf I = [I_i]$</span> and the vector of angles represented as <span>$\bm \psi = [\psi_i]$</span>. You can retrieve them using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈 = analysis.current.injection.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.08571441475064301
 0.08571441475064301</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙 = analysis.current.injection.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  1.4707964423970301
 -1.6707962111927632</code></pre><hr/><h5 id="Current-Flows"><a class="docs-heading-anchor" href="#Current-Flows">Current Flows</a><a id="Current-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flows" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf I_\mathrm{i} = [I_{ij}]$</span> and angles <span>$\bm \psi_\mathrm{i} = [\psi_{ij}]$</span> for the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a>, you can use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ᵢ = analysis.current.from.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.08571441475064301</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ᵢ = analysis.current.from.angle</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 1.4707964423970301</code></pre><p>Similarly, we can obtain the vectors of magnitudes <span>$\mathbf I_\mathrm{j} = [I_{ji}]$</span> and angles <span>$\bm \psi_\mathrm{j} = [\psi_{ji}]$</span> of the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a> using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ⱼ = analysis.current.to.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.08571441475064301</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ⱼ = analysis.current.to.angle</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 -1.6707962111927632</code></pre><hr/><h5 id="Current-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Current-at-Branch-Series-Elements">Current at Branch Series Elements</a><a id="Current-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Current-at-Branch-Series-Elements" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf I_\mathrm{l} = [I_{\mathrm{l}ij}]$</span> and angles <span>$\bm \psi_\mathrm{l} = [\psi_{\mathrm{l}ij}]$</span> of the resulting <a href="../powerSystemModel/#BranchSeriesElementTutorials">complex current flows</a>, one can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ₗ = analysis.current.series.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 0.08571441475064301</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ₗ = analysis.current.series.angle</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Float64}:
 1.4707964423970301</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcPowerFlow/">« DC Power Flow</a><a class="docs-footer-nextpage" href="../dcOptimalPowerFlow/">DC Optimal Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Wednesday 28 May 2025 13:51">Wednesday 28 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
