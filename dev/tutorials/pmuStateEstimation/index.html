<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PMU State Estimation ¬∑ JuliaGrid</title><meta name="title" content="PMU State Estimation ¬∑ JuliaGrid"/><meta property="og:title" content="PMU State Estimation ¬∑ JuliaGrid"/><meta property="twitter:title" content="PMU State Estimation ¬∑ JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li class="is-active"><a class="tocitem" href>PMU State Estimation</a><ul class="internal"><li><a class="tocitem" href="#PMUSEModelTutorials"><span>State Estimation Model</span></a></li><li><a class="tocitem" href="#PMUSEWLSStateEstimationTutorials"><span>Weighted Least-Squares Estimation</span></a></li><li><a class="tocitem" href="#PMUSEBadDataTutorials"><span>Bad Data Processing</span></a></li><li><a class="tocitem" href="#PMUSELAVTutorials"><span>Least Absolute Value Estimation</span></a></li><li><a class="tocitem" href="#optimalpmu"><span>Optimal PMU Placement</span></a></li><li><a class="tocitem" href="#PMUPowerAnalysisTutorials"><span>Power Analysis</span></a></li><li><a class="tocitem" href="#PMUCurrentAnalysisTutorials"><span>Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Power and Current Analysis</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>PMU State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PMU State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/pmuStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PMUStateEstimationTutorials"><a class="docs-heading-anchor" href="#PMUStateEstimationTutorials">PMU State Estimation</a><a id="PMUStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUStateEstimationTutorials" title="Permalink"></a></h1><p>To initiate the process, let us construct the <code>PowerSystem</code> type and formulate the AC model:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5)
addBus!(system; label = 2, type = 1, reactive = 0.3)
addBus!(system; label = 3, type = 1, active = 0.5)

@branch(resistance = 0.02, susceptance = 0.04)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.6)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.7)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.2)

addGenerator!(system; label = 1, bus = 1, active = 3.2, reactive = 0.2)

acModel!(system)</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùí© = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ∞ = [ùí©[system.branch.layout.from] ùí©[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">3√ó2 Matrix{String}:
 &quot;1&quot;  &quot;2&quot;
 &quot;1&quot;  &quot;3&quot;
 &quot;2&quot;  &quot;3&quot;</code></pre><hr/><p>Following that, we will introduce the <code>Measurement</code> type and incorporate a set of PMUs <span>$\mathcal{M} \equiv \bar{\mathcal{P}}$</span> into the graph <span>$\mathcal{G}$</span>, that capture both bus voltage and branch current phasors. To construct the linear PMU state estimation model, we represent the vector of state variables, as well as phasor measurements, in the rectangular coordinate system. This process of adding measurement devices will be carried out in the <a href="#PMUSEModelTutorials">State Estimation Model</a> section. Currently, we are only initializing the <code>Measurement</code> type:</p><pre><code class="language-julia hljs">device = measurement()</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Here, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element related with bus <span>$i \in \mathcal{N}$</span> or measurement <span>$i \in \mathcal{M}$</span>, while <span>$a_{ij}$</span> denotes the element related with branch <span>$(i,j) \in \mathcal{E}$</span>.</p></div></div><hr/><h2 id="PMUSEModelTutorials"><a class="docs-heading-anchor" href="#PMUSEModelTutorials">State Estimation Model</a><a id="PMUSEModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUSEModelTutorials" title="Permalink"></a></h2><p>Initially, PMUs output phasor measurements in polar coordinates. However, these measurements can be interpreted in rectangular coordinates, where the real and imaginary parts of bus voltages and branch current phasors serve as measurements. Additionally, to obtain the linear system of equations, we observe a vector of state variables in rectangular coordinates <span>$\mathbf x \equiv[\mathbf{V}_\text{re},\mathbf{V}_\text{im}]$</span>:</p><ul><li><span>$\mathbf{V}_\mathrm{re} =\big[\Re(\bar{V}_1),\dots,\Re(\bar{V}_n)\big]^T$</span>, representing the real parts of complex bus voltages,</li><li><span>$\mathbf{V}_\mathrm{im} =\big[\Im(\bar{V}_1),\dots,\Im(\bar{V}_n)\big]^T$</span>, representing the imaginary parts of complex bus voltages.</li></ul><p>Consequently, the total number of state variables is <span>$2n$</span>. It is worth noting that in this approach to state estimation, we do not require the slack bus.</p><p>The primary drawback of this method stems from measurement errors, which are associated with polar coordinates. Consequently, the covariance matrix must be transformed from polar to rectangular coordinates. As a result, errors from a single PMU are correlated, leading to a non-diagonal covariance matrix. Despite this, the covariance matrix is commonly treated as diagonal, impacting the state estimation accuracy in such scenarios.</p><p>Hence, the model includes real and imaginary parts of bus voltage and current phasor measurements from the set <span>$\mathcal{M}$</span>, contributing to the formulation of a linear system of equations:</p><p class="math-container">\[  \mathbf{z}=\mathbf{h}(\mathbf x) + \mathbf{u}.\]</p><p>Here, <span>$\mathbf{h}(\mathbf {x})= [h_1(\mathbf {x})$</span>, <span>$\dots$</span>, <span>$h_k(\mathbf {x})]^{{T}}$</span> represents the vector of linear measurement functions, where <span>$k = 2|\bar{\mathcal{P}}|$</span> is the number of measurement functions, <span>$\mathbf{z} = [z_1,\dots,z_k]^{T}$</span> denotes the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^T$</span> represents the vector of measurement errors.</p><p>These errors are assumed to follow a Gaussian distribution with a zero mean and covariance matrix <span>$\bm \Sigma$</span>. The diagonal elements of <span>$\bm \Sigma$</span> correspond to the measurement variances <span>$\mathbf{v} = [v_1,\dots,v_k]^T$</span>, while the off-diagonal elements represent the covariances between the measurement errors <span>$\mathbf{w} = [w_1,\dots,w_k]^{T}$</span>.</p><p>In summary, upon defining the PMU, each <span>$i$</span>-th PMU is associated with two measurement functions <span>$h_{2i-1}(\mathbf x)$</span>, <span>$h_{2i}(\mathbf x)$</span>, along with their respective measurement values <span>$z_{2i-1}$</span>, <span>$z_{2i}$</span>, as well as their variances <span>$v_{2i-1}$</span>, <span>$v_{2i}$</span>, and possibly covariances <span>$w_{2i-1}$</span>, <span>$w_{2i}$</span>.</p><hr/><h5 id="Bus-Voltage-Phasor-Measurements"><a class="docs-heading-anchor" href="#Bus-Voltage-Phasor-Measurements">Bus Voltage Phasor Measurements</a><a id="Bus-Voltage-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Phasor-Measurements" title="Permalink"></a></h5><p>When a PMU <span>$(V_i, \theta_i) \in \bar{\mathcal{P}}$</span> is introduced at bus <span>$i \in \mathcal{N}$</span> in this type of state estimation, users specify the measurement values, variances, and measurement functions of vectors as follows:</p><p class="math-container">\[    \mathbf{z} = [z_{\Re(\bar{V}_{i})}, z_{\Im(\bar{V}_{i})}], \;\;\; \mathbf{v} = [v_{\Re(\bar{V}_{i})}, v_{\Im(\bar{V}_{i})}], \;\;\; \mathbf{h}(\mathbf {x}) = [h_{\Re(\bar{V}_{i})}(\mathbf {x}), h_{\Im(\bar{V}_{i})}(\mathbf {x})].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;V‚ÇÇ, Œ∏‚ÇÇ&quot;, bus = 2, magnitude = 0.9, angle = -0.1,
varianceMagnitude = 1e-5, varianceAngle = 1e-5)</code></pre><p>Here, measurement values are obtained according to:</p><p class="math-container">\[  \begin{aligned}
    z_{\Re(\bar{V}_i)} = z_{V_i} \cos z_{\theta_i}\\
    z_{\Im(\bar{V}_i)} = z_{V_i} \sin z_{\theta_i}.
  \end{aligned}\]</p><p>Utilizing the classical theory of propagation of uncertainty [<a href="../../background/bibliography/#iso1993guide">16</a>], the variances can be calculated as follows:</p><p class="math-container">\[  \begin{aligned}
    v_{\Re(\bar{V}_i)} &amp;=
    v_{V_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \cos z_{\theta_i}) \right]^2 +
    v_{\theta_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \cos z_{\theta_i})\right]^2 =
    v_{V_i} (\cos z_{\theta_i})^2 + v_{\theta_i} (z_{V_i} \sin z_{\theta_i})^2\\
    v_{\Im(\bar{V}_i)} &amp;=
     v_{V_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \sin z_{\theta_i}) \right]^2 +
    v_{\theta_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \sin z_{\theta_i})\right]^2 =
    v_{V_i} (\sin z_{\theta_i})^2 + v_{\theta_i} (z_{V_i} \cos z_{\theta_i})^2.
  \end{aligned}\]</p><p>Lastly, the functions defining the bus voltage phasor measurement are:</p><p class="math-container">\[  \begin{aligned}
    h_{\Re(\bar{V}_i)}(\mathbf x) &amp;= \Re(\bar{V}_i)\\
    h_{\Im(\bar{V}_i)}(\mathbf x) &amp;= \Im(\bar{V}_i).
  \end{aligned}\]</p><p>The coefficient expressions for measurement functions are as follows:</p><p class="math-container">\[  \cfrac{\mathrm \partial{h_{\Re(\bar{V}_i)}(\mathbf x)}}{\mathrm \partial \Re(\bar{V}_i)}=1, \;\;\;
  \cfrac{\mathrm \partial{h_{\Im(\bar{V}_i)}(\mathbf x)}}{\mathrm \partial \Im(\bar{V}_i)}=1.\;\;\;\]</p><p>In the previous example, the user neglected the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:</p><p class="math-container">\[    \mathbf{w} = [w_{\Re(\bar{V}_{i})}, w_{\Im(\bar{V}_{i})}].\]</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;V‚ÇÉ, Œ∏‚ÇÉ&quot;, bus = 3, magnitude = 0.9, angle = -0.2,
varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true)</code></pre><p>Then, the covariances are obtained as follows:</p><p class="math-container">\[    w_{\Re(\bar{V}_{i})} = w_{\Im(\bar{V}_{i})} =
    v_{V_i} \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \cos z_{\theta_i})
    \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \sin z_{\theta_i})  +
    v_{\theta_i} \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \cos z_{\theta_i})
    \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \sin z_{\theta_i}),\]</p><p>which results in the solution:</p><p class="math-container">\[    w_{\Re(\bar{V}_{i})} = w_{\Im(\bar{V}_{i})} = \cos z_{\theta_i} \sin z_{\theta_i}(v_{V_i} - v_{\theta_i} z_{V_i}^2).\]</p><hr/><h5 id="From-Bus-End-Current-Phasor-Measurements"><a class="docs-heading-anchor" href="#From-Bus-End-Current-Phasor-Measurements">From-Bus End Current Phasor Measurements</a><a id="From-Bus-End-Current-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#From-Bus-End-Current-Phasor-Measurements" title="Permalink"></a></h5><p>If the user chooses to include phasor measurement <span>$(I_{ij}, \psi_{ij}) \in \bar{\mathcal{P}}$</span> in the state estimation model, the user will specify the measurement values, variances, and measurement functions of vectors:</p><p class="math-container">\[    \mathbf{z} = [z_{\Re(\bar{I}_{ij})}, z_{\Im(\bar{I}_{ij})}], \;\;\; \mathbf{v} = [v_{\Re(\bar{I}_{ij})}, v_{\Im(\bar{I}_{ij})}], \;\;\; \mathbf{h}(\mathbf {x}) = [h_{\Re(\bar{I}_{ij})}(\mathbf {x}), h_{\Im(\bar{I}_{ij})}(\mathbf {x})].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;I‚ÇÇ‚ÇÉ, œà‚ÇÇ‚ÇÉ&quot;, from = 3, magnitude = 0.3, angle = 0.4,
varianceMagnitude = 1e-3, varianceAngle = 1e-4)</code></pre><p>Here, measurement values are obtained according to:</p><p class="math-container">\[  \begin{aligned}
    z_{\Re(\bar{I}_{ij})} = z_{I_{ij}} \cos z_{\psi_{ij}}\\
    z_{\Im(\bar{I}_{ij})} = z_{I_{ij}} \sin z_{\psi_{ij}}.
  \end{aligned}\]</p><p>Utilizing the classical theory of propagation of uncertainty [<a href="../../background/bibliography/#iso1993guide">16</a>], the variances can be calculated as follows:</p><p class="math-container">\[  \begin{aligned}
    v_{\Re(\bar{I}_{ij})} &amp; = v_{I_{ij}} (\cos z_{\psi_{ij}})^2 + v_{\psi_{ij}} (z_{I_{ij}} \sin z_{\psi_{ij}})^2 \\
    v_{\Im(\bar{I}_{ij})} &amp;= v_{I_{ij}} (\sin z_{\psi_{ij}})^2 + v_{\psi_{ij}} (z_{I_{ij}} \cos z_{\psi_{ij}})^2.
  \end{aligned}\]</p><p>The functions defining the current phasor measurement at the from-bus end are:</p><p class="math-container">\[  \begin{aligned}
    h_{\Re(\bar{I}_{ij})}(\mathbf x) &amp;= A \Re(\bar{V}_i) - B \Im(\bar{V}_i) - \left(C \cos\phi_{ij} - D \sin \phi_{ij}\right) \Re(\bar{V}_j) + \left(C\sin \phi_{ij} + D\cos \phi_{ij} \right) \Im(\bar{V}_j) \\
    h_{\Im(\bar{I}_{ij})}(\mathbf x) &amp;= B \Re(\bar{V}_i) + A \Im(\bar{V}_i) - \left(C \sin \phi_{ij} + D \cos\phi_{ij}\right) \Re(\bar{V}_j) - \left(C\cos \phi_{ij} - D\sin \phi_{ij} \right)\Im(\bar{V}_j),
  \end{aligned}\]</p><p>where:</p><p class="math-container">\[  \begin{aligned}
    A = \cfrac{g_{ij} + g_{\text{s}ij}}{\tau_{ij}^2},\;\;\;
    B = \cfrac{b_{ij}+b_{\text{s}ij}} {\tau_{ij}^2},\;\;\;
    C = \cfrac{g_{ij}}{\tau_{ij}},\;\;\;
    D = \cfrac{b_{ij}}{\tau_{ij}}.
  \end{aligned}\]</p><p>The coefficient expressions for measurement functions are as follows:</p><p class="math-container">\[  \begin{aligned}
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \Re(\bar{V}_i)} &amp;=
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \Im(\bar{V}_i)} = A \\
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}} {\mathrm \partial \Re(\bar{V}_j)} &amp;=
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}} {\mathrm \partial \Im(\bar{V}_j)} =
  - \left(C \cos\phi_{ij} - D \sin \phi_{ij}\right)\\
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \Im(\bar{V}_i)} &amp;=-
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \Re(\bar{V}_i)} =
  -B \\
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \Im(\bar{V}_j)} &amp;= -
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial\Re(\bar{V}_j)} =
  \left(C\sin \phi_{ij} + D \cos \phi_{ij} \right).
  \end{aligned}\]</p><p>In the previous example, the user neglects the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:</p><p class="math-container">\[    \mathbf{w} = [w_{\Re(\bar{I}_{ij})}, w_{\Im(\bar{I}_{ij})}].\]</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;I‚ÇÅ‚ÇÉ, œà‚ÇÅ‚ÇÉ&quot;, from = 2, magnitude = 0.3, angle = -0.5,
varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true)</code></pre><p>Then, the covariances are obtained as follows:</p><p class="math-container">\[   w_{\Re(\bar{I}_{ij})} = w_{\Im(\bar{I}_{ij})} = \sin z_{\psi_{ij}} \cos z_{\psi_{ij}}(v_{I_{ij}}  - v_{\psi_{ij}} z_{I_{ij}}^2).\]</p><hr/><h5 id="To-Bus-End-Current-Phasor-Measurements"><a class="docs-heading-anchor" href="#To-Bus-End-Current-Phasor-Measurements">To-Bus End Current Phasor Measurements</a><a id="To-Bus-End-Current-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#To-Bus-End-Current-Phasor-Measurements" title="Permalink"></a></h5><p>If the user chooses to include phasor measurement <span>$(I_{ji}, \psi_{ji}) \in \bar{\mathcal{P}}$</span> in the state estimation model, the user will specify the measurement values, variances, and measurement functions of vectors:</p><p class="math-container">\[    \mathbf{z} = [z_{\Re(\bar{I}_{ji})}, z_{\Im(\bar{I}_{ji})}], \;\;\; \mathbf{v} = [v_{\Re(\bar{I}_{ji})}, v_{\Im(\bar{I}_{ji})}], \;\;\; \mathbf{h}(\mathbf {x}) = [h_{\Re(\bar{I}_{ji})}(\mathbf {x}), h_{\Im(\bar{I}_{ji})}(\mathbf {x})].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;I‚ÇÉ‚ÇÇ, œà‚ÇÉ‚ÇÇ&quot;, to = 3, magnitude = 0.3, angle = -2.9,
varianceMagnitude = 1e-5, varianceAngle = 1e-5)</code></pre><p>Here, measurement values are obtained according to:</p><p class="math-container">\[  \begin{aligned}
    z_{\Re(\bar{I}_{ji})} = z_{I_{ji}} \cos z_{\psi_{ji}}\\
    z_{\Im(\bar{I}_{ji})} = z_{I_{ji}} \sin z_{\psi_{ji}}.
  \end{aligned}\]</p><p>The variances can be calculated as follows:</p><p class="math-container">\[  \begin{aligned}
    v_{\Re(\bar{I}_{ji})} &amp;= v_{I_{ji}} (\cos z_{\psi_{ji}})^2 + v_{\psi_{ji}} (z_{I_{ji}} \sin z_{\psi_{ji}})^2 \\
    v_{\Im(\bar{I}_{ji})} &amp;= v_{I_{ji}} (\sin z_{\psi_{ji}})^2 + v_{\psi_{ji}} (z_{I_{ji}} \cos z_{\psi_{ji}})^2.
  \end{aligned}\]</p><p>The functions defining the current phasor measurement at the to-bus end are:</p><p class="math-container">\[  \begin{aligned}
    h_{\Re(\bar{I}_{ji})}(\mathbf x) &amp;= \tau_{ij}^2 A \Re(\bar{V}_j) - \tau_{ij}^2 B \Im(\bar{V}_j) - \left(C \cos\phi_{ij} + D \sin \phi_{ij}\right) \Re(\bar{V}_i) - \left( C\sin \phi_{ij} - D\cos \phi_{ij} \right) \Im(\bar{V}_i)\\
    h_{\Im(\bar{I}_{ji})}(\mathbf x) &amp;= \tau_{ij}^2 B \Re(\bar{V}_j) + \tau_{ij}^2 A \Im(\bar{V}_j) + \left(C \sin \phi_{ij} - D \cos\phi_{ij} \right) \Re(\bar{V}_i) - \left(C\cos \phi_{ij} + D\sin \phi_{ij}\right) \Im(\bar{V}_i).
  \end{aligned}\]</p><p>The coefficient expressions for measurement functions are as follows:</p><p class="math-container">\[  \begin{aligned}
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \Re(\bar{V}_i)} &amp;=
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \Im(\bar{V}_i)} =
  - \left(C \cos\phi_{ij} + D \sin \phi_{ij}\right)\\
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}} {\mathrm \partial \Re(\bar{V}_j)} &amp;=
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}} {\mathrm \partial \Im(\bar{V}_j)} = \tau_{ij}^2A\\
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \Im(\bar{V}_i)} &amp;= -
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \Re(\bar{V}_i)} =
  -\left(C\sin \phi_{ij} - D\cos \phi_{ij} \right) \\
  \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \Im(\bar{V}_j)} &amp;= -
  \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \Re(\bar{V}_j)} =
  -\tau_{ij}^2B.
  \end{aligned}\]</p><p>As before, we are neglecting the covariances between the real and imaginary parts of the measurement. If desired, we can include them in the state estimation model by specifying the covariances of the vector:</p><p class="math-container">\[    \mathbf{w} = [w_{\Re(\bar{I}_{ji})}, w_{\Im(\bar{I}_{ji})}].\]</p><pre><code class="language-julia hljs">addPmu!(system, device; label = &quot;I‚ÇÉ‚ÇÅ, œà‚ÇÉ‚ÇÅ&quot;, to = 2, magnitude = 0.3, angle = 2.5,
varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true)</code></pre><p>Then, the covariances are obtained as follows:</p><p class="math-container">\[   w_{\Re(\bar{I}_{ji})} = w_{\Im(\bar{I}_{ji})} = \sin z_{\psi_{ji}} \cos z_{\psi_{ji}}(v_{I_{ji}} - v_{\psi_{ji}} z_{I_{ji}}^2).\]</p><hr/><h2 id="PMUSEWLSStateEstimationTutorials"><a class="docs-heading-anchor" href="#PMUSEWLSStateEstimationTutorials">Weighted Least-Squares Estimation</a><a id="PMUSEWLSStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUSEWLSStateEstimationTutorials" title="Permalink"></a></h2><p>The solution to the PMU state estimation problem is determined by solving the linear weighted least-squares (WLS) problem, represented by the following formula:</p><p class="math-container">\[	\mathbf H^{T} \bm \Sigma^{-1} \mathbf H \mathbf x = \mathbf H^{T} \bm \Sigma^{-1} \mathbf z.\]</p><p>Here, <span>$\mathbf z \in \mathbb {R}^{k}$</span> denotes the vector of measurement values, <span>$\mathbf {H} \in \mathbb {R}^{k \times 2n}$</span> represents the coefficient matrix, and <span>$\bm \Sigma \in \mathbb {R}^{k \times k}$</span> is the measurement error covariance matrix.</p><hr/><h5 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h5><p>JuliaGrid initiates the PMU state estimation framework by setting up the WLS model, as illustrated in the following:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device)</code></pre><hr/><h5 id="Coefficient-Matrix"><a class="docs-heading-anchor" href="#Coefficient-Matrix">Coefficient Matrix</a><a id="Coefficient-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficient-Matrix" title="Permalink"></a></h5><p>Using the above-described equations, JuliaGrid forms the coefficient matrix <span>$\mathbf{H} \in \mathbb{R}^{k \times 2n}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêá = analysis.method.coefficient</code><code class="nohighlight hljs ansi" style="display:block;">12√ó6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 36 stored entries:
   ‚ãÖ         1.0        ‚ãÖ          ‚ãÖ          ‚ãÖ         ‚ãÖ
   ‚ãÖ          ‚ãÖ         ‚ãÖ          ‚ãÖ         1.0        ‚ãÖ
   ‚ãÖ          ‚ãÖ        1.0         ‚ãÖ          ‚ãÖ         ‚ãÖ
   ‚ãÖ          ‚ãÖ         ‚ãÖ          ‚ãÖ          ‚ãÖ        1.0
   ‚ãÖ         0.49505  -0.49505     ‚ãÖ         4.9305   -4.9505
   ‚ãÖ        -4.9305    4.9505      ‚ãÖ         0.49505  -0.49505
  0.040783    ‚ãÖ       -0.040783   1.40741     ‚ãÖ       -1.42741
 -1.40741     ‚ãÖ        1.42741    0.040783    ‚ãÖ       -0.040783
   ‚ãÖ        -0.49505   0.49505     ‚ãÖ        -4.9505    4.9305
   ‚ãÖ         4.9505   -4.9305      ‚ãÖ        -0.49505   0.49505
 -0.040783    ‚ãÖ        0.040783  -1.42741     ‚ãÖ        1.40741
  1.42741     ‚ãÖ       -1.40741   -0.040783    ‚ãÖ        0.040783</code></pre><p>In this matrix, each row corresponds to a specific measurement in the rectangular coordinate system. Therefore, the <span>$i$</span>-th PMU is associated with the <span>$2i - 1$</span> index of the row, representing the real part of the phasor measurement, while the <span>$2i$</span> row corresponds to the imaginary part of the phasor measurement. Columns are ordered based on how the state variables are defined <span>$\mathbf x \equiv[\mathbf{V}_\text{re},\mathbf{V}_\text{im}]$</span>.</p><hr/><h5 id="Precision-Matrix"><a class="docs-heading-anchor" href="#Precision-Matrix">Precision Matrix</a><a id="Precision-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-Matrix" title="Permalink"></a></h5><p>JuliaGrid opts not to retain the covariance matrix <span>$\bm \Sigma$</span> but rather stores its inverse, the precision or weighting matrix denoted as <span>$\mathbf W = \bm \Sigma^{-1}$</span>. The order of these values corresponds to the description provided for the coefficient matrix. Users can access these values using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêñ = analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">12√ó12 SparseArrays.SparseMatrixCSC{Float64, Int64} with 18 stored entries:
 1.0019e5   ‚ãÖ             ‚ãÖ         ‚Ä¶   ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ        1.23169e5      ‚ãÖ             ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ            1.00926e5      ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ         4567.25           ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ             ‚ãÖ             ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ             ‚ãÖ         ‚Ä¶   ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ             ‚ãÖ             ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ             ‚ãÖ             ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ             ‚ãÖ             ‚ãÖ          ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ             ‚ãÖ            7.03786e5   ‚ãÖ          ‚ãÖ
  ‚ãÖ         ‚ãÖ             ‚ãÖ         ‚Ä¶   ‚ãÖ         4.62149e5  4.84789e5
  ‚ãÖ         ‚ãÖ             ‚ãÖ             ‚ãÖ         4.84789e5  7.48963e5</code></pre><p>The precision matrix does not maintain a diagonal form, indicating that correlations between the real and imaginary parts of the phasor measurements are included in the model. To ignore these correlations, simply omit the <code>correlated</code> keyword within the function that adds a PMU. For example:</p><pre><code class="language-julia hljs">device = measurement()

@pmu(label = &quot;PMU ?&quot;, noise = false)
addPmu!(system, device; bus = 1, magnitude = 1.0, angle = 0.0)
addPmu!(system, device; bus = 2, magnitude = 0.87, angle = -0.15)
addPmu!(system, device; from = 1, magnitude = 0.30, angle = -0.71)
addPmu!(system, device; from = 2, magnitude = 0.31, angle = -0.49)</code></pre><p>Following this, we recreate the WLS state estimation model:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device)</code></pre><p>Upon inspection, it becomes evident that the precision matrix maintains a diagonal structure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêñ = analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">8√ó8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
 100000.0        ‚ãÖ    ‚ãÖ               ‚ãÖ   ‚Ä¶   ‚ãÖ          ‚ãÖ          ‚ãÖ
       ‚ãÖ   100000.0   ‚ãÖ               ‚ãÖ       ‚ãÖ          ‚ãÖ          ‚ãÖ
       ‚ãÖ         ‚ãÖ   1.00546e5        ‚ãÖ       ‚ãÖ          ‚ãÖ          ‚ãÖ
       ‚ãÖ         ‚ãÖ    ‚ãÖ         131177.0      ‚ãÖ          ‚ãÖ          ‚ãÖ
       ‚ãÖ         ‚ãÖ    ‚ãÖ               ‚ãÖ       ‚ãÖ          ‚ãÖ          ‚ãÖ
       ‚ãÖ         ‚ãÖ    ‚ãÖ               ‚ãÖ   ‚Ä¶  2.09799e5   ‚ãÖ          ‚ãÖ
       ‚ãÖ         ‚ãÖ    ‚ãÖ               ‚ãÖ       ‚ãÖ         1.25032e5   ‚ãÖ
       ‚ãÖ         ‚ãÖ    ‚ãÖ               ‚ãÖ       ‚ãÖ          ‚ãÖ         3.37492e5</code></pre><hr/><h5 id="Mean-Vector"><a class="docs-heading-anchor" href="#Mean-Vector">Mean Vector</a><a id="Mean-Vector-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Vector" title="Permalink"></a></h5><p>To retrieve the vector <span>$\mathbf z$</span>, containing the means of Gaussian distributions for each measurement, users can utilize:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùê≥ = analysis.method.mean</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{Float64}:
  1.0
  0.0
  0.8602308378043567
 -0.13001117525203132
  0.22750856279715245
 -0.19555013130646098
  0.2735231861691376
 -0.14589402533305898</code></pre><p>These values represent measurement values in the rectangular coordinate system as described earlier.</p><hr/><h5 id="Estimate-of-State-Variables"><a class="docs-heading-anchor" href="#Estimate-of-State-Variables">Estimate of State Variables</a><a id="Estimate-of-State-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Estimate-of-State-Variables" title="Permalink"></a></h5><p>Next, the WLS equation is solved to obtain the estimate of state variables:</p><p class="math-container">\[	\hat{\mathbf x} = [\mathbf H^{T} \bm \Sigma^{-1} \mathbf H]^{-1} \mathbf H^{T} \bm \Sigma^{-1} \mathbf z.\]</p><p>This process is executed using the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{LinearWLS{Normal}}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>The initial step involves the LU factorization of the gain matrix:</p><p class="math-container">\[	\mathbf G = \mathbf H^{T} \bm \Sigma^{-1} \mathbf H = \mathbf L \mathbf U.\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>By default, JuliaGrid utilizes LU factorization as the primary method to factorize the gain matrix. However, users maintain the flexibility to opt for alternative factorization methods such as LDLt or QR.</p></div></div><p>Access to the factorized gain matrix is available through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêã = analysis.method.factorization.L</code><code class="nohighlight hljs ansi" style="display:block;">6√ó6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 17 stored entries:
  1.0          ‚ãÖ            ‚ãÖ           ‚ãÖ            ‚ãÖ         ‚ãÖ
 -0.0470534   1.0           ‚ãÖ           ‚ãÖ            ‚ãÖ         ‚ãÖ
 -0.522908   -8.10654e-5   1.0          ‚ãÖ            ‚ãÖ         ‚ãÖ
   ‚ãÖ           ‚ãÖ          -1.78244     1.0           ‚ãÖ         ‚ãÖ
   ‚ãÖ           ‚ãÖ           0.0154393  -0.00521047   1.0        ‚ãÖ
  0.0165651  -0.344281    -0.0110068   0.0036689   -0.522906  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêî = analysis.method.factorization.U</code><code class="nohighlight hljs ansi" style="display:block;">6√ó6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 17 stored entries:
 0.494535  -0.00889224  -0.487608       ‚ãÖ          ‚ãÖ            0.00896556
  ‚ãÖ         0.479929    -0.000191972    ‚ãÖ          ‚ãÖ           -0.47321
  ‚ãÖ          ‚ãÖ           0.25474      -0.219243   0.00155842   -0.00162742
  ‚ãÖ          ‚ãÖ            ‚ãÖ            0.148187  -0.000633631   0.000653543
  ‚ãÖ          ‚ãÖ            ‚ãÖ             ‚ãÖ         0.561653     -0.430201
  ‚ãÖ          ‚ãÖ            ‚ãÖ             ‚ãÖ          ‚ãÖ            0.130906</code></pre><p>Finally, JuliaGrid obtains the solution in the rectangular coordinate system and then transforms these solutions into the standard form given in the polar coordinate system.</p><p>The estimated bus voltage magnitudes <span>$\hat{\mathbf V} = [\hat{V}_i]$</span> and angles <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, <span>$i \in \mathcal{N}$</span>, can be retrieved using the variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêï = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.9972846475719777
 0.8728310555274105
 0.89548122281777</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0011070674719133831
 -0.1504959040059231
 -0.21044407465996606</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is essential to note that the slack bus does not exist in the case of the PMU state estimation model.</p></div></div><hr/><h5 id="PMUSEOrthogonalWLSStateEstimationTutorials"><a class="docs-heading-anchor" href="#PMUSEOrthogonalWLSStateEstimationTutorials">Alternative Formulation</a><a id="PMUSEOrthogonalWLSStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUSEOrthogonalWLSStateEstimationTutorials" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from converging to a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal factorization [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 3.2]. This approach is suitable when measurement errors are uncorrelated, and the precision matrix remains diagonal.</p><p>To address ill-conditioned situations arising from significant differences in measurement variances, users can employ an alternative approach:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device, Orthogonal)</code></pre><p>To explain the method, we begin with the WLS equation:</p><p class="math-container">\[	\mathbf H^{T} \mathbf W \mathbf H \hat{\mathbf x} = \mathbf H^{T} \mathbf W \mathbf z,\]</p><p>where <span>$\mathbf W = \bm \Sigma^{-1}$</span>. Subsequently, we can write:</p><p class="math-container">\[  \left({\mathbf W^{1/2}} \mathbf H\right)^{T}  {\mathbf W^{1/2}} \mathbf H  \hat{\mathbf x} = \left({\mathbf W^{1/2}} \mathbf H\right)^{T} {\mathbf W^{1/2}} \mathbf z.\]</p><p>Consequently, we have:</p><p class="math-container">\[  \bar{\mathbf{H}}^{T}  \bar{\mathbf{H}} \hat{\mathbf x} = \bar{\mathbf{H}}^{T}  \bar{\mathbf{z}},\]</p><p>where:</p><p class="math-container">\[  \bar{\mathbf{H}} = {\mathbf W^{1/2}} \mathbf H; \;\;\; \bar{\mathbf{z}} = {\mathbf W^{1/2}} \mathbf z.\]</p><p>At this point, QR factorization is performed on the rectangular matrix:</p><p class="math-container">\[  \bar{\mathbf{H}} = {\mathbf W^{1/2}} \mathbf H = \mathbf{Q}\mathbf{R}.\]</p><p>Executing this procedure involves the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{PowerSystem, PMUStateEstimation{LinearWLS{Normal}}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Access to the factorized matrix is possible through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê = analysis.method.factorization.Q</code><code class="nohighlight hljs ansi" style="display:block;">8√ó8 SparseArrays.SPQR.QRSparseQ{Float64, Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêë = analysis.method.factorization.R</code><code class="nohighlight hljs ansi" style="display:block;">6√ó6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 21 stored entries:
 -1156.2  497.316    14.2388     -3.53502   586.583     -10.4591
      ‚ãÖ   659.702    -3.91115    -3.88362  -442.195       7.88459
      ‚ãÖ      ‚ãÖ     -888.673     503.067      -2.68756   283.077
      ‚ãÖ      ‚ãÖ         ‚ãÖ       -574.977      -2.97106   247.685
      ‚ãÖ      ‚ãÖ         ‚ãÖ           ‚ãÖ       -384.983       3.24637
      ‚ãÖ      ‚ãÖ         ‚ãÖ           ‚ãÖ           ‚ãÖ       -337.119</code></pre><p>To obtain the solution, JuliaGrid avoids materializing the orthogonal matrix <span>$\mathbf{Q}$</span> and proceeds to solve the system, resulting in the estimate of bus voltage magnitudes <span>$\hat{\mathbf V} = [\hat{V}_i]$</span> and angles <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, where <span>$i \in \mathcal{N}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêï = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.9972846475719777
 0.8728310555274102
 0.89548122281777</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.001107067471913468
 -0.15049590400592316
 -0.21044407465996595</code></pre><hr/><h2 id="PMUSEBadDataTutorials"><a class="docs-heading-anchor" href="#PMUSEBadDataTutorials">Bad Data Processing</a><a id="PMUSEBadDataTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUSEBadDataTutorials" title="Permalink"></a></h2><p>Besides the state estimation algorithm, one of the essential state estimation routines is the bad data processing, whose main task is to detect and identify measurement errors, and eliminate them if possible. This is usually done by processing the measurement residuals [<a href="../../background/bibliography/#aburbook">5</a>, Ch. 5], and typically, the largest normalized residual test is used to identify bad data. The largest normalized residual test is performed after we obtained the solution of the state estimation in the repetitive process of identifying and eliminating bad data measurements one after another [<a href="../../background/bibliography/#korres2010distributed">19</a>].</p><p>To illustrate this process, let us introduce a new measurement that contains an obvious outlier:</p><pre><code class="language-julia hljs">addPmu!(system, device; bus = 3, magnitude = 2.5, angle = 0.1)</code></pre><p>Subsequently, we will construct the WLS state estimation model and solve it:</p><pre><code class="language-julia hljs">analysis = pmuStateEstimation(system, device)
solve!(system, analysis)</code></pre><p>Now, the bad data processing can be executed:</p><pre><code class="language-julia hljs">outlier = residualTest!(system, device, analysis; threshold = 4.0)</code></pre><p>In this step, we employ the largest normalized residual test, guided by the analysis outlined in [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 5.7]. To be more precise, we compute all measurement residuals in the rectangular coordinate system based on the obtained estimate of state variables:</p><p class="math-container">\[    r_{i} = z_i - h_i(\hat {\mathbf x}), \;\;\; i \in \mathcal{M}.\]</p><p>The normalized residuals for all measurements are computed as follows:</p><p class="math-container">\[    \bar{r}_{i} = \cfrac{|r_i|}{\sqrt{C_{ii}}} = \cfrac{|r_i|}{\sqrt{S_{ii}\Sigma_{ii}}}, \;\;\; i \in \mathcal{M}.\]</p><p>In this equation, we denote the diagonal entries of the residual covariance matrix <span>$\mathbf C \in \mathbb{R}^{k \times k}$</span> as <span>$C_{ii} = S_{ii}\Sigma_{ii}$</span>, where <span>$S_{ii}$</span> is the diagonal entry of the residual sensitivity matrix <span>$\mathbf S$</span> representing the sensitivity of the measurement residuals to the measurement errors. For this specific configuration, the relationship is expressed as:</p><p class="math-container">\[    \mathbf C = \mathbf S \bm \Sigma = \bm \Sigma - \mathbf H [\mathbf H^T \bm \Sigma^{-1} \mathbf H]^{-1} \mathbf H^T.\]</p><p>It is important to note that only the diagonal entries of <span>$\mathbf C$</span> are required. To obtain the inverse, the JuliaGrid package utilizes a computationally efficient sparse inverse method, retrieving only the necessary elements of the inverse.</p><p>The subsequent step involves selecting the largest normalized residual, and the <span>$j$</span>-th measurement is then suspected as bad data and potentially removed from the measurement set <span>$\mathcal{M}$</span>:</p><p class="math-container">\[    \bar{r}_{j} = \text{max} \{\bar{r}_{i}, i \in \mathcal{M} \}.\]</p><p>Users can access this information using the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; outlier.maxNormalizedResidual</code><code class="nohighlight hljs ansi" style="display:block;">387.72710598252246</code></pre><p>If the largest normalized residual, denoted as <span>$\bar{r}_{j}$</span>, satisfies the inequality:</p><p class="math-container">\[    \bar{r}_{j} \ge \epsilon,\]</p><p>the corresponding measurement is identified as bad data and subsequently removed. In this example, the bad data identification <code>threshold</code> is set to <span>$\epsilon = 4$</span>. Users can verify the satisfaction of this inequality by inspecting:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; outlier.detect</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>This indicates that the measurement labeled as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; outlier.label</code><code class="nohighlight hljs ansi" style="display:block;">&quot;PMU 5&quot;</code></pre><p>is removed from the PMU model and marked as out-of-service. Specifically, either the real or imaginary part of the corresponding measurement is identified as the outlier. Consequently, both parts of the measurement are removed from the PMU state estimation model.</p><p>Subsequently, we can immediately solve the system again, but this time without the removed measurement:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>Following that, we check for outliers once more:</p><pre><code class="language-julia hljs">outlier = residualTest!(system, device, analysis; threshold = 4.0)</code></pre><p>To examine the value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; outlier.maxNormalizedResidual</code><code class="nohighlight hljs ansi" style="display:block;">1.289041523534379</code></pre><p>As this value is now less than the <code>threshold</code> <span>$\epsilon = 4$</span>, the measurement is not removed, or there are no outliers. This can also be verified by observing the bad data flag:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; outlier.detect</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><hr/><h2 id="PMUSELAVTutorials"><a class="docs-heading-anchor" href="#PMUSELAVTutorials">Least Absolute Value Estimation</a><a id="PMUSELAVTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUSELAVTutorials" title="Permalink"></a></h2><p>The least absolute value (LAV) method provides an alternative estimation approach that is considered more robust in comparison to the WLS method. The WLS state estimation problem relies on specific assumptions about measurement errors, whereas robust estimators aim to remain unbiased even in the presence of various types of measurement errors and outliers. This characteristic eliminates the need for bad data processing, as discussed in [<a href="../../background/bibliography/#aburbook">5</a>, Ch. 6]. It is important to note that robustness often comes at the cost of increased computational complexity.</p><p>It can be demonstrated that the problem can be expressed as a linear programming problem. This section outlines the method as described in [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 6.5]. To revisit, we consider the system of linear equations:</p><p class="math-container">\[  \mathbf{z}=\mathbf{h}(\mathbf x)+\mathbf{u}+\mathbf{w}.\]</p><p>Subsequently, the LAV state estimator is derived as the solution to the optimization problem:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T |\mathbf r|\\
    \text{subject\;to}&amp; \;\;\; \mathbf{z} - \mathbf{H} \mathbf x =\mathbf r.
  \end{aligned}\]</p><p>Here, <span>$\mathbf a \in \mathbb {R}^{k}$</span> is the vector with all entries equal to one, and <span>$\mathbf r$</span> represents the vector of measurement residuals. Let <span>$\bm \eta$</span> be defined in a manner that ensures:</p><p class="math-container">\[  |\mathbf r| \preceq \bm \eta,\]</p><p>and replace the above inequality with two equalities using the introduction of two non-negative slack variables <span>$\mathbf q \in \mathbb {R}_{\ge 0}^{k}$</span> and <span>$\mathbf w \in \mathbb {R}_{\ge 0}^{k}$</span>:</p><p class="math-container">\[  \begin{aligned}
    \mathbf r - \mathbf q &amp;= -\bm \eta \\
    \mathbf r + \mathbf w &amp;= \bm \eta.
  \end{aligned}\]</p><p>Let us now define four additional non-negative variables:</p><p class="math-container">\[    \mathbf x_x \in \mathbb {R}_{\ge 0}^{n}, \;\;\; \mathbf x_y  \in \mathbb {R}_{\ge 0}^{n}, \;\;\;
    \mathbf {r}_x \in \mathbb {R}_{\ge 0}^{k}, \;\;\; \mathbf {r}_y \in \mathbb {R}_{\ge 0}^{k},\]</p><p>where:</p><p class="math-container">\[    \mathbf x = \mathbf x_x - \mathbf x_y, \;\;\; \mathbf r = \mathbf {r}_x - \mathbf {r}_y\\
    \mathbf {r}_x = \cfrac{1}{2} \mathbf q, \;\;\;  \mathbf {r}_y = \cfrac{1}{2} \mathbf w.\]</p><p>Then, the above two equalities become:</p><p class="math-container">\[  \begin{aligned}
    \mathbf r - 2\mathbf {r}_x &amp;= -2\bm \eta \\
    \mathbf r + 2 \mathbf {r}_y &amp;= 2\bm \eta,
  \end{aligned}\]</p><p>that is:</p><p class="math-container">\[  \begin{aligned}
    \mathbf {r}_x + \mathbf {r}_y = \bm \eta, \;\;\; \mathbf r = \mathbf {r}_x - \mathbf {r}_y.
  \end{aligned}\]</p><p>Hence, the optimization problem can be written:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \mathbf a^T (\mathbf {r}_x + \mathbf {r}_y)\\
    \text{subject\;to}&amp; \;\;\; \mathbf{H}(\mathbf x_x - \mathbf x_y) + \mathbf {r}_x - \mathbf {r}_y = \mathbf{z} \\
                       &amp; \;\;\; \mathbf x_x \succeq \mathbf 0, \; \mathbf x_y \succeq \mathbf 0 \\
                       &amp; \;\;\; \mathbf {r}_x \succeq \mathbf 0, \; \mathbf {r}_y \succeq \mathbf 0.
  \end{aligned}\]</p><p>To form the above optimization problem, the user can call the following function:</p><pre><code class="language-julia hljs">using Ipopt

analysis = pmuLavStateEstimation(system, device, Ipopt.Optimizer)</code></pre><p>Then the user can solve the optimization problem by:</p><pre><code class="language-julia hljs">solve!(system, analysis)</code></pre><p>As a result, we obtain optimal values for the four additional non-negative variables, while the state estimator is obtained by:</p><p class="math-container">\[    \hat{\mathbf x} = \mathbf x_x - \mathbf x_y.\]</p><p>Users can retrieve the estimated bus voltage magnitudes <span>$\hat{\mathbf V} = [\hat{V}_i]$</span> and angles <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, <span>$i \in \mathcal{N}$</span>, using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêï = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.9999997979268984
 0.876149703513198
 0.8983275932436058</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùöØ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  2.1386863183370526e-7
 -0.15145892724417714
 -0.21100496414278708</code></pre><hr/><h2 id="optimalpmu"><a class="docs-heading-anchor" href="#optimalpmu">Optimal PMU Placement</a><a id="optimalpmu-1"></a><a class="docs-heading-anchor-permalink" href="#optimalpmu" title="Permalink"></a></h2><p>JuliaGrid utilizes the optimal PMU placement algorithm proposed in [<a href="../../background/bibliography/#gou2008optimal">23</a>]. The optimal positioning of PMUs is framed as an integer linear programming problem, expressed as:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \sum_{i=1}^n d_i\\
    \text{subject\;to}&amp; \;\;\; \mathbf A \mathbf d \ge \mathbf a.
  \end{aligned}\]</p><p>Here, the vector <span>$\mathbf d = [d_1,\dots,d_n]^T$</span> serves as the optimization variable, where <span>$d_i \in \mathbb{F} = \{0,1\}$</span> is the PMU placement or a binary decision variable associated with the bus <span>$i \in \mathcal{N}$</span>. The all-one vector <span>$\mathbf a$</span> is of dimension <span>$n$</span>. The binary connectivity matrix <span>$\mathbf A \in \mathbb{F}^{n \times n}$</span> can be directly derived from the bus nodal matrix <span>$\mathbf Y$</span> by converting its entries into binary form [<a href="../../background/bibliography/#xu2004observability">24</a>].</p><p>Consequently, we obtain the binary vector <span>$\mathbf d = [d_1,\dots,d_n]^T$</span>, where <span>$d_i = 1$</span>, <span>$i \in \mathcal{N}$</span>, suggests that a PMU should be placed at bus <span>$i$</span>. The primary aim of PMU placement in the power system is to determine a minimal set of PMUs such that the entire system is observable without relying on traditional measurements [<a href="../../background/bibliography/#gou2008optimal">23</a>]. Specifically, when we observe <span>$d_i = 1$</span>, it indicates that the PMU is installed at bus <span>$i \in \mathcal{N}$</span> to measure bus voltage phasor as well as all current phasors across branches incident to bus <span>$i$</span>.</p><p>Determining the optimal PMU placement involves analyzing the created power system. For example:</p><pre><code class="language-julia hljs">using GLPK

system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5)
addBus!(system; label = 2, type = 1, reactive = 0.3)
addBus!(system; label = 3, type = 1, active = 0.5)

@branch(resistance = 0.02, susceptance = 0.04)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.6)
addBranch!(system; label = 2, from = 1, to = 2, reactance = 0.7)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.2)

addGenerator!(system; label = 1, bus = 1, active = 3.2, reactive = 0.2)

acModel!(system)
placement = pmuPlacement(system, GLPK.Optimizer)</code></pre><p>The <code>placement</code> variable contains data regarding the optimal placement of measurements. It lists all buses <span>$i \in \mathcal{N}$</span> that satisfy <span>$d_i = 1$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; placement.bus</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 1 entry:
  &quot;2&quot; =&gt; 2</code></pre><p>This PMU installed at bus <code>2</code> will measure the bus voltage phasor at the corresponding bus and all current phasors at the branches incident to bus <code>2</code> located at the from-bus or to-bus ends. These data are stored in the variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; placement.from</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 1 entry:
  &quot;3&quot; =&gt; 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; placement.to</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{String, Int64} with 2 entries:
  &quot;1&quot; =&gt; 1
  &quot;2&quot; =&gt; 2</code></pre><hr/><h2 id="PMUPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#PMUPowerAnalysisTutorials">Power Analysis</a><a id="PMUPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUPowerAnalysisTutorials" title="Permalink"></a></h2><p>Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a> function, which enables the calculation of powers associated with buses and branches. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">power!(system, analysis)</code></pre><p>The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses and branches:</p><table><tr><th style="text-align: left">Bus</th><th style="text-align: left">Active</th><th style="text-align: left">Reactive</th></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf{P} = [P_i]$</span></td><td style="text-align: left"><span>$\mathbf{Q} = [Q_i]$</span></td></tr><tr><td style="text-align: left"><a href="#PMUGeneratorPowerInjectionsManual">Generator injections</a></td><td style="text-align: left"><span>$\mathbf{P}_{\text{p}} = [P_{\text{p}i}]$</span></td><td style="text-align: left"><span>$\mathbf{Q}_{\text{p}} = [Q_{\text{p}i}]$</span></td></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BusShuntElementTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf{P}_{\text{sh}} = [{P}_{\text{sh}i}]$</span></td><td style="text-align: left"><span>$\mathbf{Q}_{\text{sh}} = [{Q}_{\text{sh}i}]$</span></td></tr></table><table><tr><th style="text-align: left">Branch</th><th style="text-align: left">Active</th><th style="text-align: left">Reactive</th></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span></td><td style="text-align: left"><span>$\mathbf{Q}_{\text{i}} = [Q_{ij}]$</span></td></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span></td><td style="text-align: left"><span>$\mathbf{Q}_{\text{j}} = [Q_{ji}]$</span></td></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BranchShuntElementsTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf{P}_{\text{s}} = [P_{\text{s}ij}]$</span></td><td style="text-align: left"><span>$\mathbf{P}_{\text{s}} = [P_{\text{s}ij}]$</span></td></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf{P}_{\text{l}} = [P_{\text{l}ij}]$</span></td><td style="text-align: left"><span>$\mathbf{Q}_{\text{l}} = [Q_{\text{l}ij}]$</span></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusInjectionsTutorials">Active and reactive power injections</a> are stored as the vectors <span>$\mathbf{P} = [P_i]$</span> and <span>$\mathbf{Q} = [Q_i]$</span>, respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.4216631622492523
 -0.19530673833785805
 -0.22132365772451618</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê = analysis.power.injection.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.3612603793317748
 -0.4503322130040679
  0.11258234719068802</code></pre><hr/><h5 id="PMUGeneratorPowerInjectionsManual"><a class="docs-heading-anchor" href="#PMUGeneratorPowerInjectionsManual">Generator Power Injections</a><a id="PMUGeneratorPowerInjectionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#PMUGeneratorPowerInjectionsManual" title="Permalink"></a></h5><p>We can calculate the active and reactive power injections supplied by generators at each bus <span>$i \in \mathcal{N}$</span> by summing the active and reactive power injections and the active and reactive power demanded by consumers at each bus:</p><p class="math-container">\[  \begin{aligned}
    P_{\text{p}i} &amp;= P_i + P_{\text{d}i}\\
    Q_{\text{p}i} &amp;= Q_i + Q_{\text{d}i}.
  \end{aligned}\]</p><p>The active and reactive power injections from the generators at each bus are stored as vectors, denoted by <span>$\mathbf{P}_{\text{p}} = [P_{\text{p}i}]$</span> and <span>$\mathbf{Q}_{\text{p}} = [Q_{\text{p}i}]$</span>, which can be obtained using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çö = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.9216631622492524
 -0.19530673833785805
  0.2786763422754838</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çö = analysis.power.supply.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.3612603793317748
 -0.1503322130040679
  0.11258234719068802</code></pre><hr/><h5 id="Power-at-Bus-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Bus-Shunt-Elements">Power at Bus Shunt Elements</a><a id="Power-at-Bus-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Bus-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusShuntElementTutorials">Active and reactive powers</a> associated with the shunt elements at each bus are represented by the vectors <span>$\mathbf{P}_{\text{sh}} = [{P}_{\text{sh}i}]$</span> and <span>$\mathbf{Q}_{\text{sh}} = [{Q}_{\text{sh}i}]$</span>. To retrieve these powers in JuliaGrid, use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ‚Çï = analysis.power.shunt.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çõ‚Çï = analysis.power.shunt.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.0
 -0.0
 -0.0</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at each from-bus end are stored as the vectors <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span> and <span>$\mathbf{Q}_{\text{i}} = [Q_{ij}],$</span> respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè·µ¢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.22750847062127627
 0.19415469162797616
 0.2229482965705423</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê·µ¢ = analysis.power.from.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.19555014549544905
  0.16571023383632527
 -0.1278285740854087</code></pre><p>Similarly, the vectors of <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at the to-bus end are stored as <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span> and <span>$\mathbf{Q}_{\text{j}} = [Q_{ji}]$</span>, respectively, and can be retrieved using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚±º = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.2255440305084955
 -0.19271100439990477
 -0.22132365772451618</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚±º = analysis.power.to.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.17196970008842855
 -0.1505339388302306
  0.11258234719068802</code></pre><hr/><h5 id="Power-at-Branch-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Shunt-Elements">Power at Branch Shunt Elements</a><a id="Power-at-Branch-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchShuntElementsTutorials">Active and reactive powers</a> associated with the branch shunt elements at each branch are represented by the vectors <span>$\mathbf{P}_{\text{s}} = [P_{\text{s}ij}]$</span> and <span>$\mathbf{Q}_{\text{s}} = [Q_{\text{s}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çõ = analysis.power.charging.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çõ = analysis.power.charging.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.03535275797640205
 -0.03535275797640205
 -0.03149261535498228</code></pre><hr/><h5 id="Power-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Series-Elements">Power at Branch Series Elements</a><a id="Power-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Series-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchSeriesElementTutorials">Active and reactive powers</a> associated with the branch series element at each branch are represented by the vectors <span>$\mathbf{P}_{\text{l}} = [P_{\text{l}ij}]$</span> and <span>$\mathbf{Q}_{\text{l}} = [Q_{\text{l}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêè‚Çó = analysis.power.series.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0019644401127807513
 0.0014436872280713317
 0.0016246388460260893</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêê‚Çó = analysis.power.series.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.05893320338342248
 0.050529052982496686
 0.016246388460260896</code></pre><hr/><h2 id="PMUCurrentAnalysisTutorials"><a class="docs-heading-anchor" href="#PMUCurrentAnalysisTutorials">Current Analysis</a><a id="PMUCurrentAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUCurrentAnalysisTutorials" title="Permalink"></a></h2><p>JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a> function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">current!(system, analysis)</code></pre><p>The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:</p><table><tr><th style="text-align: left">Bus</th><th style="text-align: left">Magnitude</th><th style="text-align: left">Angle</th></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf{I} = [I_i]$</span></td><td style="text-align: left"><span>$\bm{\psi} = [\psi_i]$</span></td></tr></table><table><tr><th style="text-align: left">Branch</th><th style="text-align: left">Magnitude</th><th style="text-align: left">Angle</th></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf{I}_{\text{i}} = [I_{ij}]$</span></td><td style="text-align: left"><span>$\bm{\psi}_{\text{i}} = [\psi_{ij}]$</span></td></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf{I}_{\text{j}} = [I_{ji}]$</span></td><td style="text-align: left"><span>$\bm{\psi}_{\text{j}} = [\psi_{ji}]$</span></td></tr><tr><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf{I}_{\text{l}} = [I_{\text{l}ij}]$</span></td><td style="text-align: left"><span>$\bm{\psi}_{\text{l}} = [\psi_{\text{l}ij}]$</span></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Current-Injections"><a class="docs-heading-anchor" href="#Current-Injections">Current Injections</a><a id="Current-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injections" title="Permalink"></a></h5><p>In JuliaGrid, <a href="../powerSystemModel/#BusInjectionsTutorials">complex current injections</a> are stored in the vector of magnitudes denoted as <span>$\mathbf{I} = [I_i]$</span> and the vector of angles represented as <span>$\bm{\psi} = [\psi_i]$</span>. You can retrieve them using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà = analysis.current.injection.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.5552558047196623
 0.5602470534871392
 0.2764160838803776</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô = analysis.current.injection.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.7084001797708159
  1.8285495088264339
 -2.8820321950004284</code></pre><hr/><h5 id="Current-Flows"><a class="docs-heading-anchor" href="#Current-Flows">Current Flows</a><a id="Current-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flows" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_{\text{i}} = [I_{ij}]$</span> and angles <span>$\bm{\psi}_{\text{i}} = [\psi_{ij}]$</span> for the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a>, you can use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà·µ¢ = analysis.current.from.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.29999999996813004
 0.2552566398975199
 0.29332239932118076</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô·µ¢ = analysis.current.from.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.7100000222772045
 -0.7065199041778824
  0.3691383932390542</code></pre><p>Similarly, we can obtain the vectors of magnitudes <span>$\mathbf{I}_{\text{j}} = [I_{ji}]$</span> and angles <span>$\bm{\psi}_{\text{j}} = [\psi_{ji}]$</span> of the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a> using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà‚±º = analysis.current.to.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.3237186097853939
 0.27910332071759625
 0.2764160838803776</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô‚±º = analysis.current.to.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  2.3387018720254247
  2.3270001254267854
 -2.8820321950004284</code></pre><hr/><h5 id="Current-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Current-at-Branch-Series-Elements">Current at Branch Series Elements</a><a id="Current-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Current-at-Branch-Series-Elements" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_{\text{l}} = [I_{\text{l}ij}]$</span> and angles <span>$\bm{\psi}_{\text{l}} = [\psi_{\text{l}ij}]$</span> of the resulting <a href="../powerSystemModel/#BranchSeriesElementTutorials">complex current flows</a>, one can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùêà‚Çó = analysis.current.series.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.3134039017610302
 0.26867147486022164
 0.2850121792157389</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ùõô‚Çó = analysis.current.series.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.75841409129973
 -0.7631714293392173
  0.31577645020972367</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acStateEstimation/">¬´ AC State Estimation</a><a class="docs-footer-nextpage" href="../dcStateEstimation/">DC State Estimation ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 5 December 2024 11:54">Thursday 5 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
