<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DC State Estimation · JuliaGrid</title><meta name="title" content="DC State Estimation · JuliaGrid"/><meta property="og:title" content="DC State Estimation · JuliaGrid"/><meta property="twitter:title" content="DC State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../manual/badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li class="is-active"><a class="tocitem" href>DC State Estimation</a><ul class="internal"><li><a class="tocitem" href="#DCSEModelTutorials"><span>State Estimation Model</span></a></li><li><a class="tocitem" href="#DCSEWLSStateEstimationTutorials"><span>Weighted Least-Squares Estimation</span></a></li><li><a class="tocitem" href="#DCSELAVTutorials"><span>Least Absolute Value Estimation</span></a></li><li><a class="tocitem" href="#DCSEPowerAnalysisTutorials"><span>Power Analysis</span></a></li></ul></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>DC State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DC State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/dcStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DCStateEstimationTutorials"><a class="docs-heading-anchor" href="#DCStateEstimationTutorials">DC State Estimation</a><a id="DCStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCStateEstimationTutorials" title="Permalink"></a></h1><p>To initiate the process, let us construct the <code>PowerSystem</code> type and formulate the DC model:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, angle = 0.0)
addBus!(system; label = 2, type = 1, active = 0.1)
addBus!(system; label = 3, type = 1, active = 1.3)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.2)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.1)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.3)

addGenerator!(system; label = 1, bus = 1, active = 3.2)

dcModel!(system)</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal{G} = (\mathcal{N}, \mathcal{E})$</span>, where we have the set of buses <span>$\mathcal{N} = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal{E} \subseteq \mathcal{N} \times \mathcal{N}$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒩 = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{String}:
 &quot;1&quot;  &quot;2&quot;
 &quot;1&quot;  &quot;3&quot;
 &quot;2&quot;  &quot;3&quot;</code></pre><hr/><p>Following that, we will introduce the <code>Measurement</code> type and incorporate a set of measurement devices <span>$\mathcal{M}$</span> into the graph <span>$\mathcal{G}$</span>. In typical scenarios, the DC state estimation model relies solely on active power measurements  originating from the set of wattmeters <span>$\mathcal{P}$</span>. However, we provide the option for users to include measurements from the set of PMUs <span>$\bar{\mathcal{P}}$</span>. Specifically, we utilize only the PMUs installed at the buses <span>$\bar{\mathcal{P}}_\text{b} \subset \bar{\mathcal{P}}$</span> that measure bus voltage angles. This process of adding measurement devices will be carried out in the <a href="#DCSEModelTutorials">State Estimation Model</a> section. Currently, we are only initializing the <code>Measurement</code> type:</p><pre><code class="language-julia hljs">monitoring = measurement(system)</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Here, when referring to a vector <span>$\mathbf{a}$</span>, we use the notation <span>$\mathbf{a} = [a_{i}]$</span> or <span>$\mathbf{a} = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element related with bus <span>$i \in \mathcal{N}$</span> or measurement <span>$i \in \mathcal{M}$</span>, while <span>$a_{ij}$</span> denotes the element related with branch <span>$(i,j) \in \mathcal{E}$</span>.</p></div></div><hr/><h2 id="DCSEModelTutorials"><a class="docs-heading-anchor" href="#DCSEModelTutorials">State Estimation Model</a><a id="DCSEModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEModelTutorials" title="Permalink"></a></h2><p>In accordance with the <a href="../powerSystemModel/#DCModelTutorials">DC Model</a>, the DC state estimation is derived through the linearization of the non-linear model. In this linearized model, all bus voltage magnitudes are assumed to be <span>$V_i \approx 1$</span>, <span>$i \in \mathcal{N}$</span>. Additionally, shunt elements and branch resistances are neglected. This simplification implies that the DC model disregards reactive powers and transmission losses, focusing solely on active powers. Consequently, the DC state estimation considers only bus voltage angles, represented as <span>$\mathbf x \equiv \bm {\Theta}$</span>, as the state variables. As a result, the total number of state variables is <span>$n-1$</span>, with one voltage angle corresponding to the slack bus.</p><p>Within the JuliaGrid framework for DC state estimation, the methodology encompasses both active power flow and injection measurements from the set <span>$\mathcal{P}$</span>, along with bus voltage angle measurements represented by the set <span>$\bar{\mathcal{P}}_\text{b}$</span>. These measurements contribute to the construction of a linear system of equations:</p><p class="math-container">\[    \mathbf{z}=\mathbf{h}(\bm {\Theta})+\mathbf{u},\]</p><p>where <span>$\mathbf{h}(\bm {\Theta})=$</span> <span>$[h_1(\bm {\Theta})$</span>, <span>$\dots$</span>, <span>$h_k(\bm {\Theta})]^{{T}}$</span> is the vector of linear measurement functions, <span>$\mathbf{z} = [z_1,\dots,z_k]^{\mathrm{T}}$</span> is the vector of measurement values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{\mathrm{T}}$</span> is the vector of uncorrelated measurement errors, and this defines the vector of measurement variances <span>$\mathbf{v} = [v_1,\dots,v_k]^{\mathrm{T}}$</span>, where <span>$k = |\mathcal{M}|$</span>.</p><p>Therefore, the linear system of equations can be represented based on the specific devices from which measurements originate, whether wattmeters or PMUs:</p><p class="math-container">\[    \begin{bmatrix}
      \mathbf{z}_\mathcal{P}\\[3pt]
      \mathbf{z}_{\bar{\mathcal{P}}_\text{b}}
    \end{bmatrix} =
    \begin{bmatrix}
      \mathbf{h}_\mathcal{P}(\bm {\Theta})\\[3pt]
      \mathbf{h}_{\bar{\mathcal{P}}_\text{b}}(\bm {\Theta})
    \end{bmatrix} +
    \begin{bmatrix}
      \mathbf{u}_\mathcal{P}\\[3pt]
      \mathbf{u}_{\bar{\mathcal{P}}_\text{b}}.
    \end{bmatrix}\]</p><p>In summary, upon user definition of the measurement devices, each <span>$i$</span>-th measurement device is linked to the measurement function <span>$h_i(\bm {\Theta})$</span>, the corresponding measurement value <span>$z_i$</span>, and the measurement variance <span>$v_i$</span>.</p><hr/><h5 id="Active-Power-Injection-Measurements"><a class="docs-heading-anchor" href="#Active-Power-Injection-Measurements">Active Power Injection Measurements</a><a id="Active-Power-Injection-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-Measurements" title="Permalink"></a></h5><p>When adding a wattmeter <span>$P_i \in \mathcal{P}$</span> at bus <span>$i \in \mathcal{N}$</span>, users specify that the wattmeter measures active power injection and define measurement value, variance and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{P} = [z_{P_{i}}], \;\;\; \mathbf{v}_\mathcal{P} = [v_{P_{i}}], \;\;\; \mathbf{h}_\mathcal{P}(\bm {\Theta}) = [h_{P_{i}}(\bm {\Theta})].\]</p><p>For example:</p><pre><code class="language-julia hljs">addWattmeter!(monitoring; label = &quot;P₃&quot;, bus = 3, active = -1.30, variance = 1e-3)</code></pre><p>Here, utilizing the <a href="../powerSystemModel/#DCNodalNetworkEquationsTutorials">DC Model</a>, we derive the function defining the active power injection as follows:</p><p class="math-container">\[   h_{P_{i}}(\bm {\Theta}) = B_{ii}\theta_i + \sum_{j \in \mathcal{N}_i \setminus i} {B}_{ij} \theta_j + P_{\text{tr}i} + P_{\text{sh}i},\]</p><p>where <span>$\mathcal{N}_i \setminus i$</span> contains buses incident to bus <span>$i$</span>, excluding bus <span>$i$</span>, with the following coefficient expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{P_{i}}(\bm {\Theta})}}{\mathrm \partial \theta_{i}} = B_{ii}, \;\;\;
  \cfrac{\mathrm \partial{{h_{P_{i}}}(\bm {\Theta})}}{\mathrm \partial \theta_{j}} = {B}_{ij}.
  \end{aligned}\]</p><hr/><h5 id="From-Bus-End-Active-Power-Flow-Measurements"><a class="docs-heading-anchor" href="#From-Bus-End-Active-Power-Flow-Measurements">From-Bus End Active Power Flow Measurements</a><a id="From-Bus-End-Active-Power-Flow-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#From-Bus-End-Active-Power-Flow-Measurements" title="Permalink"></a></h5><p>Additionally, when introducing a wattmeter at branch <span>$(i,j) \in \mathcal{E}$</span>, users specify that the wattmeter measures active power flow. It can be positioned at the from-bus end, denoted as <span>$P_{ij} \in \mathcal{P}$</span>, specifying the measurement value, variance and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{P} = [z_{P_{ij}}], \;\;\; \mathbf{v}_\mathcal{P} = [v_{P_{ij}}], \;\;\; \mathbf{h}_\mathcal{P}(\bm {\Theta}) = [h_{P_{ij}}(\bm {\Theta})].\]</p><p>For example:</p><pre><code class="language-julia hljs">addWattmeter!(monitoring; label = &quot;P₁₂&quot;, from = 1, active = 0.28, variance = 1e-4)</code></pre><p>Here, the function describing active power flow at the from-bus end is defined as follows:</p><p class="math-container">\[  h_{P_{ij}}(\bm {\Theta}) = \cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij}),\]</p><p>with the following coefficient expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{P_{ij}}(\bm {\Theta})}}{\mathrm \partial \theta_{i}} = \cfrac{1}{\tau_{ij} x_{ij}}, \;\;\;
    \cfrac{\mathrm \partial{{h_{P_{ij}}}(\bm {\Theta})}}{\mathrm \partial \theta_{j}} = -\cfrac{1}{\tau_{ij} x_{ij}}.
  \end{aligned}\]</p><hr/><h5 id="To-Bus-End-Active-Power-Flow-Measurements"><a class="docs-heading-anchor" href="#To-Bus-End-Active-Power-Flow-Measurements">To-Bus End Active Power Flow Measurements</a><a id="To-Bus-End-Active-Power-Flow-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#To-Bus-End-Active-Power-Flow-Measurements" title="Permalink"></a></h5><p>Similarly, a wattmeter can be placed at the to-bus end, denoted as <span>$P_{ji} \in \mathcal{P}$</span>, specifying the measurement value, variance and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{P} = [z_{P_{ji}}], \;\;\; \mathbf{v}_\mathcal{P} = [v_{P_{ji}}], \;\;\; \mathbf{h}_\mathcal{P}(\bm {\Theta}) = [h_{P_{ji}}(\bm {\Theta})].\]</p><p>For example:</p><pre><code class="language-julia hljs">addWattmeter!(monitoring; label = &quot;P₂₁&quot;, to = 1, active = -0.28, variance = 1e-4)</code></pre><p>Thus, the function describing active power flow at the to-bus end is defined as follows:</p><p class="math-container">\[  h_{P_{ji}}(\bm {\Theta}) = -\cfrac{1}{\tau_{ij} x_{ij}} (\theta_{i} -\theta_{j}-\phi_{ij}),\]</p><p>with the following coefficient expressions:</p><p class="math-container">\[  \cfrac{\mathrm \partial{h_{P_{ji}}(\bm {\Theta})}}{\mathrm \partial \theta_{i}} = -\cfrac{1}{\tau_{ij} x_{ij}}, \;\;\;
  \cfrac{\mathrm \partial{{h_{P_{ji}}}(\bm {\Theta})}}{\mathrm \partial \theta_{j}} = \cfrac{1}{\tau_{ij} x_{ij}}.\]</p><hr/><h5 id="Bus-Voltage-Angle-Measurements"><a class="docs-heading-anchor" href="#Bus-Voltage-Angle-Measurements">Bus Voltage Angle Measurements</a><a id="Bus-Voltage-Angle-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Angle-Measurements" title="Permalink"></a></h5><p>If the user opts to include phasor measurements that measure bus voltage angle at bus <span>$i \in \mathcal{N}$</span>, denoted as <span>$\theta_i \in \bar{\mathcal{P}}_\text{b}$</span>, the user will specify the measurement values, variances, and measurement functions of vectors:</p><p class="math-container">\[    \mathbf{z}_{\bar{\mathcal{P}}_\text{b}} = [z_{\theta_i}], \;\;\; \mathbf{v}_{\bar{\mathcal{P}}_\text{b}} = [v_{\theta_i}], \;\;\; \mathbf{h}_{\bar{\mathcal{P}}_\text{b}}(\bm {\Theta}) = [h_{\theta_{i}}(\bm {\Theta})].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;V₁, θ₁&quot;, bus = 1, magnitude = 1.0, angle = 0,
  varianceMagnitude = 1e-5, varianceAngle = 1e-6
)</code></pre><p>Here, the function defining the bus voltage angle measurement is straightforward:</p><p class="math-container">\[    h_{\theta_{i}}(\bm {\Theta}) = \theta_{i},\]</p><p>with the following coefficient expression:</p><p class="math-container">\[  \cfrac{\mathrm \partial{{h_{\theta_i}(\bm {\Theta})}}}{\mathrm \partial \theta_{i}}=1.\]</p><hr/><h2 id="DCSEWLSStateEstimationTutorials"><a class="docs-heading-anchor" href="#DCSEWLSStateEstimationTutorials">Weighted Least-Squares Estimation</a><a id="DCSEWLSStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEWLSStateEstimationTutorials" title="Permalink"></a></h2><p>The solution to the DC state estimation problem is determined by solving the linear weighted least-squares (WLS) problem, represented by the following formula:</p><p class="math-container">\[	\mathbf H^{T} \bm \Sigma^{-1} \mathbf H \bm {\Theta} = \mathbf H^{T} \bm \Sigma^{-1} (\mathbf z - \mathbf{c}).\]</p><p>Here, <span>$\mathbf z \in \mathbb {R}^{k}$</span> denotes the vector of measurement values, the vector <span>$\mathbf c \in \mathbb {R}^{k}$</span> holds constant terms, <span>$\mathbf {H} \in \mathbb {R}^{k \times (n-1)}$</span> represents the coefficient matrix, and <span>$\bm \Sigma \in \mathbb {R}^{k \times k}$</span> is the measurement error covariance matrix, where the diagonal elements hold measurement variances.</p><p>The inclusion of the vector <span>$\mathbf{c}$</span> is necessary due to the fact that measurement functions associated with active power measurements may include constant terms, especially when there are non-zero shift angles of transformers or shunt elements in the system consuming active powers, as evident from the provided measurement functions.</p><hr/><h5 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h5><p>JuliaGrid initiates the DC state estimation framework by setting up the WLS model, as illustrated in the following:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(monitoring)</code></pre><hr/><h5 id="Coefficient-Matrix"><a class="docs-heading-anchor" href="#Coefficient-Matrix">Coefficient Matrix</a><a id="Coefficient-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficient-Matrix" title="Permalink"></a></h5><p>Using the above-described equations, JuliaGrid forms the coefficient matrix <span>$\mathbf{H} \in \mathbb{R}^{k \times (n-1)}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐇 = analysis.method.coefficient</code><code class="nohighlight hljs ansi" style="display:block;">4×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
 -10.0  -3.33333  13.3333
   5.0  -5.0        ⋅
  -5.0   5.0        ⋅
   1.0    ⋅         ⋅</code></pre><p>Each row in the matrix corresponds to a specific measurement. The first <span>$|\mathcal{P}|$</span> rows correspond to wattmeters, ordered as users add wattmeters, while the last <span>$|{\bar{\mathcal{P}}_\text{b}}|$</span> rows correspond to PMUs, also in the order users add PMUs.</p><hr/><h5 id="Precision-Matrix"><a class="docs-heading-anchor" href="#Precision-Matrix">Precision Matrix</a><a id="Precision-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-Matrix" title="Permalink"></a></h5><p>JuliaGrid opts not to retain the covariance matrix <span>$\bm \Sigma$</span> but rather stores its inverse, the precision or weighting matrix denoted as <span>$\mathbf W = \bm \Sigma^{-1}$</span>. The order of these values corresponds to the description provided for the coefficient matrix. Users can access these values using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐖 = analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1000.0       ⋅        ⋅    ⋅
     ⋅   10000.0       ⋅    ⋅
     ⋅        ⋅   10000.0   ⋅
     ⋅        ⋅        ⋅   1.0e6</code></pre><hr/><h5 id="Mean-Vector"><a class="docs-heading-anchor" href="#Mean-Vector">Mean Vector</a><a id="Mean-Vector-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Vector" title="Permalink"></a></h5><p>Users can access the vector <span>$\mathbf z - \mathbf{c}$</span>, which contains the means of Gaussian distributions describing each measurement, using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐳 = analysis.method.mean</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -1.3
  0.28
 -0.28
  0.0</code></pre><p>In the context of the power system, where phase-shifting transformers and shunt elements consuming active powers are absent, and the slack angle has a zero value, the vector <span>$\mathbf{c}= \mathbf{0}$</span>. Consequently, the vector of means holds values that are equal to the measurement values.</p><hr/><h5 id="Estimate-of-State-Variables"><a class="docs-heading-anchor" href="#Estimate-of-State-Variables">Estimate of State Variables</a><a id="Estimate-of-State-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Estimate-of-State-Variables" title="Permalink"></a></h5><p>Once the model is established, we solve the WLS equation to derive the estimate of bus voltage angles:</p><p class="math-container">\[	\hat{\bm {\Theta}} = [\mathbf H^{T} \bm \Sigma^{-1} \mathbf H]^{-1} \mathbf H^{T} \bm \Sigma^{-1} (\mathbf z - \mathbf{c}).\]</p><p>This process is executed using the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>The initial step involves the LU factorization of the gain matrix:</p><p class="math-container">\[	\mathbf G = \mathbf H^{T} \bm \Sigma^{-1} \mathbf H = \mathbf L \mathbf U.\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>By default, JuliaGrid utilizes LU factorization as the primary method to factorize the gain matrix. However, users maintain the flexibility to opt for alternative factorization methods such as LDLt or QR.</p></div></div><p>Access to the factorized gain matrix is available through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐋 = analysis.method.factorization.L</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0    ⋅         ⋅
  ⋅    1.0        ⋅
  ⋅   -0.217391  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐔 = analysis.method.factorization.U</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0   ⋅      ⋅
  ⋅   0.92  -0.08
  ⋅    ⋅     0.782609</code></pre><p>Finally, the estimated bus voltage angles <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, <span>$i \in \mathcal{N}$</span>, can be retrieved using the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.05600000000000001
 -0.11150000000000002</code></pre><p>It is essential to note that the slack bus voltage angle is temporarily excluded from the gain matrix <span>$\mathbf G$</span> during computation. It is important to emphasize that this internal handling does not alter the stored elements.</p><hr/><h5 id="DCSEOrthogonalWLSStateEstimationTutorials"><a class="docs-heading-anchor" href="#DCSEOrthogonalWLSStateEstimationTutorials">Alternative Formulation</a><a id="DCSEOrthogonalWLSStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEOrthogonalWLSStateEstimationTutorials" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from converging to a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal factorization [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 3.2].</p><p>To address ill-conditioned situations arising from significant differences in measurement variances, users can employ an alternative approach:</p><pre><code class="language-julia hljs">analysis = dcStateEstimation(monitoring, Orthogonal)</code></pre><p>To explain the method, we begin with the WLS equation:</p><p class="math-container">\[	\mathbf H^{T} \mathbf W \mathbf H \bm {\Theta} = \mathbf H^{T} \mathbf W (\mathbf z - \mathbf{c}),\]</p><p>where <span>$\mathbf W = \bm \Sigma^{-1}$</span>. Subsequently, we can write:</p><p class="math-container">\[  \left({\mathbf W^{1/2}} \mathbf H\right)^{T}  {\mathbf W^{1/2}} \mathbf H  \bm {\Theta} = \left({\mathbf W^{1/2}} \mathbf H\right)^{T} {\mathbf W^{1/2}} (\mathbf z - \mathbf{c}).\]</p><p>Consequently, we have:</p><p class="math-container">\[  \bar{\mathbf{H}}^{T}  \bar{\mathbf{H}} \bm {\Theta} = \bar{\mathbf{H}}^{T}  \bar{\mathbf{z}},\]</p><p>where:</p><p class="math-container">\[  \bar{\mathbf{H}} = {\mathbf W^{1/2}} \mathbf H; \;\;\; \bar{\mathbf{z}} = {\mathbf W^{1/2}} (\mathbf z - \mathbf{c}).\]</p><p>At this point, QR factorization is performed on the rectangular matrix:</p><p class="math-container">\[  \bar{\mathbf{H}} = {\mathbf W^{1/2}} \mathbf H = \mathbf{Q}\mathbf{R}.\]</p><p>Executing this procedure involves the <a href="../../api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>Access to the factorized matrix is possible through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐 = analysis.method.factorization.Q</code><code class="nohighlight hljs ansi" style="display:block;">4×4 SparseArrays.SPQR.QRSparseQ{Float64, Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐑 = analysis.method.factorization.R</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 421.637  -105.409  0.0
    ⋅      707.107   ⋅
    ⋅         ⋅      ⋅</code></pre><p>To obtain the solution, JuliaGrid avoids materializing the orthogonal matrix <span>$\mathbf{Q}$</span> and proceeds to solve the system, resulting in the estimate of state variables <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, where <span>$i \in \mathcal{N}$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.05600000000000001
 -0.1115</code></pre><hr/><h2 id="DCSELAVTutorials"><a class="docs-heading-anchor" href="#DCSELAVTutorials">Least Absolute Value Estimation</a><a id="DCSELAVTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSELAVTutorials" title="Permalink"></a></h2><p>The least absolute value (LAV) method provides an alternative estimation approach that is considered more robust in comparison to the WLS method. The WLS state estimation problem relies on specific assumptions about measurement errors, whereas robust estimators aim to remain unbiased even in the presence of various types of measurement errors and outliers. This characteristic eliminates the need for bad data analysis, as discussed in [<a href="../../background/bibliography/#aburbook">5</a>, Ch. 6]. It is important to note that robustness often comes at the cost of increased computational complexity.</p><p>It can be demonstrated that the problem can be expressed as a linear programming problem. This section outlines the method as described in [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 6.5]. To revisit, we consider the system of linear equations:</p><p class="math-container">\[  \mathbf{z}=\mathbf{h}(\bm {\Theta})+\mathbf{u}.\]</p><p>The LAV state estimator is then formulated as the solution to the following optimization problem:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \sum_{i \in \mathcal M} |r_i|\\
    \text{subject\;to}&amp; \;\;\; z_i - h_i(\bm {\Theta}) =  r_i, \;\;\; \forall i \in \mathcal M,
  \end{aligned}\]</p><p>where <span>$r_i$</span> denotes the residual of the <span>$i$</span>-th measurement.</p><p>To explicitly handle absolute values, we introduce two nonnegative variables <span>$u_i \ge 0$</span> and <span>$v_i \ge 0$</span>, referred to as positive and negative deviations. This allows the optimization problem to be rewritten as:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \sum_{i \in \mathcal M} (u_i + v_i) \\
    \text{subject\;to}  &amp; \;\;\; z_i - h_i(\bm {\Theta}) = u_i - v_i, \;\;\; \forall i \in \mathcal M \\
                        &amp; \;\;\; u_i \geq  0, \; v_i \geq  0, \;\;\; \forall i \in \mathcal M.
  \end{aligned}\]</p><p>To form the above optimization problem, the user can call the following function:</p><pre><code class="language-julia hljs">using Ipopt

analysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer)</code></pre><p>Then the user can solve the optimization problem by:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>Users can retrieve the estimated bus voltage angles <span>$\hat{\bm {\Theta}} = [\hat{\theta}_i]$</span>, <span>$i \in \mathcal{N}$</span>, using the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.05600000000000001
 -0.1115</code></pre><hr/><h2 id="DCSEPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#DCSEPowerAnalysisTutorials">Power Analysis</a><a id="DCSEPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCSEPowerAnalysisTutorials" title="Permalink"></a></h2><p>After obtaining the solution from the DC state estimation, we can calculate powers related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../powerSystemModel/#DCBusInjectionTutorials">Active power injections</a> are stored as the vector <span>$\mathbf{P} = [P_i]$</span>, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏 = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  1.395
 -0.09500000000000008
 -1.3</code></pre><hr/><h5 id="Generator-Power-Injections"><a class="docs-heading-anchor" href="#Generator-Power-Injections">Generator Power Injections</a><a id="Generator-Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Power-Injections" title="Permalink"></a></h5><p>We can determine the active power supplied by generators to the buses by summing the active power injections and the active power demanded by consumers at each bus:</p><p class="math-container">\[    P_{\text{p}i} = P_i + P_{\text{d}i},\;\;\; i \in \mathcal{N}.\]</p><p>The vector of active power injected by generators into the buses, denoted by <span>$\mathbf{P}_{\text{p}} = [P_{\text{p}i}]$</span>, can be obtained using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₚ = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.395
 0.004999999999999921
 0.0</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">active power flows</a> are stored as the vector <span>$\mathbf{P}_{\text{i}} = [P_{ij}]$</span>, which can be retrieved using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ᵢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.28
 1.115
 0.185</code></pre><p>Similarly, the resulting <a href="../powerSystemModel/#DCBranchNetworkEquationsTutorials">active power flows</a> are stored as the vector <span>$\mathbf{P}_{\text{j}} = [P_{ji}]$</span>, which can be retrieved using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ⱼ = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.28
 -1.115
 -0.185</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pmuStateEstimation/">« PMU State Estimation</a><a class="docs-footer-nextpage" href="../badDataAnalysis/">Bad Data Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 15 April 2025 11:21">Tuesday 15 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
