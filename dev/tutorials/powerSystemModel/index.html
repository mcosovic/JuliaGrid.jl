<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power System Model · JuliaGrid</title><meta name="title" content="Power System Model · JuliaGrid"/><meta property="og:title" content="Power System Model · JuliaGrid"/><meta property="twitter:title" content="Power System Model · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../manual/badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Power System Model</a><ul class="internal"><li><a class="tocitem" href="#ACModelTutorials"><span>AC Model</span></a></li><li><a class="tocitem" href="#DCModelTutorials"><span>DC Model</span></a></li></ul></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Power System Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power System Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/powerSystemModel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACDCModelTutorials"><a class="docs-heading-anchor" href="#ACDCModelTutorials">Power System Model</a><a id="ACDCModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACDCModelTutorials" title="Permalink"></a></h1><p>Power system analyses commonly utilize the unified branch model that provides linear relationships between voltages and currents. However, as the focus is on power calculations rather than current calculations, the resulting equations become nonlinear, posing challenges in solving them [<a href="../../background/bibliography/#andersson2012power">6</a>]. Hence, to accurately analyze power systems without any approximations, we use the AC model, which is a crucial component of our framework. In contrast, to obtain a linear system of equations for various DC analyses, we introduce approximations in the unified branch model, resulting in the DC model.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In this section, we not only describe the AC and DC models derived from the unified branch model but also furnish the power and current equations utilized in all JuliaGrid analyses.</p></div></div><p>A common way to describe the power system network topology is through the bus/branch model, which employs the two-port <span>$\pi$</span>-model, which results in the unified branch model. The bus/branch model can be represented by a graph denoted by <span>$\mathcal G = (\mathcal N, \mathcal E)$</span>, where the set of nodes <span>$\mathcal N = \{1, \dots, n\}$</span> corresponds to buses, and the set of edges <span>$\mathcal E \subseteq \mathcal N \times \mathcal N$</span> represents the branches of the power network.</p><p>Let us now construct the power system:</p><pre><code class="language-julia hljs">@config(label = Integer)
@power(MW, MVAr)
@voltage(pu, deg)

system = powerSystem()

addBus!(system; label = 1, type = 3)
addBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)
addBus!(system; label = 3, type = 2, conductance = 2.1, susceptance = 1.2)

addBranch!(system; from = 1, to = 2, resistance = 0.02, reactance = 0.06, susceptance = 0.05)
addBranch!(system; from = 2, to = 3, reactance = 0.21, turnsRatio = 0.98, shiftAngle = 1.2)

addGenerator!(system; bus = 1, active = 40.0, reactive = 42.4)</code></pre><p>The given example provides the set of buses <span>$\mathcal N$</span> and the set of branches <span>$\mathcal E$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒩 = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 1  2
 2  3</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>In this section, when referring to a vector <span>$\mathbf a$</span>, we use the notation <span>$\mathbf a = [a_{ij}]$</span>, where <span>$a_{ij}$</span> represents the generic element associated with the branch <span>$(i,j) \in \mathcal E$</span>.</p></div></div><hr/><h2 id="ACModelTutorials"><a class="docs-heading-anchor" href="#ACModelTutorials">AC Model</a><a id="ACModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACModelTutorials" title="Permalink"></a></h2><p>To generate matrices and vectors for AC analysis, JuliaGrid employs the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function:</p><pre><code class="language-julia hljs">acModel!(system)</code></pre><hr/><h5 id="UnifiedBranchModelTutorials"><a class="docs-heading-anchor" href="#UnifiedBranchModelTutorials">Unified Branch Model</a><a id="UnifiedBranchModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#UnifiedBranchModelTutorials" title="Permalink"></a></h5><p>The equivalent unified <span>$\pi$</span>-model for a branch <span>$(i,j) \in \mathcal E$</span> incident to the buses <span>$\{i,j\} \in \mathcal N$</span> is shown in Figure 1.</p><div style="text-align: center;">
  <img src="../../assets/tutorials/powerSystemModel/pi_model.svg" width="500" class="my-svg"/>
  <p>Figure 1: The equivalent branch model, where the transformer is located at the from-bus end of the branch.</p>
</div>
&nbsp;<div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The directions of the currents <span>$\bar{I}_{ij}$</span>, <span>$\bar{I}_{ji}$</span>, <span>$\bar{I}_{\mathrm{s}i}$</span>, and <span>$\bar{I}_{\mathrm{s}j}$</span> are vital for power flow analysis. Positive power aligns with the assumed current direction, moving away from the bus, while negative power implies a reverse flow towards the bus. JuliaGrid consistently uses these directions, along with <span>$\bar{I}_{\mathrm{l}ij}$</span>, for power and current calculations.</p></div></div><p>The branch series admittance <span>$y_{ij}$</span> is inversely proportional to the branch series impedance <span>$z_{ij}$</span>:</p><p class="math-container">\[  y_{ij} = \frac{1}{z_{ij}} = \frac{1}{r_{ij} + \mathrm{j} x_{ij}} =
  \frac{r_{ij}}{r_{ij}^2 + x_{ij}^2} - \mathrm{j} \frac{x_{ij}}{r_{ij}^2 + x_{ij}^2} = g_{ij} + \mathrm{j} b_{ij},\]</p><p>where <span>$r_{ij}$</span> is a resistance, <span>$x_{ij}$</span> is a reactance, <span>$g_{ij}$</span> is a conductance and <span>$b_{ij}$</span> is a susceptance of the branch.</p><p>The vectors of resistances, denoted by <span>$\mathbf r = [r_{ij}]$</span>, and reactances, denoted by <span>$\mathbf x = [x_{ij}]$</span>, are stored in the variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐫 = system.branch.parameter.resistance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.02
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐱 = system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.06
 0.21</code></pre><p>Moreover, the <code>ac</code> field stores the computed vector of branch series admittances <span>$\mathbf y = [y_{ij}]$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐲 = system.model.ac.admittance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 5.0 - 15.0im
 0.0 - 4.761904761904763im</code></pre><p>The branch shunt admittance <span>$y_{\mathrm{s}ij}$</span> is equal to:</p><p class="math-container">\[  y_{\mathrm{s}ij} = g_{\mathrm{s}ij} + \mathrm{j} b_{\mathrm{s}ij},\]</p><p>where <span>$g_{\mathrm{s}ij}$</span> represents the shunt conductance of the branch, and <span>$b_{\mathrm{s}ij}$</span> represents the shunt susceptance. Both of these values are positive for real line sections. It is worth noting that while the shunt conductance <span>$g_{\mathrm{s}ij}$</span> is often insignificantly small and can be ignored in many cases, it is included in the analyses to ensure comprehensive consideration of all potential scenarios.</p><p>Within JuliaGrid, the total shunt conductances and susceptances of branches are stored. In order to obtain the vectors <span>$\mathbf{g}_\mathrm{s} = [g_{\mathrm{s}ij}]$</span> and <span>$\mathbf{b}_\mathrm{s} = [b_{\mathrm{s}ij}]$</span>, the conductances and susceptances must be distributed by considering the ends of the branches:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐠ₛ = 0.5 * system.branch.parameter.conductance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐛ₛ = 0.5 * system.branch.parameter.susceptance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.025
 0.0</code></pre><p>The transformer complex ratio <span>$\alpha_{ij}$</span> is defined:</p><p class="math-container">\[  \alpha_{ij} = \cfrac{1}{\tau_{ij}} e^{-\mathrm{j}\phi_{ij}},\]</p><p>where <span>$\tau_{ij} \neq 0$</span> is a transformer turns ratio, specifically the off-nominal turns ratio, while <span>$\phi_{ij}$</span> is a transformer phase shift angle, always located at the from-bus end of the branch. Note, if <span>$\tau_{ij} = 1$</span> and <span>$\phi_{ij} = 0$</span> the model describes the line. In-phase transformers are defined if <span>$\tau_{ij} \neq 1$</span>, <span>$\phi_{ij} = 0$</span>, and <span>$y_{\mathrm{s}ij} = 0$</span>, while phase-shifting transformers are obtained if <span>$\tau_{ij} \neq 1$</span>, <span>$\phi_{ij} \neq 0$</span>, and <span>$y_{\mathrm{s}ij} = 0$</span>.</p><p>These transformer parameters are stored in the vectors <span>$\bm \tau = [\tau_{ij}]$</span> and <span>$\bm \phi = [\phi_{ij}]$</span>, respectively:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛕 = system.branch.parameter.turnsRatio</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.0
 0.98</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚽 = system.branch.parameter.shiftAngle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.0
 0.020943951023931952</code></pre><hr/><h5 id="BranchShuntElementsTutorials"><a class="docs-heading-anchor" href="#BranchShuntElementsTutorials">Branch Shunt Elements</a><a id="BranchShuntElementsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#BranchShuntElementsTutorials" title="Permalink"></a></h5><p>The currents flowing through shunt admittances denoted as <span>$y_{\mathrm{s}ij}$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \bar{I}_{\mathrm{s}i} &amp;= \alpha_{ij} y_{\mathrm{s}ij} \bar{V}_i, \;\;\; (i,j) \in \mathcal E \\
    \bar{I}_{\mathrm{s}j} &amp;= y_{\mathrm{s}ij} \bar{V}_j, \;\;\; (i,j) \in \mathcal E.
  \end{aligned}\]</p><p>With these specified currents in place, it becomes straightforward to compute both the total active and reactive power that branch shunt elements demand and inject concerning the power system:</p><p class="math-container">\[  S_{\mathrm{s}ij} = P_{\mathrm{s}ij} + \mathrm{j} Q_{\mathrm{s}ij} = \alpha_{ij} \bar{V}_i \bar{I}_{\mathrm{s}i}^* + \bar{V}_j \bar{I}_{\mathrm{s}j}^* =
  y_{\mathrm{s}ij}^* (\alpha_{ij}^2 V_i^2 + V_j^2), \;\;\; (i,j) \in \mathcal E.\]</p><p>For real branch sections, the reactive power is negative, <span>$Q_{\mathrm{s}ij} &lt; 0$</span>, signifying that the branch injects reactive power due to its capacitive nature. The negative sign implies that the power flow direction opposes the assumed direction set by the currents <span>$\bar{I}_{\mathrm{s}i}$</span> and <span>$\bar{I}_{\mathrm{s}j}$</span>. The active power <span>$P_{\mathrm{s}ij}$</span> represents active losses within the branch shunt admittances.</p><hr/><h5 id="BranchSeriesElementTutorials"><a class="docs-heading-anchor" href="#BranchSeriesElementTutorials">Branch Series Element</a><a id="BranchSeriesElementTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#BranchSeriesElementTutorials" title="Permalink"></a></h5><p>The current flowing through a series admittance, denoted as <span>$y_{ij}$</span>, is defined as follows:</p><p class="math-container">\[  \bar{I}_{\mathrm{l}ij} = \alpha_{ij} y_{ij} \bar{V}_i - y_{ij} \bar{V}_i, \;\;\; (i,j) \in \mathcal E.\]</p><p>Consequently, the active and reactive powers associated with the branch series element are as follows:</p><p class="math-container">\[  S_{\mathrm{l}ij} = P_{\mathrm{l}ij} + \mathrm{j}Q_{\mathrm{l}ij} = (\alpha_{ij} \bar{V}_i - \bar{V}_j) \bar{I}_{\mathrm{l}ij}^* =
  y_{ij}^* (\alpha_{ij} \bar{V}_i - \bar{V}_j) (\alpha_{ij} \bar{V}_i - \bar{V}_j)^*, \;\;\; (i,j) \in \mathcal E.\]</p><p>The active power <span>$P_{\mathrm{l}ij}$</span> accounts for losses originating from the resistance <span>$r_{ij}$</span> of the branch, while the reactive power <span>$Q_{\mathrm{l}ij}$</span> represents losses resulting from the inductive characteristics of the impedance defined by reactance <span>$x_{ij}$</span>. This can be observed when the reactive power is positive <span>$Q_{\mathrm{l}ij} &gt; 0$</span>.</p><hr/><h5 id="BranchNetworkEquationsTutorials"><a class="docs-heading-anchor" href="#BranchNetworkEquationsTutorials">Branch Network Equations</a><a id="BranchNetworkEquationsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#BranchNetworkEquationsTutorials" title="Permalink"></a></h5><p>Using Kirchhoff&#39;s circuit laws, the branch model can be described by complex expressions:</p><p class="math-container">\[  \begin{bmatrix}
    \bar{I}_{ij} \\ \bar{I}_{ji}
  \end{bmatrix} =
  \begin{bmatrix}
    \cfrac{1}{\tau_{ij}^2} (y_{ij} + y_{\mathrm{s}ij}) &amp; -\alpha_{ij}^* y_{ij}\\
    -\alpha_{ij} y_{ij} &amp; y_{ij} + y_{\mathrm{s}ij}
  \end{bmatrix}
  \begin{bmatrix}
    \bar{V}_i \\ \bar{V}_j
  \end{bmatrix}.\]</p><p>The admittance parameters are stored in the vectors <span>$\mathbf{y}_{\mathrm{ii}} = [(y_{ij} + y_{\mathrm{s}ij}) / \tau_{ij}^2]$</span>, <span>$\mathbf{y}_{\mathrm{ij}} = [-\alpha_{ij}^* y_{ij}]$</span>, <span>$\mathbf{y}_{\mathrm{ji}} = [-\alpha_{ij} y_{ij}]$</span>, and <span>$\mathbf{y}_{\mathrm{jj}} = [y_{ij} + y_{\mathrm{s}ij}]$</span> and can be found in the variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐲ᵢᵢ = system.model.ac.nodalFromFrom</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 5.0 - 14.975im
 0.0 - 4.958251522183218im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐲ᵢⱼ = system.model.ac.nodalFromTo</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
                 -5.0 + 15.0im
 -0.10176102955955763 + 4.85802081377476im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐲ⱼᵢ = system.model.ac.nodalToFrom</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
                -5.0 + 15.0im
 0.10176102955955763 + 4.85802081377476im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐲ⱼⱼ = system.model.ac.nodalToTo</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 5.0 - 14.975im
 0.0 - 4.761904761904763im</code></pre><p>In this context, we have easily derived the active and reactive power flow at the from-bus end of the branch:</p><p class="math-container">\[  S_{ij} = P_{ij} + \mathrm{j} Q_{ij} =
  \bar{V}_i \left[\cfrac{1}{\tau_{ij}^2} (y_{ij} + y_{\mathrm{s}ij}) \bar{V}_i - \alpha_{ij}^* y_{ij} \bar{V}_j\right]^*, \;\;\; (i,j) \in \mathcal E.\]</p><p>Similarly, we can determine the active and reactive power flow at the to-bus end of the branch:</p><p class="math-container">\[  S_{ji} = P_{ji} + \mathrm{j} Q_{ji} =
  \bar{V}_j \left[-\alpha_{ij} y_{ij} \bar{V}_i + (y_{ij} + y_{\mathrm{s}ij}) \bar{V}_j\right]^*, \;\;\; (i,j) \in \mathcal E.\]</p><p>Positive values of active or reactive power, <span>$P_{ij} &gt; 0$</span> or <span>$Q_{ij} &gt; 0$</span>, indicate power flow originating from the from-bus and moving towards the to-bus, following the direction of the current <span>$\bar{I}_{ij}$</span>. Conversely, negative values, <span>$P_{ij} &lt; 0$</span> or <span>$Q_{ij} &lt; 0$</span>, signify power flow in the opposite direction. The same principles apply to <span>$P_{ji} &gt; 0$</span> or <span>$Q_{ji} &gt; 0$</span>, indicating power flow from the to-bus to the from-bus, aligned with the current <span>$\bar{I}_{ji}$</span>, while negative values, <span>$P_{ji} &lt; 0$</span> or <span>$Q_{ji} &lt; 0$</span>, denote the reverse flow direction.</p><hr/><h5 id="NodalNetworkEquationsTutorials"><a class="docs-heading-anchor" href="#NodalNetworkEquationsTutorials">Nodal Network Equations</a><a id="NodalNetworkEquationsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#NodalNetworkEquationsTutorials" title="Permalink"></a></h5><p>Let us consider an illustrative example from our case study, depicted in Figure 2. This example provides a smooth transition to the general case, demonstrating a system with three buses represented as <span>$\mathcal{N} = \{1, 2, 3\}$</span> and two branches <span>$\mathcal{E} = \{(1, 2), (2, 3)\}$</span>, where bus <span>$2$</span> is incident to the shunt element with admittance <span>${y}_{\mathrm{sh}2}$</span>.</p><div style="text-align: center;">
  <img src="../../assets/tutorials/powerSystemModel/pi_model_example.svg" width="650" class="my-svg"/>
  <p>Figure 2: The example of the system with three buses and two branches.</p>
</div>
&nbsp;<div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The current <span>$\bar{I}_{\mathrm{sh}2}$</span> follows the convention of coming out from the bus in terms of its direction. When calculating powers related to shunt elements, this current direction is assumed. Therefore, in cases where power is positive, it signifies alignment with the assumed current direction, emerging away from the bus. Conversely, when power is negative, the direction is reversed, indicating a flow towards the bus.</p></div></div><p>According to the <a href="#BranchNetworkEquationsTutorials">Branch Network Equations</a> each branch is described using the system of equations as follows:</p><p class="math-container">\[  \begin{bmatrix}
    \bar{I}_{12} \\ \bar{I}_{21}
  \end{bmatrix} =
  \begin{bmatrix}
    \cfrac{1}{\tau_{12}^2} (y_{12} + y_{\mathrm{s}12}) &amp; -\alpha_{12}^* y_{12}\\
    -\alpha_{12} y_{12} &amp; y_{12} + y_{\mathrm{s}12}
  \end{bmatrix}
  \begin{bmatrix}
    \bar{V}_1 \\ \bar{V}_2
  \end{bmatrix}\]</p><p class="math-container">\[  \begin{bmatrix}
    \bar{I}_{23} \\ \bar{I}_{32}
  \end{bmatrix} =
  \begin{bmatrix}
    \cfrac{1}{\tau_{23}^2} (y_{23} + y_{\mathrm{s}23}) &amp; -\alpha_{23}^* y_{23}\\
    -\alpha_{23} y_{23} &amp; y_{23} + y_{\mathrm{s}23}
  \end{bmatrix}
  \begin{bmatrix}
    \bar{V}_2 \\ \bar{V}_3
  \end{bmatrix}.\]</p><p>The complex current injections at buses are:</p><p class="math-container">\[  \begin{aligned}
    \bar{I}_1 &amp;= \bar{I}_{12} = \cfrac{1}{\tau_{12}^2} (y_{12} + y_{\mathrm{s}12}) \bar{V}_1 -\alpha_{12}^* y_{12} \bar{V}_2 \\
    \bar{I}_2 &amp;= \bar{I}_{21} + \bar{I}_{23} + \bar{I}_{\mathrm{sh}2} = -\alpha_{12} y_{12} \bar{V}_1 + (y_{12} + y_{\mathrm{s}12}) \bar{V}_2 +
    \cfrac{1}{\tau_{23}^2} (y_{23} + y_{\mathrm{s}23}) \bar{V}_2 -\alpha_{23}^* y_{23} \bar{V}_3 + y_{\mathrm{sh}2} \bar{V}_2 \\
    \bar{I}_3 &amp;= \bar{I}_{32} = -\alpha_{23} y_{23} \bar{V}_2 + (y_{23} + y_{\mathrm{s}23}) \bar{V}_3.
  \end{aligned}\]</p><p>The system of equations can be written in the matrix form:</p><p class="math-container">\[  \begin{bmatrix}
    \bar{I}_1 \\ \bar{I}_2 \\ \bar{I}_3
  \end{bmatrix} =
  \begin{bmatrix}
    \cfrac{1}{\tau_{12}^2} (y_{12} + y_{\mathrm{s}12}) &amp; -\alpha_{12}^* y_{12} &amp; 0 \\
   -\alpha_{12} y_{12} &amp; y_{12} + y_{\mathrm{s}12} + \cfrac{1}{\tau_{23}^2} (y_{23} + y_{\mathrm{s}23}) + y_{\mathrm{sh}2}  &amp; -\alpha_{23}^* y_{23} \\
    0 &amp; -\alpha_{23} y_{23} &amp; y_{23} + y_{\mathrm{s}23}
  \end{bmatrix}
  \begin{bmatrix}
    \bar{V}_1 \\ \bar{V}_2 \\ \bar{V}_3
  \end{bmatrix}.\]</p><p>This system of equations can be generalized to accommodate the scenario where the set <span>$\mathcal{N}$</span> comprises <span>$n$</span> buses:</p><p class="math-container">\[  \mathbf{\bar I} = \mathbf{Y} \mathbf{\bar V},\]</p><p>where <span>$\mathbf{\bar V} \in \mathbb{C}^{n}$</span> is the vector of bus complex voltages, and <span>$\mathbf{\bar I} \in \mathbb{C}^{n}$</span> is the vector of complex current injections at buses. The matrix <span>$\mathbf{Y} = \mathbf{G} + \mathrm{j}\mathbf{B} \in \mathbb{C}^{n \times n}$</span> is the bus or nodal admittance matrix, with elements:</p><ul><li>the diagonal elements, where <span>$i \in \mathcal{N}$</span>, are equal to:<p class="math-container">\[  Y_{ii} = G_{ii} + \mathrm{j} B_{ii} =
  y_{\mathrm{sh}i} + \sum\limits_{e \in \mathcal{E}, \; e(1) = i} \cfrac{1}{\tau_{ij}^2} (y_{ij} + y_{\mathrm{s}ij}) +
  \sum\limits_{e \in \mathcal{E}, \; e(2) = i} (y_{ji} + y_{\mathrm{s}ji}),\]</p></li><li>the non-diagonal elements, where <span>$i = e(1),\; j = e(2), \; e \in \mathcal{E}$</span>, are equal to:<p class="math-container">\[  \begin{aligned}
    Y_{ij} &amp;= G_{ij} + \mathrm{j} B_{ij} = -\alpha_{ij}^* y_{ij} \\[4pt]
    Y_{ji} &amp;= G_{ji} + \mathrm{j} B_{ji} = -\alpha_{ij} y_{ij}.
  \end{aligned}\]</p></li></ul><p>When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix <span>$\mathbf{Y}$</span> is equal to zero. The nodal admittance matrix <span>$\mathbf{Y}$</span> is sparse (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix <span>$\mathbf{Y}$</span> is symmetrical, it is not a general case. For example, in the presence of phase shifting transformers the matrix <span>$\mathbf{Y}$</span> is not symmetric [<a href="../../background/bibliography/#john1994power">7</a>, Sec. 9.6]. JuliaGrid stores both the matrix <span>$\mathbf{Y}$</span> and its transpose <span>$\mathbf{Y}^T$</span> in the <code>ac</code> field of the <code>PowerSystem</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐘 = system.model.ac.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
  5.0-14.975im      -5.0+15.0im               ⋅
 -5.0+15.0im         5.0-19.9333im  -0.101761+4.85802im
      ⋅         0.101761+4.85802im      0.021-4.7499im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐘ᵀ = system.model.ac.nodalMatrixTranspose</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 7 stored entries:
  5.0-14.975im       -5.0+15.0im              ⋅
 -5.0+15.0im          5.0-19.9333im  0.101761+4.85802im
      ⋅         -0.101761+4.85802im     0.021-4.7499im</code></pre><hr/><h5 id="BusInjectionsTutorials"><a class="docs-heading-anchor" href="#BusInjectionsTutorials">Bus Injections</a><a id="BusInjectionsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#BusInjectionsTutorials" title="Permalink"></a></h5><p>From the previous analysis, we can determine the complex current injection at each bus as follows:</p><p class="math-container">\[  \bar{I}_i = \sum\limits_{j = 1}^n Y_{ij} \bar{V}_j, \;\;\; i \in \mathcal N.\]</p><p>Furthermore, the calculation of active and reactive power injection at each bus is expressed by the following:</p><p class="math-container">\[  S_i = P_i + \mathrm{j} Q_i = \bar{V}_i \sum\limits_{j = 1}^n Y_{ij}^* \bar{V}_{j}^*, \;\;\; i \in \mathcal N.\]</p><p>Positive values of active or reactive powers, <span>$P_i &gt; 0$</span> or <span>$Q_i &gt; 0$</span>, indicate that the bus is supplying power into the power system. Conversely, negative values, <span>$P_i &lt; 0$</span> or <span>$Q_i &lt; 0$</span>, suggest that the bus is drawing active or reactive power from the power system.</p><hr/><h5 id="BusShuntElementTutorials"><a class="docs-heading-anchor" href="#BusShuntElementTutorials">Bus Shunt Element</a><a id="BusShuntElementTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#BusShuntElementTutorials" title="Permalink"></a></h5><p>Based on the previous analysis, we can determine the active and reactive power at the shunt element of each bus using the following equation:</p><p class="math-container">\[  S_{\mathrm{sh}i} = P_{\mathrm{sh}i} + \mathrm{j} Q_{\mathrm{sh}i} =
  \bar{V}_i \bar{I}_{\mathrm{sh}i}^* = y_{\mathrm{sh}i}^* V_i^2, \;\;\; i \in \mathcal N.\]</p><p>The positive active power value <span>$P_{\mathrm{sh}i} &gt; 0$</span> indicates that the shunt element is consuming active power. In terms of power flow, this signifies that active power flows from bus <span>$i \in \mathcal N$</span> towards the ground. A negative reactive power value <span>$Q_{\mathrm{sh}i} &lt; 0$</span> suggests that the shunt element is injecting reactive power into the power system. This implies that the direction of reactive power is from the ground to bus <span>$i \in \mathcal N$</span>, illustrating the capacitive nature of the shunt component. Conversely, if <span>$Q_{\mathrm{sh}i} &gt; 0$</span>, it indicates an inductive characteristic, implying that the shunt component is absorbing reactive power.</p><hr/><h2 id="DCModelTutorials"><a class="docs-heading-anchor" href="#DCModelTutorials">DC Model</a><a id="DCModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCModelTutorials" title="Permalink"></a></h2><p>The DC model is obtained by linearization of the nonlinear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses <span>$(i,j) \in \mathcal{E}$</span> is very small <span>$\theta_i - \theta_j \approx 0$</span>, which implies <span>$\cos(\theta_i - \theta_j) \approx 1$</span> and <span>$\sin(\theta_i - \theta_j) \approx \theta_i - \theta_j$</span>. Further, all bus voltage magnitudes are <span>$V_i \approx 1$</span>, <span>$i \in \mathcal{N}$</span>, and all branch shunt admittances and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers.</p><p>Therefore, the DC power flow takes only bus voltage angles <span>$\bm \Theta \in \mathbb{R}^{n}$</span> as variables. To create vectors and matrices related to DC or linear analyses, JuliaGrid uses the function <a href="../../api/powerSystemModel/#JuliaGrid.dcModel!"><code>dcModel!</code></a>:</p><pre><code class="language-julia hljs">dcModel!(system)</code></pre><hr/><h5 id="DCBranchNetworkEquationsTutorials"><a class="docs-heading-anchor" href="#DCBranchNetworkEquationsTutorials">Branch Network Equations</a><a id="DCBranchNetworkEquationsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCBranchNetworkEquationsTutorials" title="Permalink"></a></h5><p>According to the above assumptions, we start from the <a href="#UnifiedBranchModelTutorials">Unified Branch Model</a>:</p><p class="math-container">\[  \begin{bmatrix}
    \bar{I}_{ij} \\ \bar{I}_{ji}
  \end{bmatrix} = \cfrac{1}{\mathrm{j} x_{ij}}
  \begin{bmatrix}
    \cfrac{1}{\tau_{ij}^2} &amp;&amp; -\alpha_{ij}^*\\
    -\alpha_{ij} &amp;&amp; 1
  \end{bmatrix}
  \begin{bmatrix}
    \bar{V}_i \\ \bar{V}_j
  \end{bmatrix},\]</p><p>where <span>$\bar{V}_i = \mathrm{e}^{\mathrm{j}\theta_i}$</span> and <span>$\bar{V}_j = \mathrm{e}^{\mathrm{j}\theta_j}$</span>. Further, we have:</p><p class="math-container">\[  \begin{aligned}
    \bar{I}_{ij} &amp;= \cfrac{1}{\mathrm{j}x_{ij}} \left[\cfrac{1}{\tau_{ij}^2} \mathrm{e}^{\mathrm{j}\theta_i} -
    \cfrac{1}{\tau_{ij}}\mathrm{e}^{\mathrm{j}(\phi_{ij} + \theta_j)} \right] \\
    \bar{I}_{ji} &amp;= \cfrac{1}{\mathrm{j}x_{ij}} \left[-\cfrac{1}{\tau_{ij}} \mathrm{e}^{\mathrm{j}(\theta_i - \phi_{ij})} + \mathrm{e}^{\mathrm{j}\theta_j} \right].
  \end{aligned}\]</p><p>The active power flows are derived as follows:</p><p class="math-container">\[  \begin{aligned}
    P_{ij} &amp;= \Re\{\bar{V}_i \bar{I}_{ij}^*\} =
    \Re \left\{\mathrm{j} \cfrac{1}{x_{ij}}
    \left[\cfrac{1}{\tau_{ij}^2} - \cfrac{1}{\tau_{ij}} e^{\mathrm{j}(\theta_i - \theta_j - \phi_{ij})} \right] \right\} \\
    P_{ji} &amp;= \Re\{\bar{V}_j \bar{I}_{ji}^*\} =
    \Re \left\{\mathrm{j} \cfrac{1}{x_{ij}}
   \left[1 - \cfrac{1}{\tau_{ij}} e^{\mathrm{j}(-\theta_i + \theta_j + \phi_{ij})} \right]  \right\}.
  \end{aligned}\]</p><p>The real components are:</p><p class="math-container">\[  \begin{aligned}
    P_{ij} &amp;=\cfrac{1}{\tau_{ij}x_{ij}} \sin(\theta_i - \theta_j - \phi_{ij}) \approx \cfrac{1}{\tau_{ij}x_{ij}} (\theta_i - \theta_j - \phi_{ij}) \\
    P_{ji} &amp;=\cfrac{1}{\tau_{ij}x_{ij}} \sin(\theta_j - \theta_i + \phi_{ij}) \approx -\cfrac{1}{\tau_{ij} x_{ij}} (\theta_i - \theta_j - \phi_{ij}),
  \end{aligned}\]</p><p>where <span>$1/(\tau_{ij} x_{ij})$</span> represents the branch admittance in the DC framework. To recall, the <code>PowerSystem</code> type stores the reactances as vector <span>$\mathbf x = [x_{ij}]$</span> in the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐱 = system.branch.parameter.reactance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.06
 0.21</code></pre><p>Furthermore, the computed branch admittances in the DC framework are stored in the vector <span>$\mathbf y = [1/(\tau_{ij} x_{ij})]$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐲 = system.model.dc.admittance</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 16.666666666666668
  4.8590864917395535</code></pre><p>We can conclude that <span>$P_{ij} = -P_{ji}$</span> holds. With the DC model, the linear network equations relate active powers to bus voltage angles, versus complex currents to complex bus voltages in the AC model [<a href="../../background/bibliography/#zimmerman2016matpower">8</a>]. Consequently, analogous to the <a href="#BranchNetworkEquationsTutorials">Branch Network Equations</a> we can write:</p><p class="math-container">\[  \begin{bmatrix}
    P_{ij} \\ P_{ji}
  \end{bmatrix} = \cfrac{1}{\tau_{ij}x_{ij}}
  \begin{bmatrix*}[r]
    1 &amp;&amp; -1\\
    -1 &amp;&amp; 1
  \end{bmatrix*}
  \begin{bmatrix}
    \theta_{i} \\ \theta_{j}
  \end{bmatrix} + \cfrac{\phi_{ij}}{\tau_{ij}x_{ij}}
  \begin{bmatrix*}[r]
    -1 \\ 1
  \end{bmatrix*}.\]</p><hr/><h5 id="DCNodalNetworkEquationsTutorials"><a class="docs-heading-anchor" href="#DCNodalNetworkEquationsTutorials">Nodal Network Equations</a><a id="DCNodalNetworkEquationsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCNodalNetworkEquationsTutorials" title="Permalink"></a></h5><p>As before, let us consider an illustrative example from our case study, depicted in Figure 3. This example provides a smooth transition to the general case, demonstrating a system with three buses represented as <span>$\mathcal{N} = \{1, 2, 3\}$</span> and two branches <span>$\mathcal{E} = \{(1, 2), (2, 3)\}$</span>, where bus <span>$2$</span> is incident to the shunt element with admittance <span>$g_{\mathrm{sh}2}$</span>.</p><div style="text-align: center;">
  <img src="../../assets/tutorials/powerSystemModel/dc_model.svg" width="500" class="my-svg"/>
  <p>Figure 3: The example of the system with three buses and two branches.</p>
</div>
&nbsp;<p>Each branch in the DC framework is described with a system of equations as follows:</p><p class="math-container">\[  \begin{bmatrix}
    P_{12} \\ P_{21}
  \end{bmatrix} = \cfrac{1}{\tau_{12}x_{12}}
  \begin{bmatrix*}[r]
    1 &amp;&amp; -1\\
    -1 &amp;&amp; 1
  \end{bmatrix*}
  \begin{bmatrix}
    \theta_1 \\ \theta_2
  \end{bmatrix} + \cfrac{\phi_{12}}{\tau_{12}x_{12}}
  \begin{bmatrix*}[r]
    -1 \\ 1
  \end{bmatrix*}\]</p><p class="math-container">\[  \begin{bmatrix}
    P_{23} \\ P_{32}
  \end{bmatrix} = \cfrac{1}{\tau_{23}x_{23}}
  \begin{bmatrix*}[r]
    1 &amp;&amp; -1\\
    -1 &amp;&amp; 1
  \end{bmatrix*}
  \begin{bmatrix}
    \theta_2 \\ \theta_3
  \end{bmatrix} + \cfrac{\phi_{23}}{\tau_{23}x_{23}}
  \begin{bmatrix*}[r]
    -1 \\ 1
  \end{bmatrix*}.\]</p><p>The active power injections at buses are:</p><p class="math-container">\[  \begin{aligned}
    P_{1} &amp;= P_{12} =\cfrac{1}{\tau_{12}x_{12}} \theta_1 - \cfrac{1}{\tau_{12}x_{12}} \theta_2 - \cfrac{\phi_{12}}{\tau_{12}x_{12}} \\
    P_{2} &amp;= P_{21} + P_{23} + P_{\mathrm{sh}2} = -\cfrac{1}{\tau_{12}x_{12}} \theta_1 + \cfrac{1}{\tau_{12}x_{12}} \theta_2 +
    \cfrac{\phi_{12}}{\tau_{12}x_{12}} + \cfrac{1}{\tau_{23}x_{23}} \theta_2 - \cfrac{1}{\tau_{23}x_{23}} \theta_3 -
    \cfrac{\phi_{23}}{\tau_{23}x_{23}} + g_{\mathrm{sh}2} \\
    P_{3} &amp;= {P}_{32} = -\cfrac{1}{\tau_{23}x_{23}} \theta_2 +\cfrac{1}{\tau_{23}x_{23}} \theta_3 + \cfrac{\phi_{23}}{\tau_{23}x_{23}},
  \end{aligned}\]</p><p>where the active power injected by the shunt element at the bus <span>$2$</span> is equal to:</p><p class="math-container">\[  P_{\mathrm{sh}2} =
  \Re\{\bar{V}_2 \bar{I}_{\mathrm{sh}2}^*\} = \Re\{\bar{V}_2 y_{\mathrm{sh}2}^* \bar{V}_2^*\} = V_2^2 g_{\mathrm{sh}2} = g_{\mathrm{sh}2}.\]</p><p>The system of equations can be written in the matrix form:</p><p class="math-container">\[  \begin{bmatrix}
    P_{1} \\ P_{2} \\ P_{3}
  \end{bmatrix} =
  \begin{bmatrix}
    \cfrac{1}{\tau_{12}x_{12}} &amp; -\cfrac{1}{\tau_{12}x_{12}} &amp; 0 \\
    -\cfrac{1}{\tau_{12}x_{12}} &amp; \cfrac{1}{\tau_{12}x_{12}} + \cfrac{1}{\tau_{23}x_{23}}  &amp; -\cfrac{1}{\tau_{23}x_{23}} \\
    0 &amp; -\cfrac{1}{\tau_{23}x_{23}} &amp; \cfrac{1}{\tau_{23}x_{23}}
  \end{bmatrix}
  \begin{bmatrix}
    \theta_1 \\ \theta_2 \\ \theta_3
  \end{bmatrix} +
  \begin{bmatrix}
    - \cfrac{\phi_{12}}{\tau_{12}x_{12}} \\ \cfrac{\phi_{12}}{\tau_{12}x_{12}} - \cfrac{\phi_{23}}{\tau_{23}x_{23}} \\ \cfrac{\phi_{23}}{\tau_{23}x_{23}}
  \end{bmatrix} +
  \begin{bmatrix}
    0 \\ g_{\mathrm{sh}2} \\ 0
  \end{bmatrix}.\]</p><p>This system of equations can be generalized to accommodate the scenario where the set <span>$\mathcal{N}$</span> comprises <span>$n$</span> buses:</p><p class="math-container">\[  \mathbf P = \mathbf B \bm \Theta + \mathbf{P}_\mathrm{tr} + \mathbf{P}_\mathrm{sh},\]</p><p>where <span>$\bm \Theta \in \mathbb{R}^n$</span> is the vector of bus voltage angles.</p><p>The vector <span>$\mathbf P \in \mathbb{R}^n$</span> contains active power injections at buses caused by generators and demands. In JuliaGrid, the vector can be recovered using a command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏 = system.bus.supply.active - system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.4
 -0.217
  0.0</code></pre><p>The vector <span>$\mathbf{P}_\mathrm{tr} \in \mathbb{R}^n$</span> represents active powers related to the non-zero shift angle of transformers. This vector is stored in the <code>dc</code> field, and we can access it using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₜᵣ = system.model.dc.shiftPower</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.10176846950404254
  0.10176846950404254</code></pre><p>The vector <span>$\mathbf{P}_\mathrm{sh} \in \mathbb{R}^n$</span> represents active powers consumed by shunt elements. We can access this vector using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛₕ = system.bus.shunt.conductance</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.021</code></pre><p>The bus or nodal matrix in the DC framework is given as <span>$\mathbf B \in \mathbb{R}^{n \times n}$</span>, with elements:</p><ul><li>the diagonal elements, where <span>$i \in \mathcal N$</span>, are equal to:<p class="math-container">\[B_{ii} = \sum\limits_{e \in \mathcal E,\; i \in e} \cfrac{1}{\tau_{ij}x_{ij}},\]</p></li><li>the non-diagonal elements, where <span>$i = e(1),\; j = e(2), \; e \in \mathcal E$</span>, are equal to:<p class="math-container">\[  \begin{aligned}
    B_{ij} &amp;= -\cfrac{1}{\tau_{ij}x_{ij}} \\[3pt]
    B_{ji} &amp;= -\cfrac{1}{\tau_{ij}x_{ij}}.
  \end{aligned}\]</p></li></ul><p>The sparse nodal matrix <span>$\mathbf B$</span> is stored in the <code>dc</code> field, and we can access it using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐁 = system.model.dc.nodalMatrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
  16.6667  -16.6667     ⋅
 -16.6667   21.5258   -4.85909
    ⋅       -4.85909   4.85909</code></pre><hr/><h5 id="DCBusInjectionTutorials"><a class="docs-heading-anchor" href="#DCBusInjectionTutorials">Bus Injection</a><a id="DCBusInjectionTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#DCBusInjectionTutorials" title="Permalink"></a></h5><p>From the previous analysis, the calculation of active power injection at each bus is expressed by:</p><p class="math-container">\[    P_i = \sum_{j = 1}^n B_{ij} \theta_j + P_{\mathrm{tr}i} + P_{\mathrm{sh}i}, \;\;\; i \in \mathcal N.\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../manual/badDataAnalysis/">« Bad Data Analysis</a><a class="docs-footer-nextpage" href="../acPowerFlow/">AC Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 8 May 2025 16:09">Thursday 8 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
