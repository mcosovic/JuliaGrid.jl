<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC State Estimation · JuliaGrid</title><meta name="title" content="AC State Estimation · JuliaGrid"/><meta property="og:title" content="AC State Estimation · JuliaGrid"/><meta property="twitter:title" content="AC State Estimation · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../manual/badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li class="is-active"><a class="tocitem" href>AC State Estimation</a><ul class="internal"><li><a class="tocitem" href="#ACSEModelTutorials"><span>State Estimation Model</span></a></li><li><a class="tocitem" href="#ACSEWLSStateEstimationTutorials"><span>Weighted Least-Squares Estimation</span></a></li><li><a class="tocitem" href="#ACLAVTutorials"><span>Least Absolute Value Estimation</span></a></li><li><a class="tocitem" href="#ACPowerAnalysisTutorials"><span>Power Analysis</span></a></li><li><a class="tocitem" href="#PMUCurrentAnalysisTutorials"><span>Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>AC State Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC State Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/acStateEstimation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACStateEstimationTutorials"><a class="docs-heading-anchor" href="#ACStateEstimationTutorials">AC State Estimation</a><a id="ACStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACStateEstimationTutorials" title="Permalink"></a></h1><p>To initiate the process, let us construct the <code>PowerSystem</code> type and formulate the AC model:</p><pre><code class="language-julia hljs">system = powerSystem()

addBus!(system; label = 1, type = 3, active = 0.5)
addBus!(system; label = 2, reactive = 0.3)
addBus!(system; label = 3, active = 0.5)

@branch(resistance = 0.02, susceptance = 0.04)
addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.6)
addBranch!(system; label = 2, from = 1, to = 3, reactance = 0.7)
addBranch!(system; label = 3, from = 2, to = 3, reactance = 0.2)

acModel!(system)</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal G = (\mathcal N, \mathcal E)$</span>, where we have the set of buses <span>$\mathcal N = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal E \subseteq \mathcal N \times \mathcal N$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒩 = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{String}:
 &quot;1&quot;  &quot;2&quot;
 &quot;1&quot;  &quot;3&quot;
 &quot;2&quot;  &quot;3&quot;</code></pre><hr/><p>Following that, we will introduce the <code>Measurement</code> type and incorporate a set of measurement devices <span>$\mathcal M$</span> into the graph <span>$\mathcal G$</span>. The AC state estimation includes a set of voltmeters <span>$\mathcal V$</span>, ammeters <span>$\mathcal I$</span>, wattmeters <span>$\mathcal P$</span>, varmeters <span>$\mathcal Q$</span>, and PMUs <span>$\bar{\mathcal P}$</span>, with PMUs being able to integrate into AC state estimation in either rectangular coordinates or polar coordinates. To start, we initialize the <code>Measurement</code> type:</p><pre><code class="language-julia hljs">monitoring = measurement(system)</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>Here, when referring to a vector <span>$\mathbf a$</span>, we use the notation <span>$\mathbf a = [a_i]$</span> or <span>$\mathbf a = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element related with bus <span>$i \in \mathcal N$</span> or measurement <span>$i \in \mathcal M$</span>, while <span>$a_{ij}$</span> denotes the element related with branch <span>$(i,j) \in \mathcal E$</span>.</p></div></div><hr/><h2 id="ACSEModelTutorials"><a class="docs-heading-anchor" href="#ACSEModelTutorials">State Estimation Model</a><a id="ACSEModelTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACSEModelTutorials" title="Permalink"></a></h2><p>In accordance with the <a href="../powerSystemModel/#ACModelTutorials">AC Model</a>, the AC state estimation treats bus voltages as state variables, which we denoted by <span>$\mathbf x \equiv [\bm \Theta, \mathbf V]^T$</span>. The state vector encompasses two components:</p><ul><li><span>$\bm \Theta \in \mathbb{R}^{n-1}$</span>, representing bus voltage angles,</li><li><span>$\mathbf V \in \mathbb{R}^n$</span>, representing bus voltage magnitudes.</li></ul><p>Consequently, the total number of state variables is <span>$s = 2n-1$</span>, accounting for the fact that the voltage angle for the slack bus is known.</p><p>Within the JuliaGrid framework for AC state estimation, the methodology encompasses bus voltage magnitudes, branch current magnitudes, active powers, reactive powers, and phasor measurements. These measurements contribute to the construction of a nonlinear system of equations:</p><p class="math-container">\[    \mathbf{z}=\mathbf{h}(\mathbf {x}) + \mathbf{u}.\]</p><p>Here, <span>$\mathbf h(\mathbf x)= [h_1(\mathbf x)$</span>, <span>$\dots$</span>, <span>$h_k(\mathbf x)]^T$</span> represents the vector of nonlinear measurement functions, where <span>$k$</span> is the number of measurements, <span>$\mathbf z = [z_1, \dots, z_k]^T$</span> denotes the vector of measurement values, and <span>$\mathbf u = [u_1, \dots, u_k]^T$</span> represents the vector of measurement errors. It is worth noting that the number of equations in the system is equal to <span>$k = |\mathcal V \cup \mathcal I \cup \mathcal P \cup \mathcal Q| + 2|\bar{\mathcal P}|$</span>.</p><p>These errors are assumed to follow a Gaussian distribution with a zero mean and covariance matrix <span>$\bm \Sigma$</span>. The diagonal elements of <span>$\bm \Sigma$</span> correspond to the measurement variances <span>$\mathbf v = [v_1, \dots, v_k]^T$</span>, while the off-diagonal elements represent the covariances between the measurement errors <span>$\mathbf w = [w_1, \dots, w_k]^T$</span>. These covariances exist only if PMUs are observed in rectangular coordinates and correlation is required.</p><p>Hence, the nonlinear system of equations is structured according to the specific devices:</p><p class="math-container">\[    \begin{bmatrix}
      \mathbf z_\mathcal V\\[3pt]
      \mathbf z_\mathcal I\\[3pt]
      \mathbf z_\mathcal P\\[3pt]
      \mathbf z_\mathcal Q\\[3pt]
      \mathbf z_{\bar{\mathcal P}}
    \end{bmatrix} =
    \begin{bmatrix}
      \mathbf h_\mathcal V(\mathbf x)\\[3pt]
      \mathbf h_\mathcal I(\mathbf x)\\[3pt]
      \mathbf h_\mathcal P(\mathbf x)\\[3pt]
      \mathbf h_\mathcal Q(\mathbf x)\\[3pt]
      \mathbf h_{\bar{\mathcal P}}(\mathbf x)
    \end{bmatrix} +
    \begin{bmatrix}
      \mathbf u_\mathcal V\\[3pt]
      \mathbf u_\mathcal I\\[3pt]
      \mathbf u_\mathcal P\\[3pt]
      \mathbf u_\mathcal Q\\[3pt]
      \mathbf u_{\bar{\mathcal P}}
    \end{bmatrix}\]</p><p>Please note that each error vector, denoted as <span>$\mathbf{u}_i$</span>, where <span>$i \in \{\mathcal V, \mathcal I, \mathcal P, \mathcal Q\}$</span>, is associated with the variance vector <span>$\mathbf{v}_i$</span>.  However, for PMUs, the error vector <span>$\mathbf{u}_{\bar{\mathcal P}}$</span>, along with its variance vector <span>$\mathbf{v}_{\bar{\mathcal P}}$</span>, can also be associated with the covariance vector <span>$\mathbf{w}_{\bar{\mathcal P}}$</span>.</p><p>In summary, upon user definition of the measurement devices, each <span>$i$</span>-th legacy measurement device is linked to the measurement function <span>$h_i(\mathbf x)$</span>, the corresponding measurement value <span>$z_i$</span>, and the measurement variance <span>$v_i$</span>. Meanwhile, each <span>$i$</span>-th PMU is associated with two measurement functions <span>$h_{2i-1}(\mathbf x)$</span>, <span>$h_{2i}(\mathbf x)$</span>, along with their respective measurement values <span>$z_{2i-1}$</span>, <span>$z_{2i}$</span>, as well as their variances <span>$v_{2i-1}$</span>, <span>$v_{2i}$</span>, and possibly covariances <span>$w_{2i-1}$</span>, <span>$w_{2i}$</span>.</p><p>Typically, the AC state estimator is obtained using the Gauss-Newton method or its variation, which involves constructing the Jacobian matrix. Therefore, in addition to the aforementioned elements, we also need Jacobian expressions corresponding to the measurement functions, which are also provided below.</p><hr/><h5 id="Bus-Voltage-Magnitude-Measurements"><a class="docs-heading-anchor" href="#Bus-Voltage-Magnitude-Measurements">Bus Voltage Magnitude Measurements</a><a id="Bus-Voltage-Magnitude-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Magnitude-Measurements" title="Permalink"></a></h5><p>When introducing a voltmeter <span>$V_i \in \mathcal V$</span> at bus <span>$i \in \mathcal N$</span>, users specify the measurement value, variance, and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{V} = [z_{V_i}], \;\;\; \mathbf{v}_\mathcal{V} = [v_{V_i}], \;\;\; \mathbf{h}_\mathcal{V}(\mathbf x) = [h_{V_i}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addVoltmeter!(monitoring; label = &quot;V₁&quot;, bus = 1, magnitude = 1.0, variance = 1e-3)</code></pre><p>Here, the bus voltage magnitude measurement function is simply defined as:</p><p class="math-container">\[    h_{V_i}(\mathbf x) = V_i,\]</p><p>with the following Jacobian expression:</p><p class="math-container">\[   	\cfrac{\mathrm \partial{{h_{V_i}(\mathbf x)}}} {\mathrm \partial V_i} = 1.\]</p><hr/><h5 id="FromCurrentMagnitudeMeasurements"><a class="docs-heading-anchor" href="#FromCurrentMagnitudeMeasurements">From-Bus Current Magnitude Measurements</a><a id="FromCurrentMagnitudeMeasurements-1"></a><a class="docs-heading-anchor-permalink" href="#FromCurrentMagnitudeMeasurements" title="Permalink"></a></h5><p>When introducing an ammeter at branch <span>$(i,j) \in \mathcal E$</span>, it can be placed at the from-bus end, denoted as <span>$I_{ij} \in \mathcal I$</span>, specifying the measurement value, variance, and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{I} = [z_{I_{ij}}], \;\;\; \mathbf{v}_\mathcal{I} = [v_{I_{ij}}], \;\;\; \mathbf{h}_\mathcal{I}(\mathbf x) = [h_{I_{ij}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addAmmeter!(monitoring; label = &quot;I₁₂&quot;, from = 1, magnitude = 0.3, variance = 1e-2)</code></pre><p>Here, following the guidelines outlined in the <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">AC Model</a>, the function defining the current magnitude at the from-bus end is expressed as:</p><p class="math-container">\[    h_{I_{ij}}(\mathbf x) = \sqrt{A_{I_{ij}}V_i^2 + B_{I_{ij}}V_j^2 - 2[C_{I_{ij}} \cos(\theta_{ij} - \phi_{ij}) - D_{I_{ij}}\sin(\theta_{ij} - \phi_{ij})]V_iV_j},\]</p><p>where:</p><p class="math-container">\[  \begin{gathered}
    A_{I_{ij}} = \cfrac{(g_{ij} + g_{\mathrm{s}i})^2 + (b_{ij} + b_{\mathrm{s}i})^2}{\tau_{ij}^4}, \;\;\;
    B_{I_{ij}} = \cfrac{g_{ij}^2 + b_{ij}^2}{\tau_{ij}^2} \\
    C_{I_{ij}} = \cfrac{g_{ij}(g_{ij} + g_{\mathrm{s}i}) + b_{ij}(b_{ij} + b_{\mathrm{s}i})}{\tau_{ij}^3}, \;\;\;
    D_{I_{ij}} = \cfrac{g_{ij}b_{\mathrm{s}i} - b_{ij}g_{\mathrm{s}i}}{\tau_{ij}^3}.
  \end{gathered}\]</p><p>Jacobian expressions corresponding to the measurement function <span>$h_{I_{ij}}(\mathbf x)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{I_{ij}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=-
    \cfrac{\mathrm \partial{h_{I_{ij}}(\mathbf x)}}{\mathrm \partial \theta_j} =
    \cfrac{ [C_{I_{ij}}\sin(\theta_{ij} - \phi_{ij}) + D_{I_{ij}}\cos(\theta_{ij} - \phi_{ij})]V_i V_j}{h_{I_{ij}}(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{I_{ij}}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    \cfrac{A_{I_{ij}}V_i - [C_{I_{ij}}\cos(\theta_{ij} - \phi_{ij}) - D_{I_{ij}}\sin(\theta_{ij} - \phi_{ij})]V_j}{h_{I_{ij}}(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{I_{ij}}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    \cfrac{B_{I_{ij}}V_j - [C_{I_{ij}}\cos(\theta_{ij} - \phi_{ij}) - D_{I_{ij}}\sin(\theta_{ij} - \phi_{ij})]V_i}{h_{I_{ij}}(\mathbf x)}.
	\end{aligned}\]</p><p>The next option is to introduce this measurement in squared form. In this case, the measurement function and value will be squared, while the variance will be doubled:</p><p class="math-container">\[    \mathbf{z}_\mathcal{I} = [z_{I_{ij}}^2], \;\;\; \mathbf{v}_\mathcal{I} = [2v_{I_{ij}}], \;\;\; \mathbf{h}_\mathcal{I}(\mathbf x) = [h_{I_{ij}}^2(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addAmmeter!(
  monitoring; label = &quot;I²₁₂&quot;, from = 1, magnitude = 0.3, variance = 1e-2, square = true
)</code></pre><p>This approach improves numerical robustness when integrating current magnitude measurements into the AC state estimation model. The resulting model includes a measurement function where the square root disappears, while the Jacobian expressions are doubled, and the denominator is eliminated.</p><hr/><h5 id="ToCurrentMagnitudeMeasurements"><a class="docs-heading-anchor" href="#ToCurrentMagnitudeMeasurements">To-Bus Current Magnitude Measurements</a><a id="ToCurrentMagnitudeMeasurements-1"></a><a class="docs-heading-anchor-permalink" href="#ToCurrentMagnitudeMeasurements" title="Permalink"></a></h5><p>In addition to the scenario where we add ammeters at the from-bus end, an ammeter can also be positioned at the to-bus end, denoted as <span>$I_{ji} \in \mathcal I$</span>, specifying the measurement value, variance, and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{I} = [z_{I_{ji}}], \;\;\; \mathbf{v}_\mathcal{I} = [v_{I_{ji}}], \;\;\; \mathbf{h}_\mathcal{I}(\mathbf x) = [h_{I_{ji}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addAmmeter!(monitoring; label = &quot;I₂₁&quot;, to = 1, magnitude = 0.3, variance = 1e-3)</code></pre><p>Now, the measurement function is as follows:</p><p class="math-container">\[    h_{I_{ji}}(\mathbf x) = \sqrt{A_{I_{ji}}V_i^2 + B_{I_{ji}}V_j^2 - 2[C_{I_{ji}} \cos(\theta_{ij} - \phi_{ij}) + D_{I_{ji}}\sin(\theta_{ij} - \phi_{ij})]V_iV_j},\]</p><p>where:</p><p class="math-container">\[  \begin{gathered}
    A_{I_{ji}} = \cfrac{g_{ij}^2 + b_{ij}^2}{\tau_{ij}^2}, \;\;\;
    B_{I_{ji}} = (g_{ij} + g_{\mathrm{s}i})^2 + (b_{ij} + b_{\mathrm{s}i})^2 \\
    C_{I_{ji}} = \cfrac{g_{ij}(g_{ij} + g_{\mathrm{s}i}) + b_{ij}(b_{ij} + b_{\mathrm{s}i})}{\tau_{ij}}, \;\;\;
    D_{I_{ji}} = \cfrac{g_{ij}b_{\mathrm{s}i} - b_{ij}g_{\mathrm{s}i}}{\tau_{ij}}.
  \end{gathered}\]</p><p>Jacobian expressions corresponding to the measurement function <span>$h_{I_{ji}}(\mathbf x)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{I_{ji}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=-
    \cfrac{\mathrm \partial{h_{I_{ji}}(\mathbf x)}}{\mathrm \partial \theta_j} =
    \cfrac{[C_{I_{ji}}\sin(\theta_{ij} - \phi_{ij}) - D_{I_{ji}}\cos(\theta_{ij}- \phi_{ij})]V_i V_j}{h_{I_{ji}}(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{I_{ji}}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    \cfrac{A_{I_{ji}}V_i - [C_{I_{ji}}\cos(\theta_{ij} - \phi_{ij}) + D_{I_{ji}}\sin(\theta_{ij} - \phi_{ij})]V_j}{h_{I_{ji}}(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{I_{ji}}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    \cfrac{B_{I_{ji}}V_j - [C_{I_{ji}}\cos(\theta_{ij} - \phi_{ij}) + D_{I_{ji}}\sin(\theta_{ij} - \phi_{ij})]V_i}{h_{I_{ji}}(\mathbf x)} .
	\end{aligned}\]</p><p>As explained for the current magnitude measurement from the bus, we can also introduce this measurement in squared form:</p><p class="math-container">\[    \mathbf{z}_\mathcal{I} = [z_{I_{ji}}^2], \;\;\; \mathbf{v}_\mathcal{I} = [2v_{I_{ji}}], \;\;\; \mathbf{h}_\mathcal{I}(\mathbf x) = [h_{I_{ji}}^2(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addAmmeter!(
  monitoring; label = &quot;I²₂₁&quot;, to = 1, magnitude = 0.3, variance = 1e-3, square = true
)</code></pre><p>To recall, the resulting model includes a measurement function where the square root disappears, while the Jacobian expressions are doubled, and the denominator is eliminated.</p><hr/><h5 id="Active-Power-Injection-Measurements"><a class="docs-heading-anchor" href="#Active-Power-Injection-Measurements">Active Power Injection Measurements</a><a id="Active-Power-Injection-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Active-Power-Injection-Measurements" title="Permalink"></a></h5><p>When adding a wattmeter <span>$P_i \in \mathcal P$</span> at bus <span>$i \in \mathcal N$</span>, users specify that the wattmeter measures active power injection and define measurement value, variance, and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{P} = [z_{P_i}], \;\;\; \mathbf{v}_\mathcal{P} = [v_{P_i}], \;\;\; \mathbf{h}_\mathcal{P}(\mathbf x) = [h_{P_i}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addWattmeter!(monitoring; label = &quot;P₃&quot;, bus = 3, active = -0.5, variance = 1e-3)</code></pre><p>Here, utilizing the <a href="../powerSystemModel/#NodalNetworkEquationsTutorials">AC Model</a>, we derive the function defining the active power injection as follows:</p><p class="math-container">\[   h_{P_i}(\mathbf x) = V_i\sum\limits_{j \in \mathcal{N}_i} (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) V_j,\]</p><p>where <span>$\mathcal{N}_i$</span> contains buses incident to bus <span>$i$</span>, including bus <span>$i$</span>, with the following Jacobian expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{P_i}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    V_i\sum_{j \in \mathcal{N}_i} (-G_{ij}\sin\theta_{ij} + B_{ij}\cos\theta_{ij})V_j - B_{ii}V_i^2\\
    \cfrac{\mathrm \partial{h_{P_i}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij})V_iV_j \\
    \cfrac{\mathrm \partial{h_{P_i}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    \sum_{j \in \mathcal{N}_i} (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij})V_j + G_{ii}V_i\\
    \cfrac{\mathrm \partial{h_{P_i}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij})V_i.
  \end{aligned}\]</p><hr/><h5 id="From-Bus-Active-Power-Flow-Measurements"><a class="docs-heading-anchor" href="#From-Bus-Active-Power-Flow-Measurements">From-Bus Active Power Flow Measurements</a><a id="From-Bus-Active-Power-Flow-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#From-Bus-Active-Power-Flow-Measurements" title="Permalink"></a></h5><p>Additionally, when introducing a wattmeter at branch <span>$(i,j) \in \mathcal E$</span>, users specify that the wattmeter measures active power flow. It can be positioned at the from-bus end, denoted as <span>$P_{ij} \in \mathcal P$</span>, specifying the measurement value, variance, and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{P} = [z_{P_{ij}}], \;\;\; \mathbf{v}_\mathcal{P} = [v_{P_{ij}}], \;\;\; \mathbf{h}_\mathcal{P}(\mathbf x) = [h_{P_{ij}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addWattmeter!(monitoring; label = &quot;P₁₂&quot;, from = 1, active = 0.2, variance = 1e-4)</code></pre><p>Here, the function describing active power flow at the from-bus end is defined as follows:</p><p class="math-container">\[    h_{P_{ij}}(\mathbf x) = \cfrac{g_{ij} + g_{\mathrm{s}i}}{\tau_{ij}^2} V_i^2 - \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) + b_{ij}\sin(\theta_{ij} - \phi_{ij})\right]V_iV_j,\]</p><p>with the following Jacobian expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{P_{ij}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=-
    \cfrac{\mathrm \partial{h_{P_{ij}}(\mathbf x)}}{\mathrm \partial \theta_j} =
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) - b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_iV_j \\
    \cfrac{\mathrm \partial{h_{P_{ij}}(\mathbf x)}}{\mathrm \partial V_{i}} &amp;=
    2\cfrac{g_{ij} + g_{\mathrm{s}i}}{\tau_{ij}^2} V_i -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) + b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_j \\
    \cfrac{\mathrm \partial{h_{P_{ij}}(\mathbf x)}}{\mathrm \partial V_j} &amp;= -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) + b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_i.
	\end{aligned}\]</p><hr/><h5 id="To-Bus-Active-Power-Flow-Measurements"><a class="docs-heading-anchor" href="#To-Bus-Active-Power-Flow-Measurements">To-Bus Active Power Flow Measurements</a><a id="To-Bus-Active-Power-Flow-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#To-Bus-Active-Power-Flow-Measurements" title="Permalink"></a></h5><p>Similarly, a wattmeter can be placed at the to-bus end, denoted as <span>$P_{ji} \in \mathcal{P}$</span>, specifying the measurement value, variance, and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{P} = [z_{P_{ji}}], \;\;\; \mathbf{v}_\mathcal{P} = [v_{P_{ji}}], \;\;\; \mathbf{h}_\mathcal{P}(\mathbf x) = [h_{P_{ji}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addWattmeter!(monitoring; label = &quot;P₂₁&quot;, to = 1, active = -0.2, variance = 1e-4)</code></pre><p>Thus, the function describing active power flow at the to-bus end is defined as follows:</p><p class="math-container">\[    h_{P_{ji}}(\mathbf x) = (g_{ij} + g_{\mathrm{s}i}) V_j^2 - \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) - b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_iV_j,\]</p><p>with the following Jacobian expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{P_{ji}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;= -
    \cfrac{\mathrm \partial{h_{P_{ji}}(\mathbf x)}}{\mathrm \partial \theta_j} =
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) + b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_iV_j \\
    \cfrac{\mathrm \partial{h_{P_{ji}}(\mathbf x)}}{\mathrm \partial V_{i}} &amp;=  -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) - b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_j \\
    \cfrac{\mathrm \partial{h_{P_{ji}}(\mathbf x)}}{\mathrm \partial V_{j}} &amp;= 2(g_{ij} + g_{\mathrm{s}i}) V_j -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) - b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_i.
	\end{aligned}\]</p><hr/><h5 id="Reactive-Power-Injection-Measurements"><a class="docs-heading-anchor" href="#Reactive-Power-Injection-Measurements">Reactive Power Injection Measurements</a><a id="Reactive-Power-Injection-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Reactive-Power-Injection-Measurements" title="Permalink"></a></h5><p>When adding a varmeter <span>$Q_i \in \mathcal Q$</span> at bus <span>$i \in \mathcal N$</span>, users specify that the varmeter measures reactive power injection and define the measurement value, variance, and measurement function of vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{Q} = [z_{Q_i}], \;\;\; \mathbf{v}_\mathcal{Q} = [v_{Q_i}], \;\;\; \mathbf{h}_\mathcal{Q}(\mathbf x) = [h_{Q_i}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addVarmeter!(monitoring; label = &quot;Q₃&quot;, bus = 3, reactive = 0, variance = 1e-3)</code></pre><p>Here, utilizing the <a href="../powerSystemModel/#NodalNetworkEquationsTutorials">AC Model</a>, we derive the function defining the reactive power injection as follows:</p><p class="math-container">\[   h_{Q_i}(\mathbf x) = V_i\sum\limits_{j \in \mathcal{N}_i} (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij})V_j,\]</p><p>where <span>$\mathcal{N}_i$</span> contains buses incident to bus <span>$i$</span>, including bus <span>$i$</span>, with the following Jacobian expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{Q_i}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    V_i\sum_{j \in \mathcal{N}_i} (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij})V_j - G_{ii}V_i^2\\
    \cfrac{\mathrm \partial{h_{Q_i}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    -(G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij})V_iV_j \\
    \cfrac{\mathrm \partial{h_{Q_i}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    \sum_{j \in \mathcal{N}_i} (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij})V_j - B_{ii}V_i\\
    \cfrac{\mathrm \partial{h_{Q_i}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij})V_i.
  \end{aligned}\]</p><hr/><h5 id="From-Bus-Reactive-Power-Flow-Measurements"><a class="docs-heading-anchor" href="#From-Bus-Reactive-Power-Flow-Measurements">From-Bus Reactive Power Flow Measurements</a><a id="From-Bus-Reactive-Power-Flow-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#From-Bus-Reactive-Power-Flow-Measurements" title="Permalink"></a></h5><p>Additionally, when introducing a varmeter at branch <span>$(i,j) \in \mathcal E$</span>, users specify that the varmeter measures reactive power flow. It can be positioned at the from-bus end, denoted as <span>$Q_{ij} \in \mathcal Q$</span>, with its measurement value, variance, and measurement function included in vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{Q} = [z_{Q_{ij}}], \;\;\; \mathbf{v}_\mathcal{Q} = [v_{Q_{ij}}], \;\;\; \mathbf{h}_\mathcal{Q}(\mathbf x) = [h_{Q_{ij}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addVarmeter!(monitoring; label = &quot;Q₁₂&quot;, from = 1, reactive = 0.2, variance = 1e-4)</code></pre><p>Here, the function describing reactive power flow at the from-bus end is defined as follows:</p><p class="math-container">\[    h_{Q_{ij}}(\mathbf x) = -\cfrac{b_{ij} + b_{\mathrm{s}i}}{\tau_{ij}^2} V_i^2 - \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) - b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_iV_j,\]</p><p>with the following Jacobian expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{Q_{ij}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;= -
    \cfrac{\mathrm \partial{h_{Q_{ij}}(\mathbf x)}}{\mathrm \partial \theta_j} = -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) + b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_iV_j \\
    \cfrac{\mathrm \partial{h_{Q_{ij}}(\mathbf x)}}{\mathrm \partial V_i} &amp;= -
    2\cfrac{b_{ij} + b_{\mathrm{s}i}}{\tau_{ij}^2} V_i -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) - b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_j\\
    \cfrac{\mathrm \partial{h_{Q_{ij}}(\mathbf x)}}{\mathrm \partial V_j} &amp;= -
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) - b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_i.
	\end{aligned}\]</p><hr/><h5 id="To-Bus-Reactive-Power-Flow-Measurements"><a class="docs-heading-anchor" href="#To-Bus-Reactive-Power-Flow-Measurements">To-Bus Reactive Power Flow Measurements</a><a id="To-Bus-Reactive-Power-Flow-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#To-Bus-Reactive-Power-Flow-Measurements" title="Permalink"></a></h5><p>Similarly, a varmeter can be placed at the to-bus end, denoted as <span>$Q_{ji} \in \mathcal Q$</span>, with its own measurement value, variance, and measurement function included in vectors:</p><p class="math-container">\[    \mathbf{z}_\mathcal{Q} = [z_{Q_{ji}}], \;\;\; \mathbf{v}_\mathcal{Q} = [v_{Q_{ji}}], \;\;\; \mathbf{h}_\mathcal{Q}(\mathbf x) = [h_{Q_{ji}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addVarmeter!(monitoring; label = &quot;Q₂₁&quot;, to = 1, reactive = -0.2, variance = 1e-4)</code></pre><p>Thus, the function describing reactive power flow at the to-bus end is defined as follows:</p><p class="math-container">\[    h_{Q_{ji}}(\mathbf x) = -(b_{ij} + b_{\mathrm{s}i}) V_j^2 + \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) + b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_iV_j,\]</p><p>with the following Jacobian expressions:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{Q_{ji}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;= -
    \cfrac{\mathrm \partial{h_{Q_{ji}}(\mathbf x)}}{\mathrm \partial \theta_j} =
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\cos(\theta_{ij} - \phi_{ij}) - b_{ij}\sin(\theta_{ij} - \phi_{ij})\right] V_iV_j \\
    \cfrac{\mathrm \partial{h_{Q_{ji}}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) + b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_j\\
    \cfrac{\mathrm \partial{h_{Q_{ji}}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    -2(b_{ij} + b_{\mathrm{s}i}) V_{j} +
    \cfrac{1}{\tau_{ij}} \left[g_{ij}\sin(\theta_{ij} - \phi_{ij}) + b_{ij}\cos(\theta_{ij} - \phi_{ij})\right] V_i.
	\end{aligned}\]</p><hr/><h5 id="Polar-Bus-Voltage-Phasor-Measurements"><a class="docs-heading-anchor" href="#Polar-Bus-Voltage-Phasor-Measurements">Polar Bus Voltage Phasor Measurements</a><a id="Polar-Bus-Voltage-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Polar-Bus-Voltage-Phasor-Measurements" title="Permalink"></a></h5><p>To include phasor measurement <span>$(V_i, \theta_i) \in \bar{\mathcal P}$</span> at bus <span>$i \in \mathcal N$</span> in polar coordinates in the AC state estimation model, users will specify the measurement values, variances, and measurement functions as vectors:</p><p class="math-container">\[    \mathbf{z}_{\bar{\mathcal P}} = [z_{V_i}, z_{\theta_i}], \;\;\; \mathbf{v}_{\bar{\mathcal P}} = [v_{V_i}, v_{\theta_i}], \;\;\;
    \mathbf{h}_{\bar{\mathcal P}}(\mathbf x) = [h_{V_{i}}(\mathbf x), h_{\theta_{i}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;V₁, θ₁&quot;, bus = 1, magnitude = 1.0, angle = 0,
  varianceMagnitude = 1e-5, varianceAngle = 1e-6, polar = true
)</code></pre><p>Here, the functions defining the bus voltage phasor measurement are straightforward:</p><p class="math-container">\[  \begin{aligned}
    h_{V_i}(\mathbf x) = V_i\\
    h_{\theta_i}(\mathbf x) = \theta_i,
  \end{aligned}\]</p><p>with the following Jacobian expressions:</p><p class="math-container">\[  \begin{aligned}
   	\cfrac{\mathrm \partial{{h_{V_i}(\mathbf x)}}}{\mathrm \partial V_i} = 1, \;\;\;
    \cfrac{\mathrm \partial{{h_{\theta_i}(\mathbf x)}}}{\mathrm \partial \theta_i} = 1.
    \end{aligned}\]</p><hr/><h5 id="Rectangular-Bus-Voltage-Phasor-Measurements"><a class="docs-heading-anchor" href="#Rectangular-Bus-Voltage-Phasor-Measurements">Rectangular Bus Voltage Phasor Measurements</a><a id="Rectangular-Bus-Voltage-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Rectangular-Bus-Voltage-Phasor-Measurements" title="Permalink"></a></h5><p>When a PMU <span>$(V_i, \theta_i) \in \bar{\mathcal P}$</span> is introduced at bus <span>$i \in \mathcal N$</span>, it will be incorporated into the AC state estimation model using rectangular coordinates by default. It will define the measurement values, variances, and measurement functions of vectors:</p><p class="math-container">\[    \mathbf{z}_{\bar{\mathcal P}} = [z_{\Re(\bar{V}_i)}, z_{\Im(\bar{V}_i)}], \;\;\;
    \mathbf{v}_{\bar{\mathcal P}} = [v_{\Re(\bar{V}_i)}, v_{\Im(\bar{V}_i)}], \;\;\;
    \mathbf{h}_{\bar{\mathcal P}}(\mathbf x) = [h_{\Re(\bar{V}_i)}(\mathbf x), h_{\Im(\bar{V}_i)}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;V₂, θ₂&quot;, bus = 2, magnitude = 0.9, angle = -0.1,
  varianceMagnitude = 1e-5, varianceAngle = 1e-5
)</code></pre><p>Here, measurement values are obtained according to:</p><p class="math-container">\[  \begin{aligned}
    z_{\Re(\bar{V}_i)} = z_{V_i} \cos z_{\theta_i}\\
    z_{\Im(\bar{V}_i)} = z_{V_i} \sin z_{\theta_i}.
  \end{aligned}\]</p><p>Utilizing the classical theory of propagation of uncertainty [<a href="../../background/bibliography/#iso1993guide">21</a>], the variances can be calculated as follows:</p><p class="math-container">\[  \begin{aligned}
    v_{\Re(\bar{V}_i)} &amp;=
    v_{V_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \cos z_{\theta_i}) \right]^2 +
    v_{\theta_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \cos z_{\theta_i})\right]^2 =
    v_{V_i} (\cos z_{\theta_i})^2 + v_{\theta_i} (z_{V_i} \sin z_{\theta_i})^2\\
    v_{\Im(\bar{V}_i)} &amp;=
     v_{V_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \sin z_{\theta_i}) \right]^2 +
    v_{\theta_i} \left[ \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \sin z_{\theta_i})\right]^2 =
    v_{V_i} (\sin z_{\theta_i})^2 + v_{\theta_i} (z_{V_i} \cos z_{\theta_i})^2.
  \end{aligned}\]</p><p>Lastly, the functions defining the bus voltage phasor measurement are:</p><p class="math-container">\[  \begin{aligned}
    h_{\Re(\bar{V}_i)}(\mathbf x) = V_i \cos \theta_i\\
    h_{\Im(\bar{V}_i)}(\mathbf x) = V_i \sin \theta_i.
  \end{aligned}\]</p><p>Jacobian expressions corresponding to the measurement function <span>$h_{\Re(\bar{V}_i)}(\mathbf x)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
   	\cfrac{\mathrm \partial{h_{\Re(\bar{V}_i)}(\mathbf x)}}{\mathrm \partial \theta_i} = -V_i \sin \theta_i, \;\;\;
   	\cfrac{\mathrm \partial{h_{\Re(\bar{V}_i)}(\mathbf x)}}{\mathrm \partial V_i} = \cos \theta_i,
    \end{aligned}\]</p><p>while Jacobian expressions corresponding to the measurement function <span>$h_{\Im(\bar{V}_i)}(\mathbf x)$</span> are:</p><p class="math-container">\[  \begin{aligned}
   	\cfrac{\mathrm \partial{h_{\Im(\bar{V}_i)}(\mathbf x)}}{\mathrm \partial \theta_i} = V_i \cos \theta_i,\;\;\;
   	\cfrac{\mathrm \partial{h_{\Im(\bar{V}_i)}(\mathbf x)}}{\mathrm \partial V_i} = \sin \theta_i.
  \end{aligned}\]</p><p>In the previous example, the user neglects the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:</p><p class="math-container">\[    \mathbf{w}_{\bar{\mathcal P}} = [w_{\Re(\bar{V}_i)}, w_{\Im(\bar{V}_i)}].\]</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;V₃, θ₃&quot;, bus = 3, magnitude = 0.9, angle = -0.2,
  varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true
  )</code></pre><p>Then, the covariances are obtained as follows:</p><p class="math-container">\[    w_{\Re(\bar{V}_i)} = w_{\Im(\bar{V}_i)} =
    v_{V_i} \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \cos z_{\theta_i})
    \cfrac{\mathrm \partial} {\mathrm \partial z_{V_i}} (z_{V_i} \sin z_{\theta_i})  +
    v_{\theta_i} \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \cos z_{\theta_i})
    \cfrac{\mathrm \partial} {\mathrm \partial z_{\theta_i}} (z_{V_i} \sin z_{\theta_i}),\]</p><p>which results in the solution:</p><p class="math-container">\[    w_{\Re(\bar{V}_i)} = w_{\Im(\bar{V}_i)} = \cos z_{\theta_i} \sin z_{\theta_i}(v_{V_i} - v_{\theta_i} z_{V_i}^2).\]</p><hr/><h5 id="Polar-From-Bus-Current-Phasor-Measurements"><a class="docs-heading-anchor" href="#Polar-From-Bus-Current-Phasor-Measurements">Polar From-Bus Current Phasor Measurements</a><a id="Polar-From-Bus-Current-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Polar-From-Bus-Current-Phasor-Measurements" title="Permalink"></a></h5><p>To include phasor measurement <span>$(I_{ij}, \psi_{ij}) \in \bar{\mathcal P}$</span> at branch <span>$(i,j) \in \mathcal E$</span> in polar coordinates in the AC state estimation model, users will specify the measurement values, variances, and measurement functions as vectors:</p><p class="math-container">\[    \mathbf{z}_{\bar{\mathcal P}} = [z_{I_{ij}}, z_{\psi_{ij}}], \;\;\;
    \mathbf{v}_{\bar{\mathcal P}} = [v_{I_{ij}}, v_{\psi_{ij}}], \;\;\;
    \mathbf{h}_{\bar{\mathcal P}}(\mathbf x) = [h_{I_{ij}}(\mathbf x), h_{\psi_{ij}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;I₁₂, ψ₁₂&quot;, from = 1, magnitude = 0.3, angle = -0.7,
  varianceMagnitude = 1e-5, varianceAngle = 1e-4, polar = true
)</code></pre><p>Here, the function and corresponding Jacobian expressions associated with the branch current magnitude at the from-bus end remains identical to the one provided in <a href="#FromCurrentMagnitudeMeasurements">From-Bus Current Magnitude Measurements</a>. Additionally, by using <code>square = true</code>, the current magnitude measurement can also be incorporated in squared form into the state estimation model.</p><p>However, the function defining the branch current angle measurement is expressed as:</p><p class="math-container">\[    h_{\psi_{ij}}(\mathbf x) = \mathrm{atan} \Bigg[
    \cfrac{(A_{\psi_{ij}} \sin\theta_i + B_{\psi_{ij}} \cos\theta_i)V_i - [C_{\psi_{ij}} \sin(\theta_j + \phi_{ij}) + D_{\psi_{ij}}\cos(\theta_j + \phi_{ij})]V_j}
    {(A_{\psi_{ij}} \cos\theta_i - B_{\psi_{ij}} \sin\theta_i)V_i - [C_{\psi_{ij}} \cos(\theta_j + \phi_{ij}) - D_{\psi_{ij}} \sin(\theta_j + \phi_{ij})]V_j} \Bigg],\]</p><p>where:</p><p class="math-container">\[    A_{\psi_{ij}} = \cfrac{g_{ij} + g_{\mathrm{s}i}}{\tau_{ij}^2}, \;\;\;
    B_{\psi_{ij}} = \cfrac{b_{ij}+b_{\mathrm{s}i}}{\tau_{ij}^2}, \;\;\;
    C_{\psi_{ij}} = \cfrac{g_{ij}}{\tau_{ij}}, \;\;\;
    D_{\psi_{ij}} = \cfrac{b_{ij}}{\tau_{ij}}.\]</p><p>Jacobian expressions corresponding to the measurement function <span>$h_{\psi_{ij}}(\mathbf x)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{\psi_{ij}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    \cfrac{A_{I_{ij}} V_i^2- [C_{I_{ij}} \cos(\theta_{ij}- \phi_{ij}) - D_{I_{ij}} \sin (\theta_{ij} - \phi_{ij})]V_iV_j}{h_{{I}_{ij}}^2(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{\psi_{ij}}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    \cfrac{B_{I_{ij}} V_j^2 - [C_{I_{ij}} \cos (\theta_{ij} - \phi_{ij}) - D_{I_{ij}} \sin(\theta_{ij}- \phi_{ij})]V_iV_j}{h_{{I}_{ij}}^2(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{\psi_{ij}}(\mathbf x)}}{\mathrm \partial V_i} &amp;= -
    \cfrac{[C_{I_{ij}} \sin (\theta_{ij} - \phi_{ij}) + D_{I_{ij}} \cos(\theta_{ij}- \phi_{ij})]V_j }{h_{{I}_{ij}}^2(\mathbf x)}\\
    \cfrac{\mathrm \partial{h_{\psi_{ij}}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    \cfrac{[C_{I_{ij}} \sin (\theta_{ij} - \phi_{ij}) + D_{I_{ij}} \cos(\theta_{ij}- \phi_{ij})]V_i }{h_{{I}_{ij}}^2(\mathbf x)}.
  \end{aligned}\]</p><hr/><h5 id="Rectangular-From-Bus-Current-Phasor-Measurements"><a class="docs-heading-anchor" href="#Rectangular-From-Bus-Current-Phasor-Measurements">Rectangular From-Bus Current Phasor Measurements</a><a id="Rectangular-From-Bus-Current-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Rectangular-From-Bus-Current-Phasor-Measurements" title="Permalink"></a></h5><p>When introducing a PMU at branch <span>$(i,j) \in \mathcal E$</span>, it can be placed at the from-bus end, denoted as <span>$(I_{ij}, \psi_{ij}) \in \bar{\mathcal P}$</span>, and it will be integrated into the AC state estimation model using rectangular coordinates by default. Incorporating current phasor measurements in the polar coordinate system is highly susceptible to ill-conditioned problems, especially when dealing with small values of current magnitudes. This is the reason why we typically include PMUs in the rectangular coordinate system by default.</p><p>Therefore, here we specify the measurement values, variances, and measurement functions of vectors:</p><p class="math-container">\[    \mathbf{z}_{\bar{\mathcal P}} = [z_{\Re(\bar{I}_{ij})}, z_{\Im(\bar{I}_{ij})}], \;\;\;
    \mathbf{v}_{\bar{\mathcal P}} = [v_{\Re(\bar{I}_{ij})}, v_{\Im(\bar{I}_{ij})}], \;\;\;
    \mathbf{h}_{\bar{\mathcal P}}(\mathbf x) = [h_{\Re(\bar{I}_{ij})}(\mathbf x), h_{\Im(\bar{I}_{ij})}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;I₂₃, ψ₂₃&quot;, from = 3, magnitude = 0.3, angle = 0.4,
  varianceMagnitude = 1e-5, varianceAngle = 1e-4
)</code></pre><p>Here, measurement values are obtained according to:</p><p class="math-container">\[  \begin{aligned}
    z_{\Re(\bar{I}_{ij})} = z_{I_{ij}} \cos z_{\psi_{ij}}\\
    z_{\Im(\bar{I}_{ij})} = z_{I_{ij}} \sin z_{\psi_{ij}}.
  \end{aligned}\]</p><p>Utilizing the classical theory of propagation of uncertainty [<a href="../../background/bibliography/#iso1993guide">21</a>], the variances can be calculated as follows:</p><p class="math-container">\[  \begin{aligned}
    v_{\Re(\bar{I}_{ij})} &amp; = v_{I_{ij}} (\cos z_{\psi_{ij}})^2 + v_{\psi_{ij}} (z_{I_{ij}} \sin z_{\psi_{ij}})^2 \\
    v_{\Im(\bar{I}_{ij})} &amp;= v_{I_{ij}} (\sin z_{\psi_{ij}})^2 + v_{\psi_{ij}} (z_{I_{ij}} \cos z_{\psi_{ij}})^2.
  \end{aligned}\]</p><p>The functions defining the current phasor measurement at the from-bus end are:</p><p class="math-container">\[  \begin{aligned}
    h_{\Re(\bar{I}_{ij})}(\mathbf x) &amp;= (A_{\psi_{ij}} \cos\theta_i - B_{\psi_{ij}} \sin\theta_i)V_i - [C_{\psi_{ij}} \cos(\theta_j + \phi_{ij}) - D_{\psi_{ij}} \sin(\theta_j + \phi_{ij})]V_j, \\
    h_{\Im(\bar{I}_{ij})}(\mathbf x) &amp;= (A_{\psi_{ij}} \sin\theta_i + B_{\psi_{ij}} \cos\theta_i)V_i - [C_{\psi_{ij}} \sin(\theta_j + \phi_{ij}) + D_{\psi_{ij}} \cos(\theta_j + \phi_{ij})]V_j.
  \end{aligned}\]</p><p>Jacobian expressions corresponding to the measurement function <span>$h_{\Re(\bar{I}_{ij})}(\mathbf x)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    -(A_{\psi_{ij}} \sin\theta_{i} + B_{\psi_{ij}} \cos\theta_i)V_i\\
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    [C_{\psi_{ij}} \sin(\theta_j + \phi_{ij}) + D_{\psi_{ij}} \cos(\theta_j + \phi_{ij})] V_j \\
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
     A_{\psi_{ij}}  \cos\theta_{i} - B_{\psi_{ij}} \sin\theta_i\\
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    -C_{\psi_{ij}} \cos(\theta_j + \phi_{ij}) + D_{\psi_{ij}}  \sin(\theta_j + \phi_{ij}).
  \end{aligned}\]</p><p>while Jacobian expressions corresponding to the measurement function <span>$h_{\Im(\bar{I}_{ij})}(\mathbf x)$</span> are:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    (A_{\psi_{ij}} \cos \theta_{i} - B_{\psi_{ij}} \sin \theta_i)V_i\\
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    [-C_{\psi_{ij}} \cos(\theta_j + \phi_{ij}) + D_{\psi_{ij}} \sin(\theta_j + \phi_{ij})] V_j \\
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
     A_{\psi_{ij}}  \sin \theta_{i} + B_{\psi_{ij}} \cos\theta_i\\
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ij})}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    -C_{\psi_{ij}} \sin(\theta_j + \phi_{ij}) - D_{\psi_{ij}}  \cos(\theta_j + \phi_{ij}).
  \end{aligned}\]</p><p>In the previous example, the user neglects the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:</p><p class="math-container">\[    \mathbf{w}_{\bar{\mathcal{P}}} = [w_{\Re(\bar{I}_{ij})}, w_{\Im(\bar{I}_{ij})}].\]</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;I₁₃, ψ₁₃&quot;, from = 2, magnitude = 0.3, angle = -0.5,
  varianceMagnitude = 1e-4, varianceAngle = 1e-5, correlated = true
)</code></pre><p>Then, the covariances are obtained as follows:</p><p class="math-container">\[   w_{\Re(\bar{I}_{ij})} = w_{\Im(\bar{I}_{ij})} = \sin z_{\psi_{ij}} \cos z_{\psi_{ij}}(v_{I_{ij}}  - v_{\psi_{ij}} z_{I_{ij}}^2).\]</p><hr/><h5 id="Polar-To-Bus-Current-Phasor-Measurements"><a class="docs-heading-anchor" href="#Polar-To-Bus-Current-Phasor-Measurements">Polar To-Bus Current Phasor Measurements</a><a id="Polar-To-Bus-Current-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Polar-To-Bus-Current-Phasor-Measurements" title="Permalink"></a></h5><p>To include phasor measurement <span>$(I_{ji}, \psi_{ji}) \in \bar{\mathcal P}$</span> at branch <span>$(i,j) \in \mathcal E$</span> in polar coordinates in the AC state estimation model, users will specify the measurement values, variances, and measurement functions as vectors:</p><p class="math-container">\[    \mathbf{z}_{\bar{\mathcal P}} = [z_{I_{ji}}, z_{\psi_{ji}}], \;\;\;
    \mathbf{v}_{\bar{\mathcal P}} = [v_{I_{ji}}, v_{\psi_{ji}}], \;\;\;
    \mathbf{h}_{\bar{\mathcal P}}(\mathbf x) = [h_{I_{ji}}(\mathbf x), h_{\psi_{ji}}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;I₂₁, ψ₂₁&quot;, to = 1, magnitude = 0.3, angle = 2.3,
  varianceMagnitude = 1e-2, varianceAngle = 1e-3, polar = true
)</code></pre><p>Here, the function and corresponding Jacobian expressions associated with the branch current magnitude at the to-bus end remains identical to the one provided in <a href="#ToCurrentMagnitudeMeasurements">To-Bus Current Magnitude Measurements</a>. Additionally, by using <code>square = true</code>, the current magnitude measurement can also be incorporated in squared form into the state estimation model.</p><p>However, the function defining the branch current angle measurement is expressed as:</p><p class="math-container">\[    h_{\psi_{ji}}(\mathbf {x}) = \mathrm{atan}\Bigg[
    \cfrac{(A_{\psi_{ji}} \sin\theta_j + B_{\psi_{ji}} \cos\theta_j)V_j - [C_{\psi_{ji}} \sin(\theta_i - \phi_{ij}) + D_{\psi_{ji}}\cos(\theta_i - \phi_{ij})]V_i}
    {(A_{\psi_{ji}} \cos\theta_j - B_{\psi_{ji}} \sin\theta_j)V_j - [C_{\psi_{ji}} \cos(\theta_i - \phi_{ij}) - D_{\psi_{ji}} \sin(\theta_i - \phi_{ij})]V_i} \Bigg],\]</p><p>where:</p><p class="math-container">\[    A_{\psi_{ji}} = g_{ij} + g_{\mathrm{s}i}, \;\;\;
    B_{\psi_{ji}} = b_{ij} + b_{\mathrm{s}i}, \;\;\;
    C_{\psi_{ji}} = \cfrac{g_{ij}}{\tau_{ij}}, \;\;\;
    D_{\psi_{ji}} = \cfrac{b_{ij}}{\tau_{ij}}.\]</p><p>Jacobian expressions corresponding to the measurement function <span>$h_{\psi_{ji}}(\mathbf x)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{\psi_{ji}}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    \cfrac{A_{I_{ji}} V_i^2- [C_{I_{ji}} \cos(\theta_{ij}- \phi_{ij}) + D_{I_{ji}} \sin (\theta_{ij} - \phi_{ij}) ]V_iV_j}{h_{{I}_{ji}}^2(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{\psi_{ji}}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    \cfrac{B_{I_{ji}} V_j^2 - [C_{I_{ji}} \cos (\theta_{ij} - \phi_{ij}) + D_{I_{ji}} \sin(\theta_{ij}- \phi_{ij})]V_iV_j}{h_{{I}_{ji}}^2(\mathbf x)} \\
    \cfrac{\mathrm \partial{h_{\psi_{ji}}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    -\cfrac{[C_{I_{ji}} \sin (\theta_{ij} - \phi_{ij}) - D_{I_{ji}} \cos(\theta_{ij}- \phi_{ij})]V_j }{h_{{I}_{ji}}^2(\mathbf x)}\\
    \cfrac{\mathrm \partial{h_{\psi_{ji}}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    \cfrac{[C_{I_{ji}} \sin (\theta_{ij} - \phi_{ij}) - D_{I_{ji}} \cos(\theta_{ij}- \phi_{ij})]V_i }{h_{{I}_{ji}}^2(\mathbf x)}.
  \end{aligned}\]</p><hr/><h5 id="Rectangular-To-Bus-Current-Phasor-Measurements"><a class="docs-heading-anchor" href="#Rectangular-To-Bus-Current-Phasor-Measurements">Rectangular To-Bus Current Phasor Measurements</a><a id="Rectangular-To-Bus-Current-Phasor-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Rectangular-To-Bus-Current-Phasor-Measurements" title="Permalink"></a></h5><p>When introducing a PMU at branch <span>$(i,j) \in \mathcal E$</span>, it can be placed at the to-bus end, denoted as <span>$(I_{ji}, \psi_{ji}) \in \bar{\mathcal P}$</span>, and it will be integrated into the AC state estimation model using rectangular coordinates by default. The user will specify the measurement values, variances, and measurement functions of vectors:</p><p class="math-container">\[    \mathbf{z}_{\bar{\mathcal P}} = [z_{\Re(\bar{I}_{ji})}, z_{\Im(\bar{I}_{ji})}], \;\;\;
    \mathbf{v}_{\bar{\mathcal P}} = [v_{\Re(\bar{I}_{ji})}, v_{\Im(\bar{I}_{ji})}], \;\;\;
    \mathbf{h}_{\bar{\mathcal P}}(\mathbf x) = [h_{\Re(\bar{I}_{ji})}(\mathbf x), h_{\Im(\bar{I}_{ji})}(\mathbf x)].\]</p><p>For example:</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;I₃₂, ψ₃₂&quot;, to = 3, magnitude = 0.3, angle = -2.9,
  varianceMagnitude = 1e-5, varianceAngle = 1e-5
)</code></pre><p>Here, measurement values are obtained according to:</p><p class="math-container">\[  \begin{aligned}
    z_{\Re(\bar{I}_{ji})} = z_{I_{ji}} \cos z_{\psi_{ji}}\\
    z_{\Im(\bar{I}_{ji})} = z_{I_{ji}} \sin z_{\psi_{ji}}.
  \end{aligned}\]</p><p>The variances can be calculated as follows:</p><p class="math-container">\[  \begin{aligned}
    v_{\Re(\bar{I}_{ji})} &amp;= v_{I_{ji}} (\cos z_{\psi_{ji}})^2 + v_{\psi_{ji}} (z_{I_{ji}} \sin z_{\psi_{ji}})^2 \\
    v_{\Im(\bar{I}_{ji})} &amp;= v_{I_{ji}} (\sin z_{\psi_{ji}})^2 + v_{\psi_{ji}} (z_{I_{ji}} \cos z_{\psi_{ji}})^2.
  \end{aligned}\]</p><p>The functions defining the current phasor measurement at the to-bus end are:</p><p class="math-container">\[  \begin{aligned}
    h_{\Re(\bar{I}_{ji})}(\mathbf x) &amp;= (A_{\psi_{ji}} \cos\theta_j - B_{\psi_{ji}} \sin\theta_j)V_j - [C_{\psi_{ji}} \cos(\theta_i - \phi_{ij}) - D_{\psi_{ji}} \sin (\theta_i - \phi_{ij})]V_i\\
    h_{\Im(\bar{I}_{ji})}(\mathbf x) &amp;= (A_{\psi_{ji}} \sin\theta_j + B_{\psi_{ji}} \cos\theta_j)V_j - [C_{\psi_{ji}} \sin(\theta_i - \phi_{ij}) + D_{\psi_{ji}} \cos (\theta_i - \phi_{ij})]V_i.
  \end{aligned}\]</p><p>Jacobian expressions corresponding to the measurement function <span>$h_{\Re(\bar{I}_{ji})}(\mathbf x)$</span> are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    [C_{\psi_{ji}} \sin (\theta_{i} - \phi_{ij}) + D_{\psi_{ji}} \cos (\theta_i - \phi_{ij})]V_i\\
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    -(A_{\psi_{ji}} \sin\theta_j + B_{\psi_{ji}} \cos \theta_j ) V_j \\
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    - C_{\psi_{ji}} \cos (\theta_i - \phi_{ij}) + D_{\psi_{ji}} \sin(\theta_i - \phi_{ij})\\
    \cfrac{\mathrm \partial{h_{\Re(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    A_{\psi_{ji}} \cos \theta_j - B_{\psi_{ji}}  \sin \theta_j.
  \end{aligned}\]</p><p>while Jacobian expressions corresponding to the measurement function <span>$h_{\Im(\bar{I}_{ji})}(\mathbf x)$</span> are:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \theta_i} &amp;=
    [-C_{\psi_{ji}} \cos (\theta_{i} - \phi_{ij}) + D_{\psi_{ji}} \sin (\theta_i - \phi_{ij})]V_i\\
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;=
    (A_{\psi_{ji}} \cos\theta_j - B_{\psi_{ji}} \sin \theta_j ) V_j \\
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial V_i} &amp;=
    - C_{\psi_{ji}} \sin (\theta_i - \phi_{ij}) - D_{\psi_{ji}}  \cos(\theta_i - \phi_{ij})\\
    \cfrac{\mathrm \partial{h_{\Im(\bar{I}_{ji})}(\mathbf x)}}{\mathrm \partial V_j} &amp;=
    A_{\psi_{ji}} \sin \theta_j + B_{\psi_{ji}}  \cos \theta_j.
  \end{aligned}\]</p><p>As before, we are neglecting the covariances between the real and imaginary parts of the measurement. If desired, we can include them in the state estimation model by specifying the covariances of the vector:</p><p class="math-container">\[    \mathbf{w}_{\bar{\mathcal{P}}} = [w_{\Re(\bar{I}_{ji})}, w_{\Im(\bar{I}_{ji})}].\]</p><pre><code class="language-julia hljs">addPmu!(
  monitoring; label = &quot;I₃₁, ψ₃₁&quot;, to = 2, magnitude = 0.3, angle = 2.5,
  varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true
)</code></pre><p>Then, the covariances are obtained as follows:</p><p class="math-container">\[   w_{\Re(\bar{I}_{ji})} = w_{\Im(\bar{I}_{ji})} = \sin z_{\psi_{ji}} \cos z_{\psi_{ji}}(v_{I_{ji}} - v_{\psi_{ji}} z_{I_{ji}}^2).\]</p><hr/><h2 id="ACSEWLSStateEstimationTutorials"><a class="docs-heading-anchor" href="#ACSEWLSStateEstimationTutorials">Weighted Least-Squares Estimation</a><a id="ACSEWLSStateEstimationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACSEWLSStateEstimationTutorials" title="Permalink"></a></h2><p>Given the available set of measurements <span>$\mathcal M$</span>, the weighted least-squares (WLS) estimator <span>$\hat{\mathbf x}$</span> can be found using the Gauss-Newton method:</p><p class="math-container">\[\begin{gathered}
		\Big[\mathbf J (\mathbf x^{(\nu)})^T \bm \Sigma^{-1} \mathbf J (\mathbf x^{(\nu)})\Big] \mathbf \Delta \mathbf x^{(\nu)} =
		\mathbf J (\mathbf x^{(\nu)})^T \bm \Sigma^{-1} \mathbf r (\mathbf x^{(\nu)}) \\
    \mathbf x^{(\nu+1)} = \mathbf x^{(\nu)} + \mathbf \Delta \mathbf x^{(\nu)},
\end{gathered}\]</p><p>where <span>$\nu = \{0,1,2,\dots\}$</span> is the iteration index, <span>$\mathbf \Delta \mathbf x \in \mathbb {R}^s$</span> is the vector of increments of the state variables, <span>$\mathbf J (\mathbf x)\in \mathbb {R}^{k \times s}$</span> is the Jacobian matrix of measurement functions <span>$\mathbf h (\mathbf x)$</span> at <span>$\mathbf x = \mathbf x^{(\nu)}$</span>, <span>$\bm \Sigma \in \mathbb {R}^{k \times k}$</span> is a measurement error covariance matrix, and <span>$\mathbf r (\mathbf x) = \mathbf{z} - \mathbf h (\mathbf x)$</span> is the vector of residuals [<a href="../../background/bibliography/#monticellibook">13</a>, Ch. 10]. It is worth noting that assuming uncorrelated measurement errors leads to a diagonal covariance matrix <span>$\bm \Sigma$</span> corresponding to measurement variances. However, when incorporating PMUs in a rectangular coordinate system and aiming to observe error correlation, this matrix loses its diagonal form.</p><p>The nonlinear or AC state estimation represents a non-convex problem arising from the nonlinear measurement functions [<a href="../../background/bibliography/#weng2012semidefinite">22</a>]. Due to the fact that the values of state variables usually fluctuate in narrow boundaries, the model represents the mildly nonlinear problem, where solutions are in a reasonable-sized neighborhood which enables the use of the Gauss-Newton method. The Gauss-Newton method can produce different rates of convergence, which can be anywhere from linear to quadratic [<a href="../../background/bibliography/#hansen2013least">23</a>, Sec. 9.2]. The convergence rate in regard to power system state estimation depends on the topology and measurements, and if parameters are consistent (e.g., free bad data measurement set), the method shows near quadratic convergence rate [<a href="../../background/bibliography/#monticellibook">13</a>, Sec. 11.2].</p><hr/><h5 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h5><p>Let us begin by setting up a new set of measurements for the defined power system:</p><pre><code class="language-julia hljs">monitoring = measurement(system)

@wattmeter(label = &quot;Watmeter ?&quot;)
addWattmeter!(monitoring; bus = 3, active = -0.5, variance = 1e-3)
addWattmeter!(monitoring; from = 1, active = 0.2, variance = 1e-4)

@varmeter(label = &quot;Varmeter ?&quot;)
addVarmeter!(monitoring; bus = 2, reactive = -0.3, variance = 1e-3)
addVarmeter!(monitoring; from = 1, reactive = 0.2, variance = 1e-4)

@pmu(label = &quot;PMU ?&quot;)
addPmu!(monitoring; bus = 1, magnitude = 1.0, angle = 0, polar = true)
addPmu!(monitoring; bus = 3, magnitude = 0.9, angle = -0.2)</code></pre><p>To compute the voltage magnitudes and angles of buses using the Gauss-Newton method in JuliaGrid, we need to first execute the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function to set up the system. Then, initialize the Gauss-Newton method using the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function. The following code snippet demonstrates this process:</p><pre><code class="language-julia hljs">acModel!(system)
analysis = gaussNewton(monitoring)</code></pre><p>Initially, the <a href="../../api/stateEstimation/#JuliaGrid.gaussNewton"><code>gaussNewton</code></a> function constructs the mean vector holding measurement values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐳 = analysis.method.mean</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{Float64}:
 -0.5
  0.2
 -0.3
  0.2
  1.0
  0.0
  0.8820599200571175
 -0.1788023977155551</code></pre><p>Additionally, it forms the precision or weighting matrix denoted as <span>$\mathbf W = \bm \Sigma^{-1}$</span>. We can access these values using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐖 = analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
 1000.0       ⋅       ⋅        ⋅    ⋅      ⋅      ⋅          ⋅
     ⋅   10000.0      ⋅        ⋅    ⋅      ⋅      ⋅          ⋅
     ⋅        ⋅   1000.0       ⋅    ⋅      ⋅      ⋅          ⋅
     ⋅        ⋅       ⋅   10000.0   ⋅      ⋅      ⋅          ⋅
     ⋅        ⋅       ⋅        ⋅   1.0e8   ⋅      ⋅          ⋅
     ⋅        ⋅       ⋅        ⋅    ⋅     1.0e8   ⋅          ⋅
     ⋅        ⋅       ⋅        ⋅    ⋅      ⋅     1.00756e8   ⋅
     ⋅        ⋅       ⋅        ⋅    ⋅      ⋅      ⋅         1.22324e8</code></pre><p>Finally, using initial bus voltage magnitudes and angles from the <code>PowerSystem</code> type, the function creates the initial vector <span>$\mathbf{x}^{(0)}$</span> of bus voltage magnitudes <span>$\mathbf{V}^{(0)}$</span> and angles <span>$\bm{\Theta}^{(0)}$</span> for the Gauss-Newton method:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕⁽⁰⁾ = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯⁽⁰⁾ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>Here, we utilize a &quot;flat start&quot; approach in our method. It is important to keep in mind that when dealing with initial conditions in this manner, the Gauss-Newton method may encounter difficulties.</p><hr/><h5 id="Iterative-Process"><a class="docs-heading-anchor" href="#Iterative-Process">Iterative Process</a><a id="Iterative-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Process" title="Permalink"></a></h5><p>To apply the Gauss-Newton method, JuliaGrid provides the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}"><code>solve!</code></a> function. This function is utilized iteratively until a stopping criterion is met, as demonstrated in the following code snippet:</p><pre><code class="language-julia hljs">for iteration = 0:20
    stopping = increment!(analysis)
    if stopping &lt; 1e-8
        break
    end
    solve!(analysis)
end</code></pre><p>The function <a href="../../api/stateEstimation/#JuliaGrid.increment!"><code>increment!</code></a> calculates the vector of residuals at each iteration using the equation:</p><p class="math-container">\[  \mathbf r (\mathbf x^{(\nu)}) = \mathbf{z} - \mathbf h (\mathbf x^{(\nu)}).\]</p><p>The resulting vector from these calculations is stored in the residual variable of the <code>AcStateEstimation</code> type and can be accessed through the following line of code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐫 = analysis.method.residual</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{Float64}:
  0.0035064869296839163
 -0.00195862748866385
  0.01806748801610575
  0.00552270919867498
 -6.954572575601503e-7
  0.0
  7.228497772571174e-7
 -3.090376066161582e-7</code></pre><p>The order of the residual vector follows a specific pattern. If all device types exist, the first <span>$|\mathcal V|$</span> elements correspond to voltmeters, followed by <span>$|\mathcal I|$</span> elements corresponding to ammeters. Then we have <span>$|\mathcal P|$</span> elements for wattmeters and <span>$|\mathcal Q|$</span> elements for varmeters. Finally, we have <span>$2|\bar{\mathcal P}|$</span> elements for PMUs. The order of these elements within specific devices follows the same order as they appear in the input data defined by the <code>Measurement</code> type.</p><p>At the same time, the function forms the Jacobian matrix <span>$\mathbf J (\mathbf x^{(\nu)})$</span> and calculates the gain matrix <span>$\mathbf G (\mathbf{x}^{(\nu)})$</span> using:</p><p class="math-container">\[		\mathbf G (\mathbf x^{(\nu)}) = \mathbf J (\mathbf x^{(\nu)})^{T} \bm \Sigma^{-1} \mathbf J (\mathbf x^{(\nu)})\]</p><p>The Jacobian matrix and factorized gain matrix are stored in the <code>AcStateEstimation</code> type and can be accessed after each iteration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐉 = analysis.method.jacobian</code><code class="nohighlight hljs ansi" style="display:block;">8×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 26 stored entries:
 -1.25177   -3.8648    5.11657   -0.291196  -0.738569  -0.0772033
  1.45034   -1.45034    ⋅         0.257452   0.167366    ⋅
  0.242722  -0.374494  0.131773  -1.43737    5.39071   -4.3514
  0.146465  -0.146465   ⋅         1.8393    -1.65731     ⋅
   ⋅          ⋅         ⋅         1.0         ⋅          ⋅
  1.0         ⋅         ⋅          ⋅          ⋅          ⋅
   ⋅          ⋅        0.178802    ⋅          ⋅         0.980067
   ⋅          ⋅        0.882059    ⋅          ⋅        -0.198669</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐋 = analysis.method.factorization.L</code><code class="nohighlight hljs ansi" style="display:block;">6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
 1.0    ⋅            ⋅            ⋅            ⋅            ⋅
  ⋅    1.0           ⋅            ⋅            ⋅            ⋅
  ⋅   -0.00033994   1.0           ⋅            ⋅            ⋅
  ⋅   -8.34403e-5  -4.44128e-5   1.0           ⋅            ⋅
  ⋅    0.0119829   -0.0222009   -0.306728     1.0           ⋅
  ⋅    3.20528e-5  -0.0372364    6.04031e-5  -0.000476186  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐔 = analysis.method.factorization.U</code><code class="nohighlight hljs ansi" style="display:block;">6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
 1.0   ⋅         ⋅          ⋅            ⋅             ⋅
  ⋅   0.57047  -0.311314  -0.0748163    0.0131228     0.0302766
  ⋅    ⋅        0.96267   -4.18609e-5  -2.55572e-5   -0.0369733
  ⋅    ⋅         ⋅         0.999491    -0.000374433   6.36002e-5
  ⋅    ⋅         ⋅          ⋅           0.468897     -0.192589
  ⋅    ⋅         ⋅          ⋅            ⋅            0.962374</code></pre><p>Then finally, the function computes the vector of state variable increments using the equation:</p><p class="math-container">\[		\mathbf \Delta \mathbf x^{(\nu)} = \mathbf G (\mathbf x^{(\nu)})^{-1} \mathbf J (\mathbf x^{(\nu)})^{T} \bm \Sigma^{-1} \mathbf r (\mathbf x^{(\nu)})\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>By default, JuliaGrid uses LU factorization as the primary method for factorizing the gain matrix <span>$\mathbf{G} = \mathbf{L}\mathbf{U}$</span>, aiming to compute the increments. Nevertheless, users have the flexibility to opt for QR or LDLt factorization as an alternative method.</p></div></div><p>Increment values are stored in the <code>AcStateEstimation</code> type and can be accessed after each iteration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚫𝐱 = analysis.method.increment</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
  0.0
 -2.2536116143951154e-9
 -1.1813208586384162e-14
 -1.5569564317005995e-13
  9.603994185165705e-10
  1.126924248894049e-13</code></pre><p>Here again, the JuliaGrid implementation of the AC state estimation follows a specific order to store the increment vector and Jacobian matrix. The vector of increments first contains <span>$n$</span> increments of bus voltage angles <span>$\mathbf \Delta \bm{\Theta}$</span>, followed by <span>$n$</span> increments of bus voltage magnitudes <span>$\mathbf \Delta \mathbf{V}$</span>. This order also corresponds to the columns of the Jacobian matrix, while the order of rows of the Jacobian is defined according to the order of the residual vector.</p><p>Note that the increment vector and Jacobian matrix hold the slack bus with a known voltage angle. An element of the increment vector and a column of the Jacobian matrix are not deleted, and the presence on the slack bus is handled internally by JuliaGrid, which is evident from the factorization of the gain matrix.</p><p>Next, the <a href="../../api/stateEstimation/#JuliaGrid.increment!"><code>increment!</code></a> function provides the maximum absolute value of state variable increments, typically employed as the termination criterion for the iteration loop. Specifically, if it falls below a predefined stopping criterion <span>$\epsilon$</span>, the algorithm converges:</p><p class="math-container">\[  \max \{|\Delta x_i|,\; \forall i \} &lt; \epsilon.\]</p><p>Finally the function <a href="../../api/stateEstimation/#JuliaGrid.solve!-Union{Tuple{AcStateEstimation{GaussNewton{T}}}, Tuple{T}} where T&lt;:Union{Normal, Orthogonal}"><code>solve!</code></a> adds the computed increment term to the previous solution to obtain a new solution:</p><p class="math-container">\[  \mathbf {x}^{(\nu + 1)} = \mathbf {x}^{(\nu)} + \mathbf \Delta \mathbf {x}^{(\nu)}.\]</p><p>Therefore, the bus voltage magnitudes <span>$\mathbf{V} = [V_i]$</span> and angles <span>$\bm{\Theta} = [\theta_i]$</span> are stored in the following vectors:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0000006954572576
 0.8751163041335766
 0.8999992301628121</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.13396608444681726
 -0.19999982303390634</code></pre><hr/><h5 id="Jacobian-Matrix"><a class="docs-heading-anchor" href="#Jacobian-Matrix">Jacobian Matrix</a><a id="Jacobian-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-Matrix" title="Permalink"></a></h5><p>As a reminder, the Jacobian matrix consists of <span>$n$</span> columns representing bus voltage angles <span>$\bm \Theta$</span>, followed by <span>$n$</span> columns representing bus voltage magnitudes <span>$\mathbf V$</span>. The arrangement of rows is structured such that the first <span>$|\mathcal V|$</span> rows correspond to voltmeters, followed by <span>$|\mathcal I|$</span> rows corresponding to ammeters. Then, we have <span>$|\mathcal P|$</span> rows for wattmeters and <span>$|\mathcal Q|$</span> rows for varmeters. Finally, there are <span>$2|\bar{\mathcal P}|$</span> rows for PMUs. The elements are computed based on the provided Jacobian expressions.</p><hr/><h5 id="Precision-Matrix"><a class="docs-heading-anchor" href="#Precision-Matrix">Precision Matrix</a><a id="Precision-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-Matrix" title="Permalink"></a></h5><p>Let us revisit the precision matrix <span>$\mathbf W$</span>. In the previous example, we introduced a PMU in rectangular coordinates without considering correlations between measurement errors. Now, let us update that PMU to include correlation between measurement errors:</p><pre><code class="language-julia hljs">updatePmu!(analysis; label = &quot;PMU 2&quot;, correlated = true)</code></pre><p>Subsequently, we can examine the updated precision matrix <span>$\mathbf W$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐖 = analysis.method.precision</code><code class="nohighlight hljs ansi" style="display:block;">8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 10 stored entries:
 1000.0       ⋅       ⋅        ⋅    ⋅      ⋅      ⋅          ⋅
     ⋅   10000.0      ⋅        ⋅    ⋅      ⋅      ⋅          ⋅
     ⋅        ⋅   1000.0       ⋅    ⋅      ⋅      ⋅          ⋅
     ⋅        ⋅       ⋅   10000.0   ⋅      ⋅      ⋅          ⋅
     ⋅        ⋅       ⋅        ⋅   1.0e8   ⋅      ⋅          ⋅
     ⋅        ⋅       ⋅        ⋅    ⋅     1.0e8   ⋅          ⋅
     ⋅        ⋅       ⋅        ⋅    ⋅      ⋅     1.00926e8  4.56725e6
     ⋅        ⋅       ⋅        ⋅    ⋅      ⋅     4.56725e6  1.22531e8</code></pre><p>Observing the precision matrix, we notice that it loses its diagonal form due to the inclusion of measurement covariances in the model.</p><hr/><h5 id="GaussNewtonAlgorithmTutorials"><a class="docs-heading-anchor" href="#GaussNewtonAlgorithmTutorials">The Gauss-Newton Algorithm</a><a id="GaussNewtonAlgorithmTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#GaussNewtonAlgorithmTutorials" title="Permalink"></a></h5><p>In summary, the Gauss-Newton iterative algorithm for solving AC state estimation follows these steps:</p><table><tr><th style="text-align: left">Step</th><th style="text-align: left">Description</th><th style="text-align: left">Expression</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: left">Initialize the iteration index</td><td style="text-align: left"><span>$\nu = 0$</span></td></tr><tr><td style="text-align: left">2.</td><td style="text-align: left">Set the initial state variable values</td><td style="text-align: left"><span>$\mathbf{x}^{(0)} = [\mathbf{V}^{(0)}, \bm{\Theta}^{(0)}]$</span></td></tr><tr><td style="text-align: left">3.</td><td style="text-align: left">Compute the measurement residuals</td><td style="text-align: left"><span>$\mathbf r (\mathbf x^{(\nu)})$</span></td></tr><tr><td style="text-align: left">4.</td><td style="text-align: left">Compute the gain matrix</td><td style="text-align: left"><span>$\mathbf G (\mathbf x^{(\nu)})$</span></td></tr><tr><td style="text-align: left">5.</td><td style="text-align: left">Compute the state variable increments</td><td style="text-align: left"><span>$\mathbf \Delta \mathbf x^{(\nu)}$</span></td></tr><tr><td style="text-align: left">6.</td><td style="text-align: left">Check for convergence</td><td style="text-align: left"><span>$\Delta x_{\max} &lt; \epsilon$</span></td></tr><tr><td style="text-align: left">7.</td><td style="text-align: left">If the convergence criterion is met, stop the process</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">8.</td><td style="text-align: left">Update the state variable values</td><td style="text-align: left"><span>$\mathbf{x}^{(\nu + 1)} = \mathbf{x}^{(\nu)} + \mathbf \Delta \mathbf{x}^{(\nu)}$</span></td></tr><tr><td style="text-align: left">9.</td><td style="text-align: left">Increase the iteration index</td><td style="text-align: left"><span>$\nu := \nu + 1$</span></td></tr><tr><td style="text-align: left">10</td><td style="text-align: left">Repeat from step 3.</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><p>The main computational effort is in step 5, which involves factorizing the gain matrix and performing forward and backward substitutions to obtain the vector of increments.</p><hr/><h5 id="ACAlternativeFormulationTutorials"><a class="docs-heading-anchor" href="#ACAlternativeFormulationTutorials">Alternative Formulation</a><a id="ACAlternativeFormulationTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACAlternativeFormulationTutorials" title="Permalink"></a></h5><p>The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from converging to a satisfactory solution. In such cases, users may opt for an alternative formulation of the WLS state estimation, namely, employing an approach called orthogonal method [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 3.2].</p><p>This approach is suitable when measurement errors are uncorrelated, and the precision matrix remains diagonal. Therefore, as a preliminary step, we need to eliminate the correlation, as we did previously:</p><pre><code class="language-julia hljs">updatePmu!(monitoring; label = &quot;PMU 2&quot;, correlated = false)</code></pre><p>To address ill-conditioned situations arising from significant differences in measurement variances, users can now employ the orthogonal factorization approach:</p><pre><code class="language-julia hljs">analysis = gaussNewton(monitoring, Orthogonal)

for iteration = 0:20
    stopping = increment!(analysis)
    if stopping &lt; 1e-8
        break
    end
    solve!(analysis)
end</code></pre><p>To explain the method, we begin with the WLS equation:</p><p class="math-container">\[	  \Big[\mathbf J (\mathbf x^{(\nu)})^T \mathbf W \mathbf J (\mathbf x^{(\nu)})\Big] \mathbf \Delta \mathbf x^{(\nu)} =
		\mathbf J (\mathbf x^{(\nu)})^T \mathbf W \mathbf r (\mathbf x^{(\nu)})\]</p><p>where <span>$\mathbf W = \bm \Sigma^{-1}$</span>. Subsequently, we can write:</p><p class="math-container">\[  \left[{\mathbf W^{1/2}} \mathbf J (\mathbf x^{(\nu)})\right]^T  {\mathbf W^{1/2}} \mathbf J (\mathbf x^{(\nu)})  \Delta \mathbf x^{(\nu)} =
  \left[{\mathbf W^{1/2}} \mathbf J (\mathbf x^{(\nu)})\right]^T {\mathbf W^{1/2}} \mathbf r (\mathbf x^{(\nu)}).\]</p><p>Consequently, we have:</p><p class="math-container">\[  \bar{\mathbf J} (\mathbf x^{(\nu)})^T  \bar{\mathbf J}(\mathbf x^{(\nu)}) \Delta \mathbf x^{(\nu)} = \bar{\mathbf J}(\mathbf x^{(\nu)})^{T}  \bar{\mathbf r} (\mathbf x^{(\nu)}),\]</p><p>where:</p><p class="math-container">\[  \bar{\mathbf J}(\mathbf x^{(\nu)}) = {\mathbf W^{1/2}} \mathbf J (\mathbf x^{(\nu)}), \;\;\;
  \bar{\mathbf r} (\mathbf x^{(\nu)}) = {\mathbf W^{1/2}} \mathbf r (\mathbf x^{(\nu)}).\]</p><p>Therefore, within each iteration of the Gauss-Newton method, JuliaGrid conducts QR factorization on the rectangular matrix:</p><p class="math-container">\[  \bar{\mathbf J}(\mathbf x^{(\nu)}) = {\mathbf W^{1/2}} \mathbf J (\mathbf x^{(\nu)}) = \mathbf Q \mathbf R.\]</p><p>Access to the factorized matrix is possible through:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐 = analysis.method.factorization.Q</code><code class="nohighlight hljs ansi" style="display:block;">8×8 SparseArrays.SPQR.QRSparseQ{Float64, Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐑 = analysis.method.factorization.R</code><code class="nohighlight hljs ansi" style="display:block;">6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 15 stored entries:
 -9920.64    381.086     1.99825        0.169277     0.309314   ⋅
      ⋅    10073.8       0.115791       0.616705    -2.33458    ⋅
      ⋅         ⋅     -190.584         24.9998      -4.38277    ⋅
      ⋅         ⋅         ⋅        -10001.8          3.74677    ⋅
      ⋅         ⋅         ⋅              ⋅        -239.402      ⋅
      ⋅         ⋅         ⋅              ⋅            ⋅         ⋅</code></pre><p>To obtain the solution, JuliaGrid avoids explicitly forming the orthogonal matrix <span>$\mathbf Q$</span>. Once the algorithm converges, estimates of bus voltage magnitudes <span>$\hat{\mathbf V} = [\hat{V}_i]$</span> and angles <span>$\hat{\bm \Theta} = [\hat{\theta}_i]$</span>, where <span>$i \in \mathcal N$</span>  can be accessed using variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0000006954572576
 0.8751163041335766
 0.8999992301628121</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.13396608444681726
 -0.19999982303390634</code></pre><hr/><h2 id="ACLAVTutorials"><a class="docs-heading-anchor" href="#ACLAVTutorials">Least Absolute Value Estimation</a><a id="ACLAVTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACLAVTutorials" title="Permalink"></a></h2><p>The least absolute value (LAV) method provides an alternative estimation approach that is considered more robust in comparison to the WLS method. The WLS state estimation problem relies on specific assumptions about measurement errors, whereas robust estimators aim to remain unbiased even in the presence of various types of measurement errors and outliers. This characteristic eliminates the need for bad data analysis, as discussed in [<a href="../../background/bibliography/#aburbook">5</a>, Ch. 6]. It is important to note that robustness often comes at the cost of increased computational complexity.</p><p>This section outlines the method as described in [<a href="../../background/bibliography/#aburbook">5</a>, Sec. 6.5]. Hence, we consider the system of nonlinear equations:</p><p class="math-container">\[  \mathbf{z}=\mathbf{h}(\mathbf x)+\mathbf{u}.\]</p><p>The LAV state estimator is then formulated as the solution to the following optimization problem:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \sum_{i \in \mathcal M} |r_i|\\
    \text{subject\;to}&amp; \;\;\; z_i - h_i(\mathbf x) =  r_i, \;\;\; \forall i \in \mathcal M,
  \end{aligned}\]</p><p>where <span>$r_i$</span> denotes the residual of the <span>$i$</span>-th measurement.</p><p>To explicitly handle absolute values, we introduce two nonnegative variables <span>$u_i \ge 0$</span> and <span>$v_i \ge 0$</span>, referred to as positive and negative deviations. This allows the optimization problem to be rewritten as:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \sum_{i \in \mathcal M} (u_i + v_i) \\
    \text{subject\;to}  &amp; \;\;\; z_i - h_i(\mathbf x) = u_i - v_i, \;\;\; \forall i \in \mathcal M \\
                        &amp; \;\;\; u_i \geq  0, \; v_i \geq  0, \;\;\; \forall i \in \mathcal M.
  \end{aligned}\]</p><p>To form the above optimization problem, the user can call the following function:</p><pre><code class="language-julia hljs">using Ipopt

analysis = acLavStateEstimation(monitoring, Ipopt.Optimizer)</code></pre><p>Then the user can solve the optimization problem by:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>Users can retrieve the estimated bus voltage magnitudes <span>$\hat{\mathbf V} = [\hat{V}_i]$</span> and angles <span>$\hat{\bm \Theta} = [\hat{\theta}_i]$</span>, <span>$i \in \mathcal N$</span>, using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0000000176702628
 0.8716991474121621
 0.8915403079331962</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -0.13300637720863076
 -0.19921332666147923</code></pre><hr/><h2 id="ACPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#ACPowerAnalysisTutorials">Power Analysis</a><a id="ACPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerAnalysisTutorials" title="Permalink"></a></h2><p>Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function, which enables the calculation of powers associated with buses and branches. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><p>The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses and branches:</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Power</th><th style="text-align: left">Active</th><th style="text-align: left">Reactive</th></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf P = [P_i]$</span></td><td style="text-align: left"><span>$\mathbf Q = [Q_i]$</span></td></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="#ACGeneratorPowerInjectionsManual">Generator injections</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{p} = [P_{\mathrm{p}i}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{p} = [Q_{\mathrm{p}i}]$</span></td></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusShuntElementTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{sh} = [{P}_{\mathrm{sh}i}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{sh} = [{Q}_{\mathrm{sh}i}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{i} = [P_{ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{i} = [Q_{ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{j} = [P_{ji}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{j} = [Q_{ji}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchShuntElementsTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{s} = [P_{\mathrm{s}ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{s} = [Q_{\mathrm{s}ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{l} = [P_{\mathrm{l}ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{l} = [Q_{\mathrm{l}ij}]$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusInjectionsTutorials">Active and reactive power injections</a> are stored as the vectors <span>$\mathbf{P} = [P_i]$</span> and <span>$\mathbf{Q} = [Q_i]$</span>, respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏 = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.4569858265479875
  0.04858081164531904
 -0.5000000006686484</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐 = analysis.power.injection.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.3527891017279598
 -0.3000000014551565
 -0.01600197609249117</code></pre><hr/><h5 id="ACGeneratorPowerInjectionsManual"><a class="docs-heading-anchor" href="#ACGeneratorPowerInjectionsManual">Generator Power Injections</a><a id="ACGeneratorPowerInjectionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACGeneratorPowerInjectionsManual" title="Permalink"></a></h5><p>We can calculate the active and reactive power injections supplied by generators at each bus <span>$i \in \mathcal N$</span> by summing the active and reactive power injections and the active and reactive power demanded by consumers at each bus:</p><p class="math-container">\[  \begin{aligned}
    P_{\mathrm{p}i} &amp;= P_i + P_{\mathrm{d}i}\\
    Q_{\mathrm{p}i} &amp;= Q_i + Q_{\mathrm{d}i}.
  \end{aligned}\]</p><p>The active and reactive power injections from the generators at each bus are stored as vectors, denoted by <span>$\mathbf{P}_\mathrm{p} = [P_{\mathrm{p}i}]$</span> and <span>$\mathbf{Q}_\mathrm{p} = [Q_{\mathrm{p}i}]$</span>, which can be obtained using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₚ = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.9569858265479875
  0.04858081164531904
 -6.686483589035674e-10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₚ = analysis.power.supply.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.3527891017279598
 -1.4551564953002583e-9
 -0.01600197609249117</code></pre><hr/><h5 id="Power-at-Bus-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Bus-Shunt-Elements">Power at Bus Shunt Elements</a><a id="Power-at-Bus-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Bus-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusShuntElementTutorials">Active and reactive powers</a> associated with the shunt elements at each bus are represented by the vectors <span>$\mathbf{P}_\mathrm{sh} = [{P}_{\mathrm{sh}i}]$</span> and <span>$\mathbf{Q}_\mathrm{sh} = [{Q}_{\mathrm{sh}i}]$</span>. To retrieve these powers in JuliaGrid, use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛₕ = analysis.power.shunt.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₛₕ = analysis.power.shunt.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.0
 -0.0
 -0.0</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at each from-bus end are stored as the vectors <span>$\mathbf{P}_\mathrm{i} = [P_{ij}]$</span> and <span>$\mathbf{Q}_\mathrm{i} = [Q_{ij}],$</span> respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ᵢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.20000000325143732
 0.2569858232965501
 0.24681281500966376</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ᵢ = analysis.power.from.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.1999999906071776
  0.15278911112078197
 -0.11784281868196349</code></pre><p>The vectors of <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at the to-bus end are stored as <span>$\mathbf{P}_\mathrm{j} = [P_{ji}]$</span> and <span>$\mathbf{Q}_\mathrm{j} = [Q_{ji}]$</span>, respectively, and can be retrieved using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ⱼ = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.19823200336434477
 -0.2550678675535002
 -0.2449321331151481</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ⱼ = analysis.power.to.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.18215718277319337
 -0.12155754323423786
  0.10555556714174669</code></pre><hr/><h5 id="Power-at-Branch-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Shunt-Elements">Power at Branch Shunt Elements</a><a id="Power-at-Branch-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchShuntElementsTutorials">Active and reactive powers</a> associated with the branch shunt elements at each branch are represented by the vectors <span>$\mathbf{P}_\mathrm{s} = [P_{\mathrm{s}ij}]$</span> and <span>$\mathbf{Q}_\mathrm{s} = [Q_{\mathrm{s}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛ = analysis.power.charging.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₛ = analysis.power.charging.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.03519718877879233
 -0.03589688312020289
 -0.031094070485374176</code></pre><hr/><h5 id="Power-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Series-Elements">Power at Branch Series Elements</a><a id="Power-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Series-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchSeriesElementTutorials">Active and reactive powers</a> associated with the branch series element at each branch are represented by the vectors <span>$\mathbf{P}_\mathrm{l} = [P_{\mathrm{l}ij}]$</span> and <span>$\mathbf{Q}_\mathrm{l} = [Q_{\mathrm{l}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₗ = analysis.power.series.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.0017679998870925515
 0.0019179557430499157
 0.0018806818945156993</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₗ = analysis.power.series.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.053039996612776516
 0.067128451006747
 0.018806818945157004</code></pre><hr/><h2 id="PMUCurrentAnalysisTutorials"><a class="docs-heading-anchor" href="#PMUCurrentAnalysisTutorials">Current Analysis</a><a id="PMUCurrentAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#PMUCurrentAnalysisTutorials" title="Permalink"></a></h2><p>JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.current!-Tuple{AC}"><code>current!</code></a> function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">current!(analysis)</code></pre><p>The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Current</th><th style="text-align: left">Magnitude</th><th style="text-align: left">Angle</th></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf I = [I_i]$</span></td><td style="text-align: left"><span>$\bm \psi = [\psi_i]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{i} = [I_{ij}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{i} = [\psi_{ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{j} = [I_{ji}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{j} = [\psi_{ji}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{l} = [I_{\mathrm{l}ij}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{l} = [\psi_{\mathrm{l}ij}]$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Current-Injections"><a class="docs-heading-anchor" href="#Current-Injections">Current Injections</a><a id="Current-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injections" title="Permalink"></a></h5><p>In JuliaGrid, <a href="../powerSystemModel/#BusInjectionsTutorials">complex current injections</a> are stored in the vector of magnitudes denoted as <span>$\mathbf I = [I_i]$</span> and the vector of angles represented as <span>$\bm \psi = [\psi_i]$</span>. You can retrieve them using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈 = analysis.current.injection.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.5773180961869337
 0.3486386786583738
 0.5611142804435388</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙 = analysis.current.injection.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.6574276516379866
  1.277247547031396
  2.9103862947901677</code></pre><hr/><h5 id="Current-Flows"><a class="docs-heading-anchor" href="#Current-Flows">Current Flows</a><a id="Current-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flows" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_\mathrm{i} = [I_{ij}]$</span> and angles <span>$\bm{\psi}_\mathrm{i} = [\psi_{ij}]$</span> for the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a>, you can use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ᵢ = analysis.current.from.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.2828427031340992
 0.2989752877639358
 0.31375765123997196</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ᵢ = analysis.current.from.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.7853981317867985
 -0.5363973062981806
  0.31244577188517764</code></pre><p>Similarly, we can obtain the vectors of magnitudes <span>$\mathbf{I}_mathrm{j} = [I_{ji}]$</span> and angles <span>$\bm{\psi}_\mathrm{j} = [\psi_{ji}]$</span> of the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a> using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ⱼ = analysis.current.to.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.30884031133275913
 0.3169260974321891
 0.29915536831527423</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ⱼ = analysis.current.to.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  2.26542186342336
  2.4976512716044503
 -2.9338993347861493</code></pre><hr/><h5 id="Current-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Current-at-Branch-Series-Elements">Current at Branch Series Elements</a><a id="Current-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Current-at-Branch-Series-Elements" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_\mathrm{l} = [I_{\mathrm{l}ij}]$</span> and angles <span>$\bm{\psi}_\mathrm{l} = [\psi_{\mathrm{l}ij}]$</span> of the resulting <a href="../powerSystemModel/#BranchSeriesElementTutorials">complex current flows</a>, one can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ₗ = analysis.current.series.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.29732136545264876
 0.3096736784947919
 0.3066497916610821</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ₗ = analysis.current.series.angle</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -0.8329812389310085
 -0.5919394827762806
  0.2611181181949628</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../observabilityAnalysis/">« Observability Analysis</a><a class="docs-footer-nextpage" href="../pmuStateEstimation/">PMU State Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 29 April 2025 12:05">Tuesday 29 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
