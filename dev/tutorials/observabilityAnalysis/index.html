<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Observability Analysis · JuliaGrid</title><meta name="title" content="Observability Analysis · JuliaGrid"/><meta property="og:title" content="Observability Analysis · JuliaGrid"/><meta property="twitter:title" content="Observability Analysis · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../manual/badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li class="is-active"><a class="tocitem" href>Observability Analysis</a><ul class="internal"><li><a class="tocitem" href="#Identification-of-Observable-Islands"><span>Identification of Observable Islands</span></a></li><li><a class="tocitem" href="#Observability-Restoration"><span>Observability Restoration</span></a></li><li><a class="tocitem" href="#optimalpmu"><span>Optimal PMU Placement</span></a></li></ul></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Observability Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Observability Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/observabilityAnalysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACObservabilityAnalysisTutorials"><a class="docs-heading-anchor" href="#ACObservabilityAnalysisTutorials">Observability Analysis</a><a id="ACObservabilityAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACObservabilityAnalysisTutorials" title="Permalink"></a></h1><p>The state estimation algorithm aims to estimate the values of the state variables based on the measurement model described as a system of equations. Prior to applying the state estimation algorithm, the observability analysis determines the existence and uniqueness of the solution for the underlying system of equations.</p><p>Typical observability analysis, in cases where a unique solution is not guaranteed, identifies observable islands and prescribes an additional set of equations (pseudo-measurements) to ensure a unique solution [<a href="../../background/bibliography/#cosovic2021observability">16</a>]. In addition, optimal PMU placement can also be considered from an observability perspective, determining the placement of PMUs to achieve system observability using only phasor measurements.</p><p>To initiate the process, let us construct the <code>PowerSystem</code> type:</p><pre><code class="language-julia hljs">@config(label = Integer)

system = powerSystem()

addBus!(system; label = 1, type = 3)
addBus!(system; label = 2)
addBus!(system; label = 3)
addBus!(system; label = 4)
addBus!(system; label = 5)

addBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05)
addBranch!(system; label = 2, from = 2, to = 3, reactance = 0.01)
addBranch!(system; label = 3, from = 2, to = 4, reactance = 0.02)
addBranch!(system; label = 4, from = 3, to = 4, reactance = 0.03)
addBranch!(system; label = 5, from = 4, to = 5, reactance = 0.05)</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal G = (\mathcal N, \mathcal E)$</span>, where we have the set of buses <span>$\mathcal N = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal E \subseteq \mathcal N \times \mathcal N$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒩 = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
 1
 2
 3
 4
 5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℰ = hcat([𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]])</code><code class="nohighlight hljs ansi" style="display:block;">5×2 Matrix{Int64}:
 1  2
 2  3
 2  4
 3  4
 4  5</code></pre><hr/><h2 id="Identification-of-Observable-Islands"><a class="docs-heading-anchor" href="#Identification-of-Observable-Islands">Identification of Observable Islands</a><a id="Identification-of-Observable-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Identification-of-Observable-Islands" title="Permalink"></a></h2><p>JuliaGrid employs standard observability analysis performed on the linear decoupled measurement model [<a href="../../background/bibliography/#monticellibook">13</a>, Ch. 7]. Active power measurements from wattmeters are utilized to estimate bus voltage angles, while reactive power measurements from varmeters are used to estimate bus voltage magnitudes. This necessitates that measurements of active and reactive power come in pairs.</p><p>Let us illustrate this concept with the following example, where measurements form an unobservable system:</p><pre><code class="language-julia hljs">monitoring = measurement(system)

addWattmeter!(monitoring; label = 1, from = 1, active = 0.93)
addVarmeter!(monitoring; label = 1, from = 1, reactive = -0.41)

addWattmeter!(monitoring; label = 2, bus = 2, active = -0.1)
addVarmeter!(monitoring; label = 2, bus = 2, reactive = -0.01)

addWattmeter!(monitoring; label = 3, bus = 3, active = -0.30)
addVarmeter!(monitoring; label = 3, bus = 3, reactive = 0.52)</code></pre><p>If the system lacks observability, the observability analysis needs to identify all potential observable islands that can be independently solved. An observable island is defined as follows: It is a segment of the power system where the flows across all branches within that island can be calculated solely from the available measurements. This independence holds regardless of the values chosen for the bus voltage angle at the slack bus [<a href="../../background/bibliography/#monticellibook">13</a>, Sec. 7.1.1]. Within this context, two types of observable islands are evident:</p><ul><li>flow-observale islands,</li><li>maximal-observable islands.</li></ul><p>The selection between them relies on the power system&#39;s structure and the available measurements. Opting for detecting only flow observable islands simplifies the island detection function&#39;s complexity but increases the complexity in the restoration function compared to identifying maximal-observable islands.</p><hr/><h5 id="Flow-Observale-Islands"><a class="docs-heading-anchor" href="#Flow-Observale-Islands">Flow-Observale Islands</a><a id="Flow-Observale-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Flow-Observale-Islands" title="Permalink"></a></h5><p>To identify flow-observable islands, JuliaGrid employs a topological method outlined in [<a href="../../background/bibliography/#horisberger1985observability">17</a>]. The process begins with the examination of all active power flow measurements from wattmeters, aiming to determine the largest sets of connected buses within the network linked by branches with active power flow measurements. Subsequently, the analysis considers individual boundary or tie active power injection measurements, involving two islands that may potentially be merged into a single observable island. The user can initiate this process by calling the function:</p><pre><code class="language-julia hljs">islands = islandTopologicalFlow(monitoring)</code></pre><p>As a result, four flow-observable islands are identified. The first island includes buses <code>1</code> and <code>2</code>, while the second, third, and fourth islands consist of buses <code>3</code>, <code>4</code>, and <code>5</code>, respectively:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Vector{Int64}}:
 [1, 2]
 [3]
 [4]
 [5]</code></pre><p>Additionally, users can inspect the tie buses and branches resulting from the observability analysis we conducted:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.bus</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 4 elements:
  5
  4
  2
  3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.branch</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 4 elements:
  5
  4
  2
  3</code></pre><p>This tie data will be utilized throughout the restoration step, where we introduce pseudo-measurements to merge the observable flow islands obtained.</p><hr/><h5 id="Maximal-Observale-Islands"><a class="docs-heading-anchor" href="#Maximal-Observale-Islands">Maximal-Observale Islands</a><a id="Maximal-Observale-Islands-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-Observale-Islands" title="Permalink"></a></h5><p>To identify maximal-observable islands, we extend the analysis with an additional processing step. After processing individual injection tie measurements, we are left with a series of injection measurements that are not entirely contained within any observable zone. In this set of remaining tie injections, we now examine pairs involving three and only three previously determined observable zones (including individual buses). If we find such a pair, the three islands will be merged, and all injection measurements related exclusively to these three islands are no longer considered. The procedure then restarts at the stage where we process tie active power injection measurements involving two and only two islands. If no mergers are possible with pairs, we then consider sets of three injection measurements involving four islands, and so on [<a href="../../background/bibliography/#horisberger1985observability">17</a>]. The user can initiate this by calling the function:</p><pre><code class="language-julia hljs">islands = islandTopological(monitoring)</code></pre><p>The outcome reveals the identification of two maximal-observable islands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [5]</code></pre><p>Comparing this result with the flow-observable islands clearly shows that the injection measurements at buses <code>2</code> and <code>3</code> merge the first, second, and third flow-observable islands into a single island.</p><p>Here we can observe tie data:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.bus</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 2 elements:
  5
  4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.tie.branch</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 1 element:
  5</code></pre><p>Compared to the tie data obtained after detecting flow-observable islands, we now have a smaller set, indicating that the restoration step will be more computationally efficient.</p><hr/><h2 id="Observability-Restoration"><a class="docs-heading-anchor" href="#Observability-Restoration">Observability Restoration</a><a id="Observability-Restoration-1"></a><a class="docs-heading-anchor-permalink" href="#Observability-Restoration" title="Permalink"></a></h2><p>Before commencing the restoration of observability in the context of the linear decoupled measurement model and observability analysis, it is imperative to ensure that the system possesses one bus voltage magnitude measurement. This necessity arises from the fact that observable islands are identified based on wattmeters, where wattmeters are tasked with estimating voltage angles. Since one voltage angle is already known from the slack bus, the same principle should be applied to bus voltage magnitudes. Therefore, to address this requirement, we add:</p><pre><code class="language-julia hljs">addVoltmeter!(monitoring; bus = 1, magnitude = 1.0)</code></pre><p>After determining the islands, the observability analysis merges these islands in a manner that protect previously determined observable states from being altered by the new set of equations defined by the additional measurements, called pseudo-measurements. In general, this can be achieved by ensuring that the set of new measurements forms a non-redundant set [<a href="../../background/bibliography/#monticellibook">13</a>, Sec. 7.3.2], i.e., the set of equations must be linearly independent with respect to the global system. The goal of observability restoration is to find this non-redundant set.</p><p>The outcome of the island detection step results in the power system being divided into <span>$m$</span> islands. Subsequently, we focus on the set of measurements <span>$\mathcal M_\mathrm{r} \subset \mathcal M$</span>, which exclusively consists of:</p><ul><li>active power injection measurements at tie buses,</li><li>bus voltage phasor measurements.</li></ul><p>These measurements are retained from the phase where we identify observable islands, and are crucial in determining whether we need additional pseudo-measurements to be included in the measurement set <span>$\mathcal M$</span>. In this specific example, we do not have active power injection measurements at tie buses remaining after the identification of maximal-observable islands. However, if we proceed with flow-observable islands to the restoration step, we will have two injection measurements at buses <code>2</code> and <code>3</code>.</p><p>However, let us introduce the matrix <span>$\mathbf M_\mathrm{r} \in \mathbb{R}^{r \times m}$</span>, where <span>$r = |\mathcal M_\mathrm{r}|$</span>. This matrix can be conceptualized as the coefficient matrix of a reduced network, with <span>$m$</span> columns corresponding to islands and <span>$r$</span> rows associated with the set <span>$\mathcal M_\mathrm{r}$</span>. More precisely, if we construct the coefficient matrix <span>$\mathbf H_\mathrm{r}$</span> linked to the set <span>$\mathcal M_\mathrm{r}$</span> in the DC framework, the matrix <span>$\mathbf M_\mathrm{r}$</span> can be constructed by summing the columns of <span>$\mathbf H_\mathrm{r}$</span> that belong to a specific island [<a href="../../background/bibliography/#manousakis2010observability">18</a>].</p><p>Subsequently, the user needs to establish a set of pseudo-measurements, where measurements must come in pairs as well. Let us create that set:</p><pre><code class="language-julia hljs">pseudo = measurement(system)

addWattmeter!(pseudo; label = 4, bus = 1, active = 0.93)
addVarmeter!(pseudo; label = 4, bus = 1, reactive = -0.41)

addWattmeter!(pseudo; label = 5, from = 5, active = 0.30)
addVarmeter!(pseudo; label = 5, from = 5, reactive = 0.03)</code></pre><p>From this set, the restoration step will only utilize the following:</p><ul><li>active power flow measurements between tie buses,</li><li>active power injection measurements at tie buses,</li><li>bus voltage phasor measurements.</li></ul><p>These pseudo-measurements <span>$\mathcal M_\mathrm{p}$</span> will define the reduced coefficient matrix <span>$\mathbf M_\mathrm{p} \in \mathbb{R}^{p \times m}$</span>, where <span>$p = |\mathcal M_\mathrm{p}|$</span>. In this example, only the fifth wattmeter will contribute to the construction of the matrix <span>$\mathbf M_\mathrm{p}$</span>. Similar to the previous case, measurement functions linked to the set <span>$\mathcal M_\mathrm{p}$</span> define the coefficient matrix <span>$\mathbf H_\mathrm{p}$</span>, and the matrix <span>$\mathbf M_\mathrm{p}$</span> can be viewed as the sum of the columns of <span>$\mathbf H_\mathrm{p}$</span> belonging to a specific observable island.</p><p>Additionally, users have the option to include bus voltage angle measurements from PMUs. In this scenario, restoration can be conducted without merging observable islands into one island, as each island becomes globally observable when one angle is known. It is important to note that during the restoration step, JuliaGrid initially processes active power measurements and subsequently handles bus voltage angle measurements if they are present in the set of pseudo-measurements.</p><p>Users can execute the observability restoration procedure with the following:</p><pre><code class="language-julia hljs">restorationGram!(monitoring, pseudo, islands; threshold = 1e-6)</code></pre><p>The function constructs the reduced coefficient matrix as follows:</p><p class="math-container">\[  \mathbf M = \begin{bmatrix} \mathbf M_{\text{r}} \\ \mathbf M_{\text{p}} \end{bmatrix},\]</p><p>and forms the corresponding Gram matrix:</p><p class="math-container">\[  \mathbf D = \mathbf M \mathbf M^T.\]</p><p>The decomposition of <span>$\mathbf D$</span> into its <span>$\mathbf Q$</span> and <span>$\mathbf R$</span> factors is achieved through QR factorization. Non-redundant measurements are identified by non-zero diagonal elements in <span>$\mathbf R$</span>. Specifically, if the diagonal element satisfies:</p><p class="math-container">\[    |R_{ii}| &lt; \epsilon,\]</p><p>JuliaGrid designates the corresponding measurement as redundant, where <span>$\epsilon$</span> represents a pre-determined zero pivot <code>threshold</code>, set to <code>1e-6</code> in this example. The minimal set of pseudo-measurements for observability restoration corresponds to the non-zero diagonal elements at positions associated with the candidate pseudo-measurements. It is essential to note that an inappropriate choice of the zero pivot threshold may adversely affect observability restoration. Additionally, there is a possibility that the set of pseudo-measurements <span>$\mathcal{M}_\text{p}$</span> may not be sufficient for achieving observability restoration.</p><p>Finally, the fifth wattmeter, and consequently the fifth varmeter successfully restore observability, and these measurements are added to the <code>monitoring</code> variable, which stores actual measurements:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.wattmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{Int64, Int64} with 4 entries:
  1 =&gt; 1
  2 =&gt; 2
  3 =&gt; 3
  5 =&gt; 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; monitoring.varmeter.label</code><code class="nohighlight hljs ansi" style="display:block;">OrderedCollections.OrderedDict{Int64, Int64} with 4 entries:
  1 =&gt; 1
  2 =&gt; 2
  3 =&gt; 3
  5 =&gt; 4</code></pre><p>Here, we can confirm that the new measurement set establishes the observable system formed by a single island:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands = islandTopological(monitoring);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; islands.island</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Vector{Int64}}:
 [1, 2, 3, 4, 5]</code></pre><hr/><h2 id="optimalpmu"><a class="docs-heading-anchor" href="#optimalpmu">Optimal PMU Placement</a><a id="optimalpmu-1"></a><a class="docs-heading-anchor-permalink" href="#optimalpmu" title="Permalink"></a></h2><p>JuliaGrid utilizes the optimal PMU placement algorithm proposed in [<a href="../../background/bibliography/#gou2008optimal">19</a>]. The optimal positioning of PMUs is framed as an integer linear programming problem, expressed as:</p><p class="math-container">\[  \begin{aligned}
    \text{minimize}&amp; \;\;\; \sum_{i=1}^n d_i\\
    \text{subject\;to}&amp; \;\;\; \sum_{j=1}^n a_{ij}d_j, \;\; i = 1, \dots, n,
  \end{aligned}\]</p><p>where <span>$d_i \in \mathbb{F} = \{0,1\}$</span> is the PMU placement decision variable associated with bus <span>$i \in \mathcal{N}$</span>. The binary parameter <span>$a_{ij} \in \mathbb{F}$</span> indicates the connectivity of the power system network, where <span>$a_{ij}$</span> can be directly derived from the nodal admittance matrix by converting its entries into binary form [<a href="../../background/bibliography/#xu2004observability">20</a>]. This linear programming problem is implemented using JuMP package allowing compatibility with different type of optimization solvers.</p><p>Consequently, we obtain the binary vector <span>$\mathbf d = [d_1,\dots,d_n]^T$</span>, where <span>$d_i = 1$</span>, <span>$i \in \mathcal{N}$</span>, suggests that a PMU should be placed at bus <span>$i$</span>. The primary aim of PMU placement in the power system is to determine a minimal set of PMUs such that the entire system is observable without relying on legacy measurements [<a href="../../background/bibliography/#gou2008optimal">19</a>]. Specifically, when we observe <span>$d_i = 1$</span>, it indicates that the PMU is installed at bus <span>$i \in \mathcal{N}$</span> to measure bus voltage phasor as well as all current phasors across branches incident to bus <span>$i$</span>.</p><p>Now, we will determine the optimal PMU placement for our power system:</p><pre><code class="language-julia hljs">using HiGHS

placement = pmuPlacement(system, HiGHS.Optimizer)</code></pre><p>The <code>placement</code> variable contains data regarding the optimal placement of measurements. It lists all buses <span>$i \in \mathcal{N}$</span> that satisfy <span>$d_i = 1$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.bus)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{Int64, Int64} with 2 entries. Keys:
  2
  4</code></pre><p>The PMUs installed at buses <code>2</code> and <code>4</code> will measure the voltage phasors at these buses, along with all current phasors on the branches connected to them. These measurements are stored in the following variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.from)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{Int64, Int64} with 3 entries. Keys:
  2
  3
  5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(placement.to)</code><code class="nohighlight hljs ansi" style="display:block;">KeySet for a OrderedCollections.OrderedDict{Int64, Int64} with 3 entries. Keys:
  1
  3
  4</code></pre><p>Consequently, the PMUs will measure the current phasors at the from-bus ends of branches <code>2</code>, <code>3</code>, and <code>5</code>, as well as the current phasors at the to-bus ends of branches <code>1</code>, <code>3</code>, and <code>4</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../measurementModel/">« Measurement Model</a><a class="docs-footer-nextpage" href="../acStateEstimation/">AC State Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 3 June 2025 14:52">Tuesday 3 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
