<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC Power Flow · JuliaGrid</title><meta name="title" content="AC Power Flow · JuliaGrid"/><meta property="og:title" content="AC Power Flow · JuliaGrid"/><meta property="twitter:title" content="AC Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../manual/badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li class="is-active"><a class="tocitem" href>AC Power Flow</a><ul class="internal"><li><a class="tocitem" href="#FlowNodalNetworkEquationsTutorials"><span>Nodal Network Equations</span></a></li><li><a class="tocitem" href="#NewtonRaphsonMethodTutorials"><span>Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#FastNewtonRaphsonMethodTutorials"><span>Fast Newton-Raphson Method</span></a></li><li><a class="tocitem" href="#GaussSeidelMethodTutorials"><span>Gauss-Seidel Method</span></a></li><li><a class="tocitem" href="#ACPowerAnalysisTutorials"><span>Power Analysis</span></a></li><li><a class="tocitem" href="#ACCurrentAnalysisTutorials"><span>Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>AC Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/tutorials/acPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACPowerFlowTutorials"><a class="docs-heading-anchor" href="#ACPowerFlowTutorials">AC Power Flow</a><a id="ACPowerFlowTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerFlowTutorials" title="Permalink"></a></h1><p>JuliaGrid uses standard network components and the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a> for power flow analysis, allowing load profiles, generator capacities, voltage specifications, contingency analysis, and planning to be defined efficiently.</p><p>To begin, let us generate the <code>PowerSystem</code> type, as illustrated by the following example:</p><pre><code class="language-julia hljs">@config(label = Integer)
@power(MW, MVAr)
@voltage(pu, deg)

system = powerSystem()

addBus!(system; label = 1, type = 3)
addBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)
addBus!(system; label = 3, type = 1, active = 11.2, reactive = -3.0)
addBus!(system; label = 4, type = 2, conductance = 2.1, susceptance = 1.2)

addBranch!(system; from = 1, to = 2, resistance = 0.02, reactance = 0.06)
addBranch!(system; from = 1, to = 3, resistance = 0.05, reactance = 0.21)
addBranch!(system; from = 2, to = 3, resistance = 0.13, reactance = 0.26)
addBranch!(system; from = 3, to = 4, reactance = 0.17, susceptance = 0.2, conductance = 1e-4)

addGenerator!(system; bus = 1)
addGenerator!(system; bus = 3, active = 40.0, reactive = 42.4)</code></pre><p>To review, we can conceptualize the bus/branch model as the graph denoted by <span>$\mathcal G = (\mathcal N, \mathcal E)$</span>, where we have the set of buses <span>$\mathcal N = \{1, \dots, n\}$</span>, and the set of branches <span>$\mathcal E \subseteq \mathcal N \times \mathcal N$</span> within the power system:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒩 = collect(keys(system.bus.label))</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
 1
 2
 3
 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℰ = hcat([𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]])</code><code class="nohighlight hljs ansi" style="display:block;">4×2 Matrix{Int64}:
 1  2
 1  3
 2  3
 3  4</code></pre><hr/><div class="admonition is-category-ukw"><header class="admonition-header">Notation</header><div class="admonition-body"><p>In this section, when referring to a vector <span>$\mathbf a$</span>, we use the notation <span>$\mathbf a = [a_i]$</span> or <span>$\mathbf a = [a_{ij}]$</span>, where <span>$a_i$</span> represents the element associated with bus <span>$i \in \mathcal N$</span>, and <span>$a_{ij}$</span> represents the element associated with branch <span>$(i,j) \in \mathcal E$</span>.</p></div></div><hr/><h2 id="FlowNodalNetworkEquationsTutorials"><a class="docs-heading-anchor" href="#FlowNodalNetworkEquationsTutorials">Nodal Network Equations</a><a id="FlowNodalNetworkEquationsTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#FlowNodalNetworkEquationsTutorials" title="Permalink"></a></h2><p>As previously demonstrated in the section on the <a href="../powerSystemModel/#NodalNetworkEquationsTutorials">Nodal Network Equations</a>, we observe the system of equations:</p><p class="math-container">\[  \mathbf{\bar{I}} = \mathbf Y \mathbf{\bar{V}}.\]</p><p>The complex current injection at the bus <span>$i \in \mathcal N$</span> is defined as:</p><p class="math-container">\[  \bar{I}_i = \cfrac{S_i^*}{\bar{V}_i^*}.\]</p><p>Thus, for any given bus <span>$i \in \mathcal N$</span>, we can express it as:</p><p class="math-container">\[  \cfrac{S_i^*}{\bar{V}_i^*} = \sum_{j = 1}^n Y_{ij} \bar{V}_j.\]</p><p>The complex power injection denoted by <span>$S_i$</span> consists of both the active power <span>$P_i$</span> and reactive power <span>$Q_i$</span>. This relationship can be represented as follows:</p><p class="math-container">\[  \cfrac{P_i - \mathrm{j} Q_i}{\bar{V}_i^*} = \sum_{j = 1}^n Y_{ij} \bar{V}_j.\]</p><p>Recognizing that <span>$Y_{ij} =  G_{ij} + \mathrm{j} B_{ij}$</span>, <span>$\bar{V}_i = V_i \mathrm{e}^{\mathrm{j}\theta_i}$</span>, <span>$\bar{V}_j = V_j \mathrm{e}^{\mathrm{j}\theta_j}$</span>, and by defining <span>$\theta_{ij} = \theta_i - \theta_j$</span>,  we can break down the above equation into its real and imaginary parts, resulting in two equations that describe bus <span>$i \in \mathcal N$</span> as follows:</p><p class="math-container">\[  \begin{aligned}
    P_i &amp;= V_i \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) V_j\\
    Q_i &amp;= V_i \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_j.
	\end{aligned}\]</p><p>As demonstrated by the above equations, the bus <span>$i \in \mathcal N$</span> contains four unknown variables: the active power injection <span>$P_i$</span>, reactive power injection <span>$Q_i$</span>, bus voltage magnitude <span>$V_i$</span>, and bus voltage angle <span>$\theta_i$</span>.</p><p>To solve these equations, it is necessary to specify two known variables. Although any two variables can be selected mathematically, the choice is determined by the devices that are connected to a particular bus. The standard options are listed in the table below, and these options are used to define the bus types [<a href="../../background/bibliography/#wood2013power">9</a>].</p><table><tr><th style="text-align: left">Bus Type</th><th style="text-align: right">Label</th><th style="text-align: right">Known</th><th style="text-align: right">Unknown</th></tr><tr><td style="text-align: left">Demand</td><td style="text-align: right">1</td><td style="text-align: right"><span>$P_i$</span>, <span>$Q_i$</span></td><td style="text-align: right"><span>$V_i$</span>, <span>$\theta_i$</span></td></tr><tr><td style="text-align: left">Generator</td><td style="text-align: right">2</td><td style="text-align: right"><span>$P_i$</span>, <span>$V_i$</span></td><td style="text-align: right"><span>$Q_i$</span>, <span>$\theta_i$</span></td></tr><tr><td style="text-align: left">Slack</td><td style="text-align: right">3</td><td style="text-align: right"><span>$V_i$</span>, <span>$\theta_i$</span></td><td style="text-align: right"><span>$P_i$</span>, <span>$Q_i$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>Consequently, JuliaGrid operates with sets <span>$\mathcal{N}_\mathrm{pq}$</span> and <span>$\mathcal{N}_\mathrm{pv}$</span> that contain demand and generator buses, respectively, and exactly one slack bus in the set <span>$\mathcal{N}_\mathrm{sb}$</span>. The bus types are stored in the variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; system.bus.layout.type</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int8}:
 3
 1
 1
 2</code></pre><p>It should be noted that JuliaGrid cannot handle systems with multiple slack buses. Additionally, when using functions such as <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a>, <a href="../../api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a>, and <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a>, the bus type can be modified as discussed in the section on <a href="../../manual/acPowerFlow/#BusTypeModificationManual">Bus Type Modification</a>.</p><p>Furthermore, active power injections <span>$P_i$</span> and reactive power injections <span>$Q_i$</span> can be expressed as:</p><p class="math-container">\[  \begin{aligned}
  	P_i &amp;= P_{\mathrm{p}i} - P_{\mathrm{d}i} \\
    Q_i &amp;= Q_{\mathrm{p}i} - Q_{\mathrm{d}i},
  \end{aligned}\]</p><p>where <span>$P_{\mathrm{d}i}$</span> and <span>$Q_{\mathrm{d}i}$</span> denote the active and reactive power demanded at the bus <span>$i \in \mathcal N$</span>, while <span>$P_{\mathrm{p}i}$</span> and <span>$Q_{\mathrm{p}i}$</span> correspond to the active and reactive power produced by the generators at the bus <span>$i \in \mathcal N$</span>.</p><p>To provide a more comprehensive understanding, it is important to note that each bus <span>$i \in \mathcal N$</span> has the capacity to host multiple generators. This scenario can be conceptualized by introducing the set <span>$\mathcal{S}_i$</span>, which encompasses all generators connected to bus <span>$i \in \mathcal N$</span>. With this perspective, we can calculate the values of <span>$P_{\mathrm{p}i}$</span> and <span>$Q_{\mathrm{p}i}$</span> as follows:</p><p class="math-container">\[  \begin{aligned}
  	P_{\mathrm{p}i} &amp;= \sum_{k \in \mathcal{S}_i} P_{\mathrm{g}k}\\
    Q_{\mathrm{p}i} &amp;= \sum_{k \in \mathcal{S}_i} Q_{\mathrm{g}k},
  \end{aligned}\]</p><p>where <span>$P_{\mathrm{g}k}$</span> and <span>$Q_{\mathrm{g}k}$</span> represent the active and reactive power outputs of the <span>$k$</span>-th generator within the set <span>$\mathcal{S}_i$</span>.</p><p>As a way to summarize, the power injection vectors, represented as <span>$\mathbf P = [P_i]$</span> and <span>$\mathbf Q = [Q_i]$</span> can be computed based on the following variables and expressions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏 = system.bus.supply.active - system.bus.demand.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.0
 -0.217
  0.28800000000000003
  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐 = system.bus.supply.reactive - system.bus.demand.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.0
 -0.127
  0.454
  0.0</code></pre><p>Positive active or reactive power values, <span>$P_i &gt; 0$</span> or <span>$Q_i &gt; 0$</span>, signify that power is being supplied into the power system from the specific bus. This indicates that the generators connected to this bus are producing more power than what the connected load is consuming. Conversely, negative values, <span>$P_i &lt; 0$</span> or <span>$Q_i &lt; 0$</span>, indicate that the bus is drawing in active or reactive power from the power system. This suggests that the load&#39;s demand is exceeding the output from the generators.</p><hr/><h2 id="NewtonRaphsonMethodTutorials"><a class="docs-heading-anchor" href="#NewtonRaphsonMethodTutorials">Newton-Raphson Method</a><a id="NewtonRaphsonMethodTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#NewtonRaphsonMethodTutorials" title="Permalink"></a></h2><p>The Newton-Raphson method is commonly used in AC power flow calculations due to its quadratic rate of convergence. It provides an accurate approximation of the roots of the system of nonlinear equations:</p><p class="math-container">\[  \mathbf f (\mathbf x) = \mathbf 0.\]</p><p>This, in turn, allows for the determination of unknown voltage magnitudes and angles of buses, represented by the state vector <span>$\mathbf x = [\mathbf x_\mathrm{a}, \mathbf x_\mathrm{m}]^T$</span>. The state vector comprises two components:</p><ul><li><span>$\mathbf x_\mathrm{a} \in \mathbb{R}^{n-1}$</span>, which holds the bus voltage angles of demand and generator buses, represented by <span>$\mathbf x_\mathrm{a} = [\theta_i]$</span>, where <span>$i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv}$</span>,</li><li><span>$\mathbf x_\mathrm{m} \in \mathbb{R}^{n_\mathrm{pq}}$</span>, which holds the bus voltage magnitudes of demand buses, represented by <span>$\mathbf x_\mathrm{m} = [V_i]$</span>, where <span>$i \in \mathcal{N}_\mathrm{pq}$</span>, and <span>$n_\mathrm{pq} = |\mathcal{N}_\mathrm{pq}|$</span>.</li></ul><p>Knowing the voltage magnitudes and angles for certain types of buses is a consequence of the structure of the state vector <span>$\mathbf x$</span>. Specifically, the voltage magnitude and angle at the slack bus are known, as well as the voltage magnitude at generator buses.</p><p>As detailed in the <a href="#FlowNodalNetworkEquationsTutorials">Nodal Network Equations</a> section of this manual, the expressions for active and reactive power injection are as follows:</p><p class="math-container">\[  \begin{aligned}
    P_i &amp;= V_i \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) V_j\\
    Q_i &amp;= V_i \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_j.
	\end{aligned}\]</p><p>Using the above equations, we can define the active power injection function for demand and generator buses:</p><p class="math-container">\[  f_{P_i}(\mathbf x) = V_i \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij}) V_j - P_i = 0,
  \;\;\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv},\]</p><p>and the reactive power injection function for demand buses:</p><p class="math-container">\[  f_{Q_i}(\mathbf x) = V_i \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_j - Q_i = 0,
  \;\;\; \forall i \in \mathcal{N}_\mathrm{pq}.\]</p><p>The active and reactive mismatches, often denoted as <span>$\Delta P_i(\mathbf x)$</span> and <span>$\Delta Q_i(\mathbf x)$</span>, respectively, are defined as the functions <span>$f_{P_i}(\mathbf x)$</span> and <span>$f_{Q_i}(\mathbf x)$</span>. The first terms on the right-hand side represent power injections at a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Therefore, the Newton-Raphson method solves the system of nonlinear equations:</p><p class="math-container">\[  \mathbf f (\mathbf x) =
  \begin{bmatrix}
    \mathbf{f}_\mathrm{P}(\mathbf x) \\ \mathbf{f}_\mathrm{Q}(\mathbf x)
  \end{bmatrix} = \mathbf 0,\]</p><p>where the first <span>$n - 1$</span> equations correspond to demand and generator buses, and the last <span>$n_\mathrm{pq}$</span> equations correspond to demand buses.</p><hr/><h5 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h5><p>To compute the voltage magnitudes and angles of buses using the Newton-Raphson method in JuliaGrid, you must first execute the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function to set up the system, followed by initializing the Newton-Raphson method using the <a href="../../api/powerFlow/#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a> function. The following code snippet demonstrates this process:</p><pre><code class="language-julia hljs">acModel!(system)
analysis = newtonRaphson(system)</code></pre><p>This results in the creation of the initial vectors of bus voltage magnitudes <span>$\mathbf{V}^{(0)}$</span> and angles <span>$\bm{\Theta}^{(0)}$</span>, as shown below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕⁽⁰⁾ = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯⁽⁰⁾ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0</code></pre><p>Here, we utilize a &quot;flat start&quot; approach in our method. It is important to keep in mind that when dealing with initial conditions in this manner, the Newton-Raphson method may encounter difficulties.</p><hr/><h5 id="Iterative-Process"><a class="docs-heading-anchor" href="#Iterative-Process">Iterative Process</a><a id="Iterative-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Process" title="Permalink"></a></h5><p>To implement the Newton-Raphson method, the iterative approach based on the Taylor series expansion, JuliaGrid provides the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> and <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>solve!</code></a> functions. These functions are utilized to carry out the Newton-Raphson method iteratively until a stopping criterion is reached, as demonstrated in the following code snippet:</p><pre><code class="language-julia hljs">for iteration = 0:20
    stopping = mismatch!(analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(analysis)
end</code></pre><p>The <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration <span>$\nu = \{0, 1, 2, \dots\}$</span>. The equations used for these computations are:</p><p class="math-container">\[  f_{P_i}(\mathbf x^{(\nu)}) = V_i^{(\nu)} \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij}^{(\nu)} + B_{ij}\sin\theta_{ij}^{(\nu)}) V_j^{(\nu)} - P_i,
  \;\;\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv},\]</p><p>as well as the reactive power injection mismatch for demand buses:</p><p class="math-container">\[  f_{Q_i}(\mathbf x^{(\nu)}) = V_i^{(\nu)} \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij}^{(\nu)} - B_{ij}\cos\theta_{ij}^{(\nu)}) V_j^{(\nu)} - Q_i,
  \;\;\; \forall i \in \mathcal{N}_\mathrm{pq}.\]</p><p>The resulting vector from these calculations is stored in the <code>mismatch</code> variable of the <code>AcPowerFlow</code> type and can be accessed through the following line of code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐟 = analysis.method.mismatch</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
  1.5543122344752192e-15
  4.579669976578771e-16
 -1.810613397539215e-16
  3.497202527569243e-15
  1.1345091532888318e-15
  0.0</code></pre><p>In addition to computing the mismatches in active and reactive power injection, the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion <span>$\epsilon$</span>:</p><p class="math-container">\[  \max \{|f_{P_i}(\mathbf x^{(\nu)})|,\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv} \} &lt; \epsilon \\
  \max \{|f_{Q_i}(\mathbf x^{(\nu)})|,\; \forall i \in \mathcal{N}_\mathrm{pq} \} &lt; \epsilon.\]</p><p>Next, the function <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>solve!</code></a> computes the increments of bus voltage angle and magnitude at each iteration using:</p><p class="math-container">\[  \mathbf \Delta \mathbf{x}^{(\nu)} = -\mathbf J (\mathbf{x}^{(\nu)})^{-1} \mathbf f (\mathbf{x}^{(\nu)}),\]</p><p>where <span>$\mathbf \Delta \mathbf x = [\mathbf \Delta \mathbf x_\mathrm{a}, \mathbf \Delta \mathbf x_\mathrm{m}]^T$</span> consists of the vector of bus voltage angle increments <span>$\mathbf \Delta \mathbf x_\mathrm{a} \in \mathbb{R}^{n-1}$</span> and bus voltage magnitude increments <span>$\mathbf \Delta \mathbf x_\mathrm{m} \in \mathbb{R}^{n_\mathrm{pq}}$</span>, and <span>$\mathbf J (\mathbf{x}) \in \mathbb{R}^{n_\mathrm{u} \times n_\mathrm{u}}$</span> is the Jacobian matrix, <span>$n_\mathrm{u} = n + n_\mathrm{pq} - 1$</span>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>By default, JuliaGrid uses LU factorization as the primary method for factorizing the Jacobian matrix <span>$\mathbf{J} = \mathbf{L}\mathbf{U}$</span>, aiming to compute the increments. Nevertheless, users have the flexibility to opt for QR factorization as an alternative method.</p></div></div><p>These values are stored in the <code>AcPowerFlow</code> type and can be accessed after each iteration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚫𝐱 = analysis.method.increment</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
  7.92699879268019e-11
 -3.5508852576600275e-10
 -2.6233074858150384e-9
  9.233062009151665e-10
  5.1042499891742e-9
  7.485907667424543e-9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐉 = analysis.method.jacobian</code><code class="nohighlight hljs ansi" style="display:block;">6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 28 stored entries:
 18.4159   -3.36093     ⋅         6.36094  -1.56596      ⋅
 -3.38112  15.4035    -7.11439   -1.65565   3.10891     0.0233733
   ⋅       -7.11439    7.11439     ⋅       -0.0238268   0.0233733
 -6.83212   1.7057      ⋅        18.0563   -3.08559      ⋅
  1.66532  -2.81034   -0.025953  -3.36147  14.9752     -6.40723
   ⋅        0.025953  -0.025953    ⋅       -6.53154     6.40723</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐋 = analysis.method.factorization.L</code><code class="nohighlight hljs ansi" style="display:block;">6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 17 stored entries:
  1.0           ⋅            ⋅           ⋅           ⋅         ⋅
 -0.00400889   1.0           ⋅           ⋅           ⋅         ⋅
   ⋅            ⋅           1.0          ⋅           ⋅         ⋅
 -0.465213     0.00308853  -0.177715    1.0          ⋅         ⋅
   ⋅            ⋅          -0.371291    0.0618339   1.0        ⋅
 -0.00178072  -0.444182     0.0918455  -0.346344   -0.203397  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐔 = analysis.method.factorization.U</code><code class="nohighlight hljs ansi" style="display:block;">6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 17 stored entries:
 0.498347  0.00163724   ⋅        -0.498347       ⋅         -0.00166901
  ⋅        0.493224     ⋅         4.33681e-19    ⋅         -0.502794
  ⋅         ⋅          0.619986  -0.113149      0.214146   -0.0527194
  ⋅         ⋅           ⋅         0.250011     -0.0158957   0.092718
  ⋅         ⋅           ⋅          ⋅            0.688866   -0.12927
  ⋅         ⋅           ⋅          ⋅             ⋅          0.299378</code></pre><p>The JuliaGrid implementation of the AC power flow follows a specific order to store the increment <span>$\mathbf \Delta \mathbf x$</span> and mismatch <span>$\mathbf{f}(\mathbf x)$</span> vectors. The first <span>$n-1$</span> elements of both vectors correspond to the demand and generator buses in the same order as they appear in the input data. The first <span>$n-1$</span> elements of the increment vector <span>$\mathbf \Delta \mathbf x$</span> correspond to the voltage angle increments <span>$\mathbf \Delta \mathbf x_\mathrm{a}$</span>, while the first <span>$n-1$</span> elements of the mismatch vector <span>$\mathbf{f}(\mathbf x)$</span> correspond to the mismatch in active power injections <span>$\mathbf{f}_\mathrm{P}(\mathbf x)$</span>.</p><p>The last <span>$n_\mathrm{pq}$</span> elements of the increment <span>$\mathbf \Delta  \mathbf x$</span> and mismatch <span>$\mathbf{f}(\mathbf x)$</span> vectors correspond to the demand buses in the order they appear in the input data. For the increment vector <span>$\mathbf \Delta \mathbf x$</span>, it matches the bus voltage magnitude increments <span>$\mathbf \Delta \mathbf x_\mathrm{m}$</span>, while for the mismatch vector <span>$\mathbf{f}(\mathbf x)$</span>, it matches the mismatch in reactive power injections <span>$\mathbf{f}_\mathrm{Q}(\mathbf x)$</span>.</p><p>These specified orders dictate the row and column order of the Jacobian matrix <span>$\mathbf J(\mathbf x)$</span>.</p><p>Finally, the function <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>solve!</code></a> adds the computed increment term to the previous solution to obtain a new solution:</p><p class="math-container">\[  \mathbf{x}^{(\nu + 1)} = \mathbf{x}^{(\nu)} + \mathbf \Delta \mathbf{x}^{(\nu)}.\]</p><p>The bus voltage magnitudes <span>$\mathbf V = [V_i]$</span> and angles <span>$\bm \Theta = [\theta_i]$</span> are then updated based on the obtained solution <span>$\mathbf x$</span>. It is important to note that only the voltage magnitudes related to demand buses and angles related to demand and generator buses are updated; not all values are updated. Therefore, the final solution obtained by JuliaGrid is stored in the following vectors:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0
 1.0058448714519173
 1.0892355535521518
 1.1103697460384185</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.0
 -0.00644900951642222
 -0.00046072472071607
 -0.0041086656422506945</code></pre><hr/><h5 id="Jacobian-Matrix"><a class="docs-heading-anchor" href="#Jacobian-Matrix">Jacobian Matrix</a><a id="Jacobian-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian-Matrix" title="Permalink"></a></h5><p>To complete the tutorial on the Newton-Raphson method, we will now describe the Jacobian matrix and provide the equations involved in its evolution. Without loss of generality, we assume that the slack bus is the first bus, followed by the set of demand buses and the set of generator buses:</p><p class="math-container">\[  \begin{aligned}
    \mathcal{N}_\mathrm{sb} &amp;= \{ 1 \} \\
    \mathcal{N}_\mathrm{pq} &amp;= \{2, \dots, m\} \\
    \mathcal{N}_\mathrm{pv} &amp;= \{m + 1,\dots, n\},
  \end{aligned}\]</p><p>where <span>$\mathcal N = \mathcal{N}_\mathrm{sb} \cup \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv}$</span>. Therefore, we can express:</p><p class="math-container">\[  \begin{aligned}
    \mathbf x_\mathrm{a} &amp;= [\theta_2, \dots, \theta_n]^T, \;\;\;\;\;\; \mathbf \Delta \mathbf x_\mathrm{a} = [\Delta \theta_2, \dots, \Delta \theta_n]^T \\
    \mathbf x_\mathrm{m} &amp;= [V_2, \dots, V_{m}]^T, \;\;\; \mathbf \Delta \mathbf x_\mathrm{m} = [\Delta V_2, \dots, \Delta V_{m}]^T.
  \end{aligned}\]</p><p>The Jacobian matrix <span>$\mathbf{J(x^{(\nu)})} \in \mathbb{R}^{n_\mathrm{u} \times n_\mathrm{u}}$</span> is:</p><p class="math-container">\[  \mathbf{J(x^{(\nu)})}=
  \left[
  \begin{array}{ccc|ccc}
    \cfrac{\mathrm \partial{f_{P_2}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
    \cfrac{\mathrm \partial{f_{P_2}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_n} &amp;
    \cfrac{\mathrm \partial{f_{P_2}(\mathbf x^{(\nu)})}}{\mathrm \partial V_2} &amp;\cdots &amp;
    \cfrac{\mathrm \partial{f_{P_2}(\mathbf x^{(\nu)})}}{\mathrm \partial V_m}\\
    \;\vdots &amp; \\
    \cfrac{\mathrm \partial{f_{P_n}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
    \cfrac{\mathrm \partial{f_{P_n}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_n} &amp;
    \cfrac{\mathrm \partial{f_{P_n}(\mathbf x^{(\nu)})}}{\mathrm \partial V_2} &amp;\cdots &amp;
    \cfrac{\mathrm \partial{f_{P_n}(\mathbf x^{(\nu)})}}{\mathrm \partial V_m} \\[10pt]
    \hline \\
    \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
    \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_n} &amp;
    \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x^{(\nu)})}}{\mathrm \partial V_2} &amp;\cdots &amp;
    \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x^{(\nu)})}}{\mathrm \partial V_m}\\
    \;\vdots &amp; \\
    \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_2} &amp; \cdots &amp;
    \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_n} &amp;
    \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_2} &amp;\cdots &amp;
    \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x^{(\nu)})}}{\mathrm \partial V_m}
  \end{array}
  \right].\]</p><p>The Jacobian matrix can be expressed using four block matrices:</p><p class="math-container">\[	\mathbf{J(x^{(\nu)})} =
  \begin{bmatrix}
    \mathbf{J_{11}(x^{(\nu)})} &amp; \mathbf{J_{12}(x^{(\nu)})} \\ \mathbf{J_{21}(x^{(\nu)})} &amp; \mathbf{J_{22}(x^{(\nu)})}
  \end{bmatrix},\]</p><p>where diagonal elements of the Jacobian sub-matrices are defined as follows:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_i} &amp;=
    V_i^{(\nu)} \sum\limits_{j=1}^n (-G_{ij}\sin\theta_{ij}^{(\nu)} + B_{ij}\cos\theta_{ij}^{(\nu)}) V_j^{(\nu)} - B_{ii}(V_i^{(\nu)})^2\\
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x^{(\nu)})}}{\mathrm \partial V_i^{(\nu)}} &amp;=
    \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij}^{(\nu)} + B_{ij}\sin\theta_{ij}^{(\nu)}) V_j^{(\nu)} + G_{ii}V_i^{(\nu)}\\
    \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x^{(\nu)})}} {\mathrm \partial \theta_i} &amp;=
    V_i^{(\nu)} \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij}^{(\nu)} + B_{ij}\sin\theta_{ij}^{(\nu)}) V_j^{(\nu)} - G_{ii}(V_i^{(\nu)})^2\\
    \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x^{(\nu)})}}{\mathrm \partial V_i} &amp;=
    \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij}^{(\nu)} - B_{ij}\cos\theta_{ij}^{(\nu)}) V_j^{(\nu)} - B_{ii}V_i^{(\nu)},
  \end{aligned}\]</p><p>while non-diagonal elements of the Jacobian sub-matrices are:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_j} &amp;=
    (G_{ij}\sin\theta_{ij}^{(\nu)} - B_{ij}\cos\theta_{ij}^{(\nu)}) V_i^{(\nu)}V_j^{(\nu)}\\
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x^{(\nu)})}}{\mathrm \partial V_j^{(\nu)}} &amp;=
    (G_{ij}\cos\theta_{ij}^{(\nu)} + B_{ij}\sin\theta_{ij}^{(\nu)}) V_i^{(\nu)}\\
    \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x^{(\nu)})}}{\mathrm \partial \theta_j} &amp;=
    -(G_{ij}\cos\theta_{ij}^{(\nu)} + B_{ij}\sin\theta_{ij}^{(\nu)}) V_i^{(\nu)}V_j^{(\nu)}\\
    \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x^{(\nu)})}}{\mathrm\partial V_j} &amp;=
    (G_{ij}\sin\theta_{ij}^{(\nu)} - B_{ij}\cos\theta_{ij}^{(\nu)}) V_i^{(\nu)}.
  \end{aligned}\]</p><hr/><h5 id="NewtonRaphsonAlgorithmTutorials"><a class="docs-heading-anchor" href="#NewtonRaphsonAlgorithmTutorials">The Newton-Raphson Algorithm</a><a id="NewtonRaphsonAlgorithmTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#NewtonRaphsonAlgorithmTutorials" title="Permalink"></a></h5><p>In summary, the Newton-Raphson iterative algorithm for solving AC power flow follows these steps:</p><table><tr><th style="text-align: left">Step</th><th style="text-align: left">Description</th><th style="text-align: left">Expression</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: left">Initialize the iteration index</td><td style="text-align: left"><span>$\nu = 0$</span></td></tr><tr><td style="text-align: left">2.</td><td style="text-align: left">Set the initial bus voltage magnitudes and angles</td><td style="text-align: left"><span>$\mathbf{x}^{(0)} = [\mathbf{V}^{(0)}, \bm{\Theta}^{(0)}]$</span></td></tr><tr><td style="text-align: left">3.</td><td style="text-align: left">Compute mismatches for active and reactive power injections</td><td style="text-align: left"><span>$\mathbf f (\mathbf{x}^{(\nu)})$</span></td></tr><tr><td style="text-align: left">4.</td><td style="text-align: left">Check for convergence</td><td style="text-align: left"><span>$f_{P\max}(\mathbf x^{(\nu)}) &lt; \epsilon$</span>, <span>$f_{Q\max}(\mathbf x^{(\nu)}) &lt; \epsilon$</span></td></tr><tr><td style="text-align: left">5.</td><td style="text-align: left">If the convergence criteria are met, stop the process</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">6.</td><td style="text-align: left">Compute the voltage magnitude and angle increments</td><td style="text-align: left"><span>$\mathbf \Delta \mathbf{x}^{(\nu)}$</span></td></tr><tr><td style="text-align: left">7.</td><td style="text-align: left">Update the voltage magnitude and angle values</td><td style="text-align: left"><span>$\mathbf{x}^{(\nu + 1)} = \mathbf{x}^{(\nu)} + \mathbf \Delta \mathbf{x}^{(\nu)}$</span></td></tr><tr><td style="text-align: left">8.</td><td style="text-align: left">Increase the iteration index</td><td style="text-align: left"><span>$\nu := \nu + 1$</span></td></tr><tr><td style="text-align: left">9.</td><td style="text-align: left">Repeat from step 3.</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><p>The main computational effort is in step 6, which involves forming and factorizing the Jacobian matrix and performing forward and backward substitutions to obtain the vector of increments.</p><hr/><h2 id="FastNewtonRaphsonMethodTutorials"><a class="docs-heading-anchor" href="#FastNewtonRaphsonMethodTutorials">Fast Newton-Raphson Method</a><a id="FastNewtonRaphsonMethodTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#FastNewtonRaphsonMethodTutorials" title="Permalink"></a></h2><p>Although the fast Newton-Raphson method may converge more slowly than the traditional Newton-Raphson method, the shorter solution time for the updates often compensates for this slower convergence, resulting in a shorter overall solution time. This is particularly true for systems that are not heavily loaded, where a shorter overall solution time is almost always achieved. It is important to note that if the algorithm converges, it will converge to a correct solution [<a href="../../background/bibliography/#andersson2012power">6</a>].</p><p>The fast Newton-Raphson method involves decoupling the power flow equations. Namely, the Newton-Raphson method is based on the equations:</p><p class="math-container">\[  \begin{bmatrix}
    \mathbf{J_{11}(x)} &amp; \mathbf{J_{12}(x)} \\ \mathbf{J_{21}(x)} &amp; \mathbf{J_{22}(x)}
  \end{bmatrix}
  \begin{bmatrix}
    \mathbf \Delta \mathbf x_\mathrm{a} \\ \mathbf \Delta \mathbf x_\mathrm{m}
  \end{bmatrix}	+
  \begin{bmatrix}
    \mathbf{f}_\mathrm{P}(\mathbf x) \\ \mathbf{f}_\mathrm{Q}(\mathbf x)
  \end{bmatrix} = \mathbf 0,\]</p><p>where the iteration index has been omitted for simplicity. However, in transmission grids, there exists a strong coupling between active powers and voltage angles, as well as between reactive powers and voltage magnitudes. To achieve decoupling, two conditions must be satisfied: first, the resistance values <span>$r_{ij}$</span> of the branches must be small compared to their reactance values <span>$x_{ij}$</span>, and second, the angle differences must be small, i.e., <span>$\theta_{ij} \approx 0$</span> [<a href="../../background/bibliography/#van1989general">10</a>]. Therefore, starting from the above equation, we have:</p><p class="math-container">\[  \begin{bmatrix}
    \mathbf{J_{11}(x)} &amp; \mathbf 0 \\ \mathbf 0 &amp; \mathbf{J_{22}(x)}
  \end{bmatrix}
  \begin{bmatrix}
    \mathbf \Delta \mathbf x_\mathrm{a} \\ \mathbf \Delta \mathbf x_\mathrm{m}
  \end{bmatrix}	+
  \begin{bmatrix}
    \mathbf{f}_\mathrm{P}(\mathbf x) \\ \mathbf{f}_\mathrm{Q}(\mathbf x)
  \end{bmatrix} = \mathbf 0,\]</p><p>which gives the decoupled system as follows:</p><p class="math-container">\[  \begin{aligned}
    \mathbf{f}_\mathrm{P}(\mathbf x) &amp;= -\mathbf{J_{11}(x)} \mathbf \Delta \mathbf x_\mathrm{a} \\
    \mathbf{f}_\mathrm{Q}(\mathbf x) &amp;= -\mathbf{J_{22}(x)} \mathbf \Delta \mathbf x_\mathrm{m}.
  \end{aligned}\]</p><p>To examine the problem, it is helpful to express it as:</p><p class="math-container">\[  \begin{aligned}
    f_{P_2}(\mathbf x) &amp;= -\Delta \theta_2 \cfrac{\mathrm \partial{f_{P_2}(\mathbf x)}} {\mathrm \partial \theta_2} - \cdots -
    \Delta \theta_n \cfrac{\mathrm \partial{f_{P_2}(\mathbf x)}}{\mathrm \partial \theta_n} \\
    &amp; \vdots \\
    f_{P_n}(\mathbf x) &amp;= -\Delta \theta_2 \cfrac{\mathrm \partial{f_{P_n}(\mathbf x)}} {\mathrm \partial \theta_2} - \cdots -
    \Delta \theta_n \cfrac{\mathrm \partial{f_{P_i}(\mathbf x)}}{\mathrm \partial \theta_n}\\
    f_{Q_2}(\mathbf x) &amp;= - \Delta V_2 \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x)}}{\mathrm \partial V_2} - \cdots -
    \Delta V_{m} \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x)}}{\mathrm \partial V_m}\\
    &amp; \vdots \\
    f_{Q_m}(\mathbf x) &amp;= - \Delta V_2 \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x)}}{\mathrm \partial V_2} - \cdots -
    \Delta V_m \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x)}}{\mathrm \partial V_m}.
  \end{aligned}\]</p><p>Firstly, the second part of the expressions is expanded as follows:</p><p class="math-container">\[  \begin{aligned}
    f_{Q_2}(\mathbf x) &amp;=
    -\cfrac{\Delta V_2}{V_2} V_2 \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x)}}{\mathrm \partial V_2} - \cdots - \cfrac{\Delta V_m}{V_m} V_m
    \cfrac{\mathrm \partial{f_{Q_2}(\mathbf x)}}{\mathrm \partial V_m}\\
    &amp; \vdots \\
    f_{Q_m}(\mathbf x) &amp;=
    - \cfrac{\Delta V_2}{V_2} V_2 \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x)}}{\mathrm \partial V_2} - \cdots - \cfrac{\Delta V_m}{V_m} V_m
    \cfrac{\mathrm \partial{f_{Q_{m}}(\mathbf x)}}{\mathrm \partial V_m}.
  \end{aligned}\]</p><p>Next, the Jacobian elements are derived. To achieve this, we can use the expressions defined for the Newton-Raphson method. For demand buses, the above expansions are applied as:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x)}} {\mathrm \partial \theta_i} &amp;= V_i \sum\limits_{j=1}^n (-G_{ij}\sin\theta_{ij} + B_{ij}\cos\theta_{ij}) V_j - B_{ii}V_i^2\\
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;= (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_iV_j\\
    V_i \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x)}}{\mathrm \partial V_i} &amp;= V_i \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_j - B_{ii}V_i^2\\
    V_j \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x)}}{\mathrm\partial V_j} &amp;= (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_i V_j.
  \end{aligned}\]</p><p>As the definition of reactive power is given by the equation:</p><p class="math-container">\[  Q_i = V_i \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_j,\]</p><p>the Jacobian elements can be expressed in the following manner:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x)}} {\mathrm \partial \theta_i} &amp;= -Q_i - B_{ii}V_i^2\\
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x)}}{\mathrm \partial \theta_j} &amp;= (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_i V_j\\
    V_i \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x)}}{\mathrm \partial V_i} &amp;= Q_i - B_{ii}V_i^2\\
    V_j \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x)}}{\mathrm\partial V_j} &amp;= (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij}) V_i V_j.
  \end{aligned}\]</p><p>The decoupled model is established through the following approximations:</p><p class="math-container">\[  \begin{aligned}
    \sin(\theta_{ij}) \approx 0 \\
    \cos(\theta_{ij}) \approx 1 \\
    Q_i &lt;&lt; B_{ii}V_i^2.
  \end{aligned}\]</p><p>Thus, when the approximations are made, the Jacobian elements are simplified, resulting in the decoupled model where the Jacobian elements are:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x)}} {\mathrm \partial \theta_i} &amp;= -B_{ii}V_i^2\\
    \cfrac{\mathrm \partial{f_{P_i}(\mathbf x)}} {\mathrm \partial \theta_j} &amp;= -B_{ij}V_iV_j\\
    V_i \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x)}} {\mathrm \partial V_i} &amp;= -B_{ii}V_i^2\\
    V_j \cfrac{\mathrm \partial{f_{Q_i}(\mathbf x)}}{\mathrm\partial V_j} &amp;= -B_{ij}V_iV_j.
  \end{aligned}\]</p><p>Thus, the initial system of equations becomes:</p><p class="math-container">\[  \begin{aligned}
    f_{P_2}(\mathbf x) &amp;= B_{22} \Delta \theta_2 V_2^2 + \cdots + B_{2n} \Delta \theta_n V_2V_n \\
    &amp; \vdots \\
    f_{P_n}(\mathbf x) &amp;= B_{n2} \Delta \theta_2 V_2V_n + \cdots + B_{nn} \Delta \theta_n V_n^2 \\
    f_{Q_2}(\mathbf x) &amp;= B_{22} \cfrac{\Delta V_2}{V_2} V_2^2 + \cdots + B_{2m} \cfrac{\Delta V_m}{V_m} V_2V_m \\
    &amp; \vdots \\
    f_{Q_m}(\mathbf x) &amp;= B_{m2} \cfrac{\Delta V_2}{V_2} V_2V_m + \cdots + B_{mm} \cfrac{\Delta V_m}{V_m} V_m^2.
  \end{aligned}\]</p><p>Using <span>$V_j \approx 1$</span>, wherein <span>$V_i^2 = V_iV_j, j=i$</span>, the first part of the equations can be simplified to:</p><p class="math-container">\[  \begin{aligned}
    f_{P_2}(\mathbf x) &amp;= B_{22} \Delta \theta_2 V_2 + \cdots + B_{2n} \Delta \theta_n V_2 \\
    &amp; \vdots \\
    f_{P_n}(\mathbf x) &amp;= B_{n2} \Delta \theta_2 V_n + \cdots + B_{nn} \Delta \theta_n V_n.
  \end{aligned}\]</p><p>Similarly, the second part of the equations can be simplified to:</p><p class="math-container">\[  \begin{aligned}
    f_{Q_2}(\mathbf x) &amp;= B_{22} V_2 \Delta V_2 + \cdots + B_{2m} V_2 \Delta V_m \\
    &amp; \vdots \\
    f_{Q_m}(\mathbf x) &amp;= B_{m2} V_m \Delta V_2 + \cdots + B_{mm} V_m \Delta V_m.
  \end{aligned}\]</p><p>The fast Newton-Raphson method is ultimately based on the system of equations presented below:</p><p class="math-container">\[  \begin{aligned}
    \cfrac{f_{P_2}(\mathbf x)}{V_2} &amp;= B_{22} \Delta \theta_2 + \cdots + B_{2n} \Delta \theta_n \\
    &amp; \vdots \\
    \cfrac{f_{P_n}(\mathbf x)}{V_n} &amp;= B_{n2} \Delta \theta_2 + \cdots + B_{nn} \Delta \theta_n \\
    \cfrac{f_{Q_2}(\mathbf x)}{V_2} &amp;= B_{22} \Delta V_2 + \cdots + B_{2m} \Delta V_m \\
    &amp; \vdots \\
    \cfrac{f_{Q_m}(\mathbf x)}{V_m} &amp;= B_{m2} \Delta V_2 + \cdots +
    B_{mm} \Delta V_m.
  \end{aligned}\]</p><p>This system can be written as:</p><p class="math-container">\[  \begin{aligned}
    \mathbf{h}_{\mathrm{P}}(\mathbf x) &amp;= \mathbf{B}_1 \mathbf \Delta \mathbf x_\mathrm{a} \\
    \mathbf{h}_{\mathrm{Q}}(\mathbf x) &amp;= \mathbf{B}_2 \mathbf \Delta \mathbf x_\mathrm{m}.
  \end{aligned}\]</p><p>One of the main advantages of this approach is that the Jacobian matrices <span>$\mathbf{B}_1$</span> and <span>$\mathbf{B}_2$</span> are constant and need only be formed once. Furthermore, this method can be used to define both the XB and BX versions of the fast Newton-Raphson method.</p><hr/><h5 id="XB-Version"><a class="docs-heading-anchor" href="#XB-Version">XB Version</a><a id="XB-Version-1"></a><a class="docs-heading-anchor-permalink" href="#XB-Version" title="Permalink"></a></h5><p>The matrix <span>$\mathbf{B}_1$</span> is formed by neglecting the resistance <span>$r_{ij}$</span>, shunt susceptance <span>$\Im \{ y_{\mathrm{sh}i} \}$</span>, charging susceptance <span>$\Im \{ y_{\mathrm{s}ij} \}$</span>, and transformer tap ratio magnitude <span>$\tau_{ij}$</span>. The matrix <span>$\mathbf{B}_2$</span> is constructed by disregarding the transformer phase shift angle <span>$\phi_{ij}$</span>. This approach corresponds to the standard fast Newton-Raphson method and is known to exhibit exceptional convergence properties in typical scenarios [<a href="../../background/bibliography/#van1989general">10</a>].</p><p>To initialize the XB version of the fast Newton-Raphson method, one can utilize the following code snippet:</p><pre><code class="language-julia hljs">acModel!(system)
analysis = fastNewtonRaphsonXB(system)</code></pre><hr/><h5 id="BX-Version"><a class="docs-heading-anchor" href="#BX-Version">BX Version</a><a id="BX-Version-1"></a><a class="docs-heading-anchor-permalink" href="#BX-Version" title="Permalink"></a></h5><p>The matrix <span>$\mathbf{B}_1$</span> ignores the shunt susceptance<span>$\Im \{ y_{\mathrm{sh}i} \}$</span>, charging susceptance <span>$\Im \{ y_{\mathrm{s}ij} \}$</span>, and transformer tap ratio magnitude <span>$\tau_{ij}$</span>. The matrix <span>$\mathbf{B}_2$</span> ignores the resistance <span>$r_{ij}$</span> and transformer phase shift angle <span>$\phi_{ij}$</span>. In usual cases, the iteration count for the BX version is comparable to the XB scheme. However, for systems with high <span>$r_{ij}/x_{ij}$</span> ratios, the BX scheme requires considerably fewer iterations than the XB scheme to solve the power flow [<a href="../../background/bibliography/#van1989general">10</a>].</p><p>To initialize the BX version of the fast Newton-Raphson method, you can use the following code:</p><pre><code class="language-julia hljs">acModel!(system)
analysis = fastNewtonRaphsonBX(system)</code></pre><hr/><h5 id="Initialization-2"><a class="docs-heading-anchor" href="#Initialization-2">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-2" title="Permalink"></a></h5><p>When a user creates the fast Newton-Raphson method in JuliaGrid, the Jacobian matrices <span>$\mathbf{B}_1$</span> and <span>$\mathbf{B}_2$</span> are formed to correspond to the active and reactive power equations, respectively:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐁₁ = analysis.method.active.jacobian</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
 -18.0769     3.07692    ⋅
   3.07692  -13.4657    5.88235
    ⋅         5.88235  -5.88235</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐁₂ = analysis.method.reactive.jacobian</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:
 -20.5128     3.84615    ⋅
   3.84615  -14.3904    5.88235
    ⋅         5.88235  -5.77035</code></pre><p>Additionally, during this stage, JuliaGrid generates the initial vectors for bus voltage magnitudes <span>$\mathbf{V}^{(0)}$</span> and angles <span>$\bm{\Theta}^{(0)}$</span> as demonstrated below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕⁽⁰⁾ = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯⁽⁰⁾ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0</code></pre><hr/><h5 id="Iterative-Process-2"><a class="docs-heading-anchor" href="#Iterative-Process-2">Iterative Process</a><a class="docs-heading-anchor-permalink" href="#Iterative-Process-2" title="Permalink"></a></h5><p>JuliaGrid offers the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> and <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>solve!</code></a> functions to implement the fast Newton-Raphson method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:</p><pre><code class="language-julia hljs">for iteration = 0:100
    stopping = mismatch!(analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(analysis)
end</code></pre><p>The functions <span>$\mathbf{f}_\mathrm{P}(\mathbf x)$</span> and <span>$\mathbf{f}_\mathrm{Q}(\mathbf x)$</span> remain free of approximations, with only the calculation of the state variable increments affected [<a href="../../background/bibliography/#andersson2012power">6</a>]. As a result, we still use the following equations to compute the mismatches:</p><p class="math-container">\[  \begin{aligned}
    f_{P_i}(\mathbf x) &amp;= V_i \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij} + B_{ij}\sin\theta_{ij})V_j - P_i = 0,
    \;\;\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv}\\
    f_{Q_i}(\mathbf x) &amp;= V_i \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij} - B_{ij}\cos\theta_{ij})V_j - Q_i = 0,
    \;\;\; \forall i \in \mathcal{N}_\mathrm{pq}.
  \end{aligned}\]</p><p>Therefore, the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration <span>$\nu = \{0, 1, 2, \dots\}$</span>:</p><p class="math-container">\[  \begin{aligned}
    h_{P_i}(\mathbf {x}^{(\nu)}) &amp;=
    \sum\limits_{j=1}^n (G_{ij}\cos\theta_{ij}^{(\nu)} + B_{ij}\sin\theta_{ij}^{(\nu)})V_j^{(\nu)} - \cfrac{P_i}{V_i^{(\nu)}},
    \;\;\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv} \\
    h_{Q_i}(\mathbf {x}^{(\nu)}) &amp;=
    \sum\limits_{j=1}^n (G_{ij}\sin\theta_{ij}^{(\nu)} - B_{ij}\cos\theta_{ij}^{(\nu)})V_j^{(\nu)} - \cfrac{Q_i}{V_i^{(\nu)}},
    \;\;\; \forall i \in \mathcal{N}_\mathrm{pq}.
  \end{aligned}\]</p><p>The resulting vectors from these calculations are stored in the <code>AcPowerFlow</code> type and can be accessed by:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐡ₚ = analysis.method.active.increment</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  1.0521034860626955e-9
 -1.8809173701904967e-10
 -2.280102039884849e-10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐡ₒ = analysis.method.reactive.increment</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 9.293374091829092e-11
 4.4771575718049794e-12
 4.400285291193953e-12</code></pre><p>In addition to computing the mismatches in active and reactive power injection, the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion <span>$\epsilon$</span>:</p><p class="math-container">\[  \max \{|h_{P_i}(\mathbf x^{(\nu)})|,\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv} \} &lt; \epsilon \\
  \max \{|h_{Q_i}(\mathbf x^{(\nu)})|,\; \forall i \in \mathcal{N}_\mathrm{pq} \} &lt; \epsilon.\]</p><p>Next, the function <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>solve!</code></a> computes the bus voltage angle increments:</p><p class="math-container">\[  \mathbf \Delta \mathbf x_\mathrm{a}^{(\nu)} = \mathbf{B}_1^{-1} \mathbf{h}_\mathrm{P}(\mathbf x^{(\nu)}).\]</p><p>To obtain the voltage angle increments, JuliaGrid initially performs LU factorization on the Jacobian matrix <span>$\mathbf{B}_1 = \mathbf{L}_1\mathbf{U}_1$</span>. This factorization is executed only once and is utilized in each iteration of the algorithm:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐋₁ = analysis.method.active.factorization.L</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 5 stored entries:
  1.0         ⋅         ⋅
   ⋅         1.0        ⋅
 -0.524625  -0.160564  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐔₁ = analysis.method.active.factorization.U</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 5 stored entries:
 -0.5    ⋅         0.5
   ⋅   -0.854545   0.145455
   ⋅     ⋅        -0.314811</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>By default, JuliaGrid uses LU factorization as the primary method for factorizing Jacobian matrix. Nevertheless, users have the flexibility to opt for QR factorization as an alternative method.</p></div></div><p>The vector of increments that corresponds to the active power equations can be accessed using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚫𝐱ₐ = analysis.method.active.increment</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  1.0521034860626955e-9
 -1.8809173701904967e-10
 -2.280102039884849e-10</code></pre><p>The solution is then updated as follows:</p><p class="math-container">\[  \mathbf x_\mathrm{a}^{(\nu + 1)} = \mathbf x_\mathrm{a}^{(\nu)} + \mathbf \Delta \mathbf x_\mathrm{a}^{(\nu)}.\]</p><p>It is important to note that only the voltage angles related to demand and generator buses are updated, while the vector of bus voltage angles of all buses is stored:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.0
 -0.006449009470429831
 -0.00046072472210989724
 -0.004108665646915064</code></pre><p>After calculating the update for voltage angles, to calculate the magnitude updates the fast Newton-Raphson method then solves the equation:</p><p class="math-container">\[  \mathbf \Delta \mathbf x_\mathrm{m}^{(\nu)} = \mathbf{B}_2^{-1} \mathbf{h}_\mathrm{Q}(\mathbf x^{(\nu)}).\]</p><p>Similarly to the previous instance, JuliaGrid initially executes LU factorization on the Jacobian matrix <span>$\mathbf{B}_2 = \mathbf{L}_2\mathbf{U}_2$</span>. However, it provides the flexibility for users to opt for QR factorization instead. This factorization occurs only once and is utilized in each iteration of the fast Newton-Raphson algorithm:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐋₂ = analysis.method.reactive.factorization.L</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 5 stored entries:
  1.0         ⋅         ⋅
   ⋅         1.0        ⋅
 -0.492513  -0.189366  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐔₂ = analysis.method.reactive.factorization.U</code><code class="nohighlight hljs ansi" style="display:block;">3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 5 stored entries:
 -0.495194    ⋅         0.504806
   ⋅        -0.842105   0.157895
   ⋅          ⋅        -0.318121</code></pre><p>The vector of increments that corresponds to the reactive power equations can be accessed using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚫𝐱ₘ = analysis.method.active.increment</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  1.0521034860626955e-9
 -1.8809173701904967e-10
 -2.280102039884849e-10</code></pre><p>Finally, the solution is updated as follows:</p><p class="math-container">\[  \mathbf x_\mathrm{m}^{(\nu + 1)} = \mathbf x_\mathrm{m}^{(\nu)} + \mathbf \Delta \mathbf x_\mathrm{m}^{(\nu)}.\]</p><p>Again, it is important to note that only the voltage magnitudes of demand buses are updated, while the vector of bus voltage magnitude for all buses is stored:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0
 1.005844871456561
 1.0892355535531821
 1.1103697460394555</code></pre><hr/><h5 id="The-Fast-Newton-Raphson-Algorithm"><a class="docs-heading-anchor" href="#The-Fast-Newton-Raphson-Algorithm">The Fast Newton-Raphson Algorithm</a><a id="The-Fast-Newton-Raphson-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Fast-Newton-Raphson-Algorithm" title="Permalink"></a></h5><p>In summary, the fast Newton-Raphson iterative algorithm for solving AC power flow follows these steps:</p><table><tr><th style="text-align: left">Step</th><th style="text-align: left">Description</th><th style="text-align: left">Expression</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: left">Initialize the iteration index</td><td style="text-align: left"><span>$\nu = 0$</span></td></tr><tr><td style="text-align: left">2.</td><td style="text-align: left">Set the initial bus voltage magnitudes and angles</td><td style="text-align: left"><span>$\mathbf{x}^{(0)} = [\mathbf{V}^{(0)}, \bm{\Theta}^{(0)}]$</span></td></tr><tr><td style="text-align: left">3.</td><td style="text-align: left">Compute mismatches for active and reactive power injections</td><td style="text-align: left"><span>$\mathbf{h}_\mathrm{P}(\mathbf x^{(\nu)})$</span>, <span>$\mathbf{h}_\mathrm{Q}(\mathbf x^{(\nu)})$</span></td></tr><tr><td style="text-align: left">4.</td><td style="text-align: left">Check for convergence</td><td style="text-align: left"><span>$h_{P\max}(\mathbf x^{(\nu)}) &lt; \epsilon$</span>, <span>$h_{Q\max}(\mathbf x^{(\nu)}) &lt; \epsilon$</span></td></tr><tr><td style="text-align: left">5.</td><td style="text-align: left">If the convergence criteria are met, stop the process</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">6.</td><td style="text-align: left">Compute the voltage angle increments</td><td style="text-align: left"><span>$\mathbf \Delta \mathbf x_\mathrm{a}^{(\nu)}$</span></td></tr><tr><td style="text-align: left">7.</td><td style="text-align: left">Update the voltage angle values</td><td style="text-align: left"><span>$\mathbf x_\mathrm{a}^{(\nu + 1)} = \mathbf x_\mathrm{a}^{(\nu)} + \mathbf \Delta \mathbf x_\mathrm{a}^{(\nu)}$</span></td></tr><tr><td style="text-align: left">8.</td><td style="text-align: left">Compute the voltage magnitude increments</td><td style="text-align: left"><span>$\mathbf \Delta \mathbf x_\mathrm{m}^{(\nu)}$</span></td></tr><tr><td style="text-align: left">9.</td><td style="text-align: left">Update the voltage magnitude values</td><td style="text-align: left"><span>$\mathbf x_\mathrm{m}^{(\nu + 1)} = \mathbf x_\mathrm{m}^{(\nu)} + \mathbf \Delta \mathbf x_\mathrm{m}^{(\nu)}$</span></td></tr><tr><td style="text-align: left">10.</td><td style="text-align: left">Increase the iteration index</td><td style="text-align: left"><span>$\nu := \nu + 1$</span></td></tr><tr><td style="text-align: left">11.</td><td style="text-align: left">Repeat from step 3.</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><p>The main computational effort is in steps 6 and 8, where forward and backward substitutions are performed to obtain the vectors of increments using the Jacobian matrices, which are formed and factorized before the iterative algorithm is executed.</p><hr/><h2 id="GaussSeidelMethodTutorials"><a class="docs-heading-anchor" href="#GaussSeidelMethodTutorials">Gauss-Seidel Method</a><a id="GaussSeidelMethodTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#GaussSeidelMethodTutorials" title="Permalink"></a></h2><p>As elaborated in the <a href="#FlowNodalNetworkEquationsTutorials">Nodal Network Equations</a> section of this manual, each bus is associated with the balance equation expressed as:</p><p class="math-container">\[  \sum_{j = 1}^n Y_{ij} \bar{V}_j = \cfrac{P_i - \mathrm{j} Q_i}{\bar{V}_i}, \;\;\; \forall i \in \mathcal N.\]</p><p>In its expanded form, this can be written as:</p><p class="math-container">\[  \begin{aligned}
    Y_{11} &amp; \bar{V}_1 + \cdots + Y_{1n}\bar{V}_n = \frac{P_1 - \mathrm{j} Q_1}{\bar{V}_1^*} \\
    \; \vdots &amp; \\
    Y_{n1} &amp; \bar{V}_1 + \cdots + Y_{nn}\bar{V}_n = \frac{P_n - \mathrm{j} Q_n}{\bar{V}_n^*}.
	\end{aligned}\]</p><p>While the Gauss-Seidel method directly solves the system of equations, it suffers from very slow convergence, which increases almost linearly with the system size, necessitating numerous iterations to obtain the desired solution [<a href="../../background/bibliography/#chassin2006gauss">11</a>]. Moreover, the convergence time of the Gauss-Seidel method increases significantly for large-scale systems and can face convergence issues for systems with high active power transfers. Nevertheless, power flow programs utilize both the Gauss-Seidel and Newton-Raphson methods in a complementary manner. Specifically, the Gauss-Seidel method is employed to obtain a quick approximate solution from a &quot;flat start&quot;, while the Newton-Raphson method is utilized to obtain the final accurate solution [<a href="../../background/bibliography/#zimmerman2016matpower">8</a>].</p><p>The Gauss-Seidel method is usually applied to a system of <span>$n$</span> complex equations, where one represents the slack bus. Consequently, one equation can be eliminated, resulting in a power flow problem with <span>$n-1$</span> equations.</p><hr/><h5 id="Initialization-3"><a class="docs-heading-anchor" href="#Initialization-3">Initialization</a><a class="docs-heading-anchor-permalink" href="#Initialization-3" title="Permalink"></a></h5><p>JuliaGrid provides a way to utilize the Gauss-Seidel method for solving the AC power flow problem and determining the magnitudes and angles of bus voltages. To use this method, we need to execute the <a href="../../api/powerSystemModel/#JuliaGrid.acModel!"><code>acModel!</code></a> function first to set up the system and then initialize the Gauss-Seidel method using the <a href="../../api/powerFlow/#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a> function. The code snippet below demonstrates this process:</p><pre><code class="language-julia hljs">acModel!(system)
analysis = gaussSeidel(system)</code></pre><p>This results in the creation of the initial vectors of bus voltage magnitudes <span>$\mathbf{V}^{(0)}$</span> and angles <span>$\bm{\Theta}^{(0)}$</span>, as shown below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕⁽⁰⁾ = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯⁽⁰⁾ = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0</code></pre><hr/><h5 id="Iterative-Process-3"><a class="docs-heading-anchor" href="#Iterative-Process-3">Iterative Process</a><a class="docs-heading-anchor-permalink" href="#Iterative-Process-3" title="Permalink"></a></h5><p>JuliaGrid offers the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> and <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>solve!</code></a> functions to implement the Gauss-Seidel method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:</p><pre><code class="language-julia hljs">for iteration = 0:300
    stopping = mismatch!(analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(analysis)
end</code></pre><p>In contrast to the Newton-Raphson and fast Newton-Raphson methods, the Gauss-Seidel method does not require the calculation of the mismatch in active and reactive power injection at each iteration. Instead, the <a href="../../api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function is used solely to verify the convergence criteria. At each iteration <span>$\nu = \{0, 1, 2, \dots\}$</span>, we calculate the active power injection mismatch for demand and generator buses, as shown below:</p><p class="math-container">\[  f_{P_i}(\mathbf x^{(\nu)}) = \Re\{\bar{V}_i^{(\nu)} \bar{I}_i^{*(\nu)}\} - P_i, \;\;\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv}.\]</p><p>We also compute the reactive power injection mismatch for demand buses, given by:</p><p class="math-container">\[  f_{Q_i}(\mathbf x^{(\nu)}) = \Im\{\bar{V}_i^{(\nu)} \bar{I}_i^{*(\nu)}\} - Q_i, \;\;\; \forall i \in \mathcal{N}_\mathrm{pq}.\]</p><p>However, these mismatches are not stored, as they are only used to obtain the maximum absolute values of these mismatches. The maximum values of these mismatches are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion <span>$\epsilon$</span>, as shown below:</p><p class="math-container">\[  \max \{|f_{P_i}(\mathbf x^{(\nu)})|,\; \forall i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv} \} &lt; \epsilon \\
  \max \{|f_{Q_i}(\mathbf x^{(\nu)})|,\; \forall i \in \mathcal{N}_\mathrm{pq} \} &lt; \epsilon.\]</p><p>After initializing complex bus voltages <span>$\bar{V}_i^{(0)}$</span> for all buses in the power system, the function <a href="../../api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}"><code>solve!</code></a> proceeds to compute the voltages for demand buses using the Gauss-Seidel method:</p><p class="math-container">\[  \bar{V}_i^{(\nu + 1)} =
  \cfrac{1}{Y_{ii}} \left(\cfrac{P_i - \mathrm{j} Q_i}{\bar{V}_i^{*(\nu)}} -
  \sum\limits_{\substack{j = 1}}^{i - 1} Y_{ij}\bar{V}_j^{(\nu + 1)} -
  \sum\limits_{\substack{j = i + 1}}^n Y_{ij}\bar{V}_j^{(\nu)}\right),
  \;\;\; \forall i \in \mathcal{N}_\mathrm{pq}.\]</p><p>The next step is to determine the solution for generator buses in two stages: first, the reactive power injection is calculated, and then the bus complex voltage is updated using the following equations:</p><p class="math-container">\[  \begin{aligned}
    Q_i^{(\nu + 1)} &amp;=
    -\Im \left\{ \bar{V}_i^{*(\nu + 1)} \sum\limits_{j=1}^n Y_{ij}\bar{V}_j^{(\nu + 1)}\right\}, \;\;\; \forall i \in \mathcal{N}_\mathrm{pv} \\
    \bar{V}_i^{(\nu + 1)} &amp;:=
    \cfrac{1}{Y_{ii}} \Bigg(\cfrac{P_i - \mathrm{j} Q_i^{(\nu + 1)}}{\bar{V}_i^{*(\nu + 1)}}-
    \sum\limits_{\substack{j = 1,\;j \neq i}}^n Y_{ij}\bar{V}_j^{(\nu + 1)} \Bigg), \;\;\; \forall i \in \mathcal{N}_\mathrm{pv}.
  \end{aligned}\]</p><p>The obtained voltage magnitude may not be equal to the magnitude specified for the generator bus, so a voltage correction step is necessary:</p><p class="math-container">\[  \bar{V}_i^{(\nu + 1)} := V_i^{(0)} \cfrac{\bar{V}_i^{(\nu + 1)}}{V_i^{(\nu + 1)}}, \;\;\; \forall i \in \mathcal{N}_\mathrm{pv}.\]</p><p>JuliaGrid stores the final results in vectors that contain all bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐕 = analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0
 1.005844871851792
 1.0892355545361385
 1.1103697470414973</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝚯 = analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.0
 -0.006449009444866342
 -0.0004607248321877602
 -0.004108665753722359</code></pre><hr/><h5 id="The-Gauss-Seidel-Algorithm"><a class="docs-heading-anchor" href="#The-Gauss-Seidel-Algorithm">The Gauss-Seidel Algorithm</a><a id="The-Gauss-Seidel-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Gauss-Seidel-Algorithm" title="Permalink"></a></h5><p>In summary, the Gauss-Seidel iterative algorithm for solving AC power flow follows these steps:</p><table><tr><th style="text-align: left">Step</th><th style="text-align: left">Description</th><th style="text-align: left">Expression</th></tr><tr><td style="text-align: left">1.</td><td style="text-align: left">Initialize the iteration index</td><td style="text-align: left"><span>$\nu = 0$</span></td></tr><tr><td style="text-align: left">2.</td><td style="text-align: left">Set the initial bus voltage magnitudes and angles</td><td style="text-align: left"><span>$\mathbf{x}^{(0)} = [\mathbf{V}^{(0)}, \bm{\Theta}^{(0)}]$</span></td></tr><tr><td style="text-align: left">3.</td><td style="text-align: left">Compute mismatches for active and reactive power injections</td><td style="text-align: left"><span>$f_{P_i}(\mathbf x^{(\nu)})$</span>, <span>$f_{Q_i}(\mathbf x^{(\nu)})$</span></td></tr><tr><td style="text-align: left">4.</td><td style="text-align: left">Check for convergence</td><td style="text-align: left"><span>$h_{P\max}(\mathbf x^{(\nu)}) &lt; \epsilon$</span>, <span>$h_{Q\max}(\mathbf x^{(\nu)}) &lt; \epsilon$</span></td></tr><tr><td style="text-align: left">5.</td><td style="text-align: left">If the convergence criteria are met, stop the process</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">6.</td><td style="text-align: left">Compute voltages for demand buses</td><td style="text-align: left"><span>$\bar{V}_i^{(\nu + 1)}$</span>, <span>$\forall i \in \mathcal{N}_\mathrm{pv}$</span></td></tr><tr><td style="text-align: left">7.</td><td style="text-align: left">Compute the reactive power injections for generator buses</td><td style="text-align: left"><span>$Q_i^{(\nu + 1)}$</span>, <span>$\forall i \in \mathcal{N}_\mathrm{pq}$</span></td></tr><tr><td style="text-align: left">8.</td><td style="text-align: left">Update and apply correction the bus voltages for generator buses</td><td style="text-align: left"><span>$\bar{V}_i^{(\nu + 1)}$</span>, <span>$\forall i \in \mathcal{N}_\mathrm{pq}$</span></td></tr><tr><td style="text-align: left">9.</td><td style="text-align: left">Increase the iteration index</td><td style="text-align: left"><span>$\nu := \nu + 1$</span></td></tr><tr><td style="text-align: left">10.</td><td style="text-align: left">Repeat from step 3.</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><p>The computational effort per iteration is negligible, while the main bottleneck is the large number of iterations required for convergence.</p><hr/><h2 id="ACPowerAnalysisTutorials"><a class="docs-heading-anchor" href="#ACPowerAnalysisTutorials">Power Analysis</a><a id="ACPowerAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACPowerAnalysisTutorials" title="Permalink"></a></h2><p>Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function, which enables the calculation of powers associated with buses, branches, and generators. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">power!(analysis)</code></pre><p>The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses, branches, and generators:</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Power</th><th style="text-align: left">Active</th><th style="text-align: left">Reactive</th></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf P = [P_i]$</span></td><td style="text-align: left"><span>$\mathbf Q = [Q_i]$</span></td></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="#GeneratorPowerInjectionsManual">Generator injections</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{p} = [P_{\mathrm{p}i}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{p} = [Q_{\mathrm{p}i}]$</span></td></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusShuntElementTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{sh} = [P_{\mathrm{sh}i}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{sh} = [Q_{\mathrm{sh}i}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{i} = [P_{ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{i} = [Q_{ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{j} = [P_{ji}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{j} = [Q_{ji}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchShuntElementsTutorials">Shunt elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{s} = [P_{\mathrm{s}ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{s} = [Q_{\mathrm{s}ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{l} = [P_{\mathrm{l}ij}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{l} = [Q_{\mathrm{l}ij}]$</span></td></tr><tr><td style="text-align: left">Generator</td><td style="text-align: left"><a href="#GeneratorPowerOutputsManual">Outputs</a></td><td style="text-align: left"><span>$\mathbf P_\mathrm{g} = [P_{\mathrm{g}i}]$</span></td><td style="text-align: left"><span>$\mathbf Q_\mathrm{g} = [Q_{\mathrm{g}i}]$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Power-Injections"><a class="docs-heading-anchor" href="#Power-Injections">Power Injections</a><a id="Power-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Injections" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusInjectionsTutorials">Active and reactive power injections</a> are stored as the vectors <span>$\mathbf{P} = [P_i]$</span> and <span>$\mathbf{Q} = [Q_i]$</span>, respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏 = analysis.power.injection.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.025304583936174074
 -0.21699999730489078
  0.28800000125457986
 -2.4077102614260874e-18</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐 = analysis.power.injection.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.5224650282662511
 -0.12699999649491905
  0.4540000073996279
  9.892532361792298e-21</code></pre><hr/><h5 id="GeneratorPowerInjectionsManual"><a class="docs-heading-anchor" href="#GeneratorPowerInjectionsManual">Generator Power Injections</a><a id="GeneratorPowerInjectionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#GeneratorPowerInjectionsManual" title="Permalink"></a></h5><p>The <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> function in JuliaGrid also computes the active and reactive power injections from the generators at each bus. The active power supplied by the generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:</p><p class="math-container">\[  P_{\mathrm{p}i} = P_i + P_{\mathrm{d}i}, \;\;\; i \in \mathcal{N}_\mathrm{sb},\]</p><p>where <span>$P_{\mathrm{d}i}$</span> represents the active power demanded by consumers at the slack bus. The active power injections from the generators at each bus are stored as the vector, denoted by <span>$\mathbf{P}_\mathrm{p} = [P_{\mathrm{p}i}]$</span>, can be obtained using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₚ = analysis.power.supply.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.025304583936174074
  0.0
  0.4
  0.0</code></pre><p>The calculation of reactive power injection from the generators at generator or slack buses can be achieved using the subsequent equation:</p><p class="math-container">\[  Q_{\mathrm{p}i} = Q_i + Q_{\mathrm{d}i}, \;\;\; \forall i \in \mathcal{N}_\mathrm{pv} \cup \mathcal{N}_\mathrm{sb},\]</p><p>where <span>$Q_{\mathrm{d}i}$</span> represents the reactive power demanded by consumers at the corresponding bus. Further, the reactive power injected by the generators at buses from <span>$\mathcal{N}_\mathrm{pq}$</span> can be calculated by summing the given generator reactive powers in the input data. The vector of these reactive power injections by the generators to the buses, denoted by <span>$\mathbf{Q}_\mathrm{p} = [Q_{\mathrm{p}i}]$</span>, can be retrieved using the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₚ = analysis.power.supply.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.5224650282662511
  0.0
  0.424
  0.0</code></pre><hr/><h5 id="Power-at-Bus-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Bus-Shunt-Elements">Power at Bus Shunt Elements</a><a id="Power-at-Bus-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Bus-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BusShuntElementTutorials">Active and reactive powers</a> associated with the shunt elements at each bus are represented by the vectors <span>$\mathbf{P}_\mathrm{sh} = [P_{\mathrm{sh}i}]$</span> and <span>$\mathbf{Q}_\mathrm{sh} = [Q_{\mathrm{sh}i}]$</span>. To retrieve these powers in JuliaGrid, use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛₕ = analysis.power.shunt.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.02589134047804497</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₛₕ = analysis.power.shunt.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.0
 -0.0
 -0.0
 -0.014795051701739982</code></pre><hr/><h5 id="Power-Flows"><a class="docs-heading-anchor" href="#Power-Flows">Power Flows</a><a id="Power-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flows" title="Permalink"></a></h5><p>The resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at each from-bus end are stored as the vectors <span>$\mathbf{P}_\mathrm{i} = [P_{ij}]$</span> and <span>$\mathbf{Q}_\mathrm{i} = [Q_{ij}],$</span> respectively, and can be retrieved using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ᵢ = analysis.power.from.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.0681800941327122
 -0.09348467806888605
 -0.14919987912917734
  0.026012308231465508</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ᵢ = analysis.power.from.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.11979262337047558
 -0.4026724048957746
 -0.24793254773638929
 -0.25400850645944056</code></pre><p>The vectors of <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">active and reactive power flows</a> at the to-bus end are stored as <span>$\mathbf{P}_\mathrm{j} = [P_{ji}]$</span> and <span>$\mathbf{Q}_\mathrm{j} = [Q_{ji}]$</span>, respectively, and can be retrieved using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ⱼ = analysis.power.to.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.06780011817571369
  0.10202890060379553
  0.15995879241931948
 -0.02589134047804497</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ⱼ = analysis.power.to.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.12093255124147115
 0.4385581395423945
 0.26945037431667357
 0.014795051701739979</code></pre><hr/><h5 id="Power-at-Branch-Shunt-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Shunt-Elements">Power at Branch Shunt Elements</a><a id="Power-at-Branch-Shunt-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Shunt-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchShuntElementsTutorials">Active and reactive powers</a> associated with the branch shunt elements at each branch are represented by the vectors <span>$\mathbf{P}_\mathrm{s} = [P_{\mathrm{s}ij}]$</span> and <span>$\mathbf{Q}_\mathrm{s} = [Q_{\mathrm{s}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₛ = analysis.power.charging.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.00012096775342053239</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₛ = analysis.power.charging.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -0.0
 -0.0
 -0.0
 -0.2419355068410648</code></pre><hr/><h5 id="Power-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Power-at-Branch-Series-Elements">Power at Branch Series Elements</a><a id="Power-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Power-at-Branch-Series-Elements" title="Permalink"></a></h5><p><a href="../powerSystemModel/#BranchSeriesElementTutorials">Active and reactive powers</a> associated with the branch series element at each branch are represented by the vectors <span>$\mathbf{P}_\mathrm{l} = [P_{\mathrm{l}ij}]$</span> and <span>$\mathbf{Q}_\mathrm{l} = [Q_{\mathrm{l}ij}]$</span>. We can retrieve these values using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₗ = analysis.power.series.active</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  0.0003799759569985204
  0.008544222534909472
  0.010758913290142138
 -1.0842021724855044e-19</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₗ = analysis.power.series.reactive</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.001139927870995561
 0.03588573464661977
 0.021517826580284276
 0.0027220520833633236</code></pre><hr/><h5 id="GeneratorPowerOutputsManual"><a class="docs-heading-anchor" href="#GeneratorPowerOutputsManual">Generator Power Outputs</a><a id="GeneratorPowerOutputsManual-1"></a><a class="docs-heading-anchor-permalink" href="#GeneratorPowerOutputsManual" title="Permalink"></a></h5><p>To obtain the output active powers of each generator connected to bus <span>$i \in \mathcal{N}_\mathrm{pq} \cup \mathcal{N}_\mathrm{pv}$</span>, the given active power in the input data is utilized. For the generator connected to the slack bus, the output active power is determined using the equation:</p><p class="math-container">\[  P_{\mathrm{g}i} = P_i + P_{\mathrm{d}i},\;\;\; i \in \mathcal{N}_\mathrm{sb}.\]</p><p>In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of <span>$P_{\mathrm{g}i}$</span>. Then, this amount of power is reduced by the output active power of the other generators.</p><p>To retrieve the vector of active power outputs of generators, denoted as <span>$\mathbf{P}_\mathrm{g} = [P_{\mathrm{g}i}]$</span>, <span>$i \in \mathcal S$</span>, where the set <span>$\mathcal S$</span> represents the set of generators, users can utilize the following command:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐏ₒ = analysis.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.025304583936174074
  0.4</code></pre><p>The output reactive powers of each generator located at the bus is obtained as:</p><p class="math-container">\[  Q_{\mathrm{g}i} = Q_i + Q_{\mathrm{d}i},\;\;\; i \in \mathcal N.\]</p><p>If there are multiple generators at the same bus, the reactive power is allocated proportionally among the generators based on their reactive power capabilities.</p><p>To retrieve the vector of reactive power outputs of generators, denoted as <span>$\mathbf{Q}_\mathrm{g} = [Q_{\mathrm{g}i}]$</span>, <span>$i \in \mathcal S$</span>, users can utilize:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐐ₒ = analysis.power.generator.reactive</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.5224650282662511
  0.4240000073996279</code></pre><hr/><h2 id="ACCurrentAnalysisTutorials"><a class="docs-heading-anchor" href="#ACCurrentAnalysisTutorials">Current Analysis</a><a id="ACCurrentAnalysisTutorials-1"></a><a class="docs-heading-anchor-permalink" href="#ACCurrentAnalysisTutorials" title="Permalink"></a></h2><p>JuliaGrid offers the <a href="../../api/analysis/#JuliaGrid.current!-Tuple{AC}"><code>current!</code></a> function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:</p><pre><code class="language-julia hljs">current!(analysis)</code></pre><p>The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Current</th><th style="text-align: left">Magnitude</th><th style="text-align: left">Angle</th></tr><tr><td style="text-align: left">Bus</td><td style="text-align: left"><a href="../powerSystemModel/#BusInjectionsTutorials">Injections</a></td><td style="text-align: left"><span>$\mathbf I = [I_i]$</span></td><td style="text-align: left"><span>$\bm \psi = [\psi_i]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">From-bus end flows</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{i} = [I_{ij}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{i} = [\psi_{ij}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchNetworkEquationsTutorials">To-bus end flows</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{j} = [I_{ji}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{j} = [\psi_{ji}]$</span></td></tr><tr><td style="text-align: left">Branch</td><td style="text-align: left"><a href="../powerSystemModel/#BranchSeriesElementTutorials">Series elements</a></td><td style="text-align: left"><span>$\mathbf I_\mathrm{l} = [I_{\mathrm{l}ij}]$</span></td><td style="text-align: left"><span>$\bm \psi_\mathrm{l} = [\psi_{\mathrm{l}ij}]$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the <a href="../powerSystemModel/#UnifiedBranchModelTutorials">Unified Branch Model</a>.</p></div></div><hr/><h5 id="Current-Injections"><a class="docs-heading-anchor" href="#Current-Injections">Current Injections</a><a id="Current-Injections-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injections" title="Permalink"></a></h5><p>In JuliaGrid, <a href="../powerSystemModel/#BusInjectionsTutorials">complex current injections</a> are stored in the vector of magnitudes denoted as <span>$\mathbf{I} = [I_i]$</span> and the vector of angles represented as <span>$\bm{\psi} = [\psi_i]$</span>. You can retrieve them using the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈 = analysis.current.injection.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.5230774586325025
 0.24997084766089062
 0.4935966411616148
 2.168404344971009e-18</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙 = analysis.current.injection.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
  1.619191576605966
  2.605637769016233
 -1.0059543720614923
  3.141592653589793</code></pre><hr/><h5 id="Current-Flows"><a class="docs-heading-anchor" href="#Current-Flows">Current Flows</a><a id="Current-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flows" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_\mathrm{i} = [I_{ij}]$</span> and angles <span>$\bm{\psi}_\mathrm{i} = [\psi_{ij}]$</span> for the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a>, you can use the following commands:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ᵢ = analysis.current.from.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.1378361267952858
 0.41338172516233695
 0.28768189283066065
 0.23441849266339332</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ᵢ = analysis.current.from.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0533688181418361
 1.7989158163819308
 2.1060717428167246
 1.4682841231815587</code></pre><p>Similarly, we can obtain the vectors of magnitudes <span>$\mathbf{I}_\mathrm{j} = [I_{ji}]$</span> and angles <span>$\bm{\psi}_\mathrm{j} = [\psi_{ji}]$</span> of the resulting <a href="../powerSystemModel/#BranchNetworkEquationsTutorials">complex current flows</a> using the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ⱼ = analysis.current.to.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.1378361267952858
 0.41338172516233695
 0.28768189283066065
 0.026856261289684834</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ⱼ = analysis.current.to.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 -2.088223835447957
 -1.3426768372078626
 -1.0355209107730685
 -2.626555205096993</code></pre><hr/><h5 id="Current-at-Branch-Series-Elements"><a class="docs-heading-anchor" href="#Current-at-Branch-Series-Elements">Current at Branch Series Elements</a><a id="Current-at-Branch-Series-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Current-at-Branch-Series-Elements" title="Permalink"></a></h5><p>To obtain the vectors of magnitudes <span>$\mathbf{I}_\mathrm{l} = [I_{\mathrm{l}ij}]$</span> and angles <span>$\bm{\psi}_\mathrm{l} = [\psi_{\mathrm{l}ij}]$</span> of the resulting <a href="../powerSystemModel/#BranchSeriesElementTutorials">complex current flows</a>, one can use the following code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝐈ₗ = analysis.current.series.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 0.13783612679528548
 0.41338172516233634
 0.2876818928306608
 0.12653881253831878</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝛙ₗ = analysis.current.series.angle</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.0533688181418344
 1.798915816381931
 2.1060717428167246
 1.3809084790963575</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerSystemModel/">« Power System Model</a><a class="docs-footer-nextpage" href="../dcPowerFlow/">DC Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 29 April 2025 12:48">Tuesday 29 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
