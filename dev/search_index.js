var documenterSearchIndex = {"docs":
[{"location":"operatingState/bus/#operatingStateBus","page":"Operating State of Buses","title":"Operating State of Buses","text":"","category":"section"},{"location":"operatingState/bus/","page":"Operating State of Buses","title":"Operating State of Buses","text":"Once the bus voltages are obtained from one of the analyses, it is possible to determine powers related to the buses. The function receives composite types PowerSystem and Result.","category":"page"},{"location":"operatingState/bus/","page":"Operating State of Buses","title":"Operating State of Buses","text":"bus!","category":"page"},{"location":"operatingState/bus/#JuliaGrid.bus!","page":"Operating State of Buses","title":"JuliaGrid.bus!","text":"The function computes powers related to buses.\n\nbus!(system::PowerSystem, result::Result)\n\nThe function updates the field result.bus of the composite type Result.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbus!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\nbus!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"operatingState/branch/#operatingStateBranch","page":"Operating State of Branches","title":"Operating State of Branches","text":"","category":"section"},{"location":"operatingState/branch/","page":"Operating State of Branches","title":"Operating State of Branches","text":"Once the bus voltages are obtained from one of the analyses, it is possible to determine powers nad currents related to the branches. The function receives composite types PowerSystem and Result.","category":"page"},{"location":"operatingState/branch/","page":"Operating State of Branches","title":"Operating State of Branches","text":"branch!","category":"page"},{"location":"operatingState/branch/#JuliaGrid.branch!","page":"Operating State of Branches","title":"JuliaGrid.branch!","text":"The function computes powers and currents related to branches for the AC power flow analysis. For the DC power flow analysis, the function computes only active powers.\n\nbranch!(system::PowerSystem, result::Result)\n\nThe function updates the field result.branch of the composite type Result.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbranch!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\nbranch!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/inDepthPowerFlow/#acPowerFlowAnalysis","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid is based on common network elements and benefits the unified branch model to perform the power flow analysis, which is used for defining load profiles, generator capabilities, voltage specification, contingency analysis, and planning.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To recall, we observe the bus/branch model as a graph mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n represents the set of buses, while the set of edges mathcalE subseteq mathcalN times mathcalN represents the set of branches of the power network. As shown in section In-depth AC Model, the power flow problem is described by the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The apparent power injection S_i into the bus i in mathcalN:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"We start from the equation for the apparent power injection S_i into the bus i:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tS_i = barV_ibarI_i^*","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The apparent power S_i consists of the active power P_i and reactive power Q_i:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tP_i + jQ_i = barV_ibarI_i^*","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The energy or apparent power at the bus i is equal to zero according to Tellegen's theorem:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    S_i = S_textgi-S_textli\n    P_i + jQ_i = P_textgi + jQ_textgi - P_textli - jQ_textli\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where S_textgi = P_textgi + textjQ_textgi denotes a generator power, while S_textli = P_textli + textjQ_textli indicates a load power. Hence, the active and reactive power equations may be solved independently:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    P_i = P_textgi - P_textli\n    Q_i = Q_textgi - Q_textli\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"However, the power flow problem is described by the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where it is necessary to compute complex voltages barV_1 dots barV_n. According to the system of equations, for a single bus there are four variables: active power injection P_i, reactive power injection Q_i, voltage magnitude V_i and voltage angle theta_i. Further, to solve the system of equations, two variables for each equation need to be specified. Mathematically, any two variables may be selected, but the choice is dictated by the devices connected to a particular bus. Standard options are summarized in Table below and these options define bus types [1].","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Bus Type Label JuliaGrid Known Unknown\nSlack generator V theta 3 V_itheta_i P_iQ_i\nGenerator PV 2 P_iV_i Q_itheta_i\nDemand PQ 1 P_iQ_i V_itheta_i","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Consequently, JuliaGrid operates with sets mathcalPV and mathcalPQ that contain PV and PQ buses, respectively, and exactly one slack bus. Note that JuliaGrid does not support systems with multiple slack buses.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#newtonraphson","page":"In-depth Power Flow Solution","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Newton-Raphson method is generally preferred in power flow calculations because this method has quadratic rate of convergence. The method can have difficulties with initial conditions (\"flat start\"). The Gauss-Seidel method convergence time increases significantly for large-scale systems and can exhibit convergence problems for systems with high active power transfers. Often, the two algorithms are used complementary, meaning that power flow programs implement both. Gauss-Seidel method is used to rapidly determine an approximate solution from a \"flat start\", and then the Newton-Raphson method is used to obtain the final accurate solution [4].","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#General-Properties","page":"In-depth Power Flow Solution","title":"General Properties","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Before we apply the Newton-Raphson method to the power flow equations, we review some of its general properties [2]. First of all, let us consider a real-valued continuously differentiable function f(x). The Newton-Raphson method provides a good approximation for the root of the function f(x):","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  f(x)= 0","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Newton-Raphson method or Newton's method is essentially based on the Taylor series expansion. Namely, at any point x_0 equiv x^(0), the function f(x) is:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  f(x) = f(x^(0)) + (x-x^(0))fracmathrm df(x^(0))mathrm d x +\n  frac(x-x^(0))^22fracmathrm d^2f(x^(0))mathrm dx^2 + dots","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Neglecting the quadratic and high order terms and taking:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  Deltax^(0)=x- x^(0)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"we obtain a linear function (i.e., an affine function) f_texta(x) of the non-linear function f(x) at the point x^(0):","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  f_texta(x) = f(x^(0)) + Delta x^(0) fracmathrm df(x^(0))mathrm d x","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The expression represents a tangent line of the function f(x) at the point x^(0) f( x^(0)), as shown in Figure 1. Now, we are interested in determining the root of the equation:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f(x^(0)) + Delta x^(0) fracmathrm df(x^(0))mathrm d x = 0  to \n    Delta x^(0) = -cfracf(x^(0))cfracmathrm df(x^(0))mathrm d x","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Thus, we reveal the root x^(1) of the equation f_texta(x):","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  x^(1) = x^(0) + Delta x^(0)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"<img src=\"../../assets/lin_fx.png\" class=\"center\"/>\n<figcaption>Figure 1: The linearized function of the non-linear function around a given point.</figcaption>\n&nbsp;","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"In order to find the root x^* of the function f(x), the process is repeated using the Taylor series expansion at the point x^(1), which reveals a new point x^(2), and so on, moving towards a global solution x^*. Therefore, the Newton-Raphson is an iterative method, where we iteratively compute the increments and update solutions:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    Delta x^(nu) = -cfracf(x^(nu))cfracmathrm df(x^(nu))mathrm d x\n    x^(nu+1) = x^(nu) + Delta x^(nu)\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where nu = 01dotsnu_max is the iteration index and nu_max is the maximum number of iterations.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"For a complete description of the problem we expand the above model to a function of two variables f(xy). The affine function f_texta(xy) at the point  (x^(0)y^(0)) is defined:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"\tf_texta(xy)=f(x^(0)y^(0))+(x-x^(0)) fracmathrm partialf(x^(0)y^(0))\n\tmathrm partial x +\n\t(y-y^(0)) fracmathrm partialf(x^(0)y^(0))mathrm partial y","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Using the matrix notation, the above equation can be written in the form:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  f_texta(xy)=f(x^(0)y^(0)) +\n  beginbmatrix\n    cfracmathrm partialf(x^(0)y^(0))mathrm partial x \n    cfracmathrmpartialf(x^(0)y^(0)) mathrm partial y\n  endbmatrix\n    beginbmatrix Delta x^(0) Delta y^(0)\n  endbmatrix","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where the Jacobian matrix is:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfJ(x^(0)y^(0)) =\n  beginbmatrix\n    cfracmathrm partialf(x^(0)y^(0))mathrm partial x \n    cfracmathrmpartialf(x^(0)y^(0)) mathrm partial y\n  endbmatrix","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Although somewhat trivial, the above example gives us a good intuition and provides an easy transition to the n-dimensional case:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathbff(x) =leftf_1(mathbfx)dots f_n(mathbfx) right^T\n    mathbfx = leftx_1dots x_n right^T\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The linearization of the function mathbf f(mathbf x) at the point mathbf x^(nu) is defined by the Taylor expansion:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf f_texta(mathbf x)=mathbf f(mathbf x^(nu))+mathbf J(mathbf x^(nu)) mathbf Delta mathbf x^(nu)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"By taking mathbf f_texta(mathbf x) = mathbf 0, the vector of increments can be obtained by solving:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"   mathbf Delta mathbf x^(nu) = -mathbf J(mathbf x^(nu))^-1 mathbf f(mathbf x^(nu))","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"that is, written in the extended form:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginbmatrix Delta x_1^(nu)   vdots   Delta x_n^(nu) endbmatrix =\n  -beginbmatrix\n    cfracmathrm partialf_1(mathbf x^(nu))mathrm partial x_1 \n    dots \n    cfracmathrm partialf_1(mathbf x^(nu))mathrm partial x_n\n    vdots\n    cfracmathrm partialf_n(mathbf x^(nu))mathrm partial x_1 \n     \n    cfracmathrm partialf_n(mathbf x^(nu))mathrm partial x_n\n  endbmatrix^-1\n  beginbmatrix f_1(mathbf x^(nu)) vdots f_n(mathbf x^(nu)) endbmatrix","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Then, we obtain the solution:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf x^(nu + 1)=   mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/#Newton-Raphson-Applied-to-the-Power-Flow-Equations","page":"In-depth Power Flow Solution","title":"Newton-Raphson Applied to the Power Flow Equations","text":"","category":"section"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"In the following, we observe a power system with the set of buses mathcalH = 1dotsn . Without loss of generality, we assume that the slack bus is the first bus, followed by the set of PQ buses and the set of PV buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathcalH =  V theta cup mathcalPQ cup mathcalPV","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathcalPQ = 2 dots m \n    mathcalPV = m + 1dots n\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where m = n_textpq + 1, and n_textpq = mathcalPQ is the number of PQ buses.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Let us observe the vector given in the polar coordinate system:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf x_textsv = theta_1dotstheta_nV_1dotsV_n^T","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"In general, the vector mathbf x_textsv in mathbbR^2n contains elements whose values are known: (i) voltage angle theta_1 and magnitude V_1 at the slack bus; (ii) voltage magnitude at PV buses V_i i in mathcalPV. More precisely, the number of unknowns is n_textu = 2n-n_textpv - 2, where n_textpv = mathcalPV is the number of PV buses.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Thus, we observe the state vector mathbf x in mathbbR^n_textu and associated vector of increments mathbf Delta mathbf x in mathbbR^n_textu:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf x =\n  beginbmatrix\n    bm theta  mathbf V\n  endbmatrix \n  mathbf Delta mathbf x =\n  beginbmatrix\n    mathbf Delta bm theta  mathbf Delta mathbf V\n  endbmatrix","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    bm theta = theta_2dotstheta_n^T  mathbf Delta bm theta = Delta theta_2dotsDelta theta_n^T \n    mathbf V = V_2dotsV_m^T  mathbf Delta mathbf V = Delta V_2dotsDelta V_m^T\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The apparent power at the bus i in mathcalH is a function of the complex bus voltage S_i=f(bar V_i). Hence, the real and imaginary components of the apparent power define the active and reactive power injection expressions:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j\n    (G_ijcostheta_ij+B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j\n    (G_ijsintheta_ij-B_ijcostheta_ij)\n\tendaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Based on the above equations, it is possible to define the active power injection functions for PV and PQ buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalPV cup mathcalPQ","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection functions for PQ buses:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalPQ","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Functions f_P_i(mathbf x) and f_Q_i(mathbf x) are called active and reactive mismatch, respectively, and are often marked as Delta P_i(mathbf x) and Delta Q_i(mathbf x). The first terms on the right-hand side represents power injections into the bus i, while the second term is constant and represents active and reactive powers from generators and loads connected to the bus i. Thus, the power flow problem is described by the system of equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbff(x) =\n  beginbmatrix\n      f_P_2(mathbf x)  vdots  f_P_n(mathbf x)  f_Q_2(mathbf x)  vdots  f_Q_m(mathbf x)\n  endbmatrix =\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where the first n - 1 equations are defined for PV and PQ buses, while the last m-1 equations are defined only for PQ buses.","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Applying the Newton-Raphson method over power flow equations we have:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"\tmathbfJ(x^(nu))mathbf Delta x^(nu)+mathbf f(x^(nu))=0  to \n  mathbf Delta x^(nu) = -mathbfJ(x^(nu))^-1mathbf f(x^(nu))","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf x^(nu + 1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where the Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_textu times n_textu is:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n  cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n  hline \n  cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"As we can see, the Jacobian matrix can be written using four block matrices:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"\t  mathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where diagonal elements of the Jacobian sub-matrices are defined according to:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n  V_i^(nu)sumlimits_j=1^n V_j^(nu)(-G_ij\n  sintheta_ij^(nu)+B_ijcostheta_ij^(nu)) - (V_i^(nu))^2B_ii\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_i^(nu) = sumlimits_\n  j=1^n V_j^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))+V_i^(nu) G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_i=V_i^(nu)\n  sumlimits_j=1^n V_j^(nu)\n  (G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu))- (V_i^(nu))^2G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial V_i=sumlimits_j=1\n  ^n V_j^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))-V_i^(nu) B_ii\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu))\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_j^(nu) = V_i^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (-G_ijcostheta_ij^(nu) -B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm\n  partial V_j=V_i^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))\n  endaligned","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To conclude, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"powerFlow/inDepthPowerFlow/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix\n  beginbmatrix\n    mathbfDelta theta^(nu)  mathbfDelta V^(nu)\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x^(nu))  mathbff_Q(mathbf x^(nu))\n  endbmatrix = mathbf 0","category":"page"},{"location":"operatingState/generator/#operatingStateGenerator","page":"Operating State of Generators","title":"Operating State of Generators","text":"","category":"section"},{"location":"operatingState/generator/","page":"Operating State of Generators","title":"Operating State of Generators","text":"Once the bus voltages are obtained from one of the analyses, it is possible to determine powers related to the generators. The function receives composite types PowerSystem and Result.","category":"page"},{"location":"operatingState/generator/","page":"Operating State of Generators","title":"Operating State of Generators","text":"generator!","category":"page"},{"location":"operatingState/generator/#JuliaGrid.generator!","page":"Operating State of Generators","title":"JuliaGrid.generator!","text":"The function computes powers related to generators.\n\ngenerator!(system::PowerSystem, result::Result)\n\nThe function updates the field result.generator of the composite type Result.\n\nAC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:200\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\ngenerator!(system, result)\n\nDC Power Flow Example\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\ngenerator!(system, result)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#buildPowerSystemModel","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The composite type PowerSystem with fields bus, branch, generator, acModel, dcModel, and basePower can be created using a function:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"powerSystem().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Once the model is created, it is possible to add buses, branches and generators using the functions:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBus!()\naddBranch!()\naddGenerator!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"In addition, it is possible to manipulate the parameters of buses, branches and generators using functions:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"shuntBus!()\nstatusBranch!()\nparameterBranch!()\nstatusGenerator!()\noutputGenerator!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The execution of these functions will automatically trigger the update of all fields affected by these functions. Changing other parameters of the power system can be done by changing variables by accessing their values in fields bus, branch and generator of the composite type powerSystem.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"At any moment after the composite type PowerSystem is formed, it is possible to save the data in HDF5 format that describe the power system:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"savePowerSystem().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"To create vectors and matrices obtained based on the power system topology and parameters, following functions are used:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"acModel!()\ndcModel!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Note that, functions can be executed at any time, and when all power system buses are defined. More precisely, once the field acModel and dcModel are formed, using function addBranch!(), will automatically trigger the update of these fields. In contrast, adding a new bus, using addBus!(), requires executing the functions acModel!() and dcModel!() again. Further, the execution of the functions related to parameter manipulation of buses and branches will automatically trigger the update of the fields acModel and dcModel.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Build-Model","page":"Build Power System Model","title":"Build Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The function builds the composite type PowerSystem and populates fields bus, branch, generator and basePower.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"powerSystem","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.powerSystem","page":"Build Power System Model","title":"JuliaGrid.powerSystem","text":"The path to the HDF5 file with the .h5 extension should be passed to the function:\n\npowerSystem(\"pathToExternalData/name.h5\")\n\nSimilarly, the path to the Matpower file with the .m extension should be passed to the same function:\n\npowerSystem(\"pathToExternalData/name.m\")\n\nIgnoring the function argument initializes the composite type PowerSystem, which enables building the model from scratch:\n\npowerSystem()\n\nOnce the composite type PowerSystem is created it is possible to add new buses, branches or generators, and also change the parameters of the existing ones.\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Bus-Functions","page":"Build Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change bus parameters and update the field bus.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBus!\nshuntBus!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addBus!","page":"Build Power System Model","title":"JuliaGrid.addBus!","text":"The function adds a new bus, and updates the field bus. Names, descriptions and units of keywords are given in the table bus group.\n\naddBus!(system::PowerSystem; label, slackLabel, area, lossZone, active, reactive,\n    conductance, susceptance, magnitude, angle, minMagnitude, maxMagnitude, base)\n\nThe keyword label is mandatory. Default keyword values are set to zero, except for keywords lossZone = 1, area = 1, magnitude = 1.0, minMagnitude = 0.9, and maxMagnitude = 1.1.\n\nThe slack bus, using the keyword slackLabel, can be specified in each function call with the label of the bus being defined or already existing. If the bus is not defined as slack, the function addBus!() automatically defines the bus as the demand bus (PQ). If a generator is connected to a bus, using the function addGenerator!(), the bus becomes a generator bus (PV).\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, slackLabel = 1, active = 0.25, reactive = -0.04)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.shuntBus!","page":"Build Power System Model","title":"JuliaGrid.shuntBus!","text":"The function allows changing conductance and susceptance parameters of the shunt element connected to the bus.\n\nshuntBus!(system::PowerSystem; label, conductance, susceptance)\n\nThe keyword label should correspond to the already defined bus label. Keywords conductance or susceptancecan be omitted, then the value of the omitted parameter remains unchanged. The function also updates the field acModel, if field exist.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\nshuntBus!(system; label = 1, conductance = 0.04)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Branch-Functions","page":"Build Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change branch parameters. Further, functions update the field branch, but also fields acModel and dcModel. More precisely, once acModel and dcModel are created, the execution of functions will automatically trigger the update of these fields.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addBranch!","page":"Build Power System Model","title":"JuliaGrid.addBranch!","text":"The function adds a new branch. Names, descriptions and units of keywords are given in the table branch group. A branch can be added between already defined buses.\n\naddBranch!(system::PowerSystem; label, from, to, status, resistance, reactance,\n    susceptance, turnsRatio, shiftAngle, longTerm, shortTerm, emergency,\n    minAngleDifference, maxAngleDifference)\n\nThe keywords label, from, to, and one of the parameters resistance or reactance are mandatory. Default keyword values are set to zero, except for keywords status = 1, minAngleDifference = -2*pi, maxAngleDifference = 2*pi.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.statusBranch!","page":"Build Power System Model","title":"JuliaGrid.statusBranch!","text":"The function allows changing the operating status of the branch, from in-service to out-of-service, and vice versa.\n\nstatusBranch!(system::PowerSystem; label, status)\n\nThe keywords label should correspond to the already defined branch label.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nstatusBranch!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.parameterBranch!","page":"Build Power System Model","title":"JuliaGrid.parameterBranch!","text":"The function parameterBranch! allows changing resistance, reactance, susceptance, turnsRatio and shiftAngle parameters of the branch.\n\nparameterBranch!(system::PowerSystem; label, resistance, reactance, susceptance,\n    turnsRatio, shiftAngle)\n\nThe keywords label should correspond to the already defined branch label. Keywords resistance, reactance, susceptance, turnsRatio or shiftAngle can be omitted, and then the value of the omitted parameter remains unchanged.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nparameterBranch!(system; label = 1, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Generator-Functions","page":"Build Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change generator parameters. Further, functions update fields generator and bus.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addGenerator!\nstatusGenerator!\noutputGenerator!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addGenerator!","page":"Build Power System Model","title":"JuliaGrid.addGenerator!","text":"The function adds a new generator. Names, descriptions and units of keywords are given in the table generator group. A generator can be added to an already-defined bus.\n\naddGenerator!(system::PowerSystem; label, bus, area, status, active, reactive, magnitude,\n    minActive, maxActive, minReactive, maxReactive, lowerActive, minReactiveLower,\n    maxReactiveLower, upperActive, minReactiveUpper, maxReactiveUpper, loadFollowing,\n    reserve10minute, reserve30minute, reactiveTimescale, activeModel, activeStartup,\n    activeShutdown, activeDataPoint, activeCoefficient, reactiveModel, reactiveStartup,\n    reactiveShutdown, reactiveDataPoint, reactiveCoefficient)\n\nThe keywords label and bus are mandatory. Default keyword values are set to zero, except for keywords status = 1, magnitude = 1.0, maxActive = Inf, minReactive = -Inf, maxReactive = Inf, activeModel = 2, activeDataPoint = 3, reactiveModel = 2, and reactiveDataPoint = 3.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\n\naddGenerator!(system; label = 1, bus = 1, active = 0.5 reactive = 0.1)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.statusGenerator!","page":"Build Power System Model","title":"JuliaGrid.statusGenerator!","text":"The function allows changing the operating status of the generator, from in-service to out-of-service, and vice versa.\n\nstatusGenerator!(system::PowerSystem; label, status)\n\nThe keywords label should correspond to the already defined generator label.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\n\naddGenerator!(system; label = 1, bus = 1, active = 0.5 reactive = 0.1)\nstatusGenerator!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.outputGenerator!","page":"Build Power System Model","title":"JuliaGrid.outputGenerator!","text":"The function allows changing active and reactive output power of the generator.\n\noutputGenerator!(system::PowerSystem; label, active, reactive)\n\nThe keywords label should correspond to the already defined generator label. Keywords active or reactive can be omitted, then the value of the omitted parameter remains unchanged.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\n\naddGenerator!(system; label = 1, bus = 1, active = 0.5 reactive = 0.1)\noutputGenerator!(system; label = 1, active = 0.85)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#saveModel","page":"Build Power System Model","title":"Save Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Function receives the composite type PowerSystem and arguments by keyword to set the path, reference and note of the data set.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"savePowerSystem","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.savePowerSystem","page":"Build Power System Model","title":"JuliaGrid.savePowerSystem","text":"The function saves power system data in the HDF5 file using fields bus, branch, generator and basePower of the composite type PowerSystem.\n\nsavePowerSystem(system::PowerSystem; path, reference, note)\n\nThe keyword path::String is mandatory in the form \"path/name.h5\", while keywords reference::String and note::String are optional.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"C:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Build-AC-and-DC-Model","page":"Build Power System Model","title":"Build AC and DC Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The functions receive the composite type PowerSystem and form vectors and matrices related to AC or DC simulations.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"acModel!\ndcModel!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.acModel!","page":"Build Power System Model","title":"JuliaGrid.acModel!","text":"We advise the reader to read the section in-depth AC Model, that explains all the data involved in the field acModel.\n\nacModel!(system::PowerSystem)\n\nThe function updates the field acModel. Once formed, the field will be automatically updated when using functions addBranch!(), shuntBus!(), statusBranch!(), parameterBranch!().\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.dcModel!","page":"Build Power System Model","title":"JuliaGrid.dcModel!","text":"We advise the reader to read the section in-depth DC Model, that explains all the data involved in the field dcModel.\n\ndcModel!(system::PowerSystem)\n\nThe function updates the field dcModel. Once formed, the field will be automatically updated when using functions addBranch!(), statusBranch!(), parameterBranch!().\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#powerFlowSolution","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The solution of the power flow analysis implies the determination of the bus voltages. To obtain a solution, the framework requires the composite type PowerSystem with fields bus, branch, generator. In addition, depending on whether AC or DC power flow analysis is used, acModel or dcModel is required.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"JuliaGrid stores results in the composite type Result with fields:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus\nbranch\ngenerator\nalgorithm.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Once the composite type PowerSystem is created, it is possible to create the composite type Result. The composite type Result in the DC power flow analysis is created when determining the bus voltage angle using the function dcPowerFlow(). In contrast, the AC power flow analysis first requires the initialization of the iterative method, during which the composite type Result is created:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson()\nfastNewtonRaphsonBX()\nfastNewtonRaphsonXB()\ngaussSeidel().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The calculation of the bus voltages, depending on the type of analysis and the selected method, can be performed using one of the functions:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson!()\nfastNewtonRaphson!()\ngaussSeidel!()\ndcPowerFlow().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Note that methods for solving the AC power flow problem should be called inside a loop, thus simulating an iterative process.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Then, it is possible to calculate powers related to buses, powers and currents related to branches, and powers related to generators:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus!()\nbranch!()\ngenerator!().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Newton-Raphson-Method","page":"Power Flow Solution","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson\nnewtonRaphson!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.newtonRaphson","page":"Power Flow Solution","title":"JuliaGrid.newtonRaphson","text":"The function receives the composite type PowerSystem, initializes the Newthon-Raphson method, and returns the composite type Result.\n\nnewtonRaphson(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.newtonRaphson!","page":"Power Flow Solution","title":"JuliaGrid.newtonRaphson!","text":"The function receives the composite type PowerSystem and Result. Using the Newthon-Raphson method, the function computes bus voltage magnitudes and angles.\n\nnewtonRaphson!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Fast-Newton-Raphson-Method","page":"Power Flow Solution","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"fastNewtonRaphsonBX\nfastNewtonRaphsonXB\nfastNewtonRaphson!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonBX","text":"The function receives the composite type PowerSystem, initializes the fast Newthon-Raphson method of version BX, and returns the composite type Result.\n\nfastNewtonRaphsonBX(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonXB","text":"The function receives the composite type PowerSystem, initializes the fast Newthon-Raphson method of version XB, and returns the composite type Result.\n\nfastNewtonRaphsonXB(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphson!","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphson!","text":"The function receives the composite type PowerSystem and Result. Using the fast Newthon-Raphson method, the function computes bus voltage magnitudes and angles.\n\nfastNewtonRaphson!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonBX(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:100\n    fastNewtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Gauss-Seidel-Method","page":"Power Flow Solution","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"gaussSeidel\ngaussSeidel!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.gaussSeidel","page":"Power Flow Solution","title":"JuliaGrid.gaussSeidel","text":"The function receives the composite type PowerSystem, initializes the Gauss-Seidel method, and returns the composite type Result.\n\ngaussSeidel(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.gaussSeidel!","page":"Power Flow Solution","title":"JuliaGrid.gaussSeidel!","text":"The function receives the composite type PowerSystem and Result. Using the Gauss-Seidel method, the function computes bus voltage magnitudes and angles.\n\ngaussSeidel!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:1000\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#DC-Power-Flow-Solution","page":"Power Flow Solution","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"dcPowerFlow","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.dcPowerFlow","page":"Power Flow Solution","title":"JuliaGrid.dcPowerFlow","text":"The function receives the composite type PowerSystem, solves the DC power flow problem by determining bus voltage angles, and returns the composite type Result.\n\ndcPowerFlow(system::PowerSystem)\n\nThe function updates field result.bus.voltage.angle and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"#JuliaGrid","page":"Home","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACDCModel","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Network equations obtained using the unified branch model and defined below represent the basic setup used for the power system analysis. The power system network topology is usually described by the bus/branch model, where branches of the network are defined using the two-port pi-model. The bus/branch model can be represented using a graph mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n represents the set of buses, while the set of edges mathcalE subseteq mathcalN times mathcalN represents the set of branches of the power network.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACModel","page":"In-depth AC and DC Model","title":"In-depth AC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"JuliaGrid is based on common network elements and benefits the unified branch model to perform various analyses based on the system of non-linear equations. To create vectors and matrices related with AC or non-linear analyses, JuliaGrid uses the function acModel!(), for example:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)","category":"page"},{"location":"powerSystem/inDepthACDCModel/#ACBranchModel","page":"In-depth AC and DC Model","title":"AC Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The equivalent unified pi-model for a branch (ij) in mathcalE incident to the buses ij in mathcalN is shown in Figure 2.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/pi_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The equivalent branch model, where transformer is located at \"from bus end\" of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    y_ij = frac1z_ij =\n    frac1r_ij + textjx_ij =\n    fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.resistance\njulia> system.branch.parameter.reactance\njulia> system.acModel.admittance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The branch shunt capacitive admittance (i.e. charging admittance) y_textsij at buses ij is equal to:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"y_textsij = textj b_textsij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note that JuliaGrid stores the total branch shunt capacitive susceptance 2b_textsij:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.susceptance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where tau_ij is the transformer turns ratio, while phi_ij is the transformer phase shift angle, always located \"from bus end\" of the branch.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.turnsRatio\njulia> system.branch.parameter.shiftAngle\njulia> system.acModel.transformerRatio","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The values of the terms left((y_ij + y_textsij)  tau_ij^2right), left(-alpha_ij^*y_ijright), left(-alpha_ijy_ijright), and left(y_ij + y_textsijright) can be found stored in four separate arrays, respectively:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.nodalFromFrom\njulia> system.acModel.nodalFromTo\njulia> system.acModel.nodalToFrom\njulia> system.acModel.nodalToTo","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if phi_ij = 0 and y_textsij = 0, while phase-shifting transformers are obtained if y_textsij = 0.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#ACNodalMatrix","page":"In-depth AC and DC Model","title":"AC Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Let us consider an example, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with admittance y_textshk.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/pi_model_example.png\" class=\"center\"/>\n<figcaption>Figure 3: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"According to the unified branch model each branch is described using the system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_pk^*y_pk\n    -alpha_pky_pk  y_pk + y_textspk\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_kq^2(y_kq + y_textskq)  -alpha_kq^*y_kq\n    -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The injection complex currents into buses are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    barI_p = barI_pk = cfrac1tau_pk^2(y_pk + y_textspk) barV_p -alpha_kq^*y_kq barV_k \n    barI_k = barI_kp + barI_kq - barI_textshk =\n    -alpha_kqy_kq barV_p + (y_kq + y_textskq) barV_k +\n    cfrac1tau_kq^2(y_kq + y_textskq) barV_k -alpha_kq^*y_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = -alpha_kqy_kq barV_k + (y_kq + y_textskq) barV_q\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_kq^*y_kq  0 \n   -alpha_kqy_kq  y_kq + y_textskq + cfrac1tau_kq^2(y_kq + y_textskq) + y_textshk   -alpha_kq^*y_kq \n    0  -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where mathbf bar V in mathbbC^n is the vector of bus complex voltages, and mathbf bar I in mathbbC^n is the vector of injection complex currents.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The matrix mathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nY_ii = G_ii + textjB_ii = y_textshi +\nsumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2(y_ij + y_textsij) + sumlimits_e in mathcalE  e(2) = i (y_ij + y_textsij)\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nY_ij = G_ij + textjB_ij = -alpha_ij^*y_ij\nY_ji = G_ji + textjB_ji =  -alpha_ijy_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse matrix (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [1, Sec. 9.6].","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.nodalMatrix\njulia> system.acModel.nodalMatrixTranspose","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthDCModel","page":"In-depth AC and DC Model","title":"In-depth DC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The DC model is obtained by linearisation of the non-linear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all shunt susceptance elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles bm theta as state variables. To create vectors and matrices related with DC or linear analyses, JuliaGrid uses the function dcModel!(), for example:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#DCBranchModel","page":"In-depth AC and DC Model","title":"DC Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"According to the above assumptions, we start from the unified branch model:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    beginbmatrix\n      barI_ij  barI_ji\n    endbmatrix = cfrac1textjx_ij\n    beginbmatrix\n      cfrac1tau_ij^2  -alpha_ij^*\n      -alpha_ij  1\n    endbmatrix\n    beginbmatrix\n      barV_i  barV_j\n    endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The real components are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.admittance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active power to bus voltage angles, versus complex currents to complex bus voltages in the AC case [2]. Consequently, analogous to the unified branch model we can write:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#DCNodalMatrix","page":"In-depth AC and DC Model","title":"DC Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"As before, let us consider an example of the DC framework, given in Figure 2, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with conductance g_textshk.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/dc_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Each branch in the DC framework is described with system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix = cfrac1tau_pkx_pk\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix + cfracphi_pktau_pkx_pk\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix = cfrac1tau_kqx_kq\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix + cfracphi_kqtau_kqx_kq\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The injection active powers into buses are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_p = P_pk =cfrac1tau_pkx_pk theta_p - cfrac1tau_pkx_pk theta_k - cfracphi_pktau_pkx_pk \n    P_k = P_kp + P_kq - P_textshk = -cfrac1tau_pkx_pk theta_p + cfrac1tau_pkx_pk theta_k + cfracphi_pktau_pkx_pk +\n    cfrac1tau_kqx_kq theta_k - cfrac1tau_kqx_kq theta_q - cfracphi_kqtau_kqx_kq + g_textshk \n    P_q = P_qk = -cfrac1tau_kqx_kq theta_k +cfrac1tau_kqx_kq theta_q + cfracphi_kqtau_kqx_kq\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note that the active power injected by the shunt element into the bus i in mathcalN is equal to:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  P_textshi = RebarV_ibarI_textshi^* = Re-barV_iy_textshi^*barV_i^* = - g_textshi","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pkx_pk  - cfrac1tau_pkx_pk  0 \n    -cfrac1tau_pkx_pk  cfrac1tau_pkx_pk + cfrac1tau_kqx_kq   -cfrac1tau_kqx_kq \n    0  -cfrac1tau_kqx_kq cfrac1tau_kqx_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_pktau_pkx_pk  cfracphi_pktau_pkx_pk - cfracphi_kqtau_kqx_kq  cfracphi_kqtau_kqx_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfP_textsh","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where bm theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbf P in mathbbR^n contains injected active powers into buses caused by generators and demands. In JuliaGrid, the vector can be recovered using an expression:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbfP_textgs in mathbbR^n represents active powers related with non-zero shift angle of transformers.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.shiftActivePower","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbfP_textsh in mathbbR^n represents active powers consumed by shunt elements.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.bus.shunt.conductance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The bus or nodal matrix in the DC framework is given as mathbfB in mathbbC^n times n, with elements:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nB_ii = sumlimits_e in mathcalE i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nB_ij = -cfrac1tau_ijx_ij\nB_ji = -cfrac1tau_ijx_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.nodalMatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACDCModelReference","page":"In-depth AC and DC Model","title":"References","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"[1] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"[2] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER Users Manual, Version 7.0. 2019.","category":"page"},{"location":"powerSystem/model/#powerSystemModel","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with fields:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"bus\nbranch\ngenerator\nacModel\ndcModel\nbasePower.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The function powerSystem() returns the composite type PowerSystem with all fields. The fields bus, branch, generator hold the data related to buses, branches and generators, respectively. Fields acModel and dcModel store vectors and matrices obtained based on the power system topology and parameters. The base power of the system is kept in the field basePower, given in volt-ampere unit. JuliaGrid supports three modes to build the composite type PowerSystem:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"using built-in functions,\nusing HDF5 file format,\nusing Matpower case files.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Note that, in the case of large-scale systems, we strongly recommend to use the HDF5 file format for the input. Therefore, JuliaGrid has the function savePowerSystem() that any system loaded from Matpower case files or a system formed using built-in functions can be saved in the HDF5 format.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The HDF5 file format contains three groups: bus, branch and generator. In addition, the file contains basePower variable, given in volt-ampere. Each group is divided into subgroups that gather the same type of physical quantities, with the corresponding datasets. Note that, dataset names are identical to the keywords, which are used when the power system model is formed using built-in functions.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#busGroup","page":"Power System Model","title":"Bus Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The bus group is divided into four subgroups: layout, demand, shunt, and voltage. Each of the subgroups contains datasets that define the features of the buses.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique bus label - positive integer\nlayout slackLabel bus label of the slack bus - positive integer\nlayout lossZone loss zone - positive integer\nlayout area area number - positive integer\ndemand active active power demand per-unit float\ndemand reactive reactive power demand per-unit float\nshunt conductance active power demanded of the shunt element at voltage magnitude equal to 1 per-unit per-unit float\nshunt susceptance reactive power injected of the shunt element at voltage magnitude equal to 1 per-unit per-unit float\nvoltage magnitude initial value of the voltage magnitude per-unit float\nvoltage angle initial value of the voltage angle radian float\nvoltage minMagnitude minimum allowed voltage magnitude value per-unit float\nvoltage maxMagnitude maximum allowed voltage magnitude value per-unit float\nvoltage base base value of the voltage magnitude volt float","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#branchGroup","page":"Power System Model","title":"Branch Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The branch group is divided into four subgroups: layout, parameter, voltage, and rating. Each of the subgroups contains datasets that define the features of the branches.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique branch label - positive integer\nlayout from from bus label (corresponds to the bus label) - positive integer\nlayout to to bus label (corresponds to the bus label) - positive integer\nlayout status operating status of the branch, in-service = 1, out-of-service = 0 - zero-one integer\nparameter resistance branch resistance per-unit float\nparameter reactance branch reactance per-unit float\nparameter susceptance total line charging susceptance per-unit float\nparameter turnsRatio transformer off-nominal turns ratio, equal to zero for a line - float\nparameter shiftAngle transformer phase shift angle where positive value defines delay radian float\nvoltage minAngleDifference minimum allowed voltage angle difference value between from and to bus radian float\nvoltage maxAngleDifference maximum allowed voltage angle difference value between from and to bus radian float\nrating shortTerm short-term rating (equal to zero for unlimited) per-unit float\nrating longTerm long-term rating (equal to zero for unlimited) per-unit float\nrating emergency emergency rating (equal to zero for unlimited) per-unit positive integer","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#generatorGroup","page":"Power System Model","title":"Generator Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The generator group is divided into six subgroups: layout, output, voltage, capability, ramRate, and cost. Each of the subgroups contains datasets that define the features of the generators.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique generator label - positive integer\nlayout bus bus label to which the generator is connected - positive integer\nlayout status operating status of the generator, in-service = 1, out-of-service = 0 - zero-one integer\nlayout area area participation factor - float\noutput active output active power of the generator per-unit float\noutput reactive output reactive power of the generator per-unit float\nvoltage magnitude voltage magnitude setpoint per-unit float\ncapability minActive minimum allowed output active power value of the generator per-unit float\ncapability maxActive maximum allowed output active power value of the generator per-unit float\ncapability minReactive minimum allowed output reactive power value of the generator per-unit float\ncapability maxReactive maximum allowed output reactive power value of the generator per-unit float\ncapability lowerActive lower allowed active power output value of PQ capability curve per-unit float\ncapability minReactiveLower minimum allowed reactive power output value at lowerActive value per-unit float\ncapability maxReactiveLower maximum allowed reactive power output value at lowerActive value per-unit float\ncapability upperActive upper allowed active power output value of PQ capability curve per-unit float\ncapability minReactiveUpper minimum allowed reactive power output value at upperActive value per-unit float\ncapability maxReactiveUpper maximum allowed reactive power output value at upperActive value per-unit float\nrampRate loadFollowing ramp rate for load following/AGC per-unit/minute float\nrampRate reserve10minute ramp rate for 10-minute reserves per-unit float\nrampRate reserve30minute ramp rate for 30-minute reserves per-unit float\nrampRate reactiveTimescale ramp rate for reactive power (two seconds timescale) per-unit/minute float\ncost activeModel active power cost model, piecewise linear = 1, polynomial = 2 - one-two integer\ncost activeStartup active power startup cost currency float\ncost activeShutdown active power shutdown cost currency float\ncost activeDataPoint number of data points for active power cost model - positive integer\ncost activeCoefficient coefficients for forming the active power cost function (*) float\ncost reactiveModel reactive power cost model, piecewise linear = 1, polynomial = 2 - one-two integer\ncost reactiveStartup reactive power startup cost currency float\ncost reactiveShutdown reactive power shutdown cost currency float\ncost reactiveDataPoint number of data points for reactive power cost model - positive integer\ncost reactiveCoefficient coefficients for forming the reactive power cost function (*) float","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"&nbsp;","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The interpretation of the datasets activeCoefficient and reactiveCoefficient, given as matrices, depends on the activeModel and reactiveModel that is selected:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"piecewise linear cost model is defined according to input-output points, where the i-th row of the matrix is given as:\nactiveCoefficient: p_1 f(p_1) p_2 f(p_2) dots p_n f(p_n),\nreactiveCoefficient: q_1 f(q_1) q_2 f(q_2) dots q_n f(q_n).\npolynomial cost model is defined using the n-th degree polynomial, where the i-th row of the matrix is given as:\nactiveCoefficient: a_n dots a_1 a_0 to define f(p) = a_n p^n + dots + a_1 p + a_0,\nreactiveCoefficient: b_n dots b_1 b_0 to define f(q) = b_n q^n + dots + b_1 q + b_0.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"(*) Thus, for the piecewise linear model p_i and q_i are given in per-unit, while f(p_i) and f(q_i) have a dimension of currency/hour. In the polynomial model coefficients are dimensionless.","category":"page"}]
}
