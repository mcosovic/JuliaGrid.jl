var documenterSearchIndex = {"docs":
[{"location":"powerSystem/model/#powerSystemModel","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with the following fields: bus, branch, generator, base, acModel, and dcModel. The fields bus, branch, and generator hold data related to buses, branches, and generators, respectively. The base field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes (VA) for the base power and line-to-line voltages measured in volts (V) for base voltages. The default settings can be changed by utilizing the macro command before executing any function:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"@unit","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Finally, the acModel and dcModel fields store vectors and matrices calculated based on the power system's topology and parameters.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The composite type PowerSystem can be created using a function:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"powerSystem().","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports three modes for populating the PowerSystem type: using built-in functions, using HDF5 file format, and using Matpower case files. It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem().","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"This function allows to save power systems that were either loaded from Matpower case files or created using built-in functions in the HDF5 format.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type is created, you can add buses, branches, and generators using the following functions:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"addBus!()\naddBranch!()\naddGenerator!().","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"In addition, it is possible to manipulate the parameters of buses, branches, and generators using the following functions:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"shuntBus!()\nstatusBranch!()\nparameterBranch!()\nstatusGenerator!()\noutputGenerator!().","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Executing these functions will automatically update all fields affected by them. You can also change other parameters of the power system by accessing and modifying the values in the bus, branch, generator, and base fields of the PowerSystem composite type. The input electrical quantities should be entered in per-units or radians, but this default setting can be altered using the macro @unit.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"To create vectors and matrices based on the power system topology and parameters, you can use the following functions:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"acModel!()\ndcModel!().","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Note that these functions can be executed at any time once all power system buses are defined. Specifically, using the addBranch!() function to add a new branch will automatically update the acModel and dcModel fields. However, adding a new bus using addBus!() requires executing the acModel!() and dcModel!() functions again. In addition, executing functions related to parameter manipulation of buses and branches will also automatically update the acModel and dcModel fields.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#Build-Model","page":"Power System Model","title":"Build Model","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"powerSystem","category":"page"},{"location":"powerSystem/model/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"The function builds the composite type PowerSystem and populates bus, branch,  generator and base fields. In general, once the composite type PowerSystem has been  created, it is possible to add new buses, branches, or generators, or modify the parameters  of existing ones.\n\nTo use the powerSystem() function, the path to the HDF5 file with the .h5 extension can  be passed as arguments. For example: \n\npowerSystem(\"pathToExternalData/name.h5\")\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\nSimilarly, the path to the Matpower file with the .m extension can be passed to the same  function:\n\npowerSystem(\"pathToExternalData/name.m\")\n\nExample\n\nsystem = powerSystem(\"case14.m\")\n\nAlternatively, the PowerSystem composite type can be initialized by calling the function  without any arguments: \n\npowerSystem()\n\nThis allows the model to be built from scratch and modified as needed.\n\nExample\n\nsystem = powerSystem()\n\nUnits\n\nJuliaGrid stores all data, with the exception of base values, in per-unit and radians,  and these cannot be altered. By default, the units for base power and base voltages are  set to volt-ampere (VA) and volt (V), but prefixes can be modified using the macro:\n\n@unit(base, MVA, kV)\n\nThe macro for setting base units must be executed prior to constructing the composite type  PowerSystem.\n\nExample\n\n@unit(base, MVA, kV)\nsystem = powerSystem(\"case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#Save-Model","page":"Power System Model","title":"Save Model","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem","category":"page"},{"location":"powerSystem/model/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"The function savePowerSystem, saves the power system's data in the HDF5 file using the  fields 'bus', 'branch', 'generator', and 'base' from the composite type 'PowerSystem'. \n\nsavePowerSystem(system::PowerSystem; path, reference, note)\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword  'path::String' in the format of \"path/name.h5\". Additional information can be provided by  the optional keywords 'reference::String' and 'note::String'.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/inDepthAnalysis/#inDepthPowerFlowAnalysis","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"After the bus voltages are determined, it is possible to determine other electrical quantities. JuliaGrid stores complex currents in the polar coordinate system, while complex powers are stored in the rectangle coordinate system. In the rest of this part, we define electrical quantities evaluated by JuliaGrid.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#AC-Power-Flow-Analysis","page":"In-depth Power Flow Analysis","title":"AC Power Flow Analysis","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The AC power flow analysis implies the calculation of powers and currents related to buses and branches, and powers related to generators. To perform the AC power flow analysis JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\nbus!(system, result)\nbranch!(system, result)\ngenerator!(system, result)","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#Bus","page":"In-depth Power Flow Analysis","title":"Bus","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The complex current injection at the bus can be obtained as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_i = sumlimits_j = 1^n Y_ij barV_j i in mathcalN","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.current.injection.magnitude\njulia> result.bus.current.injection.angle","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active and reactive power injections at the bus can be obtained using the expression:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    S_i =barV_ibarI_i^* i in mathcalN","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.injection.active\njulia> result.bus.power.injection.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active power of the generators that supply the bus i in mathcalN_textpv is equal to the sum of the given generator active powers in the input data, except for the slack bus, which is determined as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textsi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where P_textdi represents the active power demanded by consumers at the slack bus.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.supply.active","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The reactive power of the generators that supply the bus is equal to:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    Q_textsi = Q_i + Q_textdi i in mathcalN_textpv cup mathcalN_textsb","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where Q_textdi represents the reactive power demanded by consumers at the corresponding bus.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.supply.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active and reactive powers related to the shunt element at the bus are obtained using:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"  S_textshi =barV_ibarI_textshi^* = y_textshi^*barV_i^2 i in mathcalN","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.shunt.active\njulia> result.bus.power.shunt.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#Branch","page":"In-depth Power Flow Analysis","title":"Branch","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The complex current flow at the bus \"from\" i in mathcalN of the the branch can be obtained using the unified branch model:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_ij = cfrac1tau_ij^2(y_ij + y_textsij) barV_i - alpha_ij^*y_ij barV_j (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.current.from.magnitude\njulia> result.branch.current.from.angle","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Similarly, the complex current flow at the bus \"to\" j in mathcalN of the branch is equal to:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_ji = -alpha_ijy_ij barV_i + (y_ij + y_textsij) barV_j (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.current.to.magnitude\njulia> result.branch.current.to.angle","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The complex current flow through the series impedance of the branch in the direction from bus i in mathcalN to bus j in mathcalN is determined as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    barI_textbij =  y_ij (alpha_ijbarV_i - barV_j) (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.current.impedance.magnitude\njulia> result.branch.current.impedance.angle","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active and reactive power flows at the bus \"from\" i in mathcalN of the branch are obtained as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    S_ij = barV_ibarI_ij^* (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.from.active\njulia> result.branch.power.from.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active and reactive power flows at the bus \"to\" j in mathcalN of the branch are obtained as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    S_ji = barV_jbarI_ji^* (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.to.active\njulia> result.branch.power.to.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Active and reactive power losses of the branch arise due to the existence of the series impedance z_ij, and can be obtained as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    beginaligned\n        P_textlossij = r_ijbarI_textbij^2 \n        Q_textlossij = x_ijbarI_textbij^2\n    endaligned","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where (ij) in mathcalE.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.loss.active\njulia> result.branch.power.loss.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"Total reactive power injected by the branch due to the existence of capacitive susceptances is obtained as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    Q_textchij = b_textsi (alpha_ijbarV_i^2 - barV_j^2) (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.shunt.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#Generator","page":"In-depth Power Flow Analysis","title":"Generator","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The output active power of the generator at the bus i in mathcalN_textpv is equal to the given active power of the generator in the input data. Moreover, if there are several generators at the bus i in mathcalN_textpv their output active powers are still equal to the active powers given in the input data. The output active power of the generator at the slack bus is determined as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"When there are several generators at the slack bus, the active power P_textgi will be assigned to the first generator in the list of input data. After that this active power will be reduced by the output active power of the rest of the generators.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.generator.power.active","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The output reactive power of the generator at the bus is equal to:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    Q_textgi = Q_i + Q_textdi i in mathcalN_textpv cup mathcalN_textsb","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"In case there are several generators, the reactive power will be proportionally distributed between the generators based on their capabilities.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.generator.power.reactive","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#DC-Power-Flow-Analysis","page":"In-depth Power Flow Analysis","title":"DC Power Flow Analysis","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The DC power flow analysis implies the calculation of active powers related to buses, branches, and generators. To perform the DC power flow analysis JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\n\nbus!(system, result)\nbranch!(system, result)\ngenerator!(system, result)","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#Bus-2","page":"In-depth Power Flow Analysis","title":"Bus","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active power injection at the bus can be obtained using the expression:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"   P_i = sum_j = 1^n B_ij theta_j + P_textgsi + P_textshi i in mathcalN","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.injection.active","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active power of the generators that supply the bus i in mathcalN_textpv is equal to the given active power of the generators in the input data, except for the slack bus, which is determined as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textsi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"where P_textdi represents the active power demanded by consumers at the slack bus.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.bus.power.supply.active","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#Branch-2","page":"In-depth Power Flow Analysis","title":"Branch","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active power flow at the bus \"from\" i in mathcalN of the branch is obtained as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_ij = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.from.active","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The active power flow at the bus \"to\" j in mathcalN of the branch is obtained as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_ji = - P_ij (ij) in mathcalE","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.branch.power.to.active","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/inDepthAnalysis/#Generator-2","page":"In-depth Power Flow Analysis","title":"Generator","text":"","category":"section"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"The output active power of the generator at the bus i in mathcalN_textpv is equal to the given active power of the generator in the input data. Moreover, if there are several generators at the bus i in mathcalN_textpv their output active powers are still equal to the active powers given in the input data. The output active power of the generator at the slack bus is determined as:","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"    P_textgi = P_i + P_textdi i in mathcalN_textsb","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"When there are several generators at the slack bus, the active power P_textgi will be assigned to the first generator in the list of input data. After that this active power will be reduced by the output active power of the rest of the generators.","category":"page"},{"location":"powerFlow/inDepthAnalysis/","page":"In-depth Power Flow Analysis","title":"In-depth Power Flow Analysis","text":"julia> result.generator.power.active","category":"page"},{"location":"powerFlow/solution/#powerFlowSolution","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The solution of the power flow implies the calculation of the bus voltages. To obtain a solution, the framework requires the composite type PowerSystem with fields bus, branch, and generator. In addition, depending on whether AC or DC power flow is used, acModel or dcModel is required.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"JuliaGrid stores results in the composite type Result with fields:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus\nbranch\ngenerator\nalgorithm.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Once the composite type PowerSystem is created, it is possible to create the composite type Result. The composite type Result in the DC power flow is created when determining the bus voltage angles using the function dcPowerFlow(). In contrast, the AC power flow requires the initialization of the iterative method, during which the composite type Result is created:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson()\nfastNewtonRaphsonBX()\nfastNewtonRaphsonXB()\ngaussSeidel().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The calculation of the bus voltages, depending on the type of power flow and the selected method, can be performed using one of the functions:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson!()\nfastNewtonRaphson!()\ngaussSeidel!()\ndcPowerFlow().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Note that methods for solving the AC power flow problem should be called inside a loop, thus simulating an iterative process.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"In addition, JuliaGrid has an additional set of functions for power flow analysis, which includes determining the powers and currents related to buses, branches or generators:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus!()\nbranch!()\ngenerator!().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"JuliaGrid also provides the function that checks reactive power limits of the generators, once the solution of the AC power flow is obtained:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"reactivePowerLimit!()","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Newton-Raphson-Method","page":"Power Flow Solution","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson\nnewtonRaphson!","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Fast-Newton-Raphson-Method","page":"Power Flow Solution","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"fastNewtonRaphsonBX\nfastNewtonRaphsonXB\nfastNewtonRaphson!","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Gauss-Seidel-Method","page":"Power Flow Solution","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"gaussSeidel\ngaussSeidel!","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#DC-Power-Flow-Solution","page":"Power Flow Solution","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"dcPowerFlow","category":"page"},{"location":"powerFlow/reactiveLimits/#generatorReactivePowerLimits","page":"Generator Reactive Power Limits","title":"Generator Reactive Power Limits","text":"","category":"section"},{"location":"powerFlow/reactiveLimits/","page":"Generator Reactive Power Limits","title":"Generator Reactive Power Limits","text":"By default, the AC power flow methods solve the system of non-linear equations and reveal bus voltage magnitudes and angles ignoring any limits. However, JuliaGrid provides a function reactivePowerLimit!() that checks reactive power limits.","category":"page"},{"location":"powerFlow/reactiveLimits/","page":"Generator Reactive Power Limits","title":"Generator Reactive Power Limits","text":"reactivePowerLimit!","category":"page"},{"location":"powerFlow/reactiveLimits/","page":"Generator Reactive Power Limits","title":"Generator Reactive Power Limits","text":"","category":"page"},{"location":"powerFlow/reactiveLimits/","page":"Generator Reactive Power Limits","title":"Generator Reactive Power Limits","text":"Furthermore, if there is a slack bus conversion, it is possible to adjust the voltage angles according to the original slack bus.","category":"page"},{"location":"powerFlow/reactiveLimits/","page":"Generator Reactive Power Limits","title":"Generator Reactive Power Limits","text":"adjustVoltageAngle!","category":"page"},{"location":"powerFlow/analysis/#powerFlowAnalysis","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"section"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"Once the bus voltages are obtained, it is possible to calculate powers and currents related to buses and branches, and powers related to generators:","category":"page"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"bus!()\nbranch!()\ngenerator!().","category":"page"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"Note that the JuliaGrid stores complex currents in the polar coordinate system, while complex powers are stored in the rectangle coordinate system.","category":"page"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/analysis/#Bus","page":"Power Flow Analysis","title":"Bus","text":"","category":"section"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"bus!","category":"page"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/analysis/#Branch","page":"Power Flow Analysis","title":"Branch","text":"","category":"section"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"branch!","category":"page"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/analysis/#Generator","page":"Power Flow Analysis","title":"Generator","text":"","category":"section"},{"location":"powerFlow/analysis/","page":"Power Flow Analysis","title":"Power Flow Analysis","text":"generator!","category":"page"},{"location":"#JuliaGrid","page":"Home","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"},{"location":"powerFlow/inDepthSolution/#inDepthPowerFlowSolution","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid is based on common network elements and benefits the unified branch model to find the power flow solution and perform the power flow analysis,  which is used for defining load profiles, generator capabilities, voltage specification, contingency analysis, and planning. In the beginning, JuliaGrid requires the composite type PowerSystem, which is obtained by using the function powerSystem(), for example:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To recall, we observe the bus/branch model as a graph mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n represents the set of buses, while the set of edges mathcalE subseteq mathcalN times mathcalN represents the set of branches of the power network. As shown in section In-depth AC Model, we observe the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    mathbfbar I = mathbfY mathbfbar V","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The complex current injection at the bus i in mathcalN is defined as:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tbarI_i = cfracS_i^*barV_i^*","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where barV_i = V_i texte^textjtheta_i. Thus, for the bus i in mathcalN we have:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tcfracS_i^*barV_i^* = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The complex power injection S_i consists of the active power P_i and reactive power Q_i, therefore we have:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  \tcfracP_i - textjQ_ibarV_i = sum_j = 1^n Y_ij bar V_j","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"According to the last equation, for the bus i in mathcalN there are four unknown variables: active power injection P_i, reactive power injection Q_i, bus voltage magnitude V_i and bus voltage angle theta_i. To solve the system of equations, two variables for each equation need to be specified. Mathematically, any two variables may be selected, but the choice is dictated by the devices connected to a particular bus. Standard options are summarized in the table below and these options define bus types [1].","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Bus Type Label JuliaGrid Known Unknown\nSlack V theta 3 V_i, theta_i P_i, Q_i\nGenerator PV 2 P_i, V_i Q_i, theta_i\nDemand PQ 1 P_i, Q_i V_i, theta_i","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Consequently, JuliaGrid operates with sets mathcalN_textpv and mathcalN_textpq that contain PV and PQ buses, respectively, and exactly one slack bus in the set mathcalN_textsb. Note that JuliaGrid does not support systems with multiple slack buses. Julia internally designates PV or PQ bus type. Namely, if the bus is not marked as a slack bus, it becomes the PV bus only if it has at least one in-service generator, otherwise the bus is PQ type.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> system.bus.layout.type","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, we note according to Tellegen's theorem, the active P_i and reactive Q_i power injections are equal to:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  \tP_i = P_textsi - P_textdi \n    Q_i = Q_textsi - Q_textdi\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where P_textsi and Q_textsi denote the active and reactive powers of the generators that supply the bus i in mathcalN, while P_textdi and Q_textdi indicate active and reactive powers demanded by consumers at the bus i in mathcalN.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> system.bus.supply.active - system.bus.demand.active\njulia> system.bus.supply.reactive - system.bus.demand.reactive","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#inDepthNewtonRaphson","page":"In-depth Power Flow Solution","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Newton-Raphson method is generally preferred in power flow calculations because this method has a quadratic rate of convergence. First of all, the Newton-Raphson method provides a good approximation for the roots of the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbff(mathbfx) = mathbf0","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Hence, the Newton-Raphson method solves the system of non-linear equations mathbff(mathbfx), and reveals bus voltage magnitudes and angles mathbfx. According to bus types, some buses have known values of the voltage magnitudes and angles:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"at the slack bus i in mathcalN_textsb voltage magnitude V_i and angle theta_i are known;\nat PV buses i in mathcalN_textpv voltage magnitude V_i is known.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Thus, we observe the state vector mathbf x = bm theta mathbf V^T, where bm theta in mathbbR^n-1 and mathbf V in mathbbR^n_textpq, while n_textpq = mathcalN_textpq is the number of PQ buses.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The complex power injection S_i at the bus i in mathcalN is a function of the complex bus voltages. Hence, the real and imaginary components of the complex power define the active and reactive power injection expressions:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    P_i =V_isumlimits_j=1^n V_j (G_ijcostheta_ij+B_ijsintheta_ij)\n    Q_i =V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij)\n\tendaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Based on the above equations, it is possible to define the active power injection function for PV and PQ buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection function for PQ buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Functions f_P_i(mathbf x) and f_Q_i(mathbf x) are called active and reactive mismatch, respectively, and are often marked as Delta P_i(mathbf x) and Delta Q_i(mathbf x). The first terms on the right-hand side represent power injections at a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Thus, the Newton-Raphson method solves the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbff(x) =\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where the first n - 1 equations are defined according to PV and PQ buses, while the last n_textpq equations are defined according to PQ buses.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#Method-Implementation","page":"In-depth Power Flow Solution","title":"Method Implementation","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To solve the AC power flow and find the bus voltage magnitudes and angles using the Newton-Raphson method, JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Newton-Raphson method or Newton's method is essentially based on the Taylor series expansion, neglecting the quadratic and high-order terms. The Newton-Raphson is an iterative method, where we iteratively compute the increments:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfDelta x^(nu) = -mathbfJ(x^(nu))^-1mathbf f(x^(nu))","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where mathbfDelta x^(nu) = mathbf Delta bm theta^(nu) mathbf Delta mathbf V^(nu)^T consists of the vector of bus voltage angle increments mathbf Delta bm theta^(nu) in mathbbR^n-1 and bus voltage magnitude increments mathbf Delta mathbf V^(nu) in mathbbR^n_textpq, and mathbfJ(x^(nu))in mathbbR^n_textu times n_textu is the Jacobian matrix, n_textu = n + n_textpq - 1.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.increment\njulia> result.algorithm.jacobian\njulia> result.algorithm.mismatch","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The increment mathbf Delta x^(nu) and mismatch mathbff(x^(nu)) vectors in JuliaGrid are stored identically as defined, the first n - 1 elements are bus voltage angles increments and active mismatches defined according to PV and PQ buses, in the order in which they appear in the input data. The last n_textpq elements are bus voltage magnitudes increments and reactive mismatches defined according to PQ buses. According to this arrangement, the Jacobian matrix mathbfJ(x^(nu)) was also formed.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"After that, we update the solution:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf x^(nu + 1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid saves the final results after updating in vectors that contain all bus voltage magnitudes and angles:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.magnitude\njulia> result.bus.voltage.angle","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The current number of iterations nu can be accessed using the command:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.iteration.number","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is repeated until the stopping criteria is met. Namely, after each iteration, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  f_P_i(mathbf x^(nu+1)) = V_i^(nu+1)sumlimits_j=1^n V_j^(nu+1)(G_ijcostheta_ij^(nu+1)+B_ijsintheta_ij^(nu+1)) - P_i\n   i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_Q_i(mathbf x^(nu+1)) = V_i^(nu+1)sumlimits_j=1^n V_j^(nu+1)(G_ijsintheta_ij^(nu+1)-B_ijcostheta_ij^(nu+1)) - Q_i\n     i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is stopped when the following conditions are met:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    max f_P_i(mathbf x^(nu+1)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu+1)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where epsilon is the predetermined stopping criteria. JuliaGrid stores these values to break the iteration loop in variables:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.iteration.stopping.active\njulia> result.algorithm.iteration.stopping.reactive","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Note that the Newton-Raphson method can have difficulties with initial conditions under \"flat start\".","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#Jacobian-Matrix","page":"In-depth Power Flow Solution","title":"Jacobian Matrix","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Without loss of generality, we assume that the slack bus is the first bus, followed by the set of PQ buses and the set of PV buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathcalN_textsb =  1  \n    mathcalN_textpq = 2 dots m \n    mathcalN_textpv = m + 1dots n\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where mathcalN = mathcalN_textsb cup mathcalN_textpq cup mathcalN_textpv. Hence, we have","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    bm theta = theta_2dotstheta_n^T  mathbf Delta bm theta = Delta theta_2dotsDelta theta_n^T \n    mathbf V = V_2dotsV_m^T  mathbf Delta mathbf V = Delta V_2dotsDelta V_m^T\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_textu times n_textu is:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n  cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n  hline \n  cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n  vdots   \n  cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n  cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"As we can see, the Jacobian matrix can be written using four block matrices:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"\t  mathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu)) mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu)) \n\t   mathbfJ_22(x^(nu))\n  endbmatrix","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where diagonal elements of the Jacobian sub-matrices are defined according to:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n  V_i^(nu)sumlimits_j=1^n V_j^(nu)(-G_ij\n  sintheta_ij^(nu)+B_ijcostheta_ij^(nu)) - (V_i^(nu))^2B_ii\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_i^(nu) = sumlimits_\n  j=1^n V_j^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))+V_i^(nu) G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_i=V_i^(nu)\n  sumlimits_j=1^n V_j^(nu)\n  (G_ijcostheta_ij^(nu)+B_ijsintheta_ij^(nu))- (V_i^(nu))^2G_ii\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial V_i=sumlimits_j=1\n  ^n V_j^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))-V_i^(nu) B_ii\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu))\n  cfracmathrm partialf_P_i(mathbf x^(nu))\n  mathrm partial V_j^(nu) = V_i^(nu)(G_ijcos\n  theta_ij^(nu)+B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))\n  mathrm partial theta_j=V_i^(nu)V_j^(nu)\n  (-G_ijcostheta_ij^(nu) -B_ijsintheta_ij^(nu))\n  cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm\n  partial V_j=V_i^(nu)(G_ijsintheta_ij^(nu)-\n  B_ijcostheta_ij^(nu))\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#inDepthFastNewtonRaphson","page":"In-depth Power Flow Solution","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The convergence of the fast Newton-Raphson method is slower than the Newton-Raphson method, but often, a shorter solution time for the updates compensates for slower convergence, resulting in an overall shorter solution time. For not too heavily loaded systems a shorter overall solution time is almost always obtained. It should be noted that if the algorithm converges, it converges to a correct solution [2].","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The fast Newton-Raphson method is based on the decoupling of the power flow equations. Namely, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginbmatrix\n    mathbfJ_11(x) mathbfJ_12(x)  mathbfJ_21(x) \n\t   mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbfDelta theta  mathbfDelta V\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where we dropped the iteration index for simplicity. In transmission grids, a strong coupling can be found between active powers and voltage angles, and between reactive powers and voltage magnitudes. To obtain decoupling, two conditions are assumed to have been satisfied: first, the resistances r_ij of the branches are small with respect to their respective reactances x_ij and, second, the angle differences are small theta_ij approx 0 [3]. Respectively, we start from the equation:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbf0  mathbf0  mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbfDelta bm theta  mathbfDelta V\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_P(mathbf x)  mathbff_Q(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Thus, the decoupled system can be written as:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathbff_P(mathbf x) = -mathbfJ_11(x) mathbfDelta bm  theta \n    mathbff_Q(mathbf x) = -mathbfJ_22(x) mathbfDelta V\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Here, it would be useful to observe the problem in the form:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_2(mathbf x) = -Delta theta_2cfracmathrm partialf_P_2(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_2(mathbf x)mathrm partial theta_n \n     vdots \n    f_P_n(mathbf x) = -Delta theta_2cfracmathrm partialf_P_n(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_n\n    f_Q_2(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_n_textpq  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"First of all, we expand the second part of the expressions as follows:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  f_Q_2(mathbf x) =\n  -cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n   vdots \n  f_Q_m(mathbf x) =\n  - cfracDelta V_2V_2V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n  cfracDelta V_mV_m V_m\n  cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The next step is deriving the Jacobian elements. For this purpose, let us consider the expressions defined for the Newton-Raphson method, where we applied the above expansions for PQ buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  V_isumlimits_j=1^n V_j(-G_ij\n  sintheta_ij+B_ijcostheta_ij) - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = V_isumlimits_j=1\n  ^n V_j(G_ijsintheta_ij-\n  B_ijcostheta_ij)-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Since the reactive power is defined as:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    Q_i =V_isumlimits_j=1^n V_j(G_ijsintheta_ij-B_ijcostheta_ij)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Jacobian elements can be written in the form:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i =\n  -Q_i - V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x)\n  mathrm partial theta_j=V_iV_j\n  (G_ijsintheta_ij-B_ijcostheta_ij)\n  V_i cfracmathrm partialf_Q_i(mathbf x)\n  mathrm partial V_i = Q_i-V_i^2 B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrm\n  partial V_j = V_iV_j (G_ijsintheta_ij-\n  B_ijcostheta_ij)\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The decoupled model is based on the following approximations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    sin(theta_ij) approx 0 \n    cos(theta_ij) approx 1 \n    Q_i  B_iiV_i^2\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Consequently, Jacobian elements become:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -V_i^2B_ii\n  cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_j = -V_iV_jB_ij\n  V_i cfracmathrm partialf_Q_i(mathbf x) mathrm partial V_i = -V_i^2B_ii\n  V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j =  -V_iV_jB_ij\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Then, the initial system of equations is:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_2(mathbf x) = V_2^2B_22 Delta theta_2 + cdots + V_2V_nB_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_2V_nB_n2 Delta theta_2 + cdots + V_n^2B_nn Delta theta_n \n    f_Q_2(mathbf x) =  V_2^2B_22 cfracDelta V_2V_2 + cdots +\n     V_2V_mB_2m cfracDelta V_mV_m \n     vdots \n    f_Q_m(mathbf x) = V_2V_mB_m2 cfracDelta V_2V_2 + cdots +\n    V_m^2 B_mm cfracDelta V_mV_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Using V_j approx 1, wherein V_i^2 = V_iV_j j=i, the first part of the equations have a form:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_2(mathbf x) = V_2B_22 Delta theta_2 + cdots + V_2B_2n Delta theta_n \n     vdots \n    f_P_n(mathbf x) = V_nB_n2 Delta theta_2 + cdots + V_nB_nn Delta theta_n\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Simplifying the second part of the equations, we obtain:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_Q_2(mathbf x) =  V_2B_22 Delta V_2 + cdots +\n     V_2 B_2m Delta V_m\n    \n     vdots \n    f_Q_m(mathbf x) = V_mB_m2 Delta V_2 + cdots +\n    V_m B_mm Delta V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, the fast Newton-Raphson method is based on the following system of equations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    cfracf_P_2(mathbf x)V_2 = B_22 Delta theta_2 + cdots + B_2n Delta theta_n \n     vdots \n    cfracf_P_n(mathbf x)V_n = B_n2 Delta theta_2 + cdots + B_nn Delta theta_n \n    cfracf_Q_2(mathbf x)V_2 =  B_22 Delta V_2 + cdots + B_2m Delta V_m \n     vdots \n    cfracf_Q_m(mathbf x)V_m = B_m2 Delta V_2 + cdots +\n    B_mm Delta V_m\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"which can be written as:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    mathbfh_P(mathbf x) = mathbfB_1 mathbfDelta bm theta \n    mathbfh_Q(mathbf x) = mathbfB_2 mathbfDelta V\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"True benefits from these equations are that Jacobian matrices mathbfB_1 and mathbfB_2 are constant and should be formed only once. Next, it is now possible to define XB and BX versions of the fast Newton-Raphson method.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#XB-Version","page":"In-depth Power Flow Solution","title":"XB Version","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The resistance r_ij, shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij  and transformer tap ratio magnitude tau_ij are ignored while forming the matrix mathbfB_1. The transformer phase shift angle phi_ij is ignored while building the matrix mathbfB_2. This version is the standard fast Newton-Raphson method and has excellent convergence properties for usual cases [3].","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To initialize the XB version of the fast Newton-Raphson method, we use:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonXB(system)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#BX-Version","page":"In-depth Power Flow Solution","title":"BX Version","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The shunt susceptance Im  y_textshi , charging susceptance Im  y_textsij  and transformer tap ratio magnitude tau_ij are ignored while forming the matrix mathbfB_1. The resistance r_ij and transformer phase shift angle phi_ij are ignored while building the matrix mathbfB_2. For usual cases, the iteration count will be similar to the XB scheme, but for systems with a few or with general high r_ijx_ij ratios the number of iterations needed to solve the power flow is considerably smaller than the number of the XB scheme [3].","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To initialize the BX version of the fast Newton-Raphson method, we use:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = fastNewtonRaphsonBX(system)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#Method-Implementation-2","page":"In-depth Power Flow Solution","title":"Method Implementation","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"In the beginning, we evaluate matrices mathbfB_1 and mathbfB_2 related with active and reactive power equations, respectively. These matrices can be accessed using commands:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.active.jacobian\njulia> result.algorithm.reactive.jacobian","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Then, JuliaGrid uses the LU factorization of matrices mathbfB_1 and mathbfB_2 to reveal solutions through iterations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.active.lower\njulia> result.algorithm.active.upper\njulia> result.algorithm.active.right\njulia> result.algorithm.active.left\njulia> result.algorithm.active.scaling","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.reactive.lower\njulia> result.algorithm.reactive.upper\njulia> result.algorithm.reactive.right\njulia> result.algorithm.reactive.left\njulia> result.algorithm.reactive.scaling","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, to solve the AC power flow and find the bus voltage magnitudes and angles, JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"stopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    fastNewtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The fast Newton-Raphson method first solves the equation:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfDelta bm theta^(nu) = mathbfB_1^-1 mathbfh_P(bm theta^(nu) mathbf V^(nu))","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.active.increment\njulia> result.algorithm.active.mismatch","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"After that, we update the solution:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  bmtheta^(nu+1) = bmtheta^(nu) + mathbf Delta bm theta^(nu)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid stores the final results after updating in the vector that contains all bus voltage angles:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.angle","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The fast Newton-Raphson method further solves the equation:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfDelta V^(nu) = mathbfB_2^-1 mathbfh_Q(bm theta^(nu + 1) mathbf V^(nu))","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.reactive.increment\njulia> result.algorithm.reactive.mismatch","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Finally, we update the solution:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbfV^(nu+1) = mathbfV^(nu) + mathbfDelta V^(nu)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid stores the final results after updating in the vector that contains all bus voltage magnitudes:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.magnitude","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"No approximations have been introduced to the functions mathbff_P(mathbf x) or mathbff_Q(mathbf x), only in the way we calculate the increments of the state variables [2]. Consequently, we still use the following equations to compute mismatches:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    f_P_i(mathbf x) = V_isumlimits_j=1^n V_j(G_ijcostheta_ij+B_ijsintheta_ij) - P_i = 0\n     i in mathcalN_textpq cup mathcalN_textpv\n    f_Q_i(mathbf x) = V_isumlimits_j=1^n V_j (G_ijsintheta_ij-B_ijcostheta_ij) - Q_i = 0\n     i in mathcalN_textpq\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Hence, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  h_P_i(mathbf x^(nu+1)) =\n  sumlimits_j=1^n V_j^(nu+1)(G_ijcostheta_ij^(nu+1)+B_ijsintheta_ij^(nu+1)) - cfracP_iV_i^(nu+1)\n    i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    h_Q_i(mathbf x^(nu+1)) =\n    sumlimits_j=1^n V_j^(nu+1) (G_ijsintheta_ij^(nu)-B_ijcostheta_ij^(nu+1)) - cfracQ_iV_i^(nu+1)\n     i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is stopped when the following conditions are met:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    max h_P_i(mathbf x^(nu)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max h_Q_i(mathbf x^(nu)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where epsilon is the predetermined stopping criteria. JuliaGrid stores these values to break the iteration loop in variables:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.iteration.stopping.active\njulia> result.algorithm.iteration.stopping.reactive","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#inDepthGaussSeidel","page":"In-depth Power Flow Solution","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Defining the complex current injection at the bus i in mathcalN as:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"\tbarI_i = fracP_i - jQ_ibarV_i^*","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"the power flow problem is described by the system of non-linear equations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"can be written in the expanded form:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    Y_11  barV_1  + cdots+ Y_1nbarV_n = fracP_1 - jQ_1barV_1^* \n     vdots  \n    Y_n1  barV_1 + cdots+ Y_nnbarV_n = fracP_n - jQ_nbarV_n^*\n\tendaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The Gauss-Seidel method directly solves the above system of equations, albeit with very slow convergence, almost linearly with the size of the system. Consequently, this method needs many iterations to achieve the desired solution [4]. The Gauss-Seidel method convergence time increases significantly for large-scale systems and can exhibit convergence problems for systems with high active power transfers. However, the Newton-Raphson and Gauss-Seidel methods are used complementary, meaning that power flow programs implement both. Gauss-Seidel method is used to rapidly determine an approximate solution from a \"flat start\", and then the Newton-Raphson method is used to obtain the final accurate solution [5].","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"In general, the Gauss-Seidel method is based on the above system of equations, where the set of non-linear equations has n complex equations, and one of these equations describes the slack bus. Consequently, one of these equations can be removed resulting in the power flow problem with n-1 equations.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#Method-Implementation-3","page":"In-depth Power Flow Solution","title":"Method Implementation","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To solve the AC power flow and find the bus voltage magnitudes and angles using the Gauss-Seidel method, JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.iteration.stopping\nfor i = 1:10\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The method starts with initial complex bus voltages barV_i^(0) i in mathcalN. The iteration scheme first computes bus complex voltages for PQ buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_ibarV_i^*(nu) -\n    sumlimits_substackj = 1^i - 1 Y_ijbarV_j^(nu + 1) -\n    sumlimits_substackj = i + 1^n Y_ijbarV_j^(nu)Bigg)\n     i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Then, the solution for PV buses is obtained in two steps: we first determine the reactive power injection, and then the bus complex voltage is updated:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  beginaligned\n    Q_i^(nu+1) =\n    -Im left barV_i^*(nu + 1) sumlimits_j=1^n Y_ijbarV_j^(nu+1)right  i in mathcalN_textpv \n    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_i^(nu + 1)barV_i^*(nu + 1)-\n    sumlimits_substackj = 1j neq i^n Y_ijbarV_j^(nu + 1) Bigg)  i in mathcalN_textpv\n  endaligned","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Obtained voltage magnitude is not equal to the magnitude specified for the PV bus. Thus, it is necessary to perform the voltage correction:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"      barV_i^(nu+1) = V_i^(0) cfracbarV_i^(nu+1)V_i^(nu+1)  i in mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid saves the final results in vectors that contain all bus voltage magnitudes and angles:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.magnitude\njulia> result.bus.voltage.angle","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is repeated until the stopping criteria is met. Namely, after one iteration loop is done, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    f_P_i(mathbf x^(nu+1)) = RebarV_i^(nu + 1) barI_i^*(nu + 1) - P_i  i in mathcalN_textpq cup mathcalN_textpv","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  f_Q_i(mathbf x^(nu+1)) = ImbarV_i^(nu + 1) barI_i^*(nu + 1) - Q_i  i in mathcalN_textpq","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The iteration loop is stopped when the following conditions are met:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    max f_P_i(mathbf x^(nu+1)) i in mathcalN_textpq cup mathcalN_textpv   epsilon \n    max f_Q_i(mathbf x^(nu+1)) i in mathcalN_textpq   epsilon","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"where epsilon is the predetermined stopping criteria. JuliaGrid stores these values to break the iteration loop:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.algorithm.iteration.stopping.active\njulia> result.algorithm.iteration.stopping.reactive","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#dcPowerFlowSolution","page":"In-depth Power Flow Solution","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"As shown in section In-depth DC Model, the DC power flow problem is described by the system of linear equations:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfP_textsh","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#Implementation","page":"In-depth Power Flow Solution","title":"Implementation","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"To solve the DC power flow and find the bus voltage angles, JuliaGrid provides the following sequence of functions:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"The DC power flow solution is obtained through a non-iterative procedure by solving the linear problem:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"    bm theta = mathbfB^-1(mathbf P - mathbfP_textgs - mathbfP_textsh)","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"Note that the slack bus voltage angle is excluded from bm theta. Hence, corresponding elements in vectors mathbf P, mathbfP_textgs, mathbfP_textsh, and corresponding column of the matrix mathbfB will be removed, during the calculation process.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"JuliaGrid saves the final result in the vector that contains all bus voltage angles:","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"julia> result.bus.voltage.angle","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/inDepthSolution/#inDepthPowerFlowSolutionReference","page":"In-depth Power Flow Solution","title":"References","text":"","category":"section"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"[1] A. Wood and B. Wollenberg, Power Generation, Operation, and Control, ser. A Wiley-Interscience publication. Wiley, 1996.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"[2] G. Andersson, Modelling and analysis of electric power systems, EEH-Power Systems Laboratory, Swiss Federal Institute of Technology (ETH), Zrich, Switzerland (2008).","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"[3] R. A. M. van Amerongen, \"A general-purpose version of the fast decoupled load flow,\" IEEE Trans. Power Syst., vol. 4, no. 2, pp. 760-770, May 1989.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"[4] D. P. Chassin, P. R. Armstrong, D. G. Chavarria-Miranda, and R. T. Guttromson, \"Gauss-seidel accelerated: implementing flow solvers on field programmable gate arrays,\" in Proc. IEEE PES General Meeting, 2006, pp. 5.","category":"page"},{"location":"powerFlow/inDepthSolution/","page":"In-depth Power Flow Solution","title":"In-depth Power Flow Solution","text":"[5] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER Users Manual, Version 7.0. 2019.","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACDCModel","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Network equations obtained using the unified branch model and defined below represent the basic setup used for the power system analysis. The power system network topology is usually described by the bus/branch model, where branches of the network are defined using the two-port pi-model. The bus/branch model can be represented using a graph mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n represents the set of buses, while the set of edges mathcalE subseteq mathcalN times mathcalN represents the set of branches of the power network.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACModel","page":"In-depth AC and DC Model","title":"AC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"JuliaGrid is based on common network elements and benefits the unified branch model to perform various analyses based on the system of non-linear equations. To create vectors and matrices related to AC or non-linear analyses, JuliaGrid uses the function acModel!(), for example:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"system = powerSystem(\"case14.h5\")\nacModel!(system)","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#ACBranchModel","page":"In-depth AC and DC Model","title":"AC Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The equivalent unified pi-model for a branch (ij) in mathcalE incident to the buses ij in mathcalN is shown in Figure 2.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/pi_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The equivalent branch model, where the transformer is located at \"from\" bus end of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    y_ij = frac1z_ij =\n    frac1r_ij + textjx_ij =\n    fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.resistance\njulia> system.branch.parameter.reactance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.admittance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The branch shunt capacitive admittance (i.e. charging admittance) y_textsij at buses ij is equal to:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"y_textsij = textj b_textsij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note that JuliaGrid stores the total branch shunt capacitive susceptance 2b_textsij:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.susceptance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where tau_ij is the transformer turns ratio, while phi_ij is the transformer phase shift angle, always located \"from\" bus end of the branch.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.branch.parameter.turnsRatio\njulia> system.branch.parameter.shiftAngle","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.transformerRatio","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The values of the terms left((y_ij + y_textsij)  tau_ij^2right), left(-alpha_ij^*y_ijright), left(-alpha_ijy_ijright), and left(y_ij + y_textsijright) can be found stored in four separate arrays, respectively:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.nodalFromFrom\njulia> system.acModel.nodalFromTo\njulia> system.acModel.nodalToFrom\njulia> system.acModel.nodalToTo","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if phi_ij = 0 and y_textsij = 0, while phase-shifting transformers are obtained if y_textsij = 0.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#ACNodalMatrix","page":"In-depth AC and DC Model","title":"AC System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Let us consider an example, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with admittance y_textshk.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/pi_model_example.png\" class=\"center\"/>\n<figcaption>Figure 3: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"According to the unified branch model each branch is described using the system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_pk^*y_pk\n    -alpha_pky_pk  y_pk + y_textspk\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_kq^2(y_kq + y_textskq)  -alpha_kq^*y_kq\n    -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The complex current injections at buses are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    barI_p = barI_pk = cfrac1tau_pk^2(y_pk + y_textspk) barV_p -alpha_kq^*y_kq barV_k \n    barI_k = barI_kp + barI_kq - barI_textshk =\n    -alpha_kqy_kq barV_p + (y_kq + y_textskq) barV_k +\n    cfrac1tau_kq^2(y_kq + y_textskq) barV_k -alpha_kq^*y_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = -alpha_kqy_kq barV_k + (y_kq + y_textskq) barV_q\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_kq^*y_kq  0 \n   -alpha_kqy_kq  y_kq + y_textskq + cfrac1tau_kq^2(y_kq + y_textskq) + y_textshk   -alpha_kq^*y_kq \n    0  -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where mathbf bar V in mathbbC^n is the vector of bus complex voltages, and mathbf bar I in mathbbC^n is the vector of complex current injections at buses.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The matrix mathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nY_ii = G_ii + textjB_ii = y_textshi +\nsumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2(y_ij + y_textsij) + sumlimits_e in mathcalE  e(2) = i (y_ij + y_textsij)\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nY_ij = G_ij + textjB_ij = -alpha_ij^*y_ij\nY_ji = G_ji + textjB_ji =  -alpha_ijy_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [1, Sec. 9.6].","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.acModel.nodalMatrix\njulia> system.acModel.nodalMatrixTranspose","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthDCModel","page":"In-depth AC and DC Model","title":"DC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The DC model is obtained by linearisation of the non-linear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all shunt susceptance elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles bm theta as state variables. To create vectors and matrices related to DC or linear analyses, JuliaGrid uses the function dcModel!(), for example:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"system = powerSystem(\"case14.h5\")\ndcModel!(system)","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#DCBranchModel","page":"In-depth AC and DC Model","title":"DC Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"According to the above assumptions, we start from the unified branch model:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"    beginbmatrix\n      barI_ij  barI_ji\n    endbmatrix = cfrac1textjx_ij\n    beginbmatrix\n      cfrac1tau_ij^2  -alpha_ij^*\n      -alpha_ij  1\n    endbmatrix\n    beginbmatrix\n      barV_i  barV_j\n    endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The real components are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.admittance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active powers to bus voltage angles, versus complex currents to complex bus voltages in the AC model [2]. Consequently, analogous to the unified branch model we can write:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#DCNodalMatrix","page":"In-depth AC and DC Model","title":"DC System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"As before, let us consider an example of the DC framework, given in Figure 2, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with conductance g_textshk.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"<img src=\"../../assets/dc_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The example of the system with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Each branch in the DC framework is described with a system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix = cfrac1tau_pkx_pk\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix + cfracphi_pktau_pkx_pk\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix = cfrac1tau_kqx_kq\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix + cfracphi_kqtau_kqx_kq\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The active power injections at buses are:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginaligned\n    P_p = P_pk =cfrac1tau_pkx_pk theta_p - cfrac1tau_pkx_pk theta_k - cfracphi_pktau_pkx_pk \n    P_k = P_kp + P_kq - P_textshk = -cfrac1tau_pkx_pk theta_p + cfrac1tau_pkx_pk theta_k + cfracphi_pktau_pkx_pk +\n    cfrac1tau_kqx_kq theta_k - cfrac1tau_kqx_kq theta_q - cfracphi_kqtau_kqx_kq + g_textshk \n    P_q = P_qk = -cfrac1tau_kqx_kq theta_k +cfrac1tau_kqx_kq theta_q + cfracphi_kqtau_kqx_kq\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Note that the active power injected by the shunt element at the bus i in mathcalN is equal to:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  P_textshi = RebarV_ibarI_textshi^* = Re-barV_iy_textshi^*barV_i^* = - g_textshi","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pkx_pk  - cfrac1tau_pkx_pk  0 \n    -cfrac1tau_pkx_pk  cfrac1tau_pkx_pk + cfrac1tau_kqx_kq   -cfrac1tau_kqx_kq \n    0  -cfrac1tau_kqx_kq cfrac1tau_kqx_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_pktau_pkx_pk  cfracphi_pktau_pkx_pk - cfracphi_kqtau_kqx_kq  cfracphi_kqtau_kqx_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfP_textsh","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"where bm theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbf P in mathbbR^n contains active power injections at buses caused by generators and demands. In JuliaGrid, the vector can be recovered using a command:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbfP_textgs in mathbbR^n represents active powers related to the non-zero shift angle of transformers.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.shiftActivePower","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The vector mathbfP_textsh in mathbbR^n represents active powers consumed by shunt elements.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.bus.shunt.conductance","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"The bus or nodal matrix in the DC framework is given as mathbfB in mathbbC^n times n, with elements:","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nB_ii = sumlimits_e in mathcalE i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nB_ij = -cfrac1tau_ijx_ij\nB_ji = -cfrac1tau_ijx_ij","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"julia> system.dcModel.nodalMatrix","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACDCModel/#inDepthACDCModelReference","page":"In-depth AC and DC Model","title":"References","text":"","category":"section"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"[1] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"powerSystem/inDepthACDCModel/","page":"In-depth AC and DC Model","title":"In-depth AC and DC Model","text":"[2] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER Users Manual, Version 7.0. 2019.","category":"page"}]
}
