var documenterSearchIndex = {"docs":
[{"location":"powerSystem/model/#powerSystemModel","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The JuliaGrid supports the composite type PowerSystem to preserve power system data, with fields:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"bus\nbranch\ngenerator\nacModel\ndcModel\nbasePower.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The fields bus, branch, generator hold the data related to buses, branches and generators, respectively. Subtypes acModel and dcModel store vectors and matrices obtained based on the power system topology and parameters. The base power of the system is kept in the field basePower, given in volt-ampere unit.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The method powerSystem() returns the composite type PowerSystem with all subtypes.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports three modes of forming the power system model:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"using built-in functions,\nusing HDF5 file format,\nusing Matpower case files.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Note that, in the case of large-scale systems, we strongly recommend to use the HDF5 file format for the input. Therefore, JuliaGrid has the function that any system loaded from Matpower case files or a system formed using built-in functions can be saved in the HDF5 format.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The HDF5 file format contains three groups: bus, branch and generator. In addition, the file contains basePower variable, given in volt-ampere. Each group is divided into subgroups that gather the same type of physical quantities, with the corresponding datasets. Note that, dataset names are identical to the keywords, which are used when the power system model is formed using built-in functions.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#busGroup","page":"Power System Model","title":"Bus Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The bus group is divided into four subgroups: layout, demand, shunt, and voltage. Each of the subgroups contains datasets that define the features of the buses.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique bus label - positive integer\nlayout slackLabel bus label of the slack bus - positive integer\nlayout lossZone loss zone - positive integer\nlayout area area number - positive integer\ndemand active active power demand per-unit float\ndemand reactive reactive power demand per-unit float\nshunt conductance active power demanded of the shunt element at voltage magnitude equal to 1 per-unit per-unit float\nshunt susceptance reactive power injected of the shunt element at voltage magnitude equal to 1 per-unit per-unit float\nvoltage magnitude initial value of the voltage magnitude per-unit float\nvoltage angle initial value of the voltage angle radian float\nvoltage minMagnitude minimum allowed voltage magnitude value per-unit float\nvoltage maxMagnitude maximum allowed voltage magnitude value per-unit float\nvoltage base base value of the voltage magnitude volt float","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#branchGroup","page":"Power System Model","title":"Branch Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The branch group is divided into four subgroups: layout, parameter, voltage, and rating. Each of the subgroups contains datasets that define the features of the branches.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique branch label - positive integer\nlayout from from bus label (corresponds to the bus label) - positive integer\nlayout to to bus label (corresponds to the bus label) - positive integer\nlayout status operating status of the branch, in-service = 1, out-of-service = 0 - zero-one integer\nparameter resistance branch resistance per-unit float\nparameter reactance branch reactance per-unit float\nparameter susceptance total line charging susceptance per-unit float\nparameter turnsRatio transformer off-nominal turns ratio, equal to zero for a line - float\nparameter shiftAngle transformer phase shift angle where positive value defines delay radian float\nvoltage minAngleDifference minimum allowed voltage angle difference value between from and to bus radian float\nvoltage maxAngleDifference maximum allowed voltage angle difference value between from and to bus radian float\nrating shortTerm short-term rating (equal to zero for unlimited) per-unit float\nrating longTerm long-term rating (equal to zero for unlimited) per-unit float\nrating emergency emergency rating (equal to zero for unlimited) per-unit positive integer","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"powerSystem/model/#generatorGroup","page":"Power System Model","title":"Generator Group","text":"","category":"section"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The generator group is divided into six subgroups: layout, output, voltage, capability, ramRate, and cost. Each of the subgroups contains datasets that define the features of the generators.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"Subgroup Dataset Description Unit Type\nlayout label unique generator label - positive integer\nlayout bus bus label to which the generator is connected - positive integer\nlayout status operating status of the generator, in-service = 1, out-of-service = 0 - zero-one integer\nlayout area area participation factor - float\noutput active output active power of the generator per-unit float\noutput reactive output reactive power of the generator per-unit float\nvoltage magnitude voltage magnitude setpoint per-unit float\ncapability minActive minimum allowed output active power value of the generator per-unit float\ncapability maxActive maximum allowed output active power value of the generator per-unit float\ncapability minReactive minimum allowed output reactive power value of the generator per-unit float\ncapability maxReactive maximum allowed output reactive power value of the generator per-unit float\ncapability lowerActive lower allowed active power output value of PQ capability curve per-unit float\ncapability minReactiveLower minimum allowed reactive power output value at lowerActive value per-unit float\ncapability maxReactiveLower maximum allowed reactive power output value at lowerActive value per-unit float\ncapability upperActive upper allowed active power output value of PQ capability curve per-unit float\ncapability minReactiveUpper minimum allowed reactive power output value at upperActive value per-unit float\ncapability maxReactiveUpper maximum allowed reactive power output value at upperActive value per-unit float\nrampRate loadFollowing ramp rate for load following/AGC per-unit/minute float\nrampRate reserve10minute ramp rate for 10-minute reserves per-unit float\nrampRate reserve30minute ramp rate for 30-minute reserves per-unit float\nrampRate reactiveTimescale ramp rate for reactive power (two seconds timescale) per-unit/minute float\ncost activeModel active power cost model, piecewise linear = 1, polynomial = 2 - one-two integer\ncost activeStartup active power startup cost currency float\ncost activeShutdown active power shutdown cost currency float\ncost activeDataPoint number of data points for active power cost model - positive integer\ncost activeCoefficient coefficients for forming the active power cost function (*) float\ncost reactiveModel reactive power cost model, piecewise linear = 1, polynomial = 2 - one-two integer\ncost reactiveStartup reactive power startup cost currency float\ncost reactiveShutdown reactive power shutdown cost currency float\ncost reactiveDataPoint number of data points for reactive power cost model - positive integer\ncost reactiveCoefficient coefficients for forming the reactive power cost function (*) float","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"&nbsp;","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"The interpretation of the datasets activeCoefficient and reactiveCoefficient, given as matrices, depends on the activeModel and reactiveModel that is selected:","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"piecewise linear cost model is defined according to input-output points, where the i-th row of the matrix is given as:\nactiveCoefficient: p_1 f(p_1) p_2 f(p_2) dots p_n f(p_n),\nreactiveCoefficient: q_1 f(q_1) q_2 f(q_2) dots q_n f(q_n).\npolynomial cost model is defined using the n-th degree polynomial, where the i-th row of the matrix is given as:\nactiveCoefficient: a_n dots a_1 a_0 to define f(p) = a_n p^n + dots + a_1 p + a_0,\nreactiveCoefficient: b_n dots b_1 b_0 to define f(q) = b_n q^n + dots + b_1 q + b_0.","category":"page"},{"location":"powerSystem/model/","page":"Power System Model","title":"Power System Model","text":"(*) Thus, for the piecewise linear model p_i and q_i are given in per-unit, while f(p_i) and f(q_i) have a dimension of currency/hour. In the polynomial model coefficients are dimensionless.","category":"page"},{"location":"powerFlow/ac/#acPowerFlowAnalysis","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"","category":"section"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The AC power flow analysis requires the main composite type PowerSystem with fields bus, branch, generator, and acModel. Further, JuliaGrid stores results of the AC power flow analysis in the composite type ACResult with subtypes:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"bus\nbranch\ngenerator\nalgorithm\nmismatch\niteration.","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"Once the main composite type PowerSystem is created, it is possible to create composite type ACResult and initialize one of the algorithms for solving the AC power flow problem:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"newtonRaphson()\nfastNewtonRaphsonBX()\nfastNewtonRaphsonXB()\ngaussSeidel().","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"Solving the AC power flows implies determining the voltage magnitudes and angles on all buses, and this can be done by using one of the functions below, the function should be inside a loop, which simulates the iterative process:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"newtonRaphson!()\nfastNewtonRaphson!()\ngaussSeidel!().","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"Then, it is possible to calculate other quantities of interest using functions:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"bus!()\nbranch!()\ngenerator!()","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/ac/#Initialize-Algorithm","page":"AC Power Flow Analysis","title":"Initialize Algorithm","text":"","category":"section"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"At the beginning, it is necessary to initialize the algorithm and create the composite type ACResult. Depending on which iterative algorithm will be chosen for solving AC power flow problem, the initialization can be done by one of the functions:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"result = newtonRaphson(system)\nresult = fastNewtonRaphsonBX(system)\nresult = fastNewtonRaphsonXB(system)\nresult = gaussSeidel(system)","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The function affects field result.algorithm, but also field result.bus.voltage, setting the voltage angles and magnitudes to the initial values.","category":"page"},{"location":"powerFlow/ac/#Solution","page":"AC Power Flow Analysis","title":"Solution","text":"","category":"section"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"Functions newtonRaphson!(), fastNewtonRaphson!(), or gaussSeidel!() solves the AC power flow problem by determining the bus voltage magnitudes and angles.","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"newtonRaphson!(system, result)\nfastNewtonRaphson!(system, result)\ngaussSeidel!(system, result)","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The execution of these functions should be inside a loop to create a iterative process. The function affects fields result.algorithm, result.mismatch, result.iteration and result.bus.voltage. The field result.mismatch contains absolute values of active and reactive mismatches, which are used to terminate the iterative process.","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/ac/#acpowerflow","page":"AC Power Flow Analysis","title":"In-depth Analysis","text":"","category":"section"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The AC power flow analysis requested acModel, we advise the reader to read the section in-depth AC Model which describes the model in details.","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"","category":"page"},{"location":"powerFlow/ac/#gaussseidel","page":"AC Power Flow Analysis","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"Defining the injected current into the bus i in mathcalN as:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"\tbarI_i = fracP_i - jQ_ibarV_i^*","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"the power flow problem which is described by the system of non-linear equations:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"    mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"can be written in the expanded form:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"  beginaligned\n    Y_11  barV_1  + cdots+ Y_1nbarV_n = fracP_1 - jQ_1barV_1^* \n     vdots  \n    Y_n1  barV_1 + cdots+ Y_nnbarV_n = fracP_n - jQ_nbarV_n^*\n\tendaligned","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The Gauss-Seidel method directly solves the above system of equations, albeit with very slow convergence, almost linearly with the size of the system. Consequently, this method needs many iterations to achieve the desired solution [3]. In general, the Gauss-Seidel method is based on the above system of equations, where the set of non-linear equations has n complex equations, and one of these equations describes the slack bus. Consequently, one of these equations can be removed resulting in the power flow problem with n-1 equations.","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"In the following, we observe a power system with sets mathcalPV and mathcalPQ that contain PV and PQ buses, respectively, and exactly one slack bus V theta:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"  mathcalH = mathcalPV cup mathcalPQ cup V theta","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The method starts with initial complex bus voltages barV_i^(0) i in mathcalH. The iteration scheme first computes complex bus voltages for PQ buses:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_ibarV_i^*(nu) -\n    sumlimits_substackj = 1^i - 1 Y_ijbarV_j^(nu + 1) -\n    sumlimits_substackj = i + 1^n Y_ijbarV_j^(nu)Bigg)\n     i in mathcalPQ","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"where nu = 01dotsnu_max is the iteration index and nu_max is the number of iterations. Then, the solution for PV buses are obtained in two steps: we first determine the reactive power injection, then the complex bus voltage is updated:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"  beginaligned\n    Q_i^(nu+1) =\n    -Im left barV_i^*(nu + 1) sumlimits_j=1^n Y_ijbarV_j^(nu+1)right  i in mathcalPV \n    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - jQ_i^(nu + 1)barV_i^*(nu + 1)-\n    sumlimits_substackj = 1j neq i^n Y_ijbarV_j^(nu + 1) Bigg)  i in mathcalPV\n  endaligned","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"Obtained voltage magnitude is not equal to the magnitude specified for the PV bus. Thus, it is necessary to perform the voltage correction:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"      barV_i^(nu+1) = V_i^(0) cfracbarV_i^(nu+1)V_i^(nu+1)  i in mathcalPV","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The iteration loop is repeated until the stopping criteria is met. Namely, after one iteration loop is done, we compute active power injection mismatch for PQ and PV buses:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"    Delta P_i^(nu + 1) = RebarV_i^(nu + 1) barI_i^*(nu + 1) - P_i  i in mathcalPQ cup mathcalPV","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"and reactive power injection mismatch for PQ buses:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"  Delta Q_i^(nu + 1) = ImbarV_i^(nu + 1) barI_i^*(nu + 1) - Q_i  i in mathcalPQ","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"The iteration loop is stopped when conditions are met:","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"  beginaligned\n    Delta P_i^(nu + 1)  epsilon  i in mathcalPQ cup mathcalPV \n    Delta Q_i^(nu + 1)  epsilon  i in mathcalPQ\n  endaligned","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"where epsilon is a predetermined stopping criteria.","category":"page"},{"location":"powerFlow/ac/","page":"AC Power Flow Analysis","title":"AC Power Flow Analysis","text":"","category":"page"},{"location":"powerSystem/buildModel/#inputdata","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The composite type PowerSystem with fields bus, branch, generator, acModel, dcModel, and basePower can be created using a method:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"powerSystem().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Once the model is created, it is possible to add buses, branches and generators using the functions:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBus!()\naddBranch!()\naddGenerator!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The final step is the formation and saving of vectors and matrices obtained based on the power system topology and parameters using functions:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"acModel!()\ndcModel!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Note that, once the field acModel and dcModel are formed, using function addBranch!(), will automatically trigger the update of these fields. In contrast, adding a new bus, using addBus!(), requires executing the functions acModel!() and dcModel!() again.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Then, it is possible to manipulate the parameters of buses, branches and generators using functions:","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"shuntBus!()\nstatusBranch!()\nparameterBranch!()\nstatusGenerator!()\noutputGenerator!().","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The execution of these functions will automatically trigger the update of all fields affected by these functions.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Build-Model","page":"Build Power System Model","title":"Build Model","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"The method powerSystem() builds the composite type PowerSystem and populates fields bus, branch, generator and basePower.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"powerSystem","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.powerSystem","page":"Build Power System Model","title":"JuliaGrid.powerSystem","text":"The path to the HDF5 file with the .h5 extension should be passed to the method:\n\npowerSystem(\"pathToExternalData/name.h5\")\n\nSimilarly, the path to the Matpower file with the .m extension should be passed to the same method:\n\npowerSystem(\"pathToExternalData/name.m\")\n\nIgnoring the method argument initializes the composite type PowerSystem, which enables building the model from scratch:\n\npowerSystem()\n\nOnce the composite type PowerSystem is created it is possible to add new buses, branches or generators, and also change the parameters of the existing ones.\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Bus-Functions","page":"Build Power System Model","title":"Bus Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change bus parameters and update the field bus.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBus!\nshuntBus!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addBus!","page":"Build Power System Model","title":"JuliaGrid.addBus!","text":"The function adds a new bus, and updates the field bus. Names, descriptions and units of keywords are given in the table bus group.\n\naddBus!(system::PowerSystem; label, slackLabel, area, lossZone, active, reactive,\n    conductance, susceptance, magnitude, angle, minMagnitude, maxMagnitude, base)\n\nThe keyword label is mandatory. Default keyword values are set to zero, except for keywords lossZone = 1, area = 1, magnitude = 1.0, minMagnitude = 0.9, and maxMagnitude = 1.1.\n\nThe slack bus, using the keyword slackLabel, can be specified in each function call with the label of the bus being defined or already existing. If the bus is not defined as slack, the function addBus!() automatically defines the bus as the demand bus (PQ). If a generator is connected to a bus, using the function addGenerator!(), the bus becomes a generator bus (PV).\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, slackLabel = 1, active = 0.25, reactive = -0.04)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.shuntBus!","page":"Build Power System Model","title":"JuliaGrid.shuntBus!","text":"The function allows changing conductance and susceptance parameters of the shunt element connected to the bus.\n\nshuntBus!(system::PowerSystem; label, conductance, susceptance)\n\nThe keyword label should correspond to the already defined bus label. Keywords conductance or susceptancecan be omitted, then the value of the omitted parameter remains unchanged. The function also updates the field acModel, if field exist.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\nshuntBus!(system; label = 1, conductance = 0.04)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Branch-Functions","page":"Build Power System Model","title":"Branch Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change branch parameters. Further, functions update the field branch, but also fields acModel and dcModel. More precisely, once acModel and dcModel are created, the execution of functions will automatically trigger the update of these fields.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"addBranch!\nstatusBranch!\nparameterBranch!","category":"page"},{"location":"powerSystem/buildModel/#JuliaGrid.addBranch!","page":"Build Power System Model","title":"JuliaGrid.addBranch!","text":"The function adds a new branch. Names, descriptions and units of keywords are given in the table branch group. A branch can be added between already defined buses.\n\naddBranch!(system::PowerSystem; label, from, to, status, resistance, reactance,\n    susceptance, turnsRatio, shiftAngle, longTerm, shortTerm, emergency,\n    minAngleDifference, maxAngleDifference)\n\nThe keywords label, from, to, and one of the parameters resistance or reactance are mandatory. Default keyword values are set to zero, except for keywords status = 1, minAngleDifference = -2*pi, maxAngleDifference = 2*pi.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.statusBranch!","page":"Build Power System Model","title":"JuliaGrid.statusBranch!","text":"The function allows changing the operating status of the branch, from in-service to out-of-service, and vice versa.\n\nstatusBranch!(system::PowerSystem; label, status)\n\nThe keywords label should correspond to the already defined branch label.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nstatusBranch!(system; label = 1, status = 0)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/#JuliaGrid.parameterBranch!","page":"Build Power System Model","title":"JuliaGrid.parameterBranch!","text":"The function parameterBranch! allows changing resistance, reactance, susceptance, turnsRatio and shiftAngle parameters of the branch.\n\nparameterBranch!(system::PowerSystem; label, resistance, reactance, susceptance,\n    turnsRatio, shiftAngle)\n\nThe keywords label should correspond to the already defined branch label. Keywords resistance, reactance, susceptance, turnsRatio or shiftAngle can be omitted, and then the value of the omitted parameter remains unchanged.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, active = 0.25, reactive = -0.04)\naddBus!(system; label = 2, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = 1, from = 1, to = 2, resistance = 0.05, reactance = 0.12)\nparameterBranch!(system; label = 1, susceptance = 0.062)\n\n\n\n\n\n","category":"function"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Generator-Functions","page":"Build Power System Model","title":"Generator Functions","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Functions receive the composite type PowerSystem and arguments by keyword to set or change generator parameters. Further, functions update fields generator and bus.```@docs addGenerator! statusGenerator! outputGenerator!","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"\n---\n\n## Build AC or DC Model\nThe functions receive the composite type `PowerSystem` and form vectors and matrices related to AC or DC simulations.","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"@docs acModel! dcModel! ```","category":"page"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"","category":"page"},{"location":"powerSystem/buildModel/#Modifying-Other-Parameters","page":"Build Power System Model","title":"Modifying Other Parameters","text":"","category":"section"},{"location":"powerSystem/buildModel/","page":"Build Power System Model","title":"Build Power System Model","text":"Changing other parameters of the power system can be done by changing variables by accessing their values in fields bus, branch and generator of the composite type powerSystem.","category":"page"},{"location":"powerFlow/solution/#dcPowerFlowAnalysis","page":"Power Flow Solution","title":"Power Flow Analysis","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The power flow analysis requires the composite type PowerSystem with fields bus, branch, generator. In addition, depending on whether AC or DC power flow analysis is used, acModel or dcModel is required.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"JuliaGrid stores results in the composite type Result with fields:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus\nbranch\ngenerator\nalgorithm","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Once the composite type PowerSystem is created, it is possible to create the composite type Result. The composite type Result in the DC power flow analysis is created when determining the bus voltages using the function dcPowerFlow(). In contrast, the AC power flow analysis first requires the initialization of the iterative method, during which the composite type Result is created:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson()\nfastNewtonRaphsonBX()\nfastNewtonRaphsonXB()\ngaussSeidel().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"The calculation of the bus voltages, depending on the type of analysis and the selected method, can be performed using one of the functions:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson!()\nfastNewtonRaphson!()\ngaussSeidel!()\ndcPowerFlow()","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Note that the methods for solving the AC power flow problem should be called inside a loop, thus simulating an iterative process.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Then, it is possible to calculate other quantities of interest using functions:","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"bus!()\nbranch!()\ngenerator!().","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Newton-Raphson-Method","page":"Power Flow Solution","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Functions receive the composite type PowerSystem.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"newtonRaphson\nnewtonRaphson!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.newtonRaphson","page":"Power Flow Solution","title":"JuliaGrid.newtonRaphson","text":"The function initializes the Newthon-Raphson method, and returns the composite type Result.\n\nnewtonRaphson(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.newtonRaphson!","page":"Power Flow Solution","title":"JuliaGrid.newtonRaphson!","text":"The function solves the AC power flow problem using the Newthon-Raphson method.\n\nnewtonRaphson!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = newtonRaphson(system)\nstopping = result.algorithm.stopping\nfor i = 1:10\n    newtonRaphson!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Fast-Newton-Raphson-Method","page":"Power Flow Solution","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Functions receive the composite type PowerSystem.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"fastNewtonRaphsonBX\nfastNewtonRaphsonXB\nfastNewtonRaphson!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonBX","text":"The function initializes the fast Newthon-Raphson BX method and returns the composite type Result.\n\nfastNewtonRaphsonBX(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow Solution","title":"JuliaGrid.fastNewtonRaphsonXB","text":"The function initializes the fast Newthon-Raphson XB method and returns the composite type Result.\n\nfastNewtonRaphsonXB(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#Gauss-Seidel-Method","page":"Power Flow Solution","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Functions receive the composite type PowerSystem.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"gaussSeidel\ngaussSeidel!","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.gaussSeidel","page":"Power Flow Solution","title":"JuliaGrid.gaussSeidel","text":"The function initializes the Gauss-Seidel method, and returns the composite type Result.\n\ngaussSeidel(system::PowerSystem)\n\nThe function updates the field algorithm of the composite type Result.\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/#JuliaGrid.gaussSeidel!","page":"Power Flow Solution","title":"JuliaGrid.gaussSeidel!","text":"The function solves the AC power flow problem using the Gauss-Seidel method.\n\ngaussSeidel!(system::PowerSystem, result::Result)\n\nThe function updates fields bus.voltage and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nresult = gaussSeidel(system)\nstopping = result.algorithm.stopping\nfor i = 1:1000\n    gaussSeidel!(system, result)\n    if stopping.active < 1e-8 && stopping.reactive < 1e-8\n        break\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"","category":"page"},{"location":"powerFlow/solution/#DC-Power-Flow-Solution","page":"Power Flow Solution","title":"DC Power Flow Solution","text":"","category":"section"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"Function receives the composite type PowerSystem, and returns the composite type Result.","category":"page"},{"location":"powerFlow/solution/","page":"Power Flow Solution","title":"Power Flow Solution","text":"dcPowerFlow","category":"page"},{"location":"powerFlow/solution/#JuliaGrid.dcPowerFlow","page":"Power Flow Solution","title":"JuliaGrid.dcPowerFlow","text":"The function solves the DC power flow problem by determining the bus voltage angles, and returns the composite type Result.\n\ndcPowerFlow(system::PowerSystem)\n\nThe function updates field result.bus.voltage.angle and algorithm of the composite type Result.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nresult = dcPowerFlow(system)\n\n\n\n\n\n","category":"function"},{"location":"#JuliaGrid","page":"Home","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuliaGrid is an open-source, easy-to-use simulation tool/solver for researchers and educators provided as a Julia package, with source code released under MIT License. JuliaGrid is inspired by the Matpower, an open-source steady-state power system solver, and allows a variety of display and manipulation options.","category":"page"},{"location":"powerSystem/inDepthACModel/#inDepthACModel","page":"In-depth AC Model","title":"In-depth AC Model","text":"","category":"section"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"Network equations obtained using the unified branch model and defined below represent the basic setup used for the power system analysis. The power system network topology is usually described by the bus/branch model, where branches of the network are defined using the two-port pi-model. The bus/branch model can be represented using a graph mathcalG = (mathcalN mathcalE), where the set of nodes mathcalN = 1 dots n represents the set of buses, while the set of edges mathcalE subseteq mathcalN times mathcalN represents the set of branches of the power network.","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACModel/#branchModelAC","page":"In-depth AC Model","title":"Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The equivalent unified pi-model for a branch (ij) in mathcalE incident to the buses ij in mathcalN is shown in Figure 2.","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"<img src=\"../../assets/pi_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The equivalent branch model, where transformer is located at \"from bus end\" of the branch.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"    y_ij = frac1z_ij =\n    frac1r_ij + textjx_ij =\n    fracr_ijr_ij^2 + x_ij^2 - textjfracx_ijr_ij^2 + x_ij^2 = g_ij + textjb_ij","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch.","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"julia> system.branch.parameter.resistance\njulia> system.branch.parameter.reactance\njulia> system.acModel.admittance","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The branch shunt capacitive admittance (i.e. charging admittance) y_textsij at buses ij is equal to:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"y_textsij = textj b_textsij","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"Note that JuliaGrid stores the total branch shunt capacitive susceptance 2b_textsij:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"julia> system.branch.parameter.susceptance","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"    alpha_ij = cfrac1tau_ije^-textjphi_ij","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"where tau_ij is the transformer turns ratio, while phi_ij is the transformer phase shift angle, always located \"from bus end\" of the branch.","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"julia> system.branch.parameter.turnsRatio\njulia> system.branch.parameter.shiftAngle\njulia> system.acModel.transformerRatio","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"Using Kirchhoff's circuit laws, the unified branch model can be described by complex expressions:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2(y_ij + y_textsij)  -alpha_ij^*y_ij\n    -alpha_ijy_ij  y_ij + y_textsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The values of the terms left((y_ij + y_textsij)  tau_ij^2right), left(-alpha_ij^*y_ijright), left(-alpha_ijy_ijright), and left(y_ij + y_textsijright) can be found stored in four separate arrays, respectively:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"julia> system.acModel.nodalFromFrom\njulia> system.acModel.nodalFromTo\njulia> system.acModel.nodalToFrom\njulia> system.acModel.nodalToTo","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if phi_ij = 0 and y_textsij = 0, while phase-shifting transformers are obtained if y_textsij = 0.","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACModel/#nodalMatrixAC","page":"In-depth AC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"Let us consider an example, given in Figure 3, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with admittance y_textshk.","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"<img src=\"../../assets/pi_model_example.png\" class=\"center\"/>\n<figcaption>Figure 3: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"According to the unified branch model each branch is described using the system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"  beginbmatrix\n    barI_pk  barI_kp\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_pk^*y_pk\n    -alpha_pky_pk  y_pk + y_textspk\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"  beginbmatrix\n    barI_kq  barI_qk\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_kq^2(y_kq + y_textskq)  -alpha_kq^*y_kq\n    -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The injection complex currents into buses are:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"  beginaligned\n    barI_p = barI_pk = cfrac1tau_pk^2(y_pk + y_textspk) barV_p -alpha_kq^*y_kq barV_k \n    barI_k = barI_kp + barI_kq - barI_textshk =\n    -alpha_kqy_kq barV_p + (y_kq + y_textskq) barV_k +\n    cfrac1tau_kq^2(y_kq + y_textskq) barV_k -alpha_kq^*y_kq barV_q + y_textshk barV_k \n    barI_q = barI_qk = -alpha_kqy_kq barV_k + (y_kq + y_textskq) barV_q\n  endaligned","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"  beginbmatrix\n    barI_p  barI_k  barI_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pk^2(y_pk + y_textspk)  -alpha_kq^*y_kq  0 \n   -alpha_kqy_kq  y_kq + y_textskq + cfrac1tau_kq^2(y_kq + y_textskq) + y_textshk   -alpha_kq^*y_kq \n    0  -alpha_kqy_kq  y_kq + y_textskq\n  endbmatrix\n  beginbmatrix\n    barV_p  barV_k  barV_q\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"Next, the system of equations for buses i=1 dots n can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"  mathbf bar I = mathbfY mathbf bar V","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"where mathbf bar V in mathbbC^n is the vector of bus complex voltages, and mathbf bar I in mathbbC^n is the vector of injection complex currents.","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"The matrix mathbfY = mathbfG + textjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nY_ii = G_ii + textjB_ii = y_textshi +\nsumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2(y_ij + y_textsij) + sumlimits_e in mathcalE  e(2) = i (y_ij + y_textsij)\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nY_ij = G_ij + textjB_ij = -alpha_ij^*y_ij\nY_ji = G_ji + textjB_ji =  -alpha_ijy_ij","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is a sparse matrix (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case, for example, in the presence of phase shifting transformers the matrix mathbfY is not symmetrical [1, Sec. 9.6].","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"julia> system.acModel.nodalMatrix\njulia> system.acModel.nodalMatrixTranspose","category":"page"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"","category":"page"},{"location":"powerSystem/inDepthACModel/#inDepthACModelReference","page":"In-depth AC Model","title":"References","text":"","category":"section"},{"location":"powerSystem/inDepthACModel/","page":"In-depth AC Model","title":"In-depth AC Model","text":"[1] J. Grainger and W. Stevenson, Power system analysis, ser. McGraw-Hill series in electrical and computer engineering: Power and energy. McGraw-Hill, 1994.","category":"page"},{"location":"powerSystem/inDepthDCModel/#inDepthDCModel","page":"In-depth DC Model","title":"In-depth DC Model","text":"","category":"section"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The DC model is obtained by linearisation of the non-linear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i-theta_j approx 0, which implies cos theta_ijapprox 1 and sin theta_ij approx theta_ij. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all shunt susceptance elements and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers. Therefore, the DC power flow takes only bus voltage angles bm theta as state variables.","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthDCModel/#branchModelDC","page":"In-depth DC Model","title":"Branch Model","text":"","category":"section"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"According to the above assumptions, we start from the unified branch model:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"    beginbmatrix\n      barI_ij  barI_ji\n    endbmatrix = cfrac1textjx_ij\n    beginbmatrix\n      cfrac1tau_ij^2  -alpha_ij^*\n      -alpha_ij  1\n    endbmatrix\n    beginbmatrix\n      barV_i  barV_j\n    endbmatrix","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"where barV_i = texte^textjtheta_i and barV_j = texte^textjtheta_j. Further, we have:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginaligned\n    barI_ij = cfrac1textjx_ij leftcfrac1tau_ij^2 texte^textjtheta_i -\n    cfrac1tau_ije^textj(phi_ij + theta_j) right \n    barI_ji = cfrac1textjx_ij left-cfrac1tau_ije^textj(theta_i - phi_ij) + texte^textjtheta_j right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginaligned\n    P_ij = RebarV_ibarI_ij^* =\n    Re lefttextjcfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ije^textj(theta_i - theta_j - phi_ij) right  right \n    P_ji = RebarV_jbarI_ji^* =\n    Re lefttextjcfrac1x_ij\n   left1-cfrac1tau_ije^textj(-theta_i +theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The real components are:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i -theta_j-phi_ij) approx cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j -theta_i+phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j-phi_ij)\n  endaligned","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework.","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"julia> system.dcModel.admittance","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"We can conclude that P_ij=-P_ji holds. With the DC model, the linear network equations relate active power to bus voltage angles, versus complex currents to complex bus voltages in the AC case [1]. Consequently, analogous to the unified branch model we can write:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthDCModel/#nodalMatrixDC","page":"In-depth DC Model","title":"System of Equations and Nodal Matrix","text":"","category":"section"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"As before, let us consider an example of the DC framework, given in Figure 2, that will allow us an easy transition to the general case. We observe system with three buses mathcalN = p k q and two branches mathcalE = (p k) (k q), where the bus k is incident to the shunt element with conductance g_textshk.","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"<img src=\"../../assets/dc_model.png\" class=\"center\"/>\n<figcaption>Figure 2: The example with three buses and two branches.</figcaption>\n&nbsp;","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"Each branch in the DC framework is described with system of equations as follows:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginbmatrix\n    P_pk  P_kp\n  endbmatrix = cfrac1tau_pkx_pk\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k\n  endbmatrix + cfracphi_pktau_pkx_pk\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginbmatrix\n    P_kq  P_qk\n  endbmatrix = cfrac1tau_kqx_kq\n  beginbmatrix\n    1  -1\n    -1  1\n  endbmatrix\n  beginbmatrix\n    theta_k  theta_q\n  endbmatrix + cfracphi_kqtau_kqx_kq\n  beginbmatrix\n    -1  1\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The injection active powers into buses are:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginaligned\n    P_p = P_pk =cfrac1tau_pkx_pk theta_p - cfrac1tau_pkx_pk theta_k - cfracphi_pktau_pkx_pk \n    P_k = P_kp + P_kq - P_textshk = -cfrac1tau_pkx_pk theta_p + cfrac1tau_pkx_pk theta_k + cfracphi_pktau_pkx_pk +\n    cfrac1tau_kqx_kq theta_k - cfrac1tau_kqx_kq theta_q - cfracphi_kqtau_kqx_kq + g_textshk \n    P_q = P_qk = -cfrac1tau_kqx_kq theta_k +cfrac1tau_kqx_kq theta_q + cfracphi_kqtau_kqx_kq\n  endaligned","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"Note that the active power injected by the shunt element into the bus i in mathcalN is equal to:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  P_textshi = RebarV_ibarI_textshi^* = Re-barV_iy_textshi^*barV_i^* = - g_textshi","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  beginbmatrix\n    P_p  P_k  P_q\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_pkx_pk  - cfrac1tau_pkx_pk  0 \n    -cfrac1tau_pkx_pk  cfrac1tau_pkx_pk + cfrac1tau_kqx_kq   -cfrac1tau_kqx_kq \n    0  -cfrac1tau_kqx_kq cfrac1tau_kqx_kq\n  endbmatrix\n  beginbmatrix\n    theta_p  theta_k  theta_q\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_pktau_pkx_pk  cfracphi_pktau_pkx_pk - cfracphi_kqtau_kqx_kq  cfracphi_kqtau_kqx_kq\n  endbmatrix +\n  beginbmatrix\n    0  g_textshk  0\n  endbmatrix","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"Next, the system of equations for i=1dotsn can be written in the matrix form:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"  mathbf P = mathbfB bm theta + mathbfP_textgs + mathbfP_textsh","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"where bm theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The vector mathbf P in mathbbR^n contains injected active powers into buses caused by generators and demands. In JuliaGrid, the vector can be recovered using an expression:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"julia> system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The vector mathbfP_textgs in mathbbR^n represents active powers related with non-zero shift angle of transformers.","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"julia> system.dcModel.shiftActivePower","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The vector mathbfP_textsh in mathbbR^n represents active powers consumed by shunt elements.","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"julia> system.bus.shunt.conductance","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"The bus or nodal matrix in the DC framework is given as mathbfB in mathbbC^n times n, with elements:","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"the diagonal elements, where i in mathcalN,  are equal to:\nB_ii = sumlimits_e in mathcalE i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1)  j = e(2)  e in mathcalE, are equal to:\nB_ij = -cfrac1tau_ijx_ij\nB_ji = -cfrac1tau_ijx_ij","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"julia> system.dcModel.nodalMatrix","category":"page"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"","category":"page"},{"location":"powerSystem/inDepthDCModel/#inDepthDCModelReference","page":"In-depth DC Model","title":"References","text":"","category":"section"},{"location":"powerSystem/inDepthDCModel/","page":"In-depth DC Model","title":"In-depth DC Model","text":"[1] R. D. Zimmerman, C. E. Murillo-Sanchez, MATPOWER Users Manual, Version 7.0. 2019.","category":"page"}]
}
