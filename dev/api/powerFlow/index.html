<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow · JuliaGrid</title><meta name="title" content="Power Flow · JuliaGrid"/><meta property="og:title" content="Power Flow · JuliaGrid"/><meta property="twitter:title" content="Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/tablestyle.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../manual/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../manual/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../manual/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../manual/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../manual/observability/">Observability Analysis</a></li><li><a class="tocitem" href="../../manual/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../manual/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../manual/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observability/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observability/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li class="is-active"><a class="tocitem" href>Power Flow</a><ul class="internal"><li><a class="tocitem" href="#AC-Power-Flow-2"><span>AC Power Flow</span></a></li><li><a class="tocitem" href="#DC-Power-Flow-2"><span>DC Power Flow</span></a></li></ul></li><li><a class="tocitem" href="../optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/api/powerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerFlowAPI"><a class="docs-heading-anchor" href="#PowerFlowAPI">Power Flow</a><a id="PowerFlowAPI-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlowAPI" title="Permalink"></a></h1><p>For further information on this topic, please see the <a href="../../manual/acPowerFlow/#ACPowerFlowManual">AC Power Flow</a> or <a href="../../manual/dcPowerFlow/#DCPowerFlowManual">DC Power Flow</a> sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.</p><p>To load power flow API functionalities into the current scope, utilize the following command:</p><pre><code class="language-julia hljs">using JuliaGrid</code></pre><hr/><h6 id="AC-Power-Flow"><a class="docs-heading-anchor" href="#AC-Power-Flow">AC Power Flow</a><a id="AC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#AC-Power-Flow" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.newtonRaphson"><code>newtonRaphson</code></a></li><li><a href="#JuliaGrid.fastNewtonRaphsonBX"><code>fastNewtonRaphsonBX</code></a></li><li><a href="#JuliaGrid.fastNewtonRaphsonXB"><code>fastNewtonRaphsonXB</code></a></li><li><a href="#JuliaGrid.gaussSeidel"><code>gaussSeidel</code></a></li><li><a href="#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>solve!</code></a></li><li><a href="#JuliaGrid.setInitialPoint!-Tuple{PowerSystem, ACPowerFlow}"><code>setInitialPoint!</code></a></li><li><a href="#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a></li><li><a href="#JuliaGrid.adjustAngle!"><code>adjustAngle!</code></a></li><li><a href="#JuliaGrid.powerFlow!-Tuple{PowerSystem, ACPowerFlow}"><code>powerFlow!</code></a></li></ul><h6 id="DC-Power-Flow"><a class="docs-heading-anchor" href="#DC-Power-Flow">DC Power Flow</a><a id="DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#DC-Power-Flow" title="Permalink"></a></h6><ul><li><a href="#JuliaGrid.dcPowerFlow"><code>dcPowerFlow</code></a></li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}"><code>solve!</code></a></li><li><a href="#JuliaGrid.powerFlow!-Tuple{PowerSystem, DCPowerFlow}"><code>powerFlow!</code></a></li></ul><hr/><h2 id="AC-Power-Flow-2"><a class="docs-heading-anchor" href="#AC-Power-Flow-2">AC Power Flow</a><a class="docs-heading-anchor-permalink" href="#AC-Power-Flow-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.newtonRaphson" href="#JuliaGrid.newtonRaphson"><code>JuliaGrid.newtonRaphson</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newtonRaphson(system::PowerSystem, [factorization::Factorization = LU])</code></pre><p>The function sets up the Newton-Raphson method to solve the AC power flow.</p><p><strong>Arguments</strong></p><p>The function requires the <code>PowerSystem</code> type to establish the framework. Next, the <code>Factorization</code> argument, while optional, determines the method used to solve the linear system of equations within each iteration. It can take one of the following values:</p><ul><li><code>LU</code>: Utilizes LU factorization (default).</li><li><code>QR</code>: Utilizes QR factorization.</li></ul><p><strong>Updates</strong></p><p>If the AC model has not been created, the function automatically initiates an update within the <code>ac</code> field of the <code>PowerSystem</code> type. It also performs a check on bus types and rectifies any mistakes present.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>current</code>: The variable allocated to store the currents.</li><li><code>method</code>: The Jacobian matrix, its factorization, mismatches, increments, and indices.</li></ul><p><strong>Examples</strong></p><p>Set up the Newton-Raphson method utilizing LU factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = newtonRaphson(system)</code></pre><p>Set up the Newton-Raphson method utilizing QR factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = newtonRaphson(system, QR)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonBX" href="#JuliaGrid.fastNewtonRaphsonBX"><code>JuliaGrid.fastNewtonRaphsonBX</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fastNewtonRaphsonBX(system::PowerSystem, [factorization::Factorization = LU])</code></pre><p>The function sets up the fast Newton-Raphson method of version BX to solve the AC power flow.</p><p><strong>Arguments</strong></p><p>The function requires the <code>PowerSystem</code> type to establish the framework. Next, the <code>Factorization</code> argument, while optional, determines the method used to solve the linear system of equations within each iteration. It can take one of the following values:</p><ul><li><code>LU</code>: Utilizes LU factorization (default).</li><li><code>QR</code>: Utilizes QR factorization.</li></ul><p><strong>Updates</strong></p><p>If the AC model has not been created, the function automatically initiates an update within the <code>ac</code> field of the <code>PowerSystem</code> type. It also performs a check on bus types and rectifies any mistakes present.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>current</code>: The variable allocated to store the currents.</li><li><code>method</code>: The Jacobian matrices, their factorizations, mismatches, increments, and indices.</li></ul><p><strong>Examples</strong></p><p>Set up the fast Newton-Raphson method utilizing LU factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = fastNewtonRaphsonBX(system)</code></pre><p>Set up the fast Newton-Raphson method utilizing QR factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = fastNewtonRaphsonBX(system, QR)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L147-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.fastNewtonRaphsonXB" href="#JuliaGrid.fastNewtonRaphsonXB"><code>JuliaGrid.fastNewtonRaphsonXB</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fastNewtonRaphsonXB(system::PowerSystem, [factorization::Factorization = LU])</code></pre><p>The function sets up the fast Newton-Raphson method of version XB to solve the AC power flow.</p><p><strong>Arguments</strong></p><p>The function requires the <code>PowerSystem</code> type to establish the framework. Next, the <code>Factorization</code> argument, while optional, determines the method used to solve the linear system of equations within each iteration. It can take one of the following values:</p><ul><li><code>LU</code>: Utilizes LU factorization (default).</li><li><code>QR</code>: Utilizes QR factorization.</li></ul><p><strong>Updates</strong></p><p>If the AC model has not been created, the function automatically initiates an update within the <code>ac</code> field of the <code>PowerSystem</code> type. It also performs a check on bus types and rectifies any mistakes present.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>current</code>: The variable allocated to store the currents.</li><li><code>method</code>: The Jacobian matrices, their factorizations, mismatches, increments, and indices.</li></ul><p><strong>Examples</strong></p><p>Set up the fast Newton-Raphson method utilizing LU factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = fastNewtonRaphsonXB(system)</code></pre><p>Set up the fast Newton-Raphson method utilizing QR factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = fastNewtonRaphsonXB(system, QR)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L194-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.gaussSeidel" href="#JuliaGrid.gaussSeidel"><code>JuliaGrid.gaussSeidel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussSeidel(system::PowerSystem)</code></pre><p>The function sets up the Gauss-Seidel method to solve the AC power flow.</p><p><strong>Argument</strong></p><p>The function requires the <code>PowerSystem</code> type to establish the framework.</p><p><strong>Updates</strong></p><p>If the AC model has not been created, the function automatically initiates an update within the <code>ac</code> field of the <code>PowerSystem</code> type. It also performs a check on bus types and rectifies any mistakes present.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>ACPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The bus voltage magnitudes and angles.</li><li><code>power</code>: The variable allocated to store the active and reactive powers.</li><li><code>current</code>: The variable allocated to store the currents.</li><li><code>method</code>: The bus complex voltages and indices.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = gaussSeidel(system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L423-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}" href="#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>JuliaGrid.mismatch!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mismatch!(system::PowerSystem, analysis::ACPowerFlow)</code></pre><p>The function calculates both active and reactive power injection mismatches.</p><p><strong>Updates</strong></p><p>This function updates the <code>mismatch</code> variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the <a href="#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>solve!</code></a> function.</p><p><strong>Returns</strong></p><p>The function returns maximum absolute values of the active and reactive power injection mismatches, which can be utilized to terminate the iteration loop of the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel methods employed to solve the AC power flow problem.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = newtonRaphson(system)
mismatch!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L502-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}" href="#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, analysis::ACPowerFlow)</code></pre><p>The function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow and calculate bus voltage magnitudes and angles.</p><p>After the <a href="#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a> function is executed, the execution of this function will perform a single iteration of one of the methods.</p><p><strong>Updates</strong></p><p>The calculated voltages are stored in the <code>voltage</code> field of the <code>ACPowerFlow</code> type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L640-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.setInitialPoint!-Tuple{PowerSystem, ACPowerFlow}" href="#JuliaGrid.setInitialPoint!-Tuple{PowerSystem, ACPowerFlow}"><code>JuliaGrid.setInitialPoint!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setInitialPoint!(source::Union{PowerSystem, Analysis}, target::ACPowerFlow)</code></pre><p>The function can reset the initial point of the AC power flow to values from the <code>PowerSystem</code> type. It can also initialize the AC power flow based on results from the <code>Analysis</code> type, whether from an AC or DC analysis.</p><p>The function assigns the bus voltage magnitudes and angles in the <code>target</code> argument, using data from the <code>source</code> argument. This allows users to initialize AC power flow as needed.</p><p>If <code>source</code> comes from a DC analysis, only the bus voltage angles are assigned in the <code>target</code> argument, while the bus voltage magnitudes remain unchanged.</p><p><strong>Examples</strong></p><p>Initialize the Newton-Raphson method with values from the Gauss-Seidel method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

gs = gaussSeidel(system)
for i = 1:10
    solve!(system, gs)
end

nr = newtonRaphson(system)

setInitialPoint!(gs, nr)
for i = 1:10
    stopping = mismatch!(system, nr)
    if all(stopping .&lt; 1e-10)
        break
    end
    solve!(system, nr)
end</code></pre><p>Use wrapper functions and initialize Newton-Raphson with Gauss-Seidel values:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

gs = gaussSeidel(system)
powerFlow!(system, gs; iteration = 10)

nr = newtonRaphson(system)

setInitialPoint!(gs, nr)
powerFlow!(system, nr; tolerance = 1e-10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L1019-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.reactiveLimit!" href="#JuliaGrid.reactiveLimit!"><code>JuliaGrid.reactiveLimit!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reactiveLimit!(system::PowerSystem, analysis::ACPowerFlow)</code></pre><p>The function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.</p><p><strong>Updates</strong></p><p>The function assigns values to the <code>generator.output.active</code> and <code>bus.supply.active</code> variables of the <code>PowerSystem</code> type.</p><p>Additionally, it examines the reactive powers of the generators and adjusts them to their maximum or minimum values if they exceed the specified threshold. This results in the modification of the variable <code>generator.output.reactive</code> of the <code>PowerSystem</code> type accordingly.</p><p>As a result of this adjustment, the <code>bus.supply.reactive</code> variable is also updated, and the bus types specified in <code>bus.layout.type</code> are modified. If the slack bus is converted, the <code>bus.layout.slack</code> field is correspondingly adjusted.</p><p><strong>Returns</strong></p><p>The function returns the variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end

violate = reactiveLimit!(system, analysis)

analysis = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L837-L889">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.adjustAngle!" href="#JuliaGrid.adjustAngle!"><code>JuliaGrid.adjustAngle!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjustAngle!(system::PowerSystem, analysis::ACPowerFlow; slack)</code></pre><p>The function modifies the bus voltage angles based on a different slack bus than the one identified by the <code>bus.layout.slack</code> field.</p><p>For instance, if the reactive power of the generator exceeds the limit on the slack bus, the <a href="#JuliaGrid.reactiveLimit!"><code>reactiveLimit!</code></a> function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus.</p><p><strong>Keyword</strong></p><p>The <code>slack</code> keyword specifies the bus label for which we want to adjust voltage angles.</p><p><strong>Updates</strong></p><p>This function only updates the <code>voltage.angle</code> variable of the <code>ACPowerFlow</code> type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end

reactiveLimit!(system, analysis)

analysis = newtonRaphson(system)
for i = 1:10
    stopping = mismatch!(system, analysis)
    if all(stopping .&lt; 1e-8)
        break
    end
    solve!(system, analysis)
end

adjustAngle!(system, analysis; slack = 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L965-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.powerFlow!-Tuple{PowerSystem, ACPowerFlow}" href="#JuliaGrid.powerFlow!-Tuple{PowerSystem, ACPowerFlow}"><code>JuliaGrid.powerFlow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">powerFlow!(system::PowerSystem, analysis::ACPowerFlow;
    iteration, tolerance, power, current, verbose)</code></pre><p>The function serves as a wrapper for solving AC power flow and includes the functions:</p><ul><li><a href="#JuliaGrid.mismatch!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>mismatch!</code></a>,</li><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, ACPowerFlow{NewtonRaphson}}"><code>solve!</code></a>,</li><li><a href="../analysis/#JuliaGrid.power!-Tuple{PowerSystem, ACPowerFlow}"><code>power!</code></a>,</li><li><a href="../analysis/#JuliaGrid.current!-Tuple{PowerSystem, AC}"><code>current!</code></a>.</li></ul><p>It computes bus voltage magnitudes and angles using an iterative algorithm with the option to compute powers and currents.</p><p><strong>Keywords</strong></p><p>Users can use the following keywords:</p><ul><li><code>iteration</code>: Specifies the maximum number of iterations (default: <code>20</code>).</li><li><code>tolerance</code>: Defines the step size tolerance for the iteration stopping criterion (default: <code>1e-8</code>).</li><li><code>power</code>: Enables power computation upon convergence or reaching the iteration limit (default: <code>false</code>).</li><li><code>current</code>: Enables current computation upon convergence or reaching the iteration limit (default: <code>false</code>).</li><li><code>verbose</code>: Controls the output display, ranging from the default silent mode (<code>0</code>) to detailed output (<code>3</code>).</li></ul><p><strong>Examples</strong></p><p>Solve the AC power flow using the Newton-Raphson method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = newtonRaphson(system)
powerFlow!(system, analysis; iteration = 30, tolerance = 1e-10, verbose = 3)</code></pre><p>Solve the AC power flow using the Gauss-Seidel method:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
acModel!(system)

analysis = gaussSeidel(system)
powerFlow!(system, analysis; iteration = 200, power = true, current = true, verbose = 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/acPowerFlow.jl#L1163-L1202">source</a></section></article><hr/><h2 id="DC-Power-Flow-2"><a class="docs-heading-anchor" href="#DC-Power-Flow-2">DC Power Flow</a><a class="docs-heading-anchor-permalink" href="#DC-Power-Flow-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.dcPowerFlow" href="#JuliaGrid.dcPowerFlow"><code>JuliaGrid.dcPowerFlow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcPowerFlow(system::PowerSystem, [factorization::Factorization = LU])</code></pre><p>The function sets up the framework to solve the DC power flow.</p><p><strong>Arguments</strong></p><p>The function requires the <code>PowerSystem</code> type to establish the framework. Next, the <code>Factorization</code> argument, while optional, determines the method used to solve the linear system of equations. It can take one of the following values:</p><ul><li><code>LU</code>: Utilizes LU factorization (default).</li><li><code>LDLt</code>: Utilizes LDLt factorization.</li><li><code>QR</code>: Utilizes QR factorization.</li></ul><p><strong>Updates</strong></p><p>If the DC model was not created, the function will automatically initiate an update of the <code>dc</code> field within the <code>PowerSystem</code> composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.</p><p><strong>Returns</strong></p><p>The function returns an instance of the <code>DCPowerFlow</code> type, which includes the following fields:</p><ul><li><code>voltage</code>: The variable allocated to store the bus voltage angles.</li><li><code>power</code>: The variable allocated to store the active powers.</li><li><code>method</code>: The factorized nodal admittance matrix.</li></ul><p><strong>Examples</strong></p><p>Set up the DC power flow utilizing LU factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

analysis = dcPowerFlow(system)</code></pre><p>Set up the DC power flow utilizing QR factorization:</p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

analysis = dcPowerFlow(system, QR)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/dcPowerFlow.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}" href="#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}"><code>JuliaGrid.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(system::PowerSystem, analysis::DCPowerFlow)</code></pre><p>The function solves the DC power flow model and calculates bus voltage angles.</p><p><strong>Updates</strong></p><p>The calculated voltage angles are stored in the <code>voltage</code> field of the <code>DCPowerFlow</code> type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

analysis = dcPowerFlow(system)
solve!(system, analysis)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/dcPowerFlow.jl#L68-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JuliaGrid.powerFlow!-Tuple{PowerSystem, DCPowerFlow}" href="#JuliaGrid.powerFlow!-Tuple{PowerSystem, DCPowerFlow}"><code>JuliaGrid.powerFlow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">powerFlow!(system::PowerSystem, analysis::DCPowerFlow; power, verbose)</code></pre><p>The function serves as a wrapper for solving DC power flow and includes the functions:</p><ul><li><a href="#JuliaGrid.solve!-Tuple{PowerSystem, DCPowerFlow}"><code>solve!</code></a>,</li><li><a href="../analysis/#JuliaGrid.power!-Tuple{PowerSystem, DCPowerFlow}"><code>power!</code></a>.</li></ul><p>It computes bus voltage angles and optionally calculates power values.</p><p><strong>Keywords</strong></p><p>Users can use the following keywords:</p><ul><li><code>power</code>: Enables the computation of powers (default: <code>false</code>).</li><li><code>verbose</code>: Controls the output display, ranging from the default silent mode (<code>0</code>) to detailed output (<code>3</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">system = powerSystem(&quot;case14.h5&quot;)
dcModel!(system)

analysis = dcPowerFlow(system)
powerFlow!(system, analysis; power = true, verbose = 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mcosovic/JuliaGrid.jl/blob/9b1f5b9191a55d496854fb9d53a6980a1677dc39/src/powerFlow/dcPowerFlow.jl#L131-L153">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powerSystemModel/">« Power System Model</a><a class="docs-footer-nextpage" href="../optimalPowerFlow/">Optimal Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 12 March 2025 12:34">Wednesday 12 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
