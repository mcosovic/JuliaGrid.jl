var documenterSearchIndex = {"docs":
[{"location":"api/analysis/#PowerCurrentAnalysisAPI","page":"Powers and Currents","title":"Powers and Currents","text":"","category":"section"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"In the following section, we have provided a list of functions that can be utilized for post-processing analysis. Once the voltage values are obtained through power flow analysis, optimal power flow analysis, or state estimation, these functions can be used to calculate power or current values. The specific procedures for computing these values depend on the chosen analysis, which are described in separate manuals for further information.","category":"page"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"To load power system model API functionalities into the current scope, utilize the following command:","category":"page"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"using JuliaGrid","category":"page"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"","category":"page"},{"location":"api/analysis/#AC-Powers","page":"Powers and Currents","title":"AC Powers","text":"","category":"section"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"power!\ninjectionPower\nsupplyPower\nshuntPower\nfromPower\ntoPower\nseriesPower\nchargingPower\ngeneratorPower","category":"page"},{"location":"api/analysis/#AC-Currents","page":"Powers and Currents","title":"AC Currents","text":"","category":"section"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"current!\ninjectionCurrent\nfromCurrent\ntoCurrent\nseriesCurrent","category":"page"},{"location":"api/analysis/#DC-Powers","page":"Powers and Currents","title":"DC Powers","text":"","category":"section"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"power!\ninjectionPower\nsupplyPower\nfromPower\ntoPower\ngeneratorPower","category":"page"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"","category":"page"},{"location":"api/analysis/#ACPowerAnalysisAPI","page":"Powers and Currents","title":"AC Powers","text":"","category":"section"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}","page":"Powers and Currents","title":"JuliaGrid.power!","text":"power!(analysis::AC)\n\nThe function computes the active and reactive powers associated with buses, branches, and generators for AC analysis.\n\nUpdates\n\nThis function updates the power field of the AC abstract type by computing the following electrical quantities:\n\ninjection: Active and reactive power bus injections.\nsupply: Active and reactive power bus injections from the generators.\nshunt: Active and reactive power values associated with shunt element at each bus.\nfrom: Active and reactive power flows at the from-bus end of each branch.\nto: Active and reactive power flows at the to-bus end of each branch.\ncharging: Active and reactive power values linked with branch charging admittances for each branch.\nseries Active and reactive power losses through each branch series impedance.\ngenerator: Produced active and reactive power outputs of each generator (not for state estimation).\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\npower!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.injectionPower","text":"injectionPower(analysis::AC; label)\n\nThe function returns the active and reactive power injections associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = injectionPower(analysis; label = \"Bus 1 HV\")\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{AcPowerFlow}","page":"Powers and Currents","title":"JuliaGrid.supplyPower","text":"supplyPower(analysis::AC; label)\n\nThe function returns the active and reactive power injections from the generators associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = supplyPower(analysis; label = \"Bus 1 HV\")\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.shuntPower-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.shuntPower","text":"shuntPower(analysis::AC; label)\n\nThe function returns the active and reactive power values of the shunt element associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = shuntPower(analysis; label = \"Bus 9 LV\")\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.fromPower","text":"fromPower(analysis::AC; label)\n\nThe function returns the active and reactive power flows at the from-bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = fromPower(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.toPower","text":"toPower(analysis::AC; label)\n\nThe function returns the active and reactive power flows at the to-bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = toPower(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesPower-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.seriesPower","text":"seriesPower(analysis::AC; label)\n\nThe function returns the active and reactive power losses across the series impedance of a specific branch within the AC framework. The label keyword argument should correspond to an existing branch label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = seriesPower(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.chargingPower-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.chargingPower","text":"chargingPower(analysis::AC; label)\n\nThe function returns the active and reactive power values associated with the charging admittances of a specific branch in the AC framework. The label keyword argument must correspond to an existing branch label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = chargingPower(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{AcPowerFlow}","page":"Powers and Currents","title":"JuliaGrid.generatorPower","text":"generatorPower(analysis::AC; label)\n\nThe function returns the active and reactive powers associated with a specific generator in the AC framework. The label keyword argument must match an existing generator label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nactive, reactive = generatorPower(analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"","category":"page"},{"location":"api/analysis/#ACCurrentAnalysisAPI","page":"Powers and Currents","title":"AC Currents","text":"","category":"section"},{"location":"api/analysis/#JuliaGrid.current!-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.current!","text":"current!(analysis::AC)\n\nThe function computes the currents in the polar coordinate system associated with buses and branches in the AC framework.\n\nUpdates\n\nThis function updates the current field of the AC abstract type by computing the following electrical quantities:\n\ninjection: Current injections at each bus.\nfrom: Current flows at each from-bus end of the branch.\nto: Current flows at each to-bus end of the branch.\nseries: Current flows through the series impedance of the branch in the direction from-bus to-bus end.\n\nExample\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\ncurrent!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.injectionCurrent-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.injectionCurrent","text":"injectionCurrent(analysis::AC; label)\n\nThe function returns the current injection in the polar coordinate system associated with a specific bus in the AC framework. The label keyword argument must match an existing bus label.\n\nExample\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nmagnitude, angle = injectionCurrent(analysis; label = \"Bus 1 HV\")\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromCurrent-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.fromCurrent","text":"fromCurrent(analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the from-bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nExample\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nmagnitude, angle = fromCurrent(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toCurrent-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.toCurrent","text":"toCurrent(analysis::AC; label)\n\nThe function returns the current in the polar coordinate system at the to-bus end associated with a specific branch in the AC framework. The label keyword argument must match an existing branch label.\n\nExample\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nmagnitude, angle = toCurrent(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.seriesCurrent-Tuple{AC}","page":"Powers and Currents","title":"JuliaGrid.seriesCurrent","text":"seriesCurrent(analysis::AC; label)\n\nThe function returns the current in the polar coordinate system through series impedance associated with a specific branch in the direction from the from-bus end to the to-bus end of the branch within the AC framework. The label keyword argument must  match an existing branch label.\n\nExample\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nmagnitude, angle = seriesCurrent(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/","page":"Powers and Currents","title":"Powers and Currents","text":"","category":"page"},{"location":"api/analysis/#DCPowerAnalysisAPI","page":"Powers and Currents","title":"DC Powers","text":"","category":"section"},{"location":"api/analysis/#JuliaGrid.power!-Tuple{DcPowerFlow}","page":"Powers and Currents","title":"JuliaGrid.power!","text":"power!(analysis::DC)\n\nThe function calculates the active power values related to buses, branches, and generators within the DC analysis framework.\n\nUpdates\n\nThis function updates the power field of the DC abstract type by computing the following electrical quantities:\n\ninjection: Active power injections at each bus.\nsupply: Active power injections from the generators at each bus.\nfrom: Active power flows at each from-bus end of the branch.\nto: Active power flows at each to-bus end of the branch.\ngenerator: Output active powers of each generator (excluding for state estimation).\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(analysis)\n\npower!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.injectionPower-Tuple{DcPowerFlow}","page":"Powers and Currents","title":"JuliaGrid.injectionPower","text":"injectionPower(analysis::DC; label)\n\nThe function returns the active power injection associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(analysis)\n\ninjection = injectionPower(analysis; label = \"Bus 2 HV\")\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.supplyPower-Tuple{DcPowerFlow}","page":"Powers and Currents","title":"JuliaGrid.supplyPower","text":"supplyPower(analysis::DC; label)\n\nThe function returns the active power injection from the generators associated with a specific bus in the DC framework. The label keyword argument must match an existing bus label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(analysis)\n\nsupply = supplyPower(analysis; label = \"Bus 2 HV\")\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.fromPower-Tuple{DC}","page":"Powers and Currents","title":"JuliaGrid.fromPower","text":"fromPower(analysis::DC; label)\n\nThe function returns the active power flow at the from-bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(analysis)\n\nfrom = fromPower(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.toPower-Tuple{DC}","page":"Powers and Currents","title":"JuliaGrid.toPower","text":"toPower(analysis::DC; label)\n\nThe function returns the active power flow at the to-bus end associated with a specific branch in the DC framework. The label keyword argument must match an existing branch label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(analysis)\n\nto = toPower(analysis; label = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/analysis/#JuliaGrid.generatorPower-Tuple{DcPowerFlow}","page":"Powers and Currents","title":"JuliaGrid.generatorPower","text":"generatorPower(analysis::DC; label)\n\nThis function returns the output active power associated with a specific generator in the DC framework. The label keyword argument must match an existing generator label.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(analysis)\n\ngenerator = generatorPower(analysis; label = 1)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/powerSystemModel/#ACDCModelTutorials","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Power system analyses commonly utilize the unified branch model that provides linear relationships between voltages and currents. However, as the focus is on power calculations rather than current calculations, the resulting equations become nonlinear, posing challenges in solving them [7]. Hence, to accurately analyze power systems without any approximations, we use the AC model, which is a crucial component of our framework. In contrast, to obtain a linear system of equations for various DC analyses, we introduce approximations in the unified branch model, resulting in the DC model.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIn this section, we not only describe the AC and DC models derived from the unified branch model but also furnish the power and current equations utilized in all JuliaGrid analyses.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"A common way to describe the power system network topology is through the bus/branch model, which employs the two-port pi-model, which results in the unified branch model. The bus/branch model can be represented by a graph denoted by mathcal G = (mathcal N mathcal E), where the set of nodes mathcal N = 1 dots n corresponds to buses, and the set of edges mathcal E subseteq mathcal N times mathcal N represents the branches of the power network.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Let us now construct the power system:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n@config(label = Integer)\n@power(MW, MVAr)\n@voltage(pu, deg)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)\naddBus!(system; label = 3, type = 2, conductance = 2.1, susceptance = 1.2)\n\naddBranch!(system; from = 1, to = 2, resistance = 0.02, reactance = 0.06, susceptance = 0.05)\naddBranch!(system; from = 2, to = 3, reactance = 0.21, turnsRatio = 0.98, shiftAngle = 1.2)\n\naddGenerator!(system; bus = 1, active = 40.0, reactive = 42.4)\nnothing #hide","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The given example provides the set of buses mathcal N and the set of branches mathcal E:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"ukw: Notation\nIn this section, when referring to a vector mathbf a, we use the notation mathbf a = a_ij, where a_ij represents the generic element associated with the branch (ij) in mathcal E.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#ACModelTutorials","page":"Power System Model","title":"AC Model","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To generate matrices and vectors for AC analysis, JuliaGrid employs the acModel! function:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!(system)\nnothing #hide","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#UnifiedBranchModelTutorials","page":"Power System Model","title":"Unified Branch Model","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The equivalent unified pi-model for a branch (ij) in mathcal E incident to the buses ij in mathcal N is shown in Figure 1.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"<div style=\"text-align: center;\">\n  <img src=\"../../assets/tutorials/powerSystemModel/pi_model.svg\" width=\"500\" class=\"my-svg\"/>\n  <p>Figure 1: The equivalent branch model, where the transformer is located at the from-bus end of the branch.</p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nThe directions of the currents barI_ij, barI_ji, barI_mathrmsi, and barI_mathrmsj are vital for power flow analysis. Positive power aligns with the assumed current direction, moving away from the bus, while negative power implies a reverse flow towards the bus. JuliaGrid consistently uses these directions, along with barI_mathrmlij, for power and current calculations.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The branch series admittance y_ij is inversely proportional to the branch series impedance z_ij:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  y_ij = frac1z_ij = frac1r_ij + mathrmj x_ij =\n  fracr_ijr_ij^2 + x_ij^2 - mathrmj fracx_ijr_ij^2 + x_ij^2 = g_ij + mathrmj b_ij","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where r_ij is a resistance, x_ij is a reactance, g_ij is a conductance and b_ij is a susceptance of the branch.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The vectors of resistances, denoted by mathbf r = r_ij, and reactances, denoted by mathbf x = x_ij, are stored in the variables:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐫 = system.branch.parameter.resistance\n𝐱 = system.branch.parameter.reactance","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Moreover, the ac field stores the computed vector of branch series admittances mathbf y = y_ij:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐲 = system.model.ac.admittance","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The branch shunt admittance y_mathrmsij is equal to:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  y_mathrmsij = g_mathrmsij + mathrmj b_mathrmsij","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where g_mathrmsij represents the shunt conductance of the branch, and b_mathrmsij represents the shunt susceptance. Both of these values are positive for real line sections. It is worth noting that while the shunt conductance g_mathrmsij is often insignificantly small and can be ignored in many cases, it is included in the analyses to ensure comprehensive consideration of all potential scenarios.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Within JuliaGrid, the total shunt conductances and susceptances of branches are stored. In order to obtain the vectors mathbfg_mathrms = g_mathrmsij and mathbfb_mathrms = b_mathrmsij, the conductances and susceptances must be distributed by considering the ends of the branches:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐠ₛ = 0.5 * system.branch.parameter.conductance\n𝐛ₛ = 0.5 * system.branch.parameter.susceptance","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The transformer complex ratio alpha_ij is defined:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  alpha_ij = cfrac1tau_ij e^-mathrmjphi_ij","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where tau_ij neq 0 is a transformer turns ratio, specifically the off-nominal turns ratio, while phi_ij is a transformer phase shift angle, always located at the from-bus end of the branch. Note, if tau_ij = 1 and phi_ij = 0 the model describes the line. In-phase transformers are defined if tau_ij neq 1, phi_ij = 0, and y_mathrmsij = 0, while phase-shifting transformers are obtained if tau_ij neq 1, phi_ij neq 0, and y_mathrmsij = 0.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"These transformer parameters are stored in the vectors bm tau = tau_ij and bm phi = phi_ij, respectively:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝛕 = system.branch.parameter.turnsRatio\n𝚽 = system.branch.parameter.shiftAngle","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#BranchShuntElementsTutorials","page":"Power System Model","title":"Branch Shunt Elements","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The currents flowing through shunt admittances denoted as y_mathrmsij are defined as follows:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginaligned\n    barI_mathrmsi = alpha_ij y_mathrmsij barV_i  (ij) in mathcal E \n    barI_mathrmsj = y_mathrmsij barV_j  (ij) in mathcal E\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"With these specified currents in place, it becomes straightforward to compute both the total active and reactive power that branch shunt elements demand and inject concerning the power system:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  S_mathrmsij = P_mathrmsij + mathrmj Q_mathrmsij = alpha_ij barV_i barI_mathrmsi^* + barV_j barI_mathrmsj^* =\n  y_mathrmsij^* (alpha_ij^2 V_i^2 + V_j^2)  (ij) in mathcal E","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For real branch sections, the reactive power is negative, Q_mathrmsij  0, signifying that the branch injects reactive power due to its capacitive nature. The negative sign implies that the power flow direction opposes the assumed direction set by the currents barI_mathrmsi and barI_mathrmsj. The active power P_mathrmsij represents active losses within the branch shunt admittances.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#BranchSeriesElementTutorials","page":"Power System Model","title":"Branch Series Element","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The current flowing through a series admittance, denoted as y_ij, is defined as follows:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  barI_mathrmlij = alpha_ij y_ij barV_i - y_ij barV_i  (ij) in mathcal E","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Consequently, the active and reactive powers associated with the branch series element are as follows:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  S_mathrmlij = P_mathrmlij + mathrmjQ_mathrmlij = (alpha_ij barV_i - barV_j) barI_mathrmlij^* =\n  y_ij^* (alpha_ij barV_i - barV_j) (alpha_ij barV_i - barV_j)^*  (ij) in mathcal E","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The active power P_mathrmlij accounts for losses originating from the resistance r_ij of the branch, while the reactive power Q_mathrmlij represents losses resulting from the inductive characteristics of the impedance defined by reactance x_ij. This can be observed when the reactive power is positive Q_mathrmlij  0.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#BranchNetworkEquationsTutorials","page":"Power System Model","title":"Branch Network Equations","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Using Kirchhoff's circuit laws, the branch model can be described by complex expressions:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_ij^2 (y_ij + y_mathrmsij)  -alpha_ij^* y_ij\n    -alpha_ij y_ij  y_ij + y_mathrmsij\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The admittance parameters are stored in the vectors mathbfy_mathrmii = (y_ij + y_mathrmsij)  tau_ij^2, mathbfy_mathrmij = -alpha_ij^* y_ij, mathbfy_mathrmji = -alpha_ij y_ij, and mathbfy_mathrmjj = y_ij + y_mathrmsij and can be found in the variables:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐲ᵢᵢ = system.model.ac.nodalFromFrom\n𝐲ᵢⱼ = system.model.ac.nodalFromTo\n𝐲ⱼᵢ = system.model.ac.nodalToFrom\n𝐲ⱼⱼ = system.model.ac.nodalToTo","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this context, we have easily derived the active and reactive power flow at the from-bus end of the branch:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  S_ij = P_ij + mathrmj Q_ij =\n  barV_i leftcfrac1tau_ij^2 (y_ij + y_mathrmsij) barV_i - alpha_ij^* y_ij barV_jright^*  (ij) in mathcal E","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, we can determine the active and reactive power flow at the to-bus end of the branch:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  S_ji = P_ji + mathrmj Q_ji =\n  barV_j left-alpha_ij y_ij barV_i + (y_ij + y_mathrmsij) barV_jright^*  (ij) in mathcal E","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Positive values of active or reactive power, P_ij  0 or Q_ij  0, indicate power flow originating from the from-bus and moving towards the to-bus, following the direction of the current barI_ij. Conversely, negative values, P_ij  0 or Q_ij  0, signify power flow in the opposite direction. The same principles apply to P_ji  0 or Q_ji  0, indicating power flow from the to-bus to the from-bus, aligned with the current barI_ji, while negative values, P_ji  0 or Q_ji  0, denote the reverse flow direction.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#NodalNetworkEquationsTutorials","page":"Power System Model","title":"Nodal Network Equations","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Let us consider an illustrative example from our case study, depicted in Figure 2. This example provides a smooth transition to the general case, demonstrating a system with three buses represented as mathcalN = 1 2 3 and two branches mathcalE = (1 2) (2 3), where bus 2 is incident to the shunt element with admittance y_mathrmsh2.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"<div style=\"text-align: center;\">\n  <img src=\"../../assets/tutorials/powerSystemModel/pi_model_example.svg\" width=\"650\" class=\"my-svg\"/>\n  <p>Figure 2: The example of the system with three buses and two branches.</p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nThe current barI_mathrmsh2 follows the convention of coming out from the bus in terms of its direction. When calculating powers related to shunt elements, this current direction is assumed. Therefore, in cases where power is positive, it signifies alignment with the assumed current direction, emerging away from the bus. Conversely, when power is negative, the direction is reversed, indicating a flow towards the bus.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"According to the Branch Network Equations each branch is described using the system of equations as follows:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    barI_12  barI_21\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_12^2 (y_12 + y_mathrms12)  -alpha_12^* y_12\n    -alpha_12 y_12  y_12 + y_mathrms12\n  endbmatrix\n  beginbmatrix\n    barV_1  barV_2\n  endbmatrix","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    barI_23  barI_32\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_23^2 (y_23 + y_mathrms23)  -alpha_23^* y_23\n    -alpha_23 y_23  y_23 + y_mathrms23\n  endbmatrix\n  beginbmatrix\n    barV_2  barV_3\n  endbmatrix","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The complex current injections at buses are:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginaligned\n    barI_1 = barI_12 = cfrac1tau_12^2 (y_12 + y_mathrms12) barV_1 -alpha_12^* y_12 barV_2 \n    barI_2 = barI_21 + barI_23 + barI_mathrmsh2 = -alpha_12 y_12 barV_1 + (y_12 + y_mathrms12) barV_2 +\n    cfrac1tau_23^2 (y_23 + y_mathrms23) barV_2 -alpha_23^* y_23 barV_3 + y_mathrmsh2 barV_2 \n    barI_3 = barI_32 = -alpha_23 y_23 barV_2 + (y_23 + y_mathrms23) barV_3\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    barI_1  barI_2  barI_3\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_12^2 (y_12 + y_mathrms12)  -alpha_12^* y_12  0 \n   -alpha_12 y_12  y_12 + y_mathrms12 + cfrac1tau_23^2 (y_23 + y_mathrms23) + y_mathrmsh2   -alpha_23^* y_23 \n    0  -alpha_23 y_23  y_23 + y_mathrms23\n  endbmatrix\n  beginbmatrix\n    barV_1  barV_2  barV_3\n  endbmatrix","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This system of equations can be generalized to accommodate the scenario where the set mathcalN comprises n buses:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  mathbfbar I = mathbfY mathbfbar V","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where mathbfbar V in mathbbC^n is the vector of bus complex voltages, and mathbfbar I in mathbbC^n is the vector of complex current injections at buses. The matrix mathbfY = mathbfG + mathrmjmathbfB in mathbbC^n times n is the bus or nodal admittance matrix, with elements:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"the diagonal elements, where i in mathcalN, are equal to:\n  Y_ii = G_ii + mathrmj B_ii =\n  y_mathrmshi + sumlimits_e in mathcalE  e(1) = i cfrac1tau_ij^2 (y_ij + y_mathrmsij) +\n  sumlimits_e in mathcalE  e(2) = i (y_ji + y_mathrmsji)\nthe non-diagonal elements, where i = e(1) j = e(2)  e in mathcalE, are equal to:\n  beginaligned\n    Y_ij = G_ij + mathrmj B_ij = -alpha_ij^* y_ij 4pt\n    Y_ji = G_ji + mathrmj B_ji = -alpha_ij y_ij\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"When a branch is not incident (or adjacent) to a bus the corresponding element in the nodal admittance matrix mathbfY is equal to zero. The nodal admittance matrix mathbfY is sparse (i.e., a small number of elements are non-zeros) for real-world power systems. Although it is often assumed that the matrix mathbfY is symmetrical, it is not a general case. For example, in the presence of phase shifting transformers the matrix mathbfY is not symmetric [8, Sec. 9.6]. JuliaGrid stores both the matrix mathbfY and its transpose mathbfY^T in the ac field of the PowerSystem type:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐘 = system.model.ac.nodalMatrix\n𝐘ᵀ = system.model.ac.nodalMatrixTranspose","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#BusInjectionsTutorials","page":"Power System Model","title":"Bus Injections","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"From the previous analysis, we can determine the complex current injection at each bus as follows:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  barI_i = sumlimits_j = 1^n Y_ij barV_j  i in mathcal N","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Furthermore, the calculation of active and reactive power injection at each bus is expressed by the following:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  S_i = P_i + mathrmj Q_i = barV_i sumlimits_j = 1^n Y_ij^* barV_j^*  i in mathcal N","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Positive values of active or reactive powers, P_i  0 or Q_i  0, indicate that the bus is supplying power into the power system. Conversely, negative values, P_i  0 or Q_i  0, suggest that the bus is drawing active or reactive power from the power system.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#BusShuntElementTutorials","page":"Power System Model","title":"Bus Shunt Element","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Based on the previous analysis, we can determine the active and reactive power at the shunt element of each bus using the following equation:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  S_mathrmshi = P_mathrmshi + mathrmj Q_mathrmshi =\n  barV_i barI_mathrmshi^* = y_mathrmshi^* V_i^2  i in mathcal N","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The positive active power value P_mathrmshi  0 indicates that the shunt element is consuming active power. In terms of power flow, this signifies that active power flows from bus i in mathcal N towards the ground. A negative reactive power value Q_mathrmshi  0 suggests that the shunt element is injecting reactive power into the power system. This implies that the direction of reactive power is from the ground to bus i in mathcal N, illustrating the capacitive nature of the shunt component. Conversely, if Q_mathrmshi  0, it indicates an inductive characteristic, implying that the shunt component is absorbing reactive power.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#DCModelTutorials","page":"Power System Model","title":"DC Model","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The DC model is obtained by linearization of the nonlinear model, and it provides an approximate solution. In the typical operating conditions, the difference of bus voltage angles between adjacent buses (ij) in mathcalE is very small theta_i - theta_j approx 0, which implies cos(theta_i - theta_j) approx 1 and sin(theta_i - theta_j) approx theta_i - theta_j. Further, all bus voltage magnitudes are V_i approx 1, i in mathcalN, and all branch shunt admittances and branch resistances can be neglected. This implies that the DC model ignores the reactive powers and transmission losses and takes into account only the active powers.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Therefore, the DC power flow takes only bus voltage angles bm Theta in mathbbR^n as variables. To create vectors and matrices related to DC or linear analyses, JuliaGrid uses the function dcModel!:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#DCBranchNetworkEquationsTutorials","page":"Power System Model","title":"Branch Network Equations","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"According to the above assumptions, we start from the Unified Branch Model:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    barI_ij  barI_ji\n  endbmatrix = cfrac1mathrmj x_ij\n  beginbmatrix\n    cfrac1tau_ij^2  -alpha_ij^*\n    -alpha_ij  1\n  endbmatrix\n  beginbmatrix\n    barV_i  barV_j\n  endbmatrix","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where barV_i = mathrme^mathrmjtheta_i and barV_j = mathrme^mathrmjtheta_j. Further, we have:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginaligned\n    barI_ij = cfrac1mathrmjx_ij leftcfrac1tau_ij^2 mathrme^mathrmjtheta_i -\n    cfrac1tau_ijmathrme^mathrmj(phi_ij + theta_j) right \n    barI_ji = cfrac1mathrmjx_ij left-cfrac1tau_ij mathrme^mathrmj(theta_i - phi_ij) + mathrme^mathrmjtheta_j right\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The active power flows are derived as follows:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginaligned\n    P_ij = RebarV_i barI_ij^* =\n    Re leftmathrmj cfrac1x_ij\n    leftcfrac1tau_ij^2 - cfrac1tau_ij e^mathrmj(theta_i - theta_j - phi_ij) right right \n    P_ji = RebarV_j barI_ji^* =\n    Re leftmathrmj cfrac1x_ij\n   left1 - cfrac1tau_ij e^mathrmj(-theta_i + theta_j + phi_ij) right  right\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The real components are:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginaligned\n    P_ij =cfrac1tau_ijx_ij sin(theta_i - theta_j - phi_ij) approx cfrac1tau_ijx_ij (theta_i - theta_j - phi_ij) \n    P_ji =cfrac1tau_ijx_ij sin(theta_j - theta_i + phi_ij) approx -cfrac1tau_ij x_ij (theta_i - theta_j - phi_ij)\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where 1(tau_ij x_ij) represents the branch admittance in the DC framework. To recall, the PowerSystem type stores the reactances as vector mathbf x = x_ij in the variable:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐱 = system.branch.parameter.reactance","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Furthermore, the computed branch admittances in the DC framework are stored in the vector mathbf y = 1(tau_ij x_ij):","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐲 = system.model.dc.admittance","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can conclude that P_ij = -P_ji holds. With the DC model, the linear network equations relate active powers to bus voltage angles, versus complex currents to complex bus voltages in the AC model [9]. Consequently, analogous to the Branch Network Equations we can write:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    P_ij  P_ji\n  endbmatrix = cfrac1tau_ijx_ij\n  beginbmatrix*r\n    1  -1\n    -1  1\n  endbmatrix*\n  beginbmatrix\n    theta_i  theta_j\n  endbmatrix + cfracphi_ijtau_ijx_ij\n  beginbmatrix*r\n    -1  1\n  endbmatrix*","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#DCNodalNetworkEquationsTutorials","page":"Power System Model","title":"Nodal Network Equations","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As before, let us consider an illustrative example from our case study, depicted in Figure 3. This example provides a smooth transition to the general case, demonstrating a system with three buses represented as mathcalN = 1 2 3 and two branches mathcalE = (1 2) (2 3), where bus 2 is incident to the shunt element with admittance g_mathrmsh2.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"<div style=\"text-align: center;\">\n  <img src=\"../../assets/tutorials/powerSystemModel/dc_model.svg\" width=\"500\" class=\"my-svg\"/>\n  <p>Figure 3: The example of the system with three buses and two branches.</p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Each branch in the DC framework is described with a system of equations as follows:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    P_12  P_21\n  endbmatrix = cfrac1tau_12x_12\n  beginbmatrix*r\n    1  -1\n    -1  1\n  endbmatrix*\n  beginbmatrix\n    theta_1  theta_2\n  endbmatrix + cfracphi_12tau_12x_12\n  beginbmatrix*r\n    -1  1\n  endbmatrix*","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    P_23  P_32\n  endbmatrix = cfrac1tau_23x_23\n  beginbmatrix*r\n    1  -1\n    -1  1\n  endbmatrix*\n  beginbmatrix\n    theta_2  theta_3\n  endbmatrix + cfracphi_23tau_23x_23\n  beginbmatrix*r\n    -1  1\n  endbmatrix*","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The active power injections at buses are:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginaligned\n    P_1 = P_12 =cfrac1tau_12x_12 theta_1 - cfrac1tau_12x_12 theta_2 - cfracphi_12tau_12x_12 \n    P_2 = P_21 + P_23 + P_mathrmsh2 = -cfrac1tau_12x_12 theta_1 + cfrac1tau_12x_12 theta_2 +\n    cfracphi_12tau_12x_12 + cfrac1tau_23x_23 theta_2 - cfrac1tau_23x_23 theta_3 -\n    cfracphi_23tau_23x_23 + g_mathrmsh2 \n    P_3 = P_32 = -cfrac1tau_23x_23 theta_2 +cfrac1tau_23x_23 theta_3 + cfracphi_23tau_23x_23\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where the active power injected by the shunt element at the bus 2 is equal to:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  P_mathrmsh2 =\n  RebarV_2 barI_mathrmsh2^* = RebarV_2 y_mathrmsh2^* barV_2^* = V_2^2 g_mathrmsh2 = g_mathrmsh2","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The system of equations can be written in the matrix form:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  beginbmatrix\n    P_1  P_2  P_3\n  endbmatrix =\n  beginbmatrix\n    cfrac1tau_12x_12  -cfrac1tau_12x_12  0 \n    -cfrac1tau_12x_12  cfrac1tau_12x_12 + cfrac1tau_23x_23   -cfrac1tau_23x_23 \n    0  -cfrac1tau_23x_23  cfrac1tau_23x_23\n  endbmatrix\n  beginbmatrix\n    theta_1  theta_2  theta_3\n  endbmatrix +\n  beginbmatrix\n    - cfracphi_12tau_12x_12  cfracphi_12tau_12x_12 - cfracphi_23tau_23x_23  cfracphi_23tau_23x_23\n  endbmatrix +\n  beginbmatrix\n    0  g_mathrmsh2  0\n  endbmatrix","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This system of equations can be generalized to accommodate the scenario where the set mathcalN comprises n buses:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"  mathbf P = mathbf B bm Theta + mathbfP_mathrmtr + mathbfP_mathrmsh","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"where bm Theta in mathbbR^n is the vector of bus voltage angles.","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The vector mathbf P in mathbbR^n contains active power injections at buses caused by generators and demands. In JuliaGrid, the vector can be recovered using a command:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐏 = system.bus.supply.active - system.bus.demand.active","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The vector mathbfP_mathrmtr in mathbbR^n represents active powers related to the non-zero shift angle of transformers. This vector is stored in the dc field, and we can access it using:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐏ₜᵣ = system.model.dc.shiftPower","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The vector mathbfP_mathrmsh in mathbbR^n represents active powers consumed by shunt elements. We can access this vector using:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐏ₛₕ = system.bus.shunt.conductance","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The bus or nodal matrix in the DC framework is given as mathbf B in mathbbR^n times n, with elements:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"the diagonal elements, where i in mathcal N, are equal to:\nB_ii = sumlimits_e in mathcal E i in e cfrac1tau_ijx_ij\nthe non-diagonal elements, where i = e(1) j = e(2)  e in mathcal E, are equal to:\n  beginaligned\n    B_ij = -cfrac1tau_ijx_ij 3pt\n    B_ji = -cfrac1tau_ijx_ij\n  endaligned","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The sparse nodal matrix mathbf B is stored in the dc field, and we can access it using:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"𝐁 = system.model.dc.nodalMatrix","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"tutorials/powerSystemModel/#DCBusInjectionTutorials","page":"Power System Model","title":"Bus Injection","text":"","category":"section"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"From the previous analysis, the calculation of active power injection at each bus is expressed by:","category":"page"},{"location":"tutorials/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"    P_i = sum_j = 1^n B_ij theta_j + P_mathrmtri + P_mathrmshi  i in mathcal N","category":"page"},{"location":"tutorials/perunit/#PerUnitSystem","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"In power system modeling and analysis, variables and parameters are often normalized using the per-unit system. The per-unit system is particularly advantageous for analyzing networks with multiple voltage levels connected by transformers with different turns ratios.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"In static scenarios, there are four key quantities of interest: voltage, current, power, and impedance or admittance. Defining a per-unit system requires selecting base values for each of these quantities. However, since these quantities are interconnected by various laws, the choice of base values cannot be arbitrary. Typically, the base quantities are chosen as voltage and power, with the base current and impedance (or admittance) then calculated accordingly. Usually, base quantities are selected as follows:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"three-phase apparent power S_3phi(textb),\nline-to-line voltage V_LL(textb).","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"While the value of three-phase apparent power is unique across the entire system, multiple line-to-line base voltages are used to account for the different voltage zones created by transformers.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"note: Info\nSince balanced three-phase power systems are treated as a single line with a neutral return, confusion may arise regarding the relationship between the per-unit values of line voltages and phase voltages, as well as between the per-unit values of single-phase and three-phase powers [8]. To clarify these relationships, we will systematically explore the conversions between the per-unit and SI systems below.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Powers","page":"Per-Unit System","title":"Powers","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Let us consider the three-phase apparent power expressed in SI units, denoted as S_3phi(textsi). To convert this into the per-unit system, we divide it by the base power:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"S_3phi(textpu) = cfracS_3phi(textsi)S_3phi(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Now, let us examine the power of a single phase and convert it to the per-unit system:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"S_1phi(textpu)  = cfracS_1phi(textsi)S_1phi(textb) = cfracS_3phi(textsi)3 cfrac3S_3phi(textb) = cfracS_3phi(textsi)S_3phi(textb) = S_3phi(textpu)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"This indicates that in the per-unit system, there is no distinction between three-phase and single-phase powers. The type of power only becomes relevant when converting back from per-unit to SI units, and vice versa.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"note: Info\nAs is standard practice, even if all simulations utilize a single-phase equivalent, input powers provided in SI units are assumed to represent three-phase powers. Similarly, if simulation results are displayed in SI units, they are considered to be three-phase powers, as we have selected three-phase power as the base value.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Voltages","page":"Per-Unit System","title":"Voltages","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Format for input data that JuliaGrid uses required value for base voltage per each bus, and those values represent the line-to-line voltages. On the other hand, in all analyses we are working with line-to-neutral voltages. To convert a line-to-neutral voltage given in SI units V_LN(textsi) to per-unit form V_LN(textpu), or vice versa, we use the formula:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"V_LN(textpu) = cfracsqrt3V_LN(textsi)V_LL(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"note: Info\nSimilarly to power, JuliaGrid simulations use a single-phase equivalent. Voltage values specified in volts correspond to line-to-neutral values, while base voltages are expected to be provided as line-to-line values.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Impedances","page":"Per-Unit System","title":"Impedances","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Let us first consider the line itself, excluding transformers. The base impedance of the line is given by:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Z_L(textb) = cfracV_LL(textb)^2S_3phi(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"If the impedance is provided in ohms, its value in the per-unit system is:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Z_L(textpu) = cfracZ_L(textsi)Z_L(textb) = cfracZ_L(textsi) S_3phi(textb)V_LL(textb)^2","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"A common question that arises is which base voltage should be used for the line, considering the two ends of the line (from-bus and to-bus). The key assumption here is that the base voltages correspond to the nominal voltages of the transformers. Therefore, when the user defines base voltages, JuliaGrid assumes these voltages represent the nominal voltages of the transformers, implying that the base voltages on both the from-bus and to-bus ends of the line will be the same.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Now, let us consider the transformer. The base voltages at the from-bus end (primary side) V_LLF(textb), and the to-bus end (secondary side) V_LLT(textb), will generally be different. This requires us to define a conversion method for impedance. Typically, when impedance is given in ohms, it refers to the primary side of the transformer, denoted as Z_F(textsi),  while the impedance in our unified branch model refers to the secondary side, denoted as Z_T(textsi). To convert the impedance from the from-bus end to the to-bus end, we use:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Z_T(textsi) = cfracZ_F(textsi)m^2","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"where m is the effective turns ratio, calculated as:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"m = tau cfracV_LLF(textb)V_LLT(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"with tau is off-nominal turns ratio. This equation provides the impedance on the to-bus end of the branch or the secondary side of the transformer in ohms.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"To convert this impedance to the per-unit system, we use the base impedance for the secondary side:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Z_T(textpu) = cfracZ_T(textsi)Z_T(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"where:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Z_T(textb) = cfracV_LLT(textb)^2S_3phi(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Substituting the previous expressions, we obtain the following formula for the impedance on the secondary side in per-unit system:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Z_T(textpu) = cfracZ_F(textsi) S_3phi(textb)tau^2 V_LLF(textb)^2","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"This formula applies to both lines and transformers. For a line, where tau = 1, the formula simplifies and becomes the same as the impedance equation for a line.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"note: Info\nIn the case of a transformer, if impedances or admittances are provided in SI units, they must be specified for the primary side (from-bus end).","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Currents","page":"Per-Unit System","title":"Currents","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Once the base power and base voltage values are set, we can calculate the base current flowing through a line or branch as follows:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"I_L(textb) = cfracS_3phi(textb)sqrt3V_LL(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"When we transform currents that are given in SI unit to per-unit, or vice versa, we use the following formula:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"I_L(textpu) = cfracI_L(textsi)I_L(textb) = cfracsqrt3I_L(textsi)V_LL(textb)S_3phi(textb)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Per-Units-to-SI-Units","page":"Per-Unit System","title":"Per-Units to SI Units","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"To create a comprehensive tutorial, let us start with an example where input data is defined in per-units, while the simulation results are outputted in SI units.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"using JuliaGrid # hide\n@default(template) # hide\n\nsystem = powerSystem()\n@base(system, MVA, kV)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"First, we initialize the power system container, setting the base value for three-phase apparent power S_3phi(textb). We use a macro to specify that power is given in megavolt-amperes (MVA):","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"system.base.power.value","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"We also specify that base line-to-line voltages will be stored in kilovolts (kV).","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Buses","page":"Per-Unit System","title":"Buses","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Next, we add buses to the system:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"addBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.0, base = 115e3)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 1.1, base = 230e3)\naddBus!(system; label = \"Bus 3\", type = 1, active = 1.2, reactive = 0.1, base = 230e3)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"The base keyword allows us to specify base line-to-line voltages V_LL(textb) for each bus in volts (V). However, these voltages are stored in kV, as specified by the @base macro:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"print(system.bus.label, system.base.voltage.value)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"The magnitude keyword sets the initial line-to-neutral bus voltages in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"print(system.bus.label, system.bus.voltage.magnitude)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Using the active and reactive keywords, we define the three-phase power demands for the load at Bus 3 in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"print(system.bus.label, system.bus.demand.active, system.bus.demand.reactive)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Branches","page":"Per-Unit System","title":"Branches","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Now, let us define the branches:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"@branch(label = \"Branch ?\")\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", turnsRatio = 0.98, reactance = 0.03)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", reactance = 0.1, susceptance = 0.03)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"The first branch represents a transformer, with its reactance given in per-units on the secondary side (to-bus end), and an off-nominal turns ratio of tau = 098. The second branch represents a transmission line, with parameters also specified in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"prmt = system.branch.parameter;\nprint(system.branch.label, prmt.reactance, prmt.susceptance, prmt.turnsRatio)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Generators","page":"Per-Unit System","title":"Generators","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Finally, we add a generator to our example:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"@generator(label = \"Generator ?\")\naddGenerator!(system; bus = \"Bus 1\", active = 2.3, reactive = 0.2)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"We set up the generator at Bus 1, using the active and reactive keywords to define the three-phase power output of the generator in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"output = system.generator.output;\nprint(system.generator.label, output.active, output.reactive)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#AC-Power-Flow","page":"Per-Unit System","title":"AC Power Flow","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"For example, we can perform AC power flow analysis on our defined power system:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"analysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Results","page":"Per-Unit System","title":"Results","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Now, we can examine some results in SI units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"@voltage(kV, deg)\n@power(MW, MVAr)\n\nshow = Dict(\"Power Generation\" => false, \"Shunt Power\" => false)\nprintBusData(analysis; show)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Here, the voltage magnitudes in kV represent line-to-neutral voltages for each bus, while the powers in MW and MVAr represent three-phase powers.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#SI-Units-to-Per-Units","page":"Per-Unit System","title":"SI Units to Per-Units","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"In this section, we will create the same power system as before, but using SI units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"using JuliaGrid # hide\n@default(template) # hide\n\n@voltage(kV, deg, kV)\n@power(MW, MVAr)\n@parameter(Ω, S)\n\nsystem = powerSystem()\n@base(system, MVA, kV)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Note that even though we define parameters in SI units, JuliaGrid will automatically convert these parameters to per-units and store them in that format.","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Buses-2","page":"Per-Unit System","title":"Buses","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Next, we add the same three buses, this time using SI units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"addBus!(system; label = \"Bus 1\", type = 3, magnitude = 115 / sqrt(3) , base = 115.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 253 / sqrt(3), base = 230.0)\naddBus!(system; label = \"Bus 3\", type = 1, active = 120, reactive = 100, base = 230.0)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"The base keyword specifies the base line-to-line voltages V_LL(textb) for each bus in kV, and these values are also stored in kV:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"print(system.bus.label, system.base.voltage.value)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"The magnitude keyword sets the initial line-to-neutral bus voltages in kV, but they are stored in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"print(system.bus.label, system.bus.voltage.magnitude)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Using the active and reactive keywords, we define the three-phase power demands for the load at Bus 3 in SI units, which are then stored in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"print(system.bus.label, system.bus.demand.active, system.bus.demand.reactive)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Branches-2","page":"Per-Unit System","title":"Branches","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Now, let us define the branches:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"@branch(label = \"Branch ?\")\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", turnsRatio = 0.98, reactance = 3.81)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", reactance = 52.9, susceptance = 5.67e-5)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"The first branch represents a transformer, with its reactance specified in ohms on the primary side (from-bus end) and an off-nominal turns ratio of tau = 098. This reactance is then converted to the secondary side and transformed into per-units. The second branch represents a transmission line, with its parameters in SI units, which are also stored in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"prmt = system.branch.parameter;\nprint(system.branch.label, prmt.reactance, prmt.susceptance, prmt.turnsRatio)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Generators-2","page":"Per-Unit System","title":"Generators","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Finally, we add the same generator as before:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"@generator(label = \"Generator ?\")\naddGenerator!(system; bus = \"Bus 1\", active = 230.0, reactive = 20.0)\n\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Using the active and reactive keywords, we define the three-phase power output of the generator in SI units, and these values are stored in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"output = system.generator.output;\nprint(system.generator.label, output.active, output.reactive)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#AC-Power-Flow-2","page":"Per-Unit System","title":"AC Power Flow","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"As before, we can perform AC power flow analysis on our defined power system:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"analysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"","category":"page"},{"location":"tutorials/perunit/#Results-2","page":"Per-Unit System","title":"Results","text":"","category":"section"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Now, we will examine the results in per-units:","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"@voltage(pu, rad)\n@power(pu, pu)\n\nshow = Dict(\"Power Generation\" => false, \"Shunt Power\" => false)\nprintBusData(analysis; show)","category":"page"},{"location":"tutorials/perunit/","page":"Per-Unit System","title":"Per-Unit System","text":"Here, the voltage magnitudes in per-units represent line-to-neutral voltages for each bus, while the powers are independent of whether they are three-phase or single-phase, since they are expressed in per-units.","category":"page"},{"location":"examples/acStateEstimation/#ACStateEstimationExamples","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In this example, we analyze a 3-bus power system, shown in Figure 1. The objective is to estimate bus voltage magnitudes and angles for a given measurement configuration.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/acStateEstimation/3bus_meter.svg\" width=\"320\" class=\"my-svg\"/>\n    <p>Figure 1: The 3-bus power system with the given measurement configuration.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The measurement set consists of Meter 1, Meter 2, and Meter 3, each measuring active and reactive power injection as well as bus voltage magnitude. Additionally, Meter 4 and Meter 5 measure active and reactive power flows along with current magnitudes.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"We define the power system, specify buses and branches, and assign the generator to the slack bus:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using JuliaGrid # hide\n@default(template) # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", magnitude = 1.01, angle = 0.0, type = 3)\naddBus!(system; label = \"Bus 2\", magnitude = 0.92, angle = -0.04)\naddBus!(system; label = \"Bus 3\", magnitude = 0.93, angle = -0.05)\n\n@branch(reactance = 0.03)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 3\", resistance = 0.02)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", resistance = 0.05)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", resistance = 0.04)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\")\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The magnitude and angle values define the initial point for the iterative AC state estimation algorithm, while the angle of the slack bus (type = 3) remains fixed at the specified value.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Display-Data-Settings","page":"AC State Estimation","title":"Display Data Settings","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Before running simulations, we set the verbose keyword from its default silent mode (0) to basic output (1):","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"@config(verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"However, if we need more detailed solver output, the verbose setting can be adjusted within the functions responsible for solving specific analyses. Next, we configure the data display settings:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"show = Dict(\"Shunt Power\" => false, \"Status\" => false)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Measurement-Model","page":"AC State Estimation","title":"Measurement Model","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The first question is how to obtain measurement data, specifically values. These can either be predefined or generated artificially. This example explores different approaches for defining measurement data.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"One way to obtain measurement data is by solving the power system to determine exact electrical quantities, which will serve as the source for measurements. More precisely, AC power flow analysis is used to compute voltages and powers, and these exact values are then used to generate measurement data.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To begin, let us initialize the measurement variable:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"monitoring = measurement(system)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#AC-Power-Flow","page":"AC State Estimation","title":"AC Power Flow","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"AC power flow analysis requires generator and load data. The system configuration is shown in Figure 2.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/acStateEstimation/3bus.svg\" width=\"350\" class=\"my-svg\"/>\n    <p>Figure 2: The 3-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Data for loads and generators is added as follows:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"updateBus!(system; label = \"Bus 2\", type = 1, active = 1.1, reactive = 0.3)\nupdateBus!(system; label = \"Bus 3\", type = 1, active = 2.3, reactive = 0.2)\n\nupdateGenerator!(system; label = \"Generator 1\", active = 3.3, reactive = 2.1)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, AC power flow analysis is performed to obtain bus voltages:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"acModel!(system)\n\npowerFlow = newtonRaphson(system)\npowerFlow!(powerFlow)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Bus-Voltage-Magnitude-Measurements","page":"AC State Estimation","title":"Bus Voltage Magnitude Measurements","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"First, let us examine the results obtained from AC power flow, as these voltage magnitude values will be used to generate measurements:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printBusData(powerFlow)","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"One way to obtain measurements is by creating all bus voltage magnitude measurements using a function that directly utilizes the results from AC power flow:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"@voltmeter(label = \"Meter ?\")\naddVoltmeter!(monitoring, powerFlow; variance = 1e-4, noise = true)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"By setting noise = true, white Gaussian noise with variance = 1e-4 is added to the exact bus voltage magnitude values to generate measurement values:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printVoltmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Active-and-Reactive-Power-Measurements","page":"AC State Estimation","title":"Active and Reactive Power Measurements","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Active and reactive power injection measurements can be created using the same method as for voltage magnitude measurements, where we first utilize the function power!. However, in this case, we take a different approach, adding measurements one by one to Meter 1, Meter 2, and Meter 3 using data from AC power flow:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"@wattmeter(label = \"Meter ?\")\n@varmeter(label = \"Meter ?\")\n\nfor (label, idx) in system.bus.label\n    Pᵢ, Qᵢ = injectionPower(powerFlow; label)\n    addWattmeter!(monitoring; bus = label, active = Pᵢ, variance = 1e-3, noise = true)\n    addVarmeter!(monitoring; bus = label, reactive = Qᵢ, variance = 1e-4, noise = true)\nend\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, we define active and reactive power flow measurements at Branch 1 for both the from-bus and to-bus ends. Again, we use data from AC power flow, computing the powers and using exact values to generate measurements. The default setting noise = false remains unchanged, meaning exact values are used:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Pᵢⱼ, Qᵢⱼ = fromPower(powerFlow; label = \"Branch 1\")\naddWattmeter!(monitoring; label = \"Meter 4\", from = \"Branch 1\", active = Pᵢⱼ)\naddVarmeter!(monitoring; label = \"Meter 4\", from = \"Branch 1\", reactive = Qᵢⱼ)\n\nPⱼᵢ, Qⱼᵢ = toPower(powerFlow; label = \"Branch 1\")\naddWattmeter!(monitoring; label = \"Meter 5\", to = \"Branch 1\", active = Pⱼᵢ)\naddVarmeter!(monitoring; label = \"Meter 5\", to = \"Branch 1\", reactive = Qⱼᵢ)","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"As a result, we obtain the set of active power measurements:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printWattmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The set of reactive power measurements can be viewed as follows:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printVarmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Current-Magnitude-Measurements","page":"AC State Estimation","title":"Current Magnitude Measurements","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Finally, current magnitude measurements need to be defined at Branch 1 for both the from-bus and to-bus ends. Here, we assume these values are known in advance and provide them directly to the functions:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"@ammeter(statusFrom = 0, statusTo = 0)\n\naddAmmeter!(monitoring; label = \"Meter 4\", from = \"Branch 1\", magnitude = 1.36)\naddAmmeter!(monitoring; label = \"Meter 5\", to = \"Branch 1\", magnitude = 2.37)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For current magnitude measurements, we set statusFrom = 0 and statusTo = 0, indicating that these measurements are out-of-service and do not influence state estimation. However, even though they do not impact the computation, they still occupy positions in the matrices and vectors used for state estimation. If there is no plan to put these measurements in-service later, it is advisable to exclude them from the measurement set.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The obtained set of current magnitude measurements is:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printAmmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Base-Case-Analysis","page":"AC State Estimation","title":"Base Case Analysis","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"After collecting the measurements, we solve the AC state estimation by initializing the Gauss-Newton method and running the iterative algorithm to estimate bus voltages. The obtained results are then used to compute powers:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring)\nstateEstimation!(analysis; power = true, verbose = 2)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This allows users to observe estimated bus voltages along with power values associated with buses:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printBusData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Power flows at branches can also be examined:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printBranchData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Additionally, users can retrieve results related to measurement devices. For instance, estimated values and corresponding residuals for wattmeters can be displayed:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printWattmeterData(analysis)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Modifying-Measurement-Data","page":"AC State Estimation","title":"Modifying Measurement Data","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Measurement values and variances will now be updated. Instead of recreating the measurement set and the Gauss-Newton method from the beginning, both models will be modified simultaneously:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"updateVoltmeter!(analysis; label = \"Meter 1\", magnitude = 1.0, noise = false)\nupdateWattmeter!(analysis; label = \"Meter 2\", active = -1.1, variance = 1e-6)\nupdateVarmeter!(analysis; label = \"Meter 3\", variance = 1e-1)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"These updates demonstrate the flexibility of JuliaGrid in modifying measurements. For the voltmeter, we now generate a measurement without adding noise, for the wattmeter, we change both the value and variance, while the varmeter retains its previous value with only a variance adjustment.","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, AC state estimation is run again to compute the new estimate without recreating the Gauss-Newton model. Additionally, this step initializes the iterative algorithm with a warm start, as the initial voltage magnitudes and angles correspond to the solution from the base case analysis:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"stateEstimation!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Bus-related data can now be examined:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printBusData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"examples/acStateEstimation/#Modifying-Measurement-Set","page":"AC State Estimation","title":"Modifying Measurement Set","text":"","category":"section"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Now, we modify the measurement set by including current magnitude measurements:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"updateAmmeter!(analysis; label = \"Meter 4\", status = 1)\nupdateAmmeter!(analysis; label = \"Meter 5\", status = 1)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"We then solve the AC state estimation again:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"stateEstimation!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Bus-related data can now be examined:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printBusData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The bus voltage estimates appear suspicious, indicating the presence of bad data among the newly added ammeter measurements. To address this, we perform bad data analysis:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"outlier = residualTest!(analysis; threshold = 4.0)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"An outlier with a significantly high normalized residual is detected, specifically related to the current magnitude measurements in Meter 4:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"outlier.detect\noutlier.maxNormalizedResidual","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The bad data analysis function automatically removes the detected outlier. Before repeating the AC state estimation, using a warm start is not advisable, as the previous state was obtained in the presence of bad data. Instead, it is useful to reset the initial point, for example, by using the values defined within the power system data:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"setInitialPoint!(analysis)\nstateEstimation!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Observing the bus-related data, we can confirm that the results now align with expectations, as the measurement set is free from bad data:","category":"page"},{"location":"examples/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printBusData(analysis; show)\nnothing # hide","category":"page"},{"location":"api/measurementModel/#measurementModelAPI","page":"Measurement Model","title":"Measurement Model","text":"","category":"section"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For further information on this topic, please see the Measurement Model section of the Manual. Below, we have provided a list of functions that can be used to create, save, and manipulate with measurement devices.","category":"page"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To load measurement model API functionalities into the current scope, utilize the following command:","category":"page"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid","category":"page"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"api/measurementModel/#Measurement-Data","page":"Measurement Model","title":"Measurement Data","text":"","category":"section"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"measurement\nems\nsaveMeasurement\nstatus!","category":"page"},{"location":"api/measurementModel/#Voltmeter","page":"Measurement Model","title":"Voltmeter","text":"","category":"section"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addVoltmeter!\nupdateVoltmeter!\nstatusVoltmeter!\n@voltmeter","category":"page"},{"location":"api/measurementModel/#Ammeter","page":"Measurement Model","title":"Ammeter","text":"","category":"section"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addAmmeter!\nupdateAmmeter!\nstatusAmmeter!\n@ammeter","category":"page"},{"location":"api/measurementModel/#Wattmeter","page":"Measurement Model","title":"Wattmeter","text":"","category":"section"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addWattmeter!\nupdateWattmeter!\nstatusWattmeter!\n@wattmeter","category":"page"},{"location":"api/measurementModel/#Varmeter","page":"Measurement Model","title":"Varmeter","text":"","category":"section"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addVarmeter!\nupdateVarmeter!\nstatusVarmeter!\n@varmeter","category":"page"},{"location":"api/measurementModel/#PMU","page":"Measurement Model","title":"PMU","text":"","category":"section"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addPmu!\nupdatePmu!\nstatusPmu!\n@pmu","category":"page"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"api/measurementModel/#Measurement-Data-2","page":"Measurement Model","title":"Measurement Data","text":"","category":"section"},{"location":"api/measurementModel/#JuliaGrid.measurement","page":"Measurement Model","title":"JuliaGrid.measurement","text":"measurement(system::PowerSystem, file::String)\n\nThe function builds a Measurement composite type for the provided PowerSystem, using data stored in the specified file. It populates the voltmeter, ammeter, wattmeter, varmeter, and pmu fields. Once the Measurement type is created, additional measurement devices can be added, or the parameters of existing ones can be modified.\n\nArgument\n\nThe function requires an existing PowerSystem instance and a string specifying the path to an HDF5 file with a .h5 extension.\n\nReturns\n\nThe Measurement type with the following fields:\n\nvoltmeter: Bus voltage magnitude measurements.\nammeter: Branch current magnitude measurements.\nwattmeter: Active power injection and active power flow measurements.\nvarmeter: Reactive power injection and reactive power flow measurements.\npmu: Bus voltage and branch current phasor measurements.\nsystem: The reference to the power system.\n\nUnits\n\nJuliaGrid stores all data in per-units and radians format.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nmonitoring = measurement(system, \"monitoring.h5\")\n\n\n\n\n\nmeasurement(system::PowerSystem)\n\nAlternatively, the Measurement composite type can be initialized without any data for the specified PowerSystem type. This allows the model to be built from scratch and modified as needed.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nmonitoring = measurement(system)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.ems","page":"Measurement Model","title":"JuliaGrid.ems","text":"ems(system::String, monitoring::Vararg{String})\n\nThis function builds the PowerSystem and Measurement composite types using data from the provided files. It acts as a wrapper that includes both powerSystem and measurement functions.\n\nArguments\n\nThe function requires a string path to the power system data, which can either be stored in an HDF5 file with the .h5 extension or a Matpower file with the .m extension. It also needs a string path to the monitoring data, which should be in an HDF5 file with the .h5 extension.\n\nAdditionally, users can ignore the path to the monitoring data to build and populate only the PowerSystem type, while initializing an empty Measurement type.\n\nReturns\n\nThe function returns the PowerSystem and Measurement types.\n\nExamples\n\nBuild the power system and the measurement model:\n\nsystem, monitoring = ems(\"case14.m\", \"monitoring.h5\")\n\nBuild the power system and multiple measurement models:\n\nsystem, monitoring, pseudo = ems(\"case14.m\", \"monitoring.h5\", \"pseudo.h5\")\n\n\n\n\n\nems()\n\nAlternatively, the PowerSystem and Measurement composite types can be initialized without any data. This provides the flexibility to build and modify the models from the ground up.\n\nExample\n\nsystem, monitoring = ems()\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.saveMeasurement","page":"Measurement Model","title":"JuliaGrid.saveMeasurement","text":"saveMeasurement(monitoring::Measurement; path::String, reference::String, note::String)\n\nThe function saves the measurement's data in the HDF5 file using the fields voltmeter, ammeter, wattmeter, varmeter, and pmu from the Measurement type.\n\nKeywords\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword path in the format of \"path/name.h5\". Additional information can be provided by the optional keywords reference and note, which can be saved along with the power system data.\n\nView HDF5 File\n\nTo view the saved HDF5 file, you can use the HDFView software.\n\nExample\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.m\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis; power = true)\n\naddVoltmeter!(monitoring, analysis)\naddWattmeter!(monitoring, analysis)\n\nsaveMeasurement(monitoring; path = \"D:/monitoring.h5\")\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.status!","page":"Measurement Model","title":"JuliaGrid.status!","text":"status!(monitoring::Measurement; inservice, outservice, redundancy)\n\nThe function generates a set of measurements, assigning measurement devices randomly to either in-service or out-of-service states based on specified keywords.\n\nKeywords\n\nOnly one of the following keywords can be used at a time to configure the measurement set:\n\ninservice: Sets the number of in-service devices.\noutservice: Sets the number of out-of-service devices.\nredundancy: Determines in-service devices based on redundancy.\n\nUpdates\n\nThe function updates all the status fields within the Measurement type.\n\nExamples\n\nCreating a measurement set with a specific number of in-service devices:\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\naddVoltmeter!(monitoring, analysis)\naddWattmeter!(monitoring, analysis)\n\nstatus!(monitoring; inservice = 30)\n\nCreating a measurement set using redundancy:\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\naddVoltmeter!(monitoring, analysis)\naddWattmeter!(monitoring, analysis)\naddVarmeter!(monitoring, analysis)\n\nstatus!(monitoring; redundancy = 2.5)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"api/measurementModel/#Voltmeter-2","page":"Measurement Model","title":"Voltmeter","text":"","category":"section"},{"location":"api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement}","page":"Measurement Model","title":"JuliaGrid.addVoltmeter!","text":"addVoltmeter!(monitoring::Measurement; label, bus, magnitude, variance, noise, status)\n\nThe function adds a voltmeter that measures bus voltage magnitude to the Measurement type. The voltmeter can be added to an already defined bus.\n\nKeywords\n\nThe voltmeter is defined with the following keywords:\n\nlabel: Unique label for the voltmeter.\nbus: Label of the bus to which the voltmeter is connected.\nmagnitude (pu or V): Bus voltage magnitude value.\nvariance (pu or V): Variance of the bus voltage magnitude measurement.\nnoise: Specifies how to generate the measurement mean:\nnoise = true: adds white Gaussian noise with the variance to the magnitude,\nnoise = false: uses the magnitude value only.\nstatus: Operating status of the voltmeter:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\n\nNote that all voltage values are referenced to line-to-neutral voltages.\n\nUpdates\n\nThe function updates the voltmeter field of the Measurement type.\n\nDefault Settings\n\nDefault settings for certain keywords are as follows: variance = 1e-4, noise = false, status = 1, and users can modify these default settings using the @voltmeter macro.\n\nUnits\n\nThe default units for the magnitude and variance keywords are per-units. However, users can choose to use volts as the units by applying the @voltage macro.\n\nExamples\n\nAdding voltmeters using the default unit system:\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\n\naddVoltmeter!(monitoring; label = \"Voltmeter 1\", bus = \"Bus 1\", magnitude = 1.1)\naddVoltmeter!(monitoring; label = \"Voltmeter 2\", bus = \"Bus 1\", magnitude = 1.0)\n\nAdding voltmeters using a custom unit system:\n\n@voltage(kV, rad, kV)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132.0)\n\naddVoltmeter!(monitoring; label = \"Voltmeter 1\", bus = \"Bus 1\", magnitude = 145.2)\naddVoltmeter!(monitoring; label = \"Voltmeter 2\", bus = \"Bus 1\", magnitude = 132.0)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.addVoltmeter!-Tuple{Measurement, AC}","page":"Measurement Model","title":"JuliaGrid.addVoltmeter!","text":"addVoltmeter!(monitoring::Measurement, analysis::AC; variance, noise, status)\n\nThe function incorporates voltmeters into the Measurement type for every bus within the PowerSystem type from which Measurement was created. These measurements are derived from the exact bus voltage magnitudes defined in the AC type.\n\nKeywords\n\nVoltmeters can be configured using:\n\nvariance (pu or V): Measurements variance.\nnoise: Defines the method for generating the measurement means:\nnoise = true: adds white Gaussian noise to the voltage magnitudes using the defined variance,\nnoise = false: uses the exact voltage magnitude values without adding noise.\nstatus: Operating status:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\n\nUpdates\n\nThe function updates the voltmeter field of the Measurement type.\n\nDefault Settings\n\nDefault settings for keywords are as follows: variance = 1e-4, noise = false, and status = 1, and users can modify these default settings using the @voltmeter macro.\n\nUnits\n\nBy default, the unit for variance is per-unit. However, users can choose to use volts as the units by applying the @voltage macro.\n\nExample\n\n@voltmeter(label = \"Voltmeter ?\")\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\naddVoltmeter!(monitoring, analysis; variance = 1e-3, noise = true)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.updateVoltmeter!","page":"Measurement Model","title":"JuliaGrid.updateVoltmeter!","text":"updateVoltmeter!(monitoring::Measurement; kwargs...)\n\nThe function allows for the alteration of parameters for a voltmeter.\n\nKeywords\n\nTo update a specific voltmeter, provide the necessary kwargs input arguments in accordance with the keywords specified in the addVoltmeter! function, along with their respective values. Ensure that the label keyword matches the label of the existing voltmeter. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the voltmeter field within the Measurement type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addVoltmeter! function.\n\nExample\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\n\naddVoltmeter!(monitoring; label = \"Voltmeter 1\", bus = \"Bus 1\", magnitude = 1.1)\nupdateVoltmeter!(monitoring; label = \"Voltmeter 1\", magnitude = 0.9)\n\n\n\n\n\nupdateVoltmeter!(analysis::Analysis; kwargs...)\n\nThe function extends the updateVoltmeter! function. By passing the Analysis type, the function first updates the specific voltmeter within the Measurement type using the provided kwargs, and then updates the Analysis type with all parameters associated with that voltmeter.\n\nA key feature of this function is that any prior modifications made to the specified voltmeter are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nupdateVoltmeter!(analysis; label = 2, magnitude = 0.9)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.statusVoltmeter!","page":"Measurement Model","title":"JuliaGrid.statusVoltmeter!","text":"statusVoltmeter!(monitoring::Measurement; inservice, outservice, redundancy)\n\nThe function generates a set of voltmeters, assigning voltmeters randomly to either in-service or out-of-service states based on specified keywords.\n\nKeywords\n\nOnly one of the following keywords can be used at a time to configure the measurement set:\n\ninservice: Sets the number of in-service voltmeters.\noutservice: Sets the number of out-of-service voltmeters.\nredundancy: Determines in-service voltmeters based on redundancy.\n\nUpdates\n\nThe function updates the status field within the Voltmeter type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\naddVoltmeter!(monitoring, analysis)\n\nstatusVoltmeter!(monitoring; inservice = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.@voltmeter","page":"Measurement Model","title":"JuliaGrid.@voltmeter","text":"@voltmeter(label, variance, noise, status)\n\nThe macro generates a template for a voltmeter.\n\nKeywords\n\nTo establish the voltmeter template, users can specify default values for the variance, noise, and status keywords, along with pattern for labels using the label keyword.\n\nUnits\n\nBy default, the unit for variance is per-unit. However, users can choose to use volts as the units by applying the @voltage macro.\n\nExamples\n\nAdding a voltmeter using the default unit system:\n\n@voltmeter(label = \"Voltmeter ?\", variance = 1e-5)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\n\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 1.1)\n\nAdding a voltmeter using a custom unit system:\n\n@voltage(kV, rad, kV)\n@voltmeter(label = \"Voltmeter ?\", variance = 0.00132)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132.0)\n\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 145.2)\n\n\n\n\n\n","category":"macro"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"api/measurementModel/#Ammeter-2","page":"Measurement Model","title":"Ammeter","text":"","category":"section"},{"location":"api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement}","page":"Measurement Model","title":"JuliaGrid.addAmmeter!","text":"addAmmeter!(monitoring::Measurement;\n    label, from, to, magnitude, variance, noise, square, status)\n\nThe function adds an ammeter that measures branch current magnitude to the Measurement type. The ammeter can be added to an already defined branch.\n\nKeywords\n\nThe ammeter is defined with the following keywords:\n\nlabel: Unique label for the ammeter.\nfrom: Label of the branch if the ammeter is located at the from-bus end.\nto: Label of the branch if the ammeter is located at the to-bus end.\nmagnitude (pu or A): Branch current magnitude value.\nvariance (pu or A): Variance of the branch current magnitude measurement.\nnoise: Specifies how to generate the measurement mean:\nnoise = true: adds white Gaussian noise with the variance to the magnitude,\nnoise = false: uses the magnitude value only.\nsquare: Specifies how the measurement is included in the state estimation model:\nsquare = true: included in squared form,\nsquare = false: included in its original form.\nstatus: Operating status of the ammeter:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\n\nUpdates\n\nThe function updates the ammeter field of the Measurement type.\n\nDefault Settings\n\nDefault settings for certain keywords are as follows: variance = 1e-4, noise = false, square = false, and status = 1, which apply to ammeters located at both the from-bus and to-bus ends. Users can fine-tune these settings by explicitly specifying the variance and status for ammeters positioned on either the from-bus or to-bus ends of branches using the @ammeter macro.\n\nUnits\n\nThe default units for the magnitude and variance keywords are per-units. However, users can choose to use amperes as the units by applying the @current macro.\n\nExamples\n\nAdding ammeters using the default unit system:\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddAmmeter!(monitoring; label = \"Ammeter 1\", from = \"Branch 1\", magnitude = 1.1)\naddAmmeter!(monitoring; label = \"Ammeter 2\", to = \"Branch 1\", magnitude = 1.0)\n\nAdding ammeters using a custom unit system:\n\n@current(A, rad)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddAmmeter!(monitoring; label = \"Ammeter 1\", from = \"Branch 1\", magnitude = 481.125)\naddAmmeter!(monitoring; label = \"Ammeter 2\", to = \"Branch 1\", magnitude = 437.386)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.addAmmeter!-Tuple{Measurement, AC}","page":"Measurement Model","title":"JuliaGrid.addAmmeter!","text":"addAmmeter!(monitoring::Measurement, analysis::AC;\n    varianceFrom, statusFrom, varianceTo, statusTo, noise, square)\n\nThe function incorporates ammeters into the Measurement type for every branch within the PowerSystem type from which Measurement was created. These measurements are derived from the exact branch current magnitudes defined in the AC type.\n\nKeywords\n\nAmmeters at the from-bus ends of the branches can be configured using:\n\nvarianceFrom (pu or A): Measurement variance.\nstatusFrom: Operating status:\nstatusFrom = 1: in-service,\nstatusFrom = 0: out-of-service,\nstatusFrom = -1: not included in the Measurement type.\n\nAmmeters at the to-bus ends of the branches can be configured using:\n\nvarianceTo (pu or A): Measurement variance.\nstatusTo: Operating status:\nstatusTo = 1: in-service,\nstatusTo = 0: out-of-service,\nstatusTo = -1: not included in the Measurement type.\n\nSettings for generating measurements include:\n\nnoise: Defines the method for generating the measurement means:\nnoise = true: adds white Gaussian noise to the current magnitudes using defined variances,\nnoise = false: uses the exact current magnitude values without adding noise.\n\nSettings for including measurements:\n\nsquare: Specifies how measurements are included in the state estimation model:\nsquare = true: included in squared form,\nsquare = false: included in its original form.\n\nUpdates\n\nThe function updates the ammeter field of the Measurement type.\n\nDefault Settings\n\nDefault settings for keywords are as follows: varianceFrom = 1e-4, statusFrom = 1, varianceTo = 1e-4, statusTo = 1, noise = false, and square = false. Users can change these default settings using the @ammeter macro.\n\nUnits\n\nThe default units for the varianceFrom and varianceTo keywords are per-units. However, users can choose to use amperes as the units by applying the @current macro.\n\nExample\n\n@ammeter(label = \"Ammeter ?\")\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; current = true)\n\naddAmmeter!(monitoring, analysis; varianceFrom = 1e-3, statusTo = 0, square = true)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.updateAmmeter!","page":"Measurement Model","title":"JuliaGrid.updateAmmeter!","text":"updateAmmeter!(monitoring::Measurement; kwargs...)\n\nThe function allows for the alteration of parameters for an ammeter.\n\nKeywords\n\nTo update a specific ammeter, provide the necessary kwargs input arguments in accordance with the keywords specified in the addAmmeter! function, along with their respective values. Ensure that the label keyword matches the label of the existing ammeter you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the ammeter field within the Measurement type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addAmmeter! function.\n\nExample\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddAmmeter!(monitoring; label = \"Ammeter 1\", from = \"Branch 1\", magnitude = 1.1)\nupdateAmmeter!(monitoring; label = \"Ammeter 1\", magnitude = 1.2, variance = 1e-3)\n\n\n\n\n\nupdateAmmeter!(analysis::Analysis; kwargs...)\n\nThe function extends the updateAmmeter! function. By passing the Analysis type, the function first updates the specific ammeter within the Measurement type using the provided kwargs, and then updates the Analysis type with all parameters associated with that ammeter.\n\nA key feature of this function is that any prior modifications made to the specified ammeter are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nupdateAmmeter!(analysis; label = \"From 1\", magnitude = 0.9, variance = 1e-5)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.statusAmmeter!","page":"Measurement Model","title":"JuliaGrid.statusAmmeter!","text":"statusAmmeter!(monitoring::Measurement;\n    inservice, inserviceFrom, inserviceTo,\n    outservice, outserviceFrom, outserviceTo,\n    redundancy, redundancyFrom, redundancyTo)\n\nThe function generates a set of ammeters, assigning ammeters randomly to either in-service or out-of-service states based on specified keywords.\n\nKeywords\n\nUsers can use one main keyword or two fine-tuning keywords to specify distinct locations per function call:\n\ninservice: Sets the number of in-service ammeters or allows fine-tuning:\ninserviceFrom: sets only ammeters loacted at the from-bus end,\ninserviceTo: sets only ammeters loacted at the to-bus end.\noutservice: Sets the number of out-of-service ammeters or allows fine-tuning:\noutserviceFrom: sets only ammeters loacted at the from-bus end,\noutserviceTo: sets only ammeters loacted at the to-bus end.\nredundancy: Determines in-service ammeters based on redundancy or allows fine-tuning:\nredundancyFrom: determines only ammeters loacted at the from-bus end,\nredundancyTo: determines only ammeters loacted at the to-bus end.\n\nUpdates\n\nThe function updates the status field within the Ammeter type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; current = true)\n\naddAmmeter!(monitoring, analysis)\n\nstatusAmmeter!(monitoring; inserviceFrom = 5, inserviceTo = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.@ammeter","page":"Measurement Model","title":"JuliaGrid.@ammeter","text":"@ammeter(label, varianceFrom, statusFrom, varianceTo, statusTo, noise, square)\n\nThe macro generates a template for an ammeter.\n\nKeywords\n\nTo establish the ammeter template, users can set default variance and status values for ammeters at both the from-bus and to-bus ends of branches, using varianceFrom and statusFrom for the former and varianceTo and statusTo for the latter. Users can also configure label patterns with the label keyword, as well as specify the noise type. Finally, the square keyword enables including the measurement in squared form for the state estimation model.\n\nUnits\n\nThe default units for the varianceFrom and varianceTo keywords are per-units. However, users can choose to use amperes as the units by applying the @current macro.\n\nExamples\n\nAdding an ammeter using the default unit system:\n\n@ammeter(label = \"Ammeter ?\", varianceTo = 1e-3, statusTo = 0, square = true)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddAmmeter!(monitoring; to = \"Branch 1\", magnitude = 1.1)\n\nAdding an ammeter using a custom unit system:\n\n@current(A, rad)\n@ammeter(label = \"Ammeter ?\", varianceTo = 0.004374, statusTo = 0, square = true)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddAmmeter!(monitoring; label = \"Ammeter 1\", to = \"Branch 1\", magnitude = 481.125)\n\n\n\n\n\n","category":"macro"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"api/measurementModel/#Wattmeter-2","page":"Measurement Model","title":"Wattmeter","text":"","category":"section"},{"location":"api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement}","page":"Measurement Model","title":"JuliaGrid.addWattmeter!","text":"addWattmeter!(monitoring::Measurement;\n    label, bus, from, to, active, variance, noise, status)\n\nThe function adds a wattmeter that measures active power injection or active power flow to the Measurement type. The wattmeter can be added to an already defined bus or branch.\n\nKeywords\n\nThe wattmeter is defined with the following keywords:\n\nlabel: Unique label for the wattmeter.\nbus: Label of the bus if the wattmeter is located at the bus.\nfrom: Label of the branch if the wattmeter is located at the from-bus end.\nto: Label of the branch if the wattmeter is located at the to-bus end.\nactive (pu or W): Active power value.\nvariance (pu or W): Variance of the active power measurement.\nnoise: Specifies how to generate the measurement mean:\nnoise = true: adds white Gaussian noise with the variance to the active,\nnoise = false: uses the active value only.\nstatus: Operating status of the wattmeter:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\n\nNote that when powers are given in SI units, they correspond to three-phase power.\n\nUpdates\n\nThe function updates the wattmeter field of the Measurement type.\n\nDefault Settings\n\nDefault settings for certain keywords are as follows: variance = 1e-4, noise = false, and status = 1, which apply to wattmeters located at the bus, as well as at both the from-bus and to-bus ends. Users can fine-tune these settings by explicitly specifying the variance and status for wattmeters positioned at the buses, from-bus ends, or to-bus ends of branches using the @wattmeter macro.\n\nUnits\n\nThe default units for the active and variance keywords are per-units. However, users can choose to use watts as the units by applying the @power macro.\n\nExamples\n\nAdding wattmeters using the default unit system:\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddWattmeter!(monitoring; label = \"Wattmeter 1\", bus = \"Bus 2\", active = 0.4)\naddWattmeter!(monitoring; label = \"Wattmeter 2\", from = \"Branch 1\", active = 0.1)\n\nAdding wattmeters using a custom unit system:\n\n@power(MW, pu)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddWattmeter!(monitoring; label = \"Wattmeter 1\", bus = \"Bus 2\", active = 40.0)\naddWattmeter!(monitoring; label = \"Wattmeter 2\", from = \"Branch 1\", active = 10.0)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.addWattmeter!-Tuple{Measurement, AC}","page":"Measurement Model","title":"JuliaGrid.addWattmeter!","text":"addWattmeter!(monitoring::Measurement, analysis::AC;\n    varianceBus, statusBus, varianceFrom, statusFrom, varianceTo, statusTo, noise)\n\nThe function incorporates wattmeters into the Measurement type for every branch within the PowerSystem type from which Measurement was created. These measurements are derived from the exact active power injections at buses and active power flows in branches defined in the AC type.\n\nKeywords\n\nWattmeters at the buses can be configured using:\n\nvarianceBus (pu or W): Measurement variance.\nstatusBus: Operating status:\nstatusBus = 1: in-service,\nstatusBus = 0: out-of-service,\nstatusBus = -1: not included in the Measurement type.\n\nWattmeters at the from-bus ends of the branches can be configured using:\n\nvarianceFrom (pu or W): Measurement variance.\nstatusFrom: Operating status:\nstatusFrom = 1: in-service,\nstatusFrom = 0: out-of-service,\nstatusFrom = -1: not included in the Measurement type.\n\nWattmeters at the to-bus ends of the branches can be configured using:\n\nvarianceTo (pu or W): Measurement variance.\nstatusTo: Operating status:\nstatusTo = 1: in-service,\nstatusTo = 0: out-of-service,\nstatusTo = -1: not included in the Measurement type.\n\nSettings for generating measurements include:\n\nnoise: Defines the method for generating the measurement means:\nnoise = true: adds white Gaussian noise to the active power values using defined variances,\nnoise = false: uses the exact active power values without adding noise.\n\nUpdates\n\nThe function updates the wattmeter field of the Measurement composite type.\n\nDefault Settings\n\nDefault settings for keywords are as follows: varianceBus = 1e-4, statusBus = 1, varianceFrom = 1e-4, statusFrom = 1, varianceTo = 1e-4, statusTo = 1, and noise = false. Users can change these default settings using the @wattmeter macro.\n\nUnits\n\nThe default units for the varianceBus, varianceFrom, and varianceTo keywords are per-units. However, users can choose to use watts as the units by applying the @power macro.\n\nExample\n\n@wattmeter(label = \"Wattmeter ?\")\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\naddWattmeter!(monitoring, analysis; varianceBus = 1e-3, statusFrom = 0)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.updateWattmeter!","page":"Measurement Model","title":"JuliaGrid.updateWattmeter!","text":"updateWattmeter!(monitoring::Measurement; kwargs...)\n\nThe function allows for the alteration of parameters for a wattmeter.\n\nKeywords\n\nTo update a specific wattmeter, provide the necessary kwargs input arguments in accordance with the keywords specified in the addWattmeter! function, along with their respective values. Ensure that the label keyword matches the label of the existing wattmeter you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the wattmeter field within the Measurement composite type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addWattmeter! function.\n\nExample\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddWattmeter!(monitoring; label = \"Wattmeter 1\", from = \"Branch 1\", active = 1.1)\nupdateWattmeter!(monitoring; label = \"Wattmeter 1\", active = 1.2, variance = 1e-4)\n\n\n\n\n\nupdateWattmeter!(analysis::Analysis; kwargs...)\n\nThe function extends the updateWattmeter! function. By passing the Analysis type, the function first updates the specific wattmeter within the Measurement type using the provided kwargs, and then updates the Analysis type with all parameters associated with that wattmeter.\n\nA key feature of this function is that any prior modifications made to the specified wattmeter are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nupdateWattmeter!(analysis; label = 4, active = 0.5, variance = 1e-4)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.statusWattmeter!","page":"Measurement Model","title":"JuliaGrid.statusWattmeter!","text":"statusWattmeter!(monitoring::Measurement;\n    inservice, inserviceBus, inserviceFrom, inserviceTo,\n    outservice, outserviceBus outserviceFrom, outserviceTo,\n    redundancy, redundancyBus, redundancyFrom, redundancyTo)\n\nThe function generates a set of wattmeters, assigning wattmeters randomly to either in-service or out-of-service states based on specified keywords.\n\nKeywords\n\nUsers can use one main keyword or three fine-tuning keywords to specify distinct locations per function call:\n\ninservice: Sets the number of in-service wattmeters or allows fine-tuning:\ninserviceBus: sets only wattmeters loacted at the bus,\ninserviceFrom: sets only wattmeters loacted at the from-bus end,\ninserviceTo: sets only wattmeters loacted at the to-bus end.\noutservice: Sets the number of out-of-service wattmeters or allows fine-tuning:\noutserviceBus: sets only wattmeters loacted at the bus,\noutserviceFrom: sets only wattmeters loacted at the from-bus end,\noutserviceTo: sets only wattmeters loacted at the to-bus end.\nredundancy: Determines in-service wattmeters based on redundancy or allows fine-tuning:\nredundancyBus: determines only wattmeters loacted at the bus,\nredundancyFrom: determines only wattmeters loacted at the from-bus end,\nredundancyTo: determines only wattmeters loacted at the to-bus end.\n\nUpdates\n\nThe function updates the status field within the Wattmeter type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\naddWattmeter!(monitoring, analysis)\n\nstatusWattmeter!(monitoring; outserviceBus = 14, inserviceFrom = 10, outserviceTo = 2)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.@wattmeter","page":"Measurement Model","title":"JuliaGrid.@wattmeter","text":"@wattmeter(label, varianceBus, statusBus, varianceFrom, statusFrom,\n    varianceTo, statusTo, noise)\n\nThe macro generates a template for a wattmeter.\n\nKeywords\n\nTo establish the wattmeter template, users can set default variance and status values for wattmeters at buses using varianceBus and statusBus, and at both the from-bus and to-bus ends of branches using varianceFrom and statusFrom for the former and varianceTo and statusTo for the latter. Users can also configure label patterns with the label keyword, as well as specify the noise type.\n\nUnits\n\nThe default units for the varianceBus, varianceFrom, and varianceTo keywords are per-units. However, users can choose to use watts as the units by applying the @power macro.\n\nExamples\n\nAdding wattmeters using the default unit system:\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\n@wattmeter(label = \"Wattmeter ?\", varianceBus = 1e-3, varianceFrom = 1e-4)\naddWattmeter!(monitoring; bus = \"Bus 2\", active = 0.4)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.1)\n\nAdding wattmeters using a custom unit system:\n\n@power(MW, pu)\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\n@wattmeter(label = \"Wattmeter ?\", varianceBus = 1e-1, varianceFrom = 1e-4)\naddWattmeter!(monitoring; bus = \"Bus 2\", active = 40.0)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 10.0)\n\n\n\n\n\n","category":"macro"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"api/measurementModel/#Varmeter-2","page":"Measurement Model","title":"Varmeter","text":"","category":"section"},{"location":"api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement}","page":"Measurement Model","title":"JuliaGrid.addVarmeter!","text":"addVarmeter!(monitoring::Measurement;\n    label, bus, from, to, reactive, variance, noise, status)\n\nThe function adds a varmeter that measures reactive power injection or reactive power flow to the Measurement type. The varmeter can be added to an already defined bus or branch.\n\nKeywords\n\nThe varmeter is defined with the following keywords:\n\nlabel: Unique label for the varmeter.\nbus: Label of the bus if the varmeter is located at the bus.\nfrom: Label of the branch if the varmeter is located at the from-bus end.\nto: Label of the branch if the varmeter is located at the to-bus end.\nreactive (pu or VAr): Reactive power value.\nvariance (pu or VAr): Variance of the reactive power measurement.\nnoise: Specifies how to generate the measurement mean:\nnoise = true: adds white Gaussian noise with the variance to the reactive,\nnoise = false: uses the reactive value only.\nstatus: Operating status of the varmeter:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\n\nNote that when powers are given in SI units, they correspond to three-phase power.\n\nUpdates\n\nThe function updates the varmeter field of the Measurement type.\n\nDefault Settings\n\nDefault settings for certain keywords are as follows: variance = 1e-4, noise = false, and status = 1, which apply to varmeters located at the bus, as well as at both the from-bus and to-bus ends. Users can fine-tune these settings by explicitly specifying the variance and status for varmeters positioned at the buses, from-bus ends, or to-bus ends of branches using the @varmeter macro.\n\nUnits\n\nThe default units for the reactive and variance keywords are per-units. However, users can choose to use volt-amperes reactive as the units by applying the @power macro.\n\nExamples\n\nAdding varmeters using the default unit system:\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddVarmeter!(monitoring; label = \"Varmeter 1\", bus = \"Bus 2\", reactive = 0.4)\naddVarmeter!(monitoring; label = \"Varmeter 2\", from = \"Branch 1\", reactive = 0.1)\n\nAdding varmeters using a custom unit system:\n\n@power(pu, MVAr)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddVarmeter!(monitoring; label = \"Varmeter 1\", bus = \"Bus 2\", reactive = 40.0)\naddVarmeter!(monitoring; label = \"Varmeter 2\", from = \"Branch 1\", reactive = 10.0)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.addVarmeter!-Tuple{Measurement, AC}","page":"Measurement Model","title":"JuliaGrid.addVarmeter!","text":"addVarmeter!(monitoring::Measurement, analysis::AC;\n    varianceBus, statusBus, varianceFrom, statusFrom, varianceTo, statusTo, noise)\n\nThe function incorporates varmeters into the Measurement type for every branch within the PowerSystem type from which Measurement was created. These measurements are derived from the exact reactive power injections at buses and reactive power flows in branches defined in the AC type.\n\nKeywords\n\nVarmeters at the buses can be configured using:\n\nvarianceBus (pu or VAr): Measurement variance.\nstatusBus: Operating status:\nstatusBus = 1: in-service,\nstatusBus = 0: out-of-service,\nstatusBus = -1: not included in the Measurement type.\n\nVarmeters at the from-bus ends of the branches can be configured using:\n\nvarianceFrom (pu or VAr): Measurement variance.\nstatusFrom: Operating status:\nstatusFrom = 1: in-service,\nstatusFrom = 0: out-of-service,\nstatusFrom = -1: not included in the Measurement type.\n\nVarmeters at the to-bus ends of the branches can be configured using:\n\nvarianceTo (pu or VAr): Measurement variance.\nstatusTo: Operating status:\nstatusTo = 1: in-service,\nstatusTo = 0: out-of-service,\nstatusTo = -1: not included in the Measurement type.\n\nSettings for generating measurements include:\n\nnoise: Defines the method for generating the measurement means:\nnoise = true: adds white Gaussian noise to the reactive power values using defined variances,\nnoise = false: uses the exact reactive power values without adding noise.\n\nUpdates\n\nThe function updates the varmeter field of the Measurement composite type.\n\nDefault Settings\n\nDefault settings for keywords are as follows: varianceBus = 1e-4, statusBus = 1, varianceFrom = 1e-4, statusFrom = 1, varianceTo = 1e-4, statusTo = 1, and noise = false. Users can change these default settings using the @varmeter macro.\n\nUnits\n\nThe default units for the varianceBus, varianceFrom, and varianceTo keywords are per-units. However, users can choose to use volt-amperes reactive as the units by applying the @power macro.\n\nExample\n\n@varmeter(label = \"Varmeter ?\")\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\naddVarmeter!(monitoring, analysis; varianceFrom = 1e-3, statusBus = 0)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.updateVarmeter!","page":"Measurement Model","title":"JuliaGrid.updateVarmeter!","text":"updateVarmeter!(monitoring::Measurement; kwargs...)\n\nThe function allows for the alteration of parameters for a varmeter.\n\nKeywords\n\nTo update a specific varmeter, provide the necessary kwargs input arguments in accordance with the keywords specified in the addVarmeter! function, along with their respective values. Ensure that the label keyword matches the label of the existing varmeter you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the varmeter field within the Measurement type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addVarmeter! function.\n\nExample\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddVarmeter!(monitoring; label = \"Varmeter 1\", from = \"Branch 1\", reactive = 1.1)\nupdateVarmeter!(monitoring; label = \"Varmeter 1\", reactive = 1.2, variance = 1e-4)\n\n\n\n\n\nupdateVarmeter!(analysis::Analysis; kwargs...)\n\nThe function extends the updateVarmeter! function. By passing the Analysis type, the function first updates the specific varmeter within the Measurement type using the provided kwargs, and then updates the Analysis type with all parameters associated with that varmeter.\n\nA key feature of this function is that any prior modifications made to the specified varmeter are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nupdateVarmeter!(analysis; label = 4, reactive = 0.3, variance = 1e-3)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.statusVarmeter!","page":"Measurement Model","title":"JuliaGrid.statusVarmeter!","text":"statusVarmeter!(monitoring::Measurement;\n    inservice, inserviceBus, inserviceFrom, inserviceTo,\n    outservice, outserviceBus outserviceFrom, outserviceTo,\n    redundancy, redundancyBus, redundancyFrom, redundancyTo)\n\nThe function generates a set of varmeters, assigning varmeters randomly to either in-service or out-of-service states based on specified keywords.\n\nKeywords\n\nUsers can use one main keyword or three fine-tuning keywords to specify distinct locations per function call:\n\ninservice: Sets the number of in-service varmeters or allows fine-tuning:\ninserviceBus: sets only varmeters loacted at the bus,\ninserviceFrom: sets only varmeters loacted at the from-bus end,\ninserviceTo: sets only varmeters loacted at the to-bus end.\noutservice: Sets the number of out-of-service varmeters or allows fine-tuning:\noutserviceBus: sets only varmeters loacted at the bus,\noutserviceFrom: sets only varmeters loacted at the from-bus end,\noutserviceTo: sets only varmeters loacted at the to-bus end.\nredundancy: Determines in-service varmeters based on redundancy or allows fine-tuning:\nredundancyBus: determines only varmeters loacted at the bus,\nredundancyFrom: determines only varmeters loacted at the from-bus end,\nredundancyTo: determines only varmeters loacted at the to-bus end.\n\nUpdates\n\nThe function updates the status field within the Varmeter type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\naddVarmeter!(monitoring, analysis)\n\nstatusVarmeter!(monitoring; inserviceFrom = 20)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.@varmeter","page":"Measurement Model","title":"JuliaGrid.@varmeter","text":"@varmeter(label, varinaceBus, statusBus, varianceFrom, statusFrom,\n    varianceTo, statusTo, noise)\n\nThe macro generates a template for a varmeter.\n\nKeywords\n\nTo establish the varmeter template, users can set default variance and status values for varmeters at buses using varianceBus and statusBus, and at both the from-bus and to-bus ends of branches using varianceFrom and statusFrom for the former and varianceTo and statusTo for the latter. Users can also configure label patterns with the label keyword, as well as specify the noise type.\n\nUnits\n\nThe default units for the varianceBus, varianceFrom, and varianceTo keywords are per-units. However, users can choose to usevolt-amperes reactive as the units by applying the @power macro.\n\nExamples\n\nAdding varmeters using the default unit system:\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\n@varmeter(label = \"Varmeter ?\", varianceBus = 1e-3, varianceFrom = 1e-4)\naddVarmeter!(monitoring; bus = \"Bus 2\", reactive = 0.4)\naddVarmeter!(monitoring; from = \"Branch 1\", reactive = 0.1)\n\nAdding varmeters using a custom unit system:\n\n@power(pu, MVAr)\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\n@varmeter(label = \"Varmeter ?\", varianceBus = 1e-1, varianceFrom = 1e-4)\naddVarmeter!(monitoring; bus = \"Bus 2\", reactive = 40.0)\naddVarmeter!(monitoring; from = \"Branch 1\", reactive = 10.0)\n\n\n\n\n\n","category":"macro"},{"location":"api/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"api/measurementModel/#PMU-2","page":"Measurement Model","title":"PMU","text":"","category":"section"},{"location":"api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement}","page":"Measurement Model","title":"JuliaGrid.addPmu!","text":"addPmu!(monitoring::Measurement;\n    label, bus, from, to, magnitude, varianceMagnitude, angle, varianceAngle,\n    noise, correlated, polar, square, status)\n\nThe function adds a PMU to the Measurement type. The PMU can be added to an already defined bus or branch. When defining the PMU, it is essential to provide the bus voltage magnitude and angle if the PMU is located at a bus or the branch current magnitude and angle if the PMU is located at a branch.\n\nKeywords\n\nThe PMU is defined with the following keywords:\n\nlabel: Unique label for the PMU.\nbus: Label of the bus if the PMU is located at the bus.\nfrom: Label of the branch if the PMU is located at the from-bus end.\nto: Label of the branch if the PMU is located at the to-bus end.\nmagnitude (pu or V, A): Bus voltage or branch current magnitude value.\nvarianceMagnitude (pu or V, A): Magnitude measurement variance.\nangle (rad or deg): Bus voltage or branch current angle value.\nvarianceAngle (rad or deg): Angle measurement variance.\nnoise: Specifies how to generate the measurement means:\nnoise = true: adds white Gaussian noises with variances to the magnitude and angle,\nnoise = false: uses the magnitude and angle values only.\ncorrelated: Specifies error correlation for PMUs for algorithms utilizing rectangular coordinates:\ncorrelated = true: considers correlated errors,\ncorrelated = false: disregards correlations between errors.\npolar: Chooses the coordinate system for including phasor measurements in AC state estimation:\npolar = true: adopts the polar coordinate system,\npolar = false: adopts the rectangular coordinate system.\nsquare: Specifies how the current magnitude is included in the model when using the polar system:\nsquare = true: included in squared form,\nsquare = false: included in its original form.\nstatus: Operating status of the phasor measurement:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\n\nNote that all voltage values are referenced to line-to-neutral voltages.\n\nUpdates\n\nThe function updates the pmu field of the Measurement type.\n\nDefault Settings\n\nDefault settings for certain keywords are as follows: varianceMagnitude = 1e-8, varianceAngle = 1e-8, noise = false, correlated = false, polar = false, square = false, and status = 1 which apply to PMUs located at the bus, as well as at both the from-bus and to-bus ends. Users can fine-tune these settings by explicitly specifying the variance and status for PMUs positioned at the buses, from-bus ends, or to-bus ends of branches using the @pmu macro.\n\nUnits\n\nThe default units for the magnitude, varianceMagnitude, and angle, varianceAngle keywords are per-units and radians. However, users have the option to switch to volts and degrees when the PMU is located at a bus using the @voltage macro, or amperes and degrees when the PMU is located at a branch through the use of the @current macro.\n\nExamples\n\nAdding PMUs using the default unit system:\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 131.8e3)\naddBus!(system; label = \"Bus 2\", base = 131.8e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddPmu!(monitoring; label = \"PMU 1\", bus = \"Bus 1\", magnitude = 1.1, angle = -0.1)\naddPmu!(monitoring; label = \"PMU 2\", from = \"Branch 1\", magnitude = 1.1, angle = 0.1)\n\nAdding PMUs using a custom unit system:\n\n@voltage(kV, deg, kV)\n@current(A, deg)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 131.8)\naddBus!(system; label = \"Bus 2\", base = 131.8)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddPmu!(monitoring; label = \"PMU 1\", bus = \"Bus 1\", magnitude = 145, angle = -5.7)\naddPmu!(monitoring; label = \"PMU 2\", from = \"Branch 1\", magnitude = 481, angle = 5.7)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.addPmu!-Tuple{Measurement, AC}","page":"Measurement Model","title":"JuliaGrid.addPmu!","text":"addPmu!(monitoring::Measurement, analysis::AC;\n    varianceMagnitudeBus, varianceAngleBus, statusBus,\n    varianceMagnitudeFrom, varianceAngleFrom, statusFrom,\n    varianceMagnitudeTo, varianceAngleTo, statusTo,\n    noise, correlated, polar, square)\n\nThe function incorporates PMUs into the Measurement type for every branch within the PowerSystem type from which Measurement was created. These measurements are derived from the exact bus voltage magnitudes and angles, as well as branch current magnitudes and angles defined in the AC type.\n\nKeywords\n\nPMUs at the buses can be configured using:\n\nvarianceMagnitudeBus (pu or V): Variance of bus voltage magnitude measurements.\nvarianceAngleBus (rad or deg): Variance of bus voltage angle measurements.\nstatuseBus: Operating status:\nstatusBus = 1: in-service,\nstatusBus = 0: out-of-service,\nstatusBus = -1: not included in the Measurement type.\n\nPMUs at the from-bus ends of the branches can be configured using:\n\nvarianceMagnitudeFrom (pu or A): Variance of current magnitude measurements.\nvarianceAngleFrom (rad or deg): Variance of current angle measurements.\nstatusFrom: Operating status:\nstatusFrom = 1: in-service,\nstatusFrom = 0: out-of-service,\nstatusFrom = -1: not included in the Measurement type.\n\nPMUs at the to-bus ends of the branches can be configured using:\n\nvarianceMagnitudeTo (pu or A): Variance of current magnitude measurements.\nvarianceAngleTo (rad or deg): Variance of current angle measurements.\nstatusTo: Operating status:\nstatusTo = 1: in-service,\nstatusTo = 0: out-of-service,\nstatusTo = -1: not included in the Measurement type.\n\nSettings for generating measurements include:\n\nnoise: Defines the method for generating the measurement means:\nnoise = true: adds white Gaussian noise to the phasor values using defined variances,\nnoise = false: uses the exact phasor values without adding noise.\n\nSettings for handling phasor measurements include:\n\ncorrelated: Specifies error correlation for PMUs for algorithms utilizing rectangular coordinates:\ncorrelated = true: considers correlated errors,\ncorrelated = false: disregards correlations between errors.\npolar: Chooses the coordinate system for including phasor measurements in AC state estimation:\npolar = true: adopts the polar coordinate system,\npolar = false: adopts the rectangular coordinate system.\nsquare: Specifies how current magnitudes are included in the model when using the polar system:\nsquare = true: included in squared form,\nsquare = false: included in its original form.\n\nUpdates\n\nThe function updates the pmu field of the Measurement type.\n\nDefault Settings\n\nDefault settings for variance keywords are established at 1e-8, with all statuses set to 1, polar = false, correlated = false, noise = false, and square = false. Users can change these default settings using the @pmu macro.\n\nUnits\n\nThe default units for the variance keywords are in per-units and radians. However, users have the option to switch to volts and degrees when the PMU is located at a bus using the @voltage macro, or amperes and degrees when the PMU is located at a branch through the use of the @current macro.\n\nExample\n\n@pmu(label = \"PMU ?\")\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; current = true)\n\naddPmu!(monitoring, analysis; varianceMagnitudeBus = 1e-3)\n\n\n\n\n\n","category":"method"},{"location":"api/measurementModel/#JuliaGrid.updatePmu!","page":"Measurement Model","title":"JuliaGrid.updatePmu!","text":"updatePmu!(monitoring::Measurement; kwargs...)\n\nThe function allows for the alteration of parameters for a PMU.\n\nKeywords\n\nTo update a specific PMU, provide the necessary kwargs input arguments in accordance with the keywords specified in the addPmu! function, along with their respective values. Ensure that the label keyword matches the label of the existing PMU you want to modify. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the pmu field within the Measurement type.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addPmu! function.\n\nExample\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\n\naddPmu!(monitoring; label = \"PMU 1\", bus = \"Bus 1\", magnitude = 1.1, angle = -0.1)\nupdatePmu!(monitoring; label = \"PMU 1\", magnitude = 1.05)\n\n\n\n\n\nupdatePmu!(analysis::Analysis; kwargs...)\n\nThe function extends the updatePmu! function. By passing the Analysis type, the function first updates the specific PMU within the Measurement type using the provided kwargs, and then updates the Analysis type with all parameters associated with that PMU.\n\nA key feature of this function is that any prior modifications made to the specified PMU are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nupdatePmu!(analysis; label = 4, magnitude = 0.95, angle = -0.1)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.statusPmu!","page":"Measurement Model","title":"JuliaGrid.statusPmu!","text":"statusPmu!(monitoring::Measurement;\n    inservice, inserviceBus, inserviceFrom, inserviceTo,\n    outservice, outserviceBus outserviceFrom, outserviceTo,\n    redundancy, redundancyBus, redundancyFrom, redundancyTo)\n\nThe function generates a set of PMUs, assigning PMUs randomly to either in-service or out-of-service states based on specified keywords. It is important to note that when we refer to PMU, we encompass both magnitude and angle measurements.\n\nKeywords\n\nUsers may use either one main keyword or three fine-tuning keywords that specify distinct locations per function call:\n\ninservice: Sets the number of in-service PMUs or allows fine-tuning:\ninserviceBus: sets only PMUs loacted at the bus,\ninserviceFrom: sets only PMUs loacted at the from-bus end,\ninserviceTo: sets only PMUs loacted at the to-bus end.\noutservice: Sets the number of out-of-service PMUs or allows fine-tuning:\noutserviceBus: sets only PMUs loacted at the bus,\noutserviceFrom: sets only PMUs loacted at the from-bus end,\noutserviceTo: sets only PMUs loacted at the to-bus end.\nredundancy: Determines in-service PMUs based on redundancy or allows fine-tuning:\nredundancyBus: determines only PMUs loacted at the bus,\nredundancyFrom: determines only PMUs loacted at the from-bus end,\nredundancyTo: determines only PMUs loacted at the to-bus end.\n\nUpdates\n\nThe function updates the status fields within the PMU type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; current = true)\n\naddPmu!(monitoring, analysis)\n\nstatusPmu!(monitoring; inserviceBus = 10)\n\n\n\n\n\n","category":"function"},{"location":"api/measurementModel/#JuliaGrid.@pmu","page":"Measurement Model","title":"JuliaGrid.@pmu","text":"@pmu(label, noise, correlated, polar, square,\n    varianceMagnitudeBus, varianceAngleBus, statusBus,\n    varianceMagnitudeFrom, varianceAngleFrom, statusFrom,\n    varianceMagnitudeTo, varianceAngleTo, statusTo)\n\nThe macro generates a template for a PMU.\n\nKeywords\n\nTo establish the PMU template, users can configure the pattern for labels using the label keyword, specify the type of noise, and indicate the correlated,polar, andsquare` system utilized for managing phasors during state estimation.\n\nUsers have the option to set default values for magnitude and angle variances, as well as statuses. This can be done for PMUs located at the buses using the varianceMagnitudeBus, varianceAngleBus, and statusBus keywords.\n\nThe same configuration can be applied at both the from-bus ends of the branches using the varianceMagnitudeFrom, varianceAngleFrom, and statusFrom keywords.\n\nFor PMUs located at the to-bus ends of the branches, users can use the varianceMagnitudeTo, varianceAngleTo, and statusTo keywords.\n\nUnits\n\nBy default, the units for variances are per-units and radians. However, users have the option to switch to volts and degrees as the units for PMUs located at the buses by using the @voltage macro, or they can switch to amperes  and degrees as the units for PMUs located at the branches by using the @current macro.\n\nExamples\n\nAdding PMUs using the default unit system:\n\n@pmu(label = \"PMU ?\", varianceAngleBus = 1e-6, varianceMagnitudeFrom = 1e-4)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132e3)\naddBus!(system; label = \"Bus 2\", base = 132e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddPmu!(monitoring; bus = \"Bus 1\", magnitude = 1.1, angle = -0.1)\naddPmu!(monitoring; from = \"Branch 1\", magnitude = 1.1, angle = -0.2)\n\nAdding PMUs using a custom unit system:\n\n@voltage(kV, deg, kV)\n@current(A, deg)\n@pmu(label = \"PMU ?\", varianceAngleBus = 5.73e-5, varianceMagnitudeFrom = 0.0481)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 132.0)\naddBus!(system; label = \"Bus 2\", base = 132.0)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddPmu!(monitoring; bus = \"Bus 1\", magnitude = 145.2, angle = -5.73)\naddPmu!(monitoring; from = \"Branch 1\", magnitude = 481.125, angle = -11.46)\n\n\n\n\n\n","category":"macro"},{"location":"examples/dcStateEstimation/#DCStateEstimationExamples","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"In this example, we monitor a 6-bus power system, shown in Figure 1, and estimate bus voltage angles using DC state estimation.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/pmuStateEstimation/6bus_acpf.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 1: The 6-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"We start by defining the units for voltage angles, which will be used throughout this example:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using JuliaGrid, JuMP, Ipopt # hide\n@default(template) # hide\n@default(unit) # hide\n\n@voltage(pu, deg)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, the power system is defined by specifying buses, branches, and generators with cost functions:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.217)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.478)\naddBus!(system; label = \"Bus 4\", type = 2, active = 0.076)\naddBus!(system; label = \"Bus 5\", type = 1, active = 0.112)\naddBus!(system; label = \"Bus 6\", type = 2, active = 0.295)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.23)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 3\", to = \"Bus 4\", reactance = 0.19)\naddBranch!(system; label = \"Branch 4\", from = \"Bus 4\", to = \"Bus 5\", reactance = 0.17)\naddBranch!(system; label = \"Branch 5\", from = \"Bus 5\", to = \"Bus 6\", reactance = 0.04)\naddBranch!(system; label = \"Branch 6\", from = \"Bus 1\", to = \"Bus 6\", reactance = 0.21)\naddBranch!(system; label = \"Branch 7\", from = \"Bus 2\", to = \"Bus 6\", reactance = 0.13)\naddBranch!(system; label = \"Branch 8\", from = \"Bus 5\", to = \"Bus 2\", reactance = 0.34)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.8, maxActive = 2.3)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 4\", active = 0.4, maxActive = 2.3)\n\ncost!(system; generator = \"Generator 1\", active = 2, polynomial = [1100.0; 500.0; 150.0])\ncost!(system; generator = \"Generator 2\", active = 2, polynomial = [1500.0; 700.0; 140.0])\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"After defining the power system data, a DC model is generated, including key matrices and vectors for analysis:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#Measurement-Model","page":"DC State Estimation","title":"Measurement Model","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, we define the measurements. The question is how to obtain measurement values. In this example, synthetic measurements are generated using DC optimal power flow results.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To start, we initialize the measurement variable:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"monitoring = measurement(system)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#DC-Optimal-Power-Flow","page":"DC State Estimation","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To obtain bus voltage angless, we solve the DC optimal power flow. Using these values, we compute the active power associated with buses and branches:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"powerFlow = dcOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(powerFlow; power = true, verbose = 1)","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#Active-Power-Injection-Measurements","page":"DC State Estimation","title":"Active Power Injection Measurements","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Active power injection measurements will be obtained from the DC optimal power flow analysis:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printBusData(powerFlow)","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, these measurements are defined:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"@wattmeter(label = \"Wattmeter ?\")\nfor (label, idx) in system.bus.label\n    Pᵢ = powerFlow.power.injection.active[idx]\n    addWattmeter!(monitoring; bus = label, active = Pᵢ, variance = 1e-4, noise = true)\nend\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Enabling noise = true adds white Gaussian noise with a variance of 1e-4 to the exact values, generating the final measurement values.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#Active-Power-Flow-Measurements","page":"DC State Estimation","title":"Active Power Flow Measurements","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, we will include a certain number of active power flow measurements using the results from the DC optimal power flow analysis:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printBranchData(powerFlow)","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Thus, two active power flow measurements are added:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"addWattmeter!(monitoring; from = \"Branch 1\", active = powerFlow.power.from.active[1])\naddWattmeter!(monitoring; from = \"Branch 4\", active = powerFlow.power.from.active[4])\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Here, noise is not set, keeping the measurement values exact.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#Active-Power-Measurements","page":"DC State Estimation","title":"Active Power Measurements","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Finally, the complete set of measurements is displayed:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printWattmeterData(monitoring)","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Figure 2 illustrates this measurement configuration, which includes active power injection measurements at all buses and two active power flow measurements.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcStateEstimation/6bus_wattmeter.svg\" width=\"380\" class=\"my-svg\"/>\n    <p>Figure 2: The 6-bus power system with active power measurement configuration.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#Base-Case-Analysis","page":"DC State Estimation","title":"Base Case Analysis","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"After obtaining the measurements, the DC state estimation model is created:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, the model is solved to determine the WLS estimator for bus voltage angles, and the results are used to compute power values:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"stateEstimation!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"This allows users to observe the estimated bus voltages along with the corresponding power values:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printBusData(analysis)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Additionally, data related to measurement monitorings can be examined:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printWattmeterData(analysis)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#Modifying-Measurement-Data","page":"DC State Estimation","title":"Modifying Measurement Data","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Let us now modify the measurement values. Instead of recreating the measurement set and the DC state estimation model from scratch, both are updated simultaneously:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"updateWattmeter!(analysis; label = \"Wattmeter 7\", active = 1.1)\nupdateWattmeter!(analysis; label = \"Wattmeter 8\", active = 1.6)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"By changing these measurement values, two outliers are introduced into the dataset, which affects the estimates.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, the DC state estimation is solved again to compute the updated estimate:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"stateEstimation!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Bus-related data can now be examined:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printBusData(analysis)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"With the modified measurement values for Wattmeter 7 and Wattmeter 8, the estimated results deviate more significantly from the exact values obtained through DC optimal power flow, as the altered measurements no longer align with their corresponding values.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Now, instead of using the WLS estimator, we compute the LAV estimator:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer)\nstateEstimation!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Bus-related data can be examined:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printBusData(analysis)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"As observed, the estimates obtained using the LAV method are closer to the exact values from the DC optimal power flow, as LAV is more robust to outliers compared to WLS.","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"examples/dcStateEstimation/#Modifying-Measurement-Set","page":"DC State Estimation","title":"Modifying Measurement Set","text":"","category":"section"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Let us proceed with the LAV state estimation model and set two measurements to out-of-service:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"updateWattmeter!(analysis; label = \"Wattmeter 1\", status = 0)\nupdateWattmeter!(analysis; label = \"Wattmeter 5\", status = 0)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Recompute the LAV estimator and active power values:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"stateEstimation!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Bus-related data can now be examined:","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printBusData(analysis)","category":"page"},{"location":"examples/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"As observed, while the LAV approach is more robust than WLS in handling outliers, the accuracy of the estimated values still depends on factors such as the magnitude of outliers, their number, and the positioning of meters within the power system. Removing two accurate measurements while keeping outliers in the system shows that even the LAV method cannot fully compensate for the loss of reliable data, leading to less accurate estimates.","category":"page"},{"location":"manual/pmuStateEstimation/#PMUStateEstimationManual","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To perform linear state estimation solely based on PMU data, the initial requirement is to have the PowerSystem type configured with the AC model, along with the Measurement type storing measurement data. Subsequently, we can formulate either the weighted least-squares (WLS) or the least absolute value (LAV) PMU state estimation model encapsulated within the type PmuStateEstimation using:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"pmuStateEstimation,\npmuLavStateEstimation.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To obtain bus voltages and solve the PMU state estimation problem, users can use the wrapper function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"solve!.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"After solving the PMU state estimation, JuliaGrid provides functions for computing powers and currents:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"power!,\ncurrent!.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Alternatively, instead of using functions responsible for solving state estimation and computing powers and currents, users can use the wrapper function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"stateEstimation!.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Users can also access specialized functions for computing specific types of powers or currents for individual buses, branches, or generators within the power system.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#PhasorMeasurementsManual","page":"PMU State Estimation","title":"Phasor Measurements","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Let us define the PowerSystem type and perform the AC power flow analysis solely for generating data to artificially create measurement values:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5)\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\n\n@generator(reactive = 0.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 2.1)\n\npf = newtonRaphson(system)\npowerFlow!(pf)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Optimal-PMU-Placment","page":"PMU State Estimation","title":"Optimal PMU Placment","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"After defining the PowerSystem type, the next step is to define the Measurement type:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"monitoring = measurement(system)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"JuliaGrid allows users to determine the minimum number of PMUs needed for observability while also generating phasor measurements based on results from AC power flow through the pmuPlacement! function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using HiGHS\n\n@pmu(label = \"PMU ? (!)\")\nplacement = pmuPlacement!(monitoring, pf, HiGHS.Optimizer)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Note that users can also generate phasor measurements using results from AC optimal power flow.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The placement variable contains data regarding the optimal placement of measurements. In this instance, installing a PMU at Bus 2 renders the system observable:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"keys(placement.bus)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"This PMU installed at Bus 2 will measure the bus voltage phasor at the corresponding bus and all current phasors at the branches incident to Bus 2 located at the from-bus or to-bus ends:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"keys(placement.from)\nkeys(placement.to)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Finally, we can observe the obtained set of measurement values:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"print(monitoring.pmu.label, monitoring.pmu.magnitude.mean, monitoring.pmu.angle.mean)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#PMUWLSStateEstimationSolutionManual","page":"PMU State Estimation","title":"Weighted Least-Squares Estimator","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Let us continue with the previous example, where we defined the PowerSystem and Measurement types. To establish the PMU state estimation model, we will use the pmuStateEstimation function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"tip: Tip\nHere, the user triggers LU factorization as the default method for solving the PMU state estimation problem. However, the user also has the option to select alternative factorization methods such as KLU, LDLt or QR:analysis = pmuStateEstimation(monitoring, QR)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To obtain the bus voltage magnitudes and angles, the solve! function can be invoked as shown:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Upon obtaining the solution, access the bus voltage magnitudes and angles using:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nWe recommend that readers refer to the tutorial on PMU State Estimation for insights into the implementation.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Wrapper-Function","page":"PMU State Estimation","title":"Wrapper Function","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"JuliaGrid provides a wrapper function for PMU state estimation analysis and also supports the computation of powers and currents using the stateEstimation! function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis; verbose = 2)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Correlated-Measurement-Errors","page":"PMU State Estimation","title":"Correlated Measurement Errors","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"In the above approach, we assume that measurement errors from a single PMU are uncorrelated. This assumption leads to the covariance matrix and its inverse matrix (i.e., precision matrix) maintaining a diagonal form:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis.method.precision","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"While this approach is suitable for many scenarios, linear PMU state estimation relies on transforming from polar to rectangular coordinate systems. Consequently, measurement errors from a single PMU become correlated due to this transformation. This correlation results in the covariance matrix, and hence the precision matrix, no longer maintaining a diagonal form but instead becoming a block diagonal matrix.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To accommodate this, users have the option to consider correlation when adding each PMU to the Measurement type. For instance, let us add a new PMU while considering correlation:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"addPmu!(monitoring; bus = \"Bus 3\", magnitude = 1.01, angle = -0.005, correlated = true)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Following this, we recreate the WLS state estimation model:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Upon inspection, it becomes evident that the precision matrix no longer maintains a diagonal structure:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis.method.precision","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Subsequently, we can address this new scenario and observe the solution:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"stateEstimation!(analysis)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Print-Results-in-the-REPL","page":"PMU State Estimation","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Users have the option to print the results in the REPL using any units that have been configured, such as:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"@voltage(pu, deg)\nprintBusData(analysis)\n@default(unit) # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, users can easily customize the print results for specific buses, for example:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"printBusData(analysis; label = \"Bus 1\", header = true)\nprintBusData(analysis; label = \"Bus 2\")\nprintBusData(analysis; label = \"Bus 3\", footer = true)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Save-Results-to-a-File","page":"PMU State Estimation","title":"Save Results to a File","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Users can also redirect print output to a file. For example, data can be saved in a text file as follows:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"open(\"bus.txt\", \"w\") do file\n    printBusData(analysis, file)\nend","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"tip: Tip\nWe also provide functions to print or save state estimation results, such as estimated values and residuals. For more details, users can consult the Power and Current Analysis section of this manual.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Alternative-Formulations","page":"PMU State Estimation","title":"Alternative Formulations","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from finding a satisfactory solution. In such scenarios, users may choose to apply an alternative formulation of the WLS estimator.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"These alternative methods are applicable when measurement errors are uncorrelated and the precision matrix is diagonal. Therefore, as a preliminary step, we need to eliminate the correlation, as we did previously:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"updatePmu!(monitoring; label = \"PMU 5 (Bus 3)\", correlated = false)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Orthogonal-Method","page":"PMU State Estimation","title":"Orthogonal Method","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"One such alternative is the orthogonal method [6, Sec. 3.2], which offers increased numerical robustness, especially when measurement variances differ significantly. This method solves the WLS problem using QR factorisation applied to a rectangular matrix formed by multiplying the square root of the precision matrix with the coefficient matrix. To enable this method, specify the Orthogonal argument in the pmuStateEstimation function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring, Orthogonal)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Peters-and-Wilkinson-Method","page":"PMU State Estimation","title":"Peters and Wilkinson Method","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Another option is the Peters and Wilkinson method [6, Sec. 3.4], which applies LU factorisation to the same rectangular matrix, constructed using the square root of the precision matrix and the coefficient matrix. This method can be selected by passing the PetersWilkinson argument to the pmuStateEstimation function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring, PetersWilkinson)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#PMULAVtateEstimationSolutionManual","page":"PMU State Estimation","title":"Least Absolute Value Estimator","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data analysis procedures [6, Ch. 6]. However, it is important to note that achieving robustness typically involves increased computational complexity.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To obtain an LAV estimator, users need to employ one of the solvers listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using Ipopt\nusing JuMP  # hide\n\nanalysis = pmuLavStateEstimation(monitoring, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Setup-Initial-Primal-Values","page":"PMU State Estimation","title":"Setup Initial Primal Values","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"In JuliaGrid, the assignment of initial primal values for optimization variables takes place when the solve! function is executed. These values are derived from the voltage magnitudes and angles stored in the PowerSystem type and are assigned to the corresponding voltage field within the PmuStateEstimation type:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Users have the flexibility to customize these values according to their requirements, and they will be utilized as the initial primal values when executing the solve! function. One practical approach is to perform an AC power flow analysis and then apply the resulting solution as the starting point for state estimation:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"pf = newtonRaphson(system)\npowerFlow!(pf)\n\nsetInitialPoint!(analysis, pf)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"As a result, the initial primal values will now reflect the outcome of the power flow solution:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Solution","page":"PMU State Estimation","title":"Solution","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To solve the formulated LAV state estimation model, simply execute the following function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"stateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Upon obtaining the solution, access the bus voltage magnitudes and angles using:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nReaders can refer to the Least Absolute Value Estimation tutorial for implementation insights.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#PMUMeasurementsAlterationManual","page":"PMU State Estimation","title":"Measurement Set Update","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"We begin by creating the PowerSystem and Measurement types with the ems function. The AC model is then configured using acModel! function. After that, we initialize the PmuStateEstimation type through the pmuStateEstimation function and solve the resulting state estimation problem:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.03)\n\nacModel!(system)\n\naddPmu!(monitoring; label = \"PMU 1\", bus = \"Bus 1\", magnitude = 1.0, angle = 0.0)\naddPmu!(monitoring; label = \"PMU 2\", bus = \"Bus 2\", magnitude = 0.98, angle = -0.023)\naddPmu!(monitoring; label = \"PMU 3\", from = \"Branch 2\", magnitude = 0.5, angle = -0.05)\n\nanalysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, we modify the existing Measurement type using add and update functions. Then, we create the new PmuStateEstimation type based on the modified system and solve the state estimation problem:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\naddPmu!(monitoring; label = \"PMU 4\", to = \"Branch 2\", magnitude = 0.5, angle = 3)\nupdatePmu!(monitoring; label = \"PMU 1\", varianceMagnitude = 1e-8)\nupdatePmu!(monitoring; label = \"PMU 3\", status = 0)\n\nanalysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nThis concept removes the need to restart and recreate the Measurement type from the beginning when implementing changes to the existing measurement set.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#PMUStateEstimationUpdateManual","page":"PMU State Estimation","title":"State Estimation Update","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"An advanced methodology involves users establishing the PmuStateEstimation type using pmuStateEstimation or pmuLavStateEstimation just once. After this initial setup, users can seamlessly modify existing measurement devices without the need to recreate the PmuStateEstimation type.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"This advancement extends beyond the previous scenario where recreating the Measurement type was unnecessary, to now include the scenario where PmuStateEstimation also does not need to be recreated.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"tip: Tip\nThe addition of new measurements after the creation of PmuStateEstimation is not practical in terms of reusing the PmuStateEstimation type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Let us now revisit our defined PowerSystem, Measurement and PmuStateEstimation types:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.03)\n\nacModel!(system)\n\naddPmu!(monitoring; label = \"PMU 1\", bus = \"Bus 1\", magnitude = 1.0, angle = 0.0)\naddPmu!(monitoring; label = \"PMU 2\", bus = \"Bus 2\", magnitude = 0.98, angle = -0.023)\naddPmu!(monitoring; label = \"PMU 3\", from = \"Branch 2\", magnitude = 0.5, angle = -0.05)\naddPmu!(monitoring; label = \"PMU 4\", to = \"Branch 2\", magnitude = 0.5, angle = 3, status = 0)\n\nanalysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, we modify the existing Measurement type as well as the PmuStateEstimation type using add and update functions. We then immediately proceed to solve the state estimation problem:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"updatePmu!(analysis; label = \"PMU 1\", varianceMagnitude = 1e-8)\nupdatePmu!(analysis; label = \"PMU 3\", status = 0)\nupdatePmu!(analysis; label = \"PMU 4\", status = 1)\n\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nThis concept removes the need to rebuild both the Measurement and the PmuStateEstimation from the beginning when implementing changes to the existing measurement set. In the scenario of employing the WLS model, JuliaGrid can reuse the symbolic factorizations of LU or LDLt, provided that the nonzero pattern of the gain matrix remains unchanged.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#PMUSEPowerCurrentAnalysisManual","page":"PMU State Estimation","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"After obtaining the solution from the PMU state estimation, we can calculate various electrical quantities related to buses and branches using the power! and current! functions. For instance, let us consider the model for which we obtained the PMU state estimation solution:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3, susceptance = 0.002)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.05)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.03)\n\naddPmu!(monitoring; bus = \"Bus 1\", magnitude = 1.0, angle = 0.0)\naddPmu!(monitoring; bus = \"Bus 2\", magnitude = 0.97, angle = -0.051)\naddPmu!(monitoring; from = \"Branch 2\", magnitude = 1.66, angle = -0.15)\naddPmu!(monitoring; to = \"Branch 2\", magnitude = 1.67, angle = 2.96)\n\nanalysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"We can now utilize the provided functions to compute powers and currents:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"power!(analysis)\ncurrent!(analysis)\nnothing # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"For instance, if we want to show the active power injections and the from-bus current magnitudes, we can employ the following code:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.current.from.magnitude)","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nTo better understand the powers and currents associated with buses and branches that are calculated by the power! and current! functions, we suggest referring to the tutorials on PMU State Estimation.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Print-Results-in-the-REPL-2","page":"PMU State Estimation","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Users can utilize any of the print functions outlined in the Print API. For example, to print state estimation data related to PMUs, we can use:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"@voltage(pu, deg)\nshow = Dict(\"Voltage Angle\" => false, \"Current Angle\" => false)\nprintPmuData(analysis; show)\n@default(unit) # hide","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Save-Results-to-a-CSV-File","page":"PMU State Estimation","title":"Save Results to a CSV File","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"For CSV output, users should first generate a simple table with style = false, and then save it to a CSV file:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using CSV\n\nio = IOBuffer()\nprintPmuData(analysis, io; style = false)\nCSV.write(\"bus.csv\", CSV.File(take!(io); delim = \"|\"))","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Active-and-Reactive-Power-Injection","page":"PMU State Estimation","title":"Active and Reactive Power Injection","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To calculate the active and reactive power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"active, reactive = injectionPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Active-and-Reactive-Power-Injection-from-Generators","page":"PMU State Estimation","title":"Active and Reactive Power Injection from Generators","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"active, reactive = supplyPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Active-and-Reactive-Power-at-Shunt-Element","page":"PMU State Estimation","title":"Active and Reactive Power at Shunt Element","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"active, reactive = shuntPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Active-and-Reactive-Power-Flow","page":"PMU State Estimation","title":"Active and Reactive Power Flow","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"active, reactive = fromPower(analysis; label = \"Branch 2\")\nactive, reactive = toPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Active-and-Reactive-Power-at-Charging-Admittances","page":"PMU State Estimation","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"active, reactive = chargingPower(analysis; label = \"Branch 1\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Active powers indicate active losses within the branch's charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Active-and-Reactive-Power-at-Series-Impedance","page":"PMU State Estimation","title":"Active and Reactive Power at Series Impedance","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To calculate the active and reactive power across the series impedance of the branch, the function can be used:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"active, reactive = seriesPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance's inductive characteristics.","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Current-Injection","page":"PMU State Estimation","title":"Current Injection","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To calculate the current injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"magnitude, angle = injectionCurrent(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Current-Flow","page":"PMU State Estimation","title":"Current Flow","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"We can compute the current flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"magnitude, angle = fromCurrent(analysis; label = \"Branch 2\")\nmagnitude, angle = toCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"manual/pmuStateEstimation/#Current-Through-Series-Impedance","page":"PMU State Estimation","title":"Current Through Series Impedance","text":"","category":"section"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:","category":"page"},{"location":"manual/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"magnitude, angle = seriesCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"examples/acPowerFlow/#ACPowerFlowExamples","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In this example, we perform several AC power flow analyses using the power system shown in Figure 1. These analyses simulate quasi-steady-state conditions where the system undergoes parameter and topology changes, demonstrating JuliaGrid's efficiency in handling such scenarios.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/acPowerFlow/4bus.svg\" width=\"400\" class=\"my-svg\"/>\n    <p>Figure 1: The 4-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We begin by defining the units for active and reactive powers, as well as voltage magnitudes and angles, which will be used throughout this example:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(template) # hide\n@default(unit) # hide\n\n@power(MW, MVAr)\n@voltage(pu, deg)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we define the bus parameters for AC power flow analysis This includes specifying the type of each bus, the connected active and reactive power loads, and shunt capacitor banks with conductance and susceptance values. The bus voltage magnitude and angle serve as initial values for the iterative power flow algorithm. Note that for the slack bus (type = 3), the angle is fixed to the specified value. With these definitions, we can start to build the power system model:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system = powerSystem()\n\n@bus(magnitude = 1.1, angle = -5.7)\naddBus!(system; label = \"Bus 1\", type = 3, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 2, active = 20.2, reactive = 10.5)\naddBus!(system; label = \"Bus 3\", type = 1, conductance = 0.1, susceptance = 8.2)\naddBus!(system; label = \"Bus 4\", type = 1, active = 50.8, reactive = 23.1)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we refine the transmission line parameters by adding resistance, reactance, and susceptance values. Additionally, for transformers, we specify the off-nominal turns ratio using the turnsRatio keyword:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"\n@branch(label = \"Branch ?\", reactance = 0.22)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", resistance = 0.02, susceptance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", resistance = 0.05, susceptance = 0.04)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.04, susceptance = 0.04)\naddBranch!(system; from = \"Bus 3\", to = \"Bus 4\", turnsRatio = 0.98)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, we define the active and reactive power outputs of the generators and set the voltage magnitude setpoints. These setpoints fix the voltage magnitudes for the slack bus (type = 3) and generator buses (type = 2):","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"@generator(label = \"Generator ?\")\naddGenerator!(system; bus = \"Bus 1\", active = 60.1, reactive = 40.2,  magnitude = 0.98)\naddGenerator!(system; bus = \"Bus 2\", active = 18.2, magnitude = 1.01)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After defining the power system data, we generate an AC model that includes essential vectors and matrices for analysis, such as the nodal admittance matrix. This model is automatically updated with data changes and can be shared across different analyses:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"examples/acPowerFlow/#Display-Data-Settings","page":"AC Power Flow","title":"Display Data Settings","text":"","category":"section"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Before running simulations, we set the verbose keyword from its default silent mode (0) to basic output (1):","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"@config(verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"However, if we need more detailed solver output, the verbose setting can be adjusted within the function responsible for performing the power flow. Next, we configure the data display settings, including the selection of displayed data elements and the numeric format for relevant power flow values.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"For bus-related data, we set:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"show1 = Dict(\"Power Injection\" => false)\nfmt1 = Dict(\"Power Generation\" => \"%.2f\", \"Power Demand\" => \"%.2f\", \"Shunt Power\" => \"%.2f\")\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, for branch-related data, we choose:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"show2 = Dict(\"Shunt Power\" => false, \"Status\" => false)\nfmt2 = Dict(\"From-Bus Power\" => \"%.2f\", \"To-Bus Power\" => \"%.2f\", \"Series Power\" => \"%.2f\")\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"examples/acPowerFlow/#Base-Case-Analysis","page":"AC Power Flow","title":"Base Case Analysis","text":"","category":"section"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"At the start, we use the fast Newton-Raphson XB method to solve the AC power flow:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"fnr = fastNewtonRaphsonXB(system)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Then, we use the AC power flow wrapper to iteratively compute bus voltages as well as active and reactive powers:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"powerFlow!(fnr; power = true, verbose = 2)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the AC power flow is solved, we can analyze the results related to the buses. For instance:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"printBusData(fnr; show = show1, fmt = fmt1)","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, the results for branches are:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"printBranchData(fnr; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, using bus and branch data, we obtained the active and reactive power flows, as illustrated in Figure 2.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acPowerFlow/4bus_base_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acPowerFlow/4bus_base_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 2: Power flows in the 4-bus power system for the base case scenario.\n    </p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Additionally, the branch data shows the series power losses, which result from the series resistance and reactance of each branch. Note that the active power at the from-bus and to-bus ends of a branch differs by the active power loss. However, this does not apply to reactive power, as branch susceptances provide partial compensation.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"examples/acPowerFlow/#Modifying-Supplies-and-Demands","page":"AC Power Flow","title":"Modifying Supplies and Demands","text":"","category":"section"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We will modify the active and reactive power outputs of the generators, as well as the active and reactive powers demanded by consumers. Instead of creating a new power system model or just updating the existing one, we will update both the power system model and the fast Newton-Raphson model simultaneously:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBus!(fnr; label = \"Bus 2\", active = 25.5, reactive = 15.0)\nupdateBus!(fnr; label = \"Bus 4\", active = 42.0, reactive = 20.0)\n\nupdateGenerator!(fnr; label = \"Generator 1\", active = 58.0, reactive = 20.0)\nupdateGenerator!(fnr; label = \"Generator 2\", active = 23.1, reactive = 20.0)\n\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we run the AC power flow again to compute the new state of the power system, without having to recreate the fast Newton-Raphson model. Additionally, this step will start the fast Newton-Raphson method with a warm start, as the initial voltage magnitudes and angles will correspond to the solution from the base case analysis:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"powerFlow!(fnr; power = true)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Since no power system changes were introduced that affect the Jacobian matrices, JuliaGrid reuses the Jacobian matrix factorizations from the base case analysis, significantly reducing computational complexity.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, we can display the relevant data:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"printBranchData(fnr; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Compared to the base case, the directions of active power flows remain unchanged, but their magnitudes differ. For reactive power, the values change, and the flow at Branch 1 on the Bus 1 side reverses, as shown in Figure 3.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acPowerFlow/4bus_power_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acPowerFlow/4bus_power_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 3: Power flows in the 4-bus power system with modified supplies and demands.\n    </p>\n</div>","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"examples/acPowerFlow/#Modifying-Network-Topology","page":"AC Power Flow","title":"Modifying Network Topology","text":"","category":"section"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we will take Branch 3 out of service. Although we could update the power system model and the fast Newton-Raphson method simultaneously, to demonstrate flexibility, we will solve this scenario using the Newton-Raphson method. As a result, we will only update the power system model:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBranch!(system; label = \"Branch 3\", status = 0)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Now, let us define the Newton-Raphson model:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"nr = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"When the model is created, we also initialize the Newton-Raphson method, with the initial voltage magnitudes and angles corresponding to the values defined when the power system model was first created. If we want to use the results from the fast Newton-Raphson method and start the Newton-Raphson method with a warm start, we can transfer the voltage magnitudes and angles:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"setInitialPoint!(nr, fnr)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Now, we can solve the AC power flow for this scenario:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"powerFlow!(nr; power = true)\nnothing # hide","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To display how the power flows are distributed when one branch is out of service, we use the following:","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"printBranchData(nr; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Compared to the previous cases, we observe that the reactive power flow at Branch 1 on the Bus 1 side reverses direction due to the outage of Branch 3, as shown in Figure 4.","category":"page"},{"location":"examples/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acPowerFlow/4bus_service_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acPowerFlow/4bus_service_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 4: Power flows in the 4-bus power system with modified network topology.\n    </p>\n</div>","category":"page"},{"location":"manual/measurementModel/#MeasurementModelManual","page":"Measurement Model","title":"Measurement Model","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The JuliaGrid supports the type Measurement to preserve measurement data, with the following fields: voltmeter, ammeter, wattmeter, varmeter, and pmu. These fields contain information pertaining to measurements such as bus voltage magnitude, branch current magnitude, active power flow and injection, reactive power flow and injection measurements, and measurements of bus voltage and branch current phasors.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The type Measurement can be created using a function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"measurement.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, the user can create both the PowerSystem and Measurement types using the wrapper function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"ems.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"JuliaGrid supports two modes for populating the Measurement type: using built-in functions or using HDF5 files.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To work with HDF5 files, JuliaGrid provides the function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"saveMeasurement.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Once the Measurement type has been established, we can incorporate voltmeters, ammeters, wattmeters, varmeters, and phasor measurement units (PMUs) using the following functions:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addVoltmeter!,\naddAmmeter!,\naddWattmeter!,\naddVarmeter!,\naddPmu!.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Also, JuliaGrid provides macros @voltmeter, @ammeter, @wattmeter, @varmeter, and @pmu to define templates that aid in creating measurement devices. These templates help avoid entering the same parameters repeatedly.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nIt is important to note that measurement devices associated with branches can only be incorporated if the branch is in-service. This reflects JuliaGrid's approach to mimic a network topology processor, where logical data analysis configures the energized components of the power system.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Moreover, it is feasible to modify the parameters of measurement devices. When these functions are executed, all relevant fields within the Measurement type will be automatically updated. These functions include:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"updateVoltmeter!,\nupdateAmmeter!,\nupdateWattmeter!,\nupdateVarmeter!,\nupdatePmu!.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"tip: Tip\nThe functions for updating measurement devices serve a dual purpose. While their primary function is to modify the Measurement type, they are also designed to accept various analysis models like AC or DC state estimation models. When feasible, these functions not only modify the Measurement type but also adapt the analysis model, often resulting in improved computational efficiency. Detailed instructions on utilizing this feature can be found in dedicated manuals for specific analyses.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Finally, the user has the capability to randomly alter the measurement set by activating or deactivating devices through the following function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"status!.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Furthermore, we provide users with the ability to modify each specific measurement set by utilizing the functions:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"statusVoltmeter!,\nstatusAmmeter!,\nstatusWattmeter!,\nstatusVarmeter!,\nstatusPmu!.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#BuildMeasurementModelManual","page":"Measurement Model","title":"Build Model","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The measurement function creates an instance of the Measurement type. It requires a PowerSystem instance representing the system being observed and a string specifying the path to the relevant HDF5 measurement file. Alternatively, the Measurement can be created without any initial data, allowing the user to construct the measurements from scratch.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#HDF5-File","page":"Measurement Model","title":"HDF5 File","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In order to use the HDF5 file as input to create the Measurement type, it is necessary to have saved the data using the saveMeasurement function beforehand. Suppose the measurement data is saved as monitoring.h5 in the C:\\hdf5 directory, and it corresponds to the IEEE 14-bus test case with system data stored in case14.h5. In that case, the following code constructs the Measurement type:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"system = powerSystem(\"case14.h5\")\nmonitoring = measurement(system, \"C:/hdf5/monitoring.h5\")","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The same result can also be achieved using the wrapper function ems:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"system, monitoring = ems(\"case14.h5\", \"C:/hdf5/monitoring.h5\")","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Model-from-Scratch","page":"Measurement Model","title":"Model from Scratch","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To start building a model from the ground up, the initial step involves constructing a power system, which facilitates the addition of measurement devices to buses or branches. As an illustration:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 1.0, variance = 1e-3)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.2, variance = 1e-4, noise = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this context, we have created the voltmeter responsible for measuring the bus voltage magnitude at Bus 1, with associated mean and variance values expressed in per-units:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.voltmeter.magnitude.mean monitoring.voltmeter.magnitude.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Furthermore, we have established the wattmeter to measure the active power flow at the from-bus end of Branch 1, with corresponding mean and variance values also expressed in per-units:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.wattmeter.active.mean monitoring.wattmeter.active.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"tip: Tip\nThe measurement values (i.e., means) can be generated by adding white Gaussian noise with specified variance values to perturb the original values. This can be achieved by setting noise = true within the functions used for adding devices.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#SaveMeasurementModelManual","page":"Measurement Model","title":"Save Model","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Once the Measurement type has been created using one of the methods outlined in Build Model, the current data can be stored in the HDF5 file by using saveMeasurement function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"saveMeasurement(monitoring; path = \"C:/hdf5/monitoring.h5\")","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"All electrical quantities saved in the HDF5 file are in per-units and radians.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AddVoltmeterManual","page":"Measurement Model","title":"Add Voltmeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"We have the option to add voltmeters to a loaded measurement type or to one created from scratch. As an example, we can initiate the Measurement type and then incorporate voltmeters by utilizing the addVoltmeter! function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\n\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 0.9, variance = 1e-4)\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 1.0, variance = 1e-3, noise = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we have established two voltmeters designed to measure the bus voltage magnitude at Bus 1. In the case of the second voltmeter, the measurement value is generated internally by introducing white Gaussian noise with the variance added to the magnitude value. As a result, we obtain the following data:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.voltmeter.magnitude.mean monitoring.voltmeter.magnitude.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nWe recommend reading the documentation for the addVoltmeter! function, where we have provided a list of the keywords that can be used.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Customizing-Input-Units-for-Keywords","page":"Measurement Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"By default, the magnitude and variance keywords are expected to be provided in per-units. However, users have the flexibility to specify these values in volts if they prefer. For instance, consider the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\n@voltage(kV, rad, V)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = sqrt(3) * 135e3)\n\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 121.5, variance = 0.0135)\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 135, variance = 0.135, noise = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we have chosen to specify magnitude and variance in kilovolts (kV). It is important to note that even though we have used kilovolts as the input units, these keywords will still be stored in the per-units:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.voltmeter.magnitude.mean monitoring.voltmeter.magnitude.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nWhen users choose to input data in volts, measurement values and variances are related to line-to-neutral voltages, while the base values are defined for line-to-line voltages. Therefore, a conversion using sqrt3 is necessary. For more information, refer to the Per-Unit System section.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Print-Data-in-the-REPL","page":"Measurement Model","title":"Print Data in the REPL","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the option to print the voltmeter data in the REPL using any units that have been configured:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"printVoltmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, users can display stored data for a specific voltmeter with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"print(monitoring; voltmeter = 1)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Finally, the unit system used for voltmeter-related keywords can be checked with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@info(unit, voltmeter)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AddAmmeterManual","page":"Measurement Model","title":"Add Ammeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users can introduce ammeters into either an existing measurement type or one that they create from the ground up by making use of the addAmmeter! function, as demonstrated in the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddAmmeter!(monitoring; from = \"Branch 1\", magnitude = 0.8, variance = 0.1, noise = true)\naddAmmeter!(monitoring; to = \"Branch 1\", magnitude = 0.9, variance = 1e-3, square = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this scenario, we have established one ammeter to measure the branch current magnitude at the from-bus end of Branch 1, as indicated by the use of the from keyword. Similarly, we have added an ammeter to measure the branch current magnitude at the to-bus end of the branch by utilizing the to keyword.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For the first ammeter, the measurement value is generated by adding white Gaussian noise with the variance to the magnitude value. In contrast, for the second ammeter, we assume that the measurement value is already known, defined by the magnitude. These actions result in the following outcomes:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.ammeter.magnitude.mean monitoring.ammeter.magnitude.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The square keyword is used for the second ammeter to indicate that the measurement will be included in AC state estimation in squared form. This means the corresponding equation is introduced without a square root, while the measurement mean is squared, and the variance is doubled. This approach enhances the robustness of state estimation when handling such measurements.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nWe recommend reading the documentation for the addAmmeter! function, where we have provided a list of the keywords that can be used.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Customizing-Input-Units-for-Keywords-2","page":"Measurement Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"By default, the magnitude and variance keywords are expected to be provided in per-unit. However, users have the flexibility to express these values in amperes (A) if they prefer. Take a look at the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n@current(A, rad)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 135e3)\naddBus!(system; label = \"Bus 2\", base = 135e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddAmmeter!(monitoring; from = \"Branch 1\", magnitude = 342, variance = 43, noise = true)\naddAmmeter!(monitoring; to = \"Branch 1\", magnitude = 385, variance = 0.43, square = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we have opted to specify the magnitude and variance in amperes. It is worth noting that, despite using amperes as the input units, these keywords will still be stored in the per-unit system:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.ammeter.magnitude.mean monitoring.ammeter.magnitude.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Print-Data-in-the-REPL-2","page":"Measurement Model","title":"Print Data in the REPL","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the option to print the ammeter data in the REPL using any units that have been configured:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"printAmmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, users can display stored data for a specific ammeter with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"print(monitoring; ammeter = 1)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Finally, the unit system used for ammeter-related keywords can be checked with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@info(unit, ammeter)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AddWattmeterManual","page":"Measurement Model","title":"Add Wattmeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users can include wattmeters in either an existing measurement type or one that they create from scratch by utilizing the addWattmeter! function, as demonstrated in the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddWattmeter!(monitoring; bus = \"Bus 1\", active = 0.6, variance = 1e-3)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.3, variance = 1e-2)\naddWattmeter!(monitoring; to = \"Branch 1\", active = 0.1, variance = 1e-3, noise = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this scenario, one wattmeter has been added to measure the active power injection at Bus 1, as indicated by the use of the bus keyword. Additionally, two wattmeters have been introduced to measure the active power flow on both sides of Branch 1 using the from and to keywords.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For the first and second wattmeters, we assume that the measurement values are already known, defined by the active. In contrast, for the third wattmeter, the measurement value is generated by adding white Gaussian noise with the variance to the active value. As a result, the measurement data is as follows:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.wattmeter.active.mean monitoring.wattmeter.active.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nWe recommend reading the documentation for the addWattmeter! function, where we have provided a list of the keywords that can be used.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Customizing-Input-Units-for-Keywords-3","page":"Measurement Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"By default, the active and variance keywords are expected to be provided in per-unit values. However, users have the option to express these values in watts if they prefer, as demonstrated in the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n@power(MW, pu)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddWattmeter!(monitoring; bus = \"Bus 1\", active = 60, variance = 1e-1)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 30, variance = 1)\naddWattmeter!(monitoring; to = \"Branch 1\", active = 10, variance = 1e-1, noise = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we have chosen to specify the active and variance in megawatts (MW), but even though we have used megawatts as the input units, these keywords will still be stored in the per-unit system:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.wattmeter.active.mean monitoring.wattmeter.active.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Print-Data-in-the-REPL-3","page":"Measurement Model","title":"Print Data in the REPL","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the option to print the wattmeter data in the REPL using any units that have been configured:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"printWattmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, users can display stored data for a specific wattmeter with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"print(monitoring; wattmeter = 1)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Finally, the unit system used for wattmeter-related keywords can be checked with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@info(unit, wattmeter)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AddVarmeterManual","page":"Measurement Model","title":"Add Varmeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To include varmeters, the same approach as described in the Add Wattmeter section can be applied, but here, we make use of the addVarmeter! function, as demonstrated in the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddVarmeter!(monitoring; bus = \"Bus 1\", reactive = 0.2, variance = 1e-3)\naddVarmeter!(monitoring; from = \"Branch 1\", reactive = 0.1, variance = 1e-2)\naddVarmeter!(monitoring; to = \"Branch 1\", reactive = 0.05, variance = 1e-3, noise = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this context, one varmeter has been added to measure the reactive power injection at Bus 1, as indicated by the use of the bus keyword. Additionally, two varmeters have been introduced to measure the reactive power flow on both sides of Branch 1 using the from and to keywords. As a result, the following outcomes are observed:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.varmeter.reactive.mean monitoring.varmeter.reactive.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nWe recommend reading the documentation for the addVarmeter! function, where we have provided a list of the keywords that can be used.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Customizing-Input-Units-for-Keywords-4","page":"Measurement Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Just as we explained for the previous device, users have the flexibility to select units different from per-units. In this case, they can opt for megavolt-ampere reactive (MVAr), as illustrated in the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n@power(pu, MVAr)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddVarmeter!(monitoring; bus = \"Bus 1\", reactive = 20, variance = 1e-1)\naddVarmeter!(monitoring; from = \"Branch 1\", reactive = 10, variance = 1)\naddVarmeter!(monitoring; to = \"Branch 1\", reactive = 5, variance = 1e-1, noise = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"JuliaGrid will still store the values in the per-unit system:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.varmeter.reactive.mean monitoring.varmeter.reactive.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Print-Data-in-the-REPL-4","page":"Measurement Model","title":"Print Data in the REPL","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the option to print the varmeter data in the REPL using any units that have been configured:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"printVarmeterData(monitoring)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, users can display stored data for a specific varmeter with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"print(monitoring; varmeter = 1)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Finally, the unit system used for varmeter-related keywords can be checked with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@info(unit, varmeter)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AddPMUManual","page":"Measurement Model","title":"Add PMU","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the capability to incorporate PMUs into either an existing measurement type or create one from scratch by utilizing the addPmu! function, as demonstrated in the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddPmu!(monitoring; bus = \"Bus 1\", magnitude = 1.1, angle = 0.1, varianceMagnitude = 0.1)\naddPmu!(monitoring; from = \"Branch 1\", magnitude = 1.0, angle = -0.2, noise = true)\naddPmu!(monitoring; to = \"Branch 1\", magnitude = 0.9, angle = 0.0, varianceAngle = 0.001)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nWhile the typical understanding of a PMU encompasses a device that measures the bus voltage phasor and all branch current phasors incident to the bus, we have chosen to deconstruct this concept to offer users increased flexibility. As a result, our approach yields PMUs that measure individual phasors, each described with magnitude and angle, along with corresponding variances, all presented in the polar coordinate system.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this context, one PMU has been added to measure the bus voltage phasor at Bus 1, as indicated by the use of the bus keyword. Additionally, two PMUs have been introduced to measure the branch current phasors on both sides of Branch 1 using the from and to keywords.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For the first and third PMUs, we assume that the measurement values are already known, defined by the magnitude and angle keywords. However, for the second PMU, we generate the measurement value by adding white Gaussian noise with varianceMagnitude and varianceAngle to the magnitude and angle values, respectively. It is important to note that when we omit specifying variance values, we rely on their default settings, both of which are equal to 1e-8. As a result, we observe the following outcomes:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.pmu.magnitude.mean monitoring.pmu.magnitude.variance]\n[monitoring.pmu.angle.mean monitoring.pmu.angle.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nWe recommend reading the documentation for the addPmu! function, where we have provided a list of the keywords that can be used.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#PMU-State-Estimation-and-Coordinate-System","page":"Measurement Model","title":"PMU State Estimation and Coordinate System","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"When users add PMUs and create a PmuStateEstimation type, they specify that the estimation model should rely only on PMUs. In this case, phasor measurements are always incorporated in the rectangular coordinate system. Here, the real and imaginary components of the phasor measurements become correlated, but these correlations are typically ignored [2]. To account for them, users can set the keyword correlated = true. For example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\naddPmu!(monitoring; bus = \"Bus 2\", magnitude = 1, angle = 0)\naddPmu!(monitoring; from = \"Branch 1\", magnitude = 0.9, angle = -0.3, correlated = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For the first phasor measurement, correlation is neglected, whereas for the second, it is considered.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AC-State-Estimation-and-Coordinate-Systems","page":"Measurement Model","title":"AC State Estimation and Coordinate Systems","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In AC state estimation, when users create an AcStateEstimation type, PMUs are by default integrated into the rectangular coordinate system, where correlations are neglected. Users can also set correlated = true to account for the correlation between the real and imaginary components of the phasor measurements. Additionally, in the AC state estimation model, users have the flexibility to incorporate phasor measurements in the polar coordinate system by specifying polar = true.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For example, let us add PMUs:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\naddPmu!(monitoring; bus = \"Bus 2\", magnitude = 1, angle = 0, polar = true, square = true)\naddPmu!(monitoring; from = \"Branch 1\", magnitude = 0.9, angle = -0.3, correlated = true)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The first phasor measurement will be incorporated into the AC state estimation model using the polar coordinate system. Additionally, by setting square = true, the current magnitude measurement will be included in its squared form. The second PMU will be integrated into the rectangular coordinate system, where a correlation exists between the real and imaginary components.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"tip: Tip\nIt is noteworthy that expressing current phasor measurements in polar coordinates can lead to ill-conditioned problems due to small current magnitudes, whereas using rectangular representation can resolve this issue.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Customizing-Input-Units-for-Keywords-5","page":"Measurement Model","title":"Customizing Input Units for Keywords","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"By default, the magnitude and varianceMagnitude keywords are expected to be provided in per-unit, while the angle and varianceAngle keywords are expected to be provided in radians. However, users have the flexibility to express these values in different units, such as volts (V) and degrees (deg) if the PMU is set to a bus, or amperes (A) and degrees (deg) if the PMU is set to a branch. This flexibility is demonstrated in the following:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit)  # hide\n@voltage(kV, deg, V)\n@current(A, deg)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", base = 135e3)\naddBus!(system; label = \"Bus 2\", base = 135e3)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddPmu!(monitoring; bus = \"Bus 1\", magnitude = 85.74, angle = 5.73, varianceAngle = 0.06)\naddPmu!(monitoring; from = \"Branch 1\", magnitude = 427.67, angle = -11.46, noise = true)\naddPmu!(monitoring; to = \"Branch 1\", magnitude = 384.91, angle = 0.0)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we have opted to specify kilovolts (kV) and degrees (deg) for the PMU located at Bus 1, and amperes (A) and degrees (deg) for the PMUs located at Branch 1. It is important to note that regardless of the units used, the values will still be stored in per-units and radians:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"[monitoring.pmu.magnitude.mean monitoring.pmu.magnitude.variance]\n[monitoring.pmu.angle.mean monitoring.pmu.angle.variance]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Print-Data-in-the-REPL-5","page":"Measurement Model","title":"Print Data in the REPL","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the option to print the PMU data in the REPL using any units that have been configured:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"printPmuData(monitoring)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, users can display stored data for a specific PMU with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"print(monitoring; pmu = 1)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Finally, the unit system used for PMU-related keywords can be checked with:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@info(unit, pmu)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AddTemplatesMeasurementManual","page":"Measurement Model","title":"Add Templates","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The functions addVoltmeter!, addAmmeter!, addWattmeter!, addVarmeter!, and addPmu! are employed to introduce measurement devices. In cases where specific keywords are not explicitly defined, default values are automatically assigned to certain parameters.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Default-Keyword-Values","page":"Measurement Model","title":"Default Keyword Values","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"When utilizing the addVoltmeter! function, the default variance is set to variance = 1e-4 per-unit, and the voltmeter's operational status is automatically assumed to be in-service, as indicated by the setting of status = 1.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Similarly, for the addAmmeter! function, the default variances are established at variance = 1e-4 per-unit, and the operational statuses are configured to status = 1. This means that if a user places an ammeter at either the from-bus or to-bus end of a branch, the default settings are identical. However, as we will explain in the following subsection, users have the flexibility to fine-tune these default values, differentiating between the two locations.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In alignment with ammeters, the addWattmeter! and addVarmeter! functions feature default variances set at variance = 1e-4 per-unit, and statuses are automatically assigned as status = 1, regardless of whether the wattmeter or varmeter is placed at the bus, the from-bus end, or the to-bus end. Users have the ability to customize these default values, making distinctions between the three positions of the measurement devices.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For the addPmu! function, variances for both magnitude and angle measurements are standardized to varianceMagnitude = 1e-8 and varianceAngle = 1e-8 in per-units. Likewise, operational status is uniformly set to status = 1, regardless of whether the PMU is positioned on the bus, the from-bus end, or the to-bus end. Once more, users retain the option to tailor these default values to their specific needs, allowing for distinctions between these three locations of the measurement devices. Additionally, the coordinate system utilized for AC state estimation is consistently configured with polar = false, while correlation in the rectangular system is disabled with correlated = false.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Across all measurement devices, the method for generating measurement means is established as noise = false.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#ChangeKeywordsMeasurementManual","page":"Measurement Model","title":"Change Default Keyword Values","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In JuliaGrid, users have the flexibility to customize default values and assign personalized settings using the @voltmeter, @ammeter, @wattmeter, @varmeter, and @pmu macros. These macros create voltmeter, ammeter, wattmeter, varmeter, and pmu templates that are employed each time functions for adding measurement devices are called. Here is an example of creating these templates with tailored default values:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\n@voltmeter(variance = 1e-4, noise = true)\naddVoltmeter!(monitoring; label = \"Voltmeter 1\", bus = \"Bus 1\", magnitude = 1.0)\n\n@ammeter(varianceFrom = 1e-3, varianceTo = 1e-4, statusTo = 0)\naddAmmeter!(monitoring; label = \"Ammeter 1\", from = \"Branch 1\", magnitude = 1.1)\naddAmmeter!(monitoring; label = \"Ammeter 2\", to = \"Branch 1\", magnitude = 0.9)\n\n@wattmeter(varianceBus = 1e-3, statusFrom = 0, noise = true)\naddWattmeter!(monitoring; label = \"Wattmeter 1\", bus = \"Bus 1\", active = 0.6)\naddWattmeter!(monitoring; label = \"Wattmeter 2\", from = \"Branch 1\", active = 0.3)\naddWattmeter!(monitoring; label = \"Wattmeter 3\", to = \"Branch 1\", active = 0.1)\n\n@varmeter(varianceFrom = 1e-3, varianceTo = 1e-3, statusBus = 0)\naddVarmeter!(monitoring; label = \"Varmeter 1\", bus = \"Bus 1\", reactive = 0.2)\naddVarmeter!(monitoring; label = \"Varmeter 2\", from = \"Branch 1\", reactive = 0.1)\naddVarmeter!(monitoring; label = \"Varmeter 3\", to = \"Branch 1\", reactive = 0.05)\n\n@pmu(varianceMagnitudeBus = 1e-4, statusBus = 0, varianceAngleFrom = 1e-3)\naddPmu!(monitoring; label = \"PMU 1\", bus = \"Bus 1\", magnitude = 1.1, angle = -0.1)\naddPmu!(monitoring; label = \"PMU 2\", from = \"Branch 1\", magnitude = 1.0, angle = -0.2)\naddPmu!(monitoring; label = \"PMU 3\", to = \"Branch 1\", magnitude = 0.9, angle = 0.0)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For instance, when adding a wattmeter to the bus, the varianceBus = 1e-3 will be applied, or if it is added to the from-bus end of the branch, these wattmeters will be set as out-of-service according to statusFrom = 0.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"It is important to note that changing input units will also impact the templates accordingly.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users can view the templates associated with the voltmeter, ammeter, wattmeter, varmeter or PMUs keywords. For example, to check templates related to wattmeter keywords, use:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@info(template, wattmeter)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Multiple-Templates","page":"Measurement Model","title":"Multiple Templates","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In the case of calling the macros multiple times, the provided keywords and values will be combined into a single template for the corresponding measurement device.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Reset-Templates","page":"Measurement Model","title":"Reset Templates","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To reset the measurement device templates to their default settings, users can utilize the following macros:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@default(voltmeter)\n@default(ammeter)\n@default(wattmeter)\n@default(varmeter)\n@default(pmu)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, users can reset all templates using the macro:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@default(template)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#LabelsMeasurementManual","page":"Measurement Model","title":"Labels","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"JuliaGrid necessitates a unique label for each voltmeter, ammeter, wattmeter, varmeter, or pmu. These labels are stored in order dictionaries, functioning as pairs of strings and integers. The string signifies the distinct label for the particular device, while the integer tracks the internal numbering of measurement devices.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In all the previous examples, with the exception of the last one, we relied on automatic labeling by omitting the label keyword. This allowed JuliaGrid to independently assign unique labels to measurement devices. In such cases, JuliaGrid utilizes a sequential set of increasing integers for labeling the devices. The last example demonstrates the user labeling approach.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"tip: Tip\nString labels improve readability, but in larger models, the overhead from using strings can become substantial. To reduce memory usage, users can configure ordered dictionaries to accept and store integers as labels:@config(label = Integer)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Integer-Based-Labeling","page":"Measurement Model","title":"Integer-Based Labeling","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Instead of using strings for labels, Julia provides the @config macro to enable storing labels as integers:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n@config(label = Integer)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\naddVoltmeter!(monitoring; label = 1, bus = 1, magnitude = 1.0)\n\naddAmmeter!(monitoring; label = 1, from = 1, magnitude = 1.1)\naddAmmeter!(monitoring; label = 2, to = 1, magnitude = 0.9)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Note that the @config macro must be executed first. Otherwise, even if integers are passed to the functions, labels will be stored as strings. In this example, all labels, both in the power system and in the measurement system, are stored as integers.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Integer-String-Based-Labeling","page":"Measurement Model","title":"Integer-String-Based Labeling","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In addition to using only strings or only integers, JuliaGrid supports mixed labeling. Users can fine-tune labels for all power system components as well as for all measurement devices. For example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n@branch(label = Integer)\n@ammeter(label = Integer)\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = 1, from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddVoltmeter!(monitoring; label = \"Voltmeter 1\", bus = \"Bus 1\", magnitude = 1.0)\n\naddAmmeter!(monitoring; label = 1, from = 1, magnitude = 1.1)\naddAmmeter!(monitoring; label = 2, to = 1, magnitude = 0.9)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, string labels are used for buses and voltmeters, while integers are used for branches and ammeters. The same configuration can be achieved by using the @config macro along with the macros for specifying power system components and measurement devices:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"@default(unit) # hide\n@default(template) # hide\n@config(label = Integer)\n@bus(label = String)\n@voltmeter(label = String)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Automated-Labeling-Using-Templates","page":"Measurement Model","title":"Automated Labeling Using Templates","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Furthermore, users can create labels using templates and include the symbol ? to insert an incremental set of integers at any position. In addition, users have the option to use the symbol ! to insert the location of the measurement device into the label. For example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\n@voltmeter(label = \"Voltmeter ?\")\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 1.0)\naddVoltmeter!(monitoring; bus = \"Bus 2\", magnitude = 0.9)\n\n@ammeter(label = \"!\")\naddAmmeter!(monitoring; from = \"Branch 1\", magnitude = 1.1)\naddAmmeter!(monitoring; to = \"Branch 1\", magnitude = 0.9)\n\n@wattmeter(label = \"Wattmeter ?: !\")\naddWattmeter!(monitoring; bus = \"Bus 1\", active = 0.6)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.3)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To illustrate, the voltmeter labels are defined with incremental integers as follows:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"monitoring.voltmeter.label","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Moreover, for ammeter labels, location information is employed:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"monitoring.ammeter.label","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Lastly, for wattmeters, a combination of both approaches is used:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"monitoring.wattmeter.label","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Retrieving-Labels","page":"Measurement Model","title":"Retrieving Labels","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Let us explore how to retrieve stored labels. Consider the following model:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 1\", reactance = 0.14)\n\naddWattmeter!(monitoring; label = \"Wattmeter 2\", bus = \"Bus 2\", active = 0.6)\naddWattmeter!(monitoring; label = \"Wattmeter 1\", bus = \"Bus 1\", active = 0.2)\naddWattmeter!(monitoring; label = \"Wattmeter 4\", from = \"Branch 1\", active = 0.3)\naddWattmeter!(monitoring; label = \"Wattmeter 3\", to = \"Branch 1\", active = 0.1)\naddWattmeter!(monitoring; label = \"Wattmeter 5\", from = \"Branch 2\", active = 0.1)\nnothing # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To access the wattmeter labels, we can use the variable:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"monitoring.wattmeter.label","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"If we need to obtain only labels, we can use the following code:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"label = collect(keys(monitoring.wattmeter.label))","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To isolate the wattmeters positioned either at the buses or at the ends of branches (from-bus or to-bus), users can achieve this using the following code:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"label[monitoring.wattmeter.layout.bus]\nlabel[monitoring.wattmeter.layout.from]\nlabel[monitoring.wattmeter.layout.to]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Furthermore, when using the addWattmeter! function, the labels for the keywords bus, from, and to are stored internally as numerical values. To retrieve bus labels, we can follow this procedure:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"label = collect(keys(system.bus.label));\nlabel[monitoring.wattmeter.layout.index[monitoring.wattmeter.layout.bus]]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Similarly, to obtain labels for branches, we can use the following code:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"label = collect(keys(system.branch.label));\n\nlabel[monitoring.wattmeter.layout.index[monitoring.wattmeter.layout.from]]\nlabel[monitoring.wattmeter.layout.index[monitoring.wattmeter.layout.to]]","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"This procedure is applicable to all measurement devices, including voltmeters, ammeters, varmeters, and PMUs.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"tip: Tip\nJuliaGrid offers the capability to print labels alongside various types of data. For instance, users can use the following code to print labels in combination with specific data:print(monitoring.wattmeter.label, monitoring.wattmeter.active.mean)","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Managing-Labels-in-HDF5-Imports","page":"Measurement Model","title":"Managing Labels in HDF5 Imports","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"When saving the measurements to an HDF5 file, the label type (strings or integers) will match the type chosen during system setup. Similarly, when loading data from an HDF5 file, the label type is preserved exactly as it was saved, regardless of any settings provided by the @config macro or macros related to measurement devices.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#AddDeviceGroupsManual","page":"Measurement Model","title":"Add Multiple Devices","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the option to add measurement devices with data generated from one of the AC analyses, specifically, using results obtained from either AC power flow or AC optimal power flow. To do this, users simply need to provide the AC type as an argument to one of the functions responsible for adding measurement devices:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)\n\n@branch(resistance = 0.03, susceptance = 0.02)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.5)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.1)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.2)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 1.2)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true, current = true)\n\n@voltmeter(label = \"!\", noise = true)\naddVoltmeter!(monitoring, analysis; variance = 1e-3)\n\n@ammeter(label = \"!\")\naddAmmeter!(monitoring, analysis; varianceFrom = 1e-3, statusTo = 0, noise = true)\n\n@wattmeter(label = \"!\")\naddWattmeter!(monitoring, analysis; varianceBus = 1e-3, statusFrom = 0)\n\n@varmeter(label = \"!\")\naddVarmeter!(monitoring, analysis; varianceFrom = 1e-3, statusBus = 0)\n\n@pmu(label = \"!\", polar = true)\naddPmu!(monitoring, analysis; varianceMagnitudeBus = 1e-3)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we incorporate voltmeters to all buses and ammeters to all branches on both ends of each branch. We set noise = true once in the template and once directly in the function, which means that measurement values are generated by adding white Gaussian noise with specified variances to perturb the values obtained from the AC power flow analysis.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"For wattmeters, varmeters, and PMUs added to all buses and branches, we rely on the default setting of noise = false to obtain measurement values that match precisely with those obtained from the AC power flow analysis. Additionally, when including PMUs in the AC state estimation model, we opt for the polar coordinate system by setting polar = true.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nIt is important to note that JuliaGrid follows a specific order: it first adds bus measurements, then branch measurements. For branches, it adds measurement located at the from-bus end, and immediately after, measurement at the to-bus end. This process is repeated for all in-service branches.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the option to employ an alternative method for adding groups of measurements, utilizing functions that add measurements individually. This approach may offer a more straightforward process. For example, to add wattmeters similarly to the procedure outlined above, we can employ the following:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Pᵢ = analysis.power.injection.active\nfor (label, idx) in system.bus.label\n    addWattmeter!(monitoring; bus = label, active = Pᵢ[idx], variance = 1e-3)\nend\n\nPᵢⱼ = analysis.power.from.active\nPⱼᵢ = analysis.power.to.active\nfor (label, idx) in system.branch.label\n    addWattmeter!(monitoring; from = label, active = Pᵢⱼ[idx], status = 0)\n    addWattmeter!(monitoring; to = label, active = Pⱼᵢ[idx])\nend\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#UpdateMeasurementDevicesManual","page":"Measurement Model","title":"Update Devices","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"After the addition of measurement devices to the Measurement type, users possess the flexibility to modify all parameters as defined in the function that added these measurement devices.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#UpdateVoltmeterManual","page":"Measurement Model","title":"Update Voltmeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users have the flexibility to modify all parameters as defined within the addVoltmeter! function. For illustration, let us continue with the example from the Add Device Groups section:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"updateVoltmeter!(monitoring; label = \"Bus 2\", magnitude = 0.9, noise = false)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we update the measurement value of the voltmeter located at Bus 2, and this measurement is now generated without the inclusion of white Gaussian noise.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#UpdateAmmeterManual","page":"Measurement Model","title":"Update Ammeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Similarly, users have the flexibility to modify all parameters defined within the addAmmeter! function. Using the same example from the Add Device Groups section, for example, we have:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"updateAmmeter!(monitoring; label = \"From Branch 2\", magnitude = 1.2, variance = 1e-4)\nupdateAmmeter!(monitoring; label = \"To Branch 2\", status = 0)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we make adjustments to the measurement and variance values of the ammeter located at Branch 2, specifically at the from-bus end. Next, we deactivate the ammeter at the same branch on the to-bus end.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#UpdateWattmeterManual","page":"Measurement Model","title":"Update Wattmeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Following the same logic, users can modify all parameters defined within the addWattmeter! function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"updateWattmeter!(monitoring; label = \"Bus 1\", active = 1.2, variance = 1e-4)\nupdateWattmeter!(monitoring; label = \"To Branch 1\", variance = 1e-6)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this case, we modify the measurement and variance values for the wattmeter located at Bus 1. The wattmeter at Branch 1 on the to-bus end retains its measurement value, while only the measurement variance is adjusted.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#UpdateVarmeterManual","page":"Measurement Model","title":"Update Varmeter","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Following the same logic, users can modify all parameters defined within the addVarmeter! function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"updateVarmeter!(monitoring; label = \"Bus 1\", reactive = 1.2)\nupdateVarmeter!(monitoring; label = \"Bus 2\", status = 0)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this instance, we make adjustments to the measurement value of the varmeter located at Bus 1, while utilizing a previously defined variance. Furthermore, we deactivate the varmeter at Bus 2 and designate it as out-of-service.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#UpdatePMUrManual","page":"Measurement Model","title":"Update PMU","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Finally, users can modify all PMU parameters defined within the addPmu! function:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"updatePmu!(monitoring; label = \"Bus 1\", magnitude = 1.05, noise = true)\nupdatePmu!(monitoring; label = \"From Branch 1\", varianceAngle = 1e-6, polar = false)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this example, we adjust the magnitude measurement value of the PMU located at Bus 1. Now, this measurement is generated by adding white Gaussian noise with specified variance value to perturb the magnitude value, while keeping the bus angle voltage value unchanged. For the PMU placed at Branch 1 on the from-bus end, we retain the existing measurement values and only adjust the variance of the angle measurement. Additionally, we choose to include this measurement in the rectangular coordinate system for the AC state estimation.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#MeasurementSetManual","page":"Measurement Model","title":"Measurement Set","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Once measurement devices are integrated into the Measurement type, we empower users to create measurement sets in a randomized manner. To be more precise, users can manipulate the status of devices, activating or deactivating them according to specific settings. To illustrate this feature, let us first create a measurement set using the following example:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)\n\n@branch(resistance = 0.03, susceptance = 0.02)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.5)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.1)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.2)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 1.2)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true, current = true)\n\naddVoltmeter!(monitoring, analysis)\naddAmmeter!(monitoring, analysis)\naddPmu!(monitoring, analysis)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Activating-Devices","page":"Measurement Model","title":"Activating Devices","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"As a starting point, we create the measurement set where all devices are set to in-service mode based on default settings. In this instance, we generate the measurement set comprising 3 voltmeters, 6 ammeters, and 9 PMUs.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Subsequently, we offer users the ability to manipulate the status of in-service devices using the status! function. For example, within this set, if we wish to have only 12 out of the total 18 devices in-service while the rest are out-of-service, we can accomplish this as follows:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"status!(monitoring; inservice = 12)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Upon executing this function, 12 devices will be randomly selected to be in-service, while the remaining 6 will be set to out-of-service.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Furthermore, users can fine-tune the manipulation of specific measurements. Let us say we want to activate only 2 ammeters while deactivating the remaining ammeters:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"statusAmmeter!(monitoring; inservice = 2)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"This action will result in 2 ammeters being in-service and 4 being out-of-service.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Users also have the option to further refine these actions by specifying devices at particular locations within the power system. For instance, we can enable 3 PMUs at buses to measure bus voltage phasors while deactivating all PMUs at branches that measure current phasors:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"statusPmu!(monitoring; inserviceBus = 3, inserviceFrom = 0, inserviceTo = 0)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The outcome will be that 3 PMUs are set to in-service at buses for voltage phasor measurements, while all PMUs at branches measuring current phasors will be in out-of-service mode.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Deactivating-Devices","page":"Measurement Model","title":"Deactivating Devices","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Likewise, we empower users to specify the number of devices to be set as out-of-service rather than defining the number of in-service devices. For instance, if the intention is to deactivate just 2 devices from the total measurement set, it can be achieved as follows:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"status!(monitoring; outservice = 2)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In this scenario 2 devices will be randomly deactivated, while the rest will remain in in-service status. Similar to the previous approach, users can apply this to specific devices or employ fine-tuning as needed.","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"manual/measurementModel/#Activating-Devices-Using-Redundancy","page":"Measurement Model","title":"Activating Devices Using Redundancy","text":"","category":"section"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Furthermore, users can take advantage of redundancy, which represents the ratio between measurement devices and state variables. For example, if we wish to have the number of measurement devices be 1.2 times greater than the number of state variables, we can utilize the following command:","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"status!(monitoring; redundancy = 1.2)\nnothing  # hide","category":"page"},{"location":"manual/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Considering that the number of state variables is 5 (excluding the voltage angle related to the slack bus), using a redundancy value of 1.2 will result in 6 devices being set to in-service, while the remainder will be deactivated. As before, users can target specific devices or adjust settings as needed.","category":"page"},{"location":"background/releasenotes/#ReleaseNotes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"","category":"page"},{"location":"background/releasenotes/#Version-0.5.1","page":"Release Notes","title":"Version 0.5.1","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Release Date: July 12, 2025","category":"page"},{"location":"background/releasenotes/#Added","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Introduced the optimal keyword in the function powerSystem to skip importing data related to optimal power flow analyses, see Partial Load for Faster Import.","category":"page"},{"location":"background/releasenotes/#Other","page":"Release Notes","title":"Other","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Removed unused parameters from the PowerSystem type.","category":"page"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"","category":"page"},{"location":"background/releasenotes/#Version-0.5.0","page":"Release Notes","title":"Version 0.5.0","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Release Date: July 5, 2025","category":"page"},{"location":"background/releasenotes/#Breaking","page":"Release Notes","title":"Breaking","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Introduced a new parser for PSSE case files.\nAdded support for KLU factorization.\nReformulated interval constraints in optimal power flow as two separate constraints.\nIntroduced support for extending the optimal power flow formulation.\nImplemented the Peters-Wilkinson method for solving all state estimation models.","category":"page"},{"location":"background/releasenotes/#Added-2","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Functions to display the currently active templates.\nFunctions to show the unit system used for keyword interpretation.\nFunctions to print data associated with specific components.\nSupport for configuring label types for each group of power system components and measurement types.\nAbility to read bus names from MATPOWER and PSSE imports.\nSupport for the setInitialPoint! function across all LAV estimators.","category":"page"},{"location":"background/releasenotes/#Fixed","page":"Release Notes","title":"Fixed","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Fixed issues related to function precompilation.\nCorrected verbosity settings in optimization methods when the silent flag is enabled.","category":"page"},{"location":"background/releasenotes/#Other-2","page":"Release Notes","title":"Other","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Optimized memory allocation in all power flow algorithms.\nImproved memory handling in all WLS state estimation algorithms.\nUpdated default generator output power limits.\nImproved efficiency in merging disconnected flow islands.\nRemoved the requirement for a generator at the slack bus in state estimation models.","category":"page"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"","category":"page"},{"location":"background/releasenotes/#Version-0.4.0","page":"Release Notes","title":"Version 0.4.0","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Release Date: April 11, 2025","category":"page"},{"location":"background/releasenotes/#Breaking-2","page":"Release Notes","title":"Breaking","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Introduced references to PowerSystem and Measurement types, allowing functions to be used with only the parent arguments.\nEnhanced computational efficiency of LAV estimators by removing deviation variables associated with state variables.\nRenamed type definitions for improved readability.","category":"page"},{"location":"background/releasenotes/#Added-3","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Bad data Chi-squared test function chiTest.\nWrapper function for creating PowerSystem and Measurement types ems.","category":"page"},{"location":"background/releasenotes/#Fixed-2","page":"Release Notes","title":"Fixed","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Update analysis functions now correctly apply updates, even changes are made regardless of the specific type.\nAdjusted tables and figures in the documentation for better compatibility with dark themes.","category":"page"},{"location":"background/releasenotes/#Other-3","page":"Release Notes","title":"Other","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Added iteration counter variables to iterative algorithms.\nEnabled support for including current magnitude measurements in squared form for AC state estimation.","category":"page"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"","category":"page"},{"location":"background/releasenotes/#Version-0.3.0","page":"Release Notes","title":"Version 0.3.0","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Release Date: March 10, 2025","category":"page"},{"location":"background/releasenotes/#Breaking-3","page":"Release Notes","title":"Breaking","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Allowing macros to execute at the code line where they are called.","category":"page"},{"location":"background/releasenotes/#Added-4","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Wrapper functions powerFlow! and stateEstimation!.","category":"page"},{"location":"background/releasenotes/#Fixed-3","page":"Release Notes","title":"Fixed","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Conversions between SI units and per-unit system\nVarious bugs related to printing data.\nVarious bugs related to integer labels.","category":"page"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"","category":"page"},{"location":"background/releasenotes/#Version-0.2.0","page":"Release Notes","title":"Version 0.2.0","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Release Date: October 17, 2024","category":"page"},{"location":"background/releasenotes/#Added-5","page":"Release Notes","title":"Added","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Power system printing functions:\nprintBusData,\nprintBranchData,\nprintGeneratorData.\nMeasurement printing functions:\nprintVoltmeterData,\nprintAmmeterData,\nprintWattmeterData,\nprintVarmeterData,\nprintPmuData.\nConstraint printing functions:\nprintBusConstraint,\nprintBranchConstraint,\nprintGeneratorConstraint.\nInteger based labeling.","category":"page"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"","category":"page"},{"location":"background/releasenotes/#Version-0.1.0","page":"Release Notes","title":"Version 0.1.0","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Release Date: April 19, 2024","category":"page"},{"location":"background/releasenotes/#Breaking-4","page":"Release Notes","title":"Breaking","text":"","category":"section"},{"location":"background/releasenotes/","page":"Release Notes","title":"Release Notes","text":"Initial stable public release.","category":"page"},{"location":"api/stateEstimation/#StateEstimationAPI","page":"State Estimation","title":"State Estimation","text":"","category":"section"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"For further information on this topic, please see the AC State Estimation, PMU State Estimation or DC State Estimation sections of the Manual. Below, we have provided a list of functions that can be utilized for state estimation, observability analysis, or bad data analysis.","category":"page"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"To load state estimation API functionalities into the current scope, utilize the following command:","category":"page"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"using JuliaGrid, Ipopt, HiGHS","category":"page"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"api/stateEstimation/#Observability-Analysis","page":"State Estimation","title":"Observability Analysis","text":"","category":"section"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"islandTopologicalFlow\nislandTopological\nrestorationGram!\npmuPlacement\npmuPlacement!","category":"page"},{"location":"api/stateEstimation/#AC-State-Estimation","page":"State Estimation","title":"AC State Estimation","text":"","category":"section"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"gaussNewton\nacLavStateEstimation\nincrement!\nsolve!\nsetInitialPoint!\nstateEstimation!","category":"page"},{"location":"api/stateEstimation/#PMU-State-Estimation","page":"State Estimation","title":"PMU State Estimation","text":"","category":"section"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"pmuStateEstimation\npmuLavStateEstimation\nsolve!\nstateEstimation!","category":"page"},{"location":"api/stateEstimation/#DC-State-Estimation","page":"State Estimation","title":"DC State Estimation","text":"","category":"section"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"dcStateEstimation\ndcLavStateEstimation\nsolve!\nstateEstimation!","category":"page"},{"location":"api/stateEstimation/#Bad-Data-Analysis","page":"State Estimation","title":"Bad Data Analysis","text":"","category":"section"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"chiTest\nresidualTest!","category":"page"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"api/stateEstimation/#Observability-Analysis-2","page":"State Estimation","title":"Observability Analysis","text":"","category":"section"},{"location":"api/stateEstimation/#JuliaGrid.islandTopologicalFlow","page":"State Estimation","title":"JuliaGrid.islandTopologicalFlow","text":"islandTopologicalFlow(monitoring::Measurement)\n\nThe function utilizes a topological approach to detect flow-observable islands, resulting in the formation of disconnected and loop-free subgraphs. It is assumed that active and reactive power measurements are paired, indicating a standard observability analysis. In this analysis, islands formed by active power measurements correspond to those formed by reactive power measurements.\n\nArguments\n\nTo define flow-observable islands, this function needs the Measurement type.\n\nReturns\n\nThe function returns an instance of the Island type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nstatusWattmeter!(monitoring; inservice = 15)\nmonitoring.varmeter.reactive.status = copy(monitoring.wattmeter.active.status)\n\nislands = islandTopologicalFlow(monitoring)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.islandTopological","page":"State Estimation","title":"JuliaGrid.islandTopological","text":"islandTopological(monitoring::Measurement)\n\nThe function employs a topological method to identify maximal-observable islands. Specifically, it employs active power measurements to pinpoint flow-observable islands. Subsequently, these islands are merged based on the available injection measurements.\n\nIt is assumed that active and reactive power measurements are paired, indicating a standard observability analysis. In this analysis, islands formed by active power measurements correspond to those formed by reactive power measurements.\n\nArguments\n\nTo define maximal-observable islands, this function needs the Measurement type.\n\nReturns\n\nThe function returns an instance of the Island type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nstatusWattmeter!(monitoring; inservice = 15)\nmonitoring.varmeter.reactive.status = copy(monitoring.wattmeter.active.status)\n\nislands = islandTopological(monitoring)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.restorationGram!","page":"State Estimation","title":"JuliaGrid.restorationGram!","text":"restorationGram!(monitoring::Measurement, pseudo::Measurement, islands::Island; threshold)\n\nUpon identifying the Island, the function incorporates measurements from the available pseudo-measurements in the pseudo variable into the monitoring variable to reinstate observability. This method relies on reduced coefficient matrices and the Gram matrix.\n\nIt is important to note that the monitoring labels in the monitoring and pseudo variables must be different to enable the function to successfully incorporate measurements from pseudo into the monitoring set of measurements.\n\nKeyword\n\nThe keyword threshold defines the zero pivot threshold value, with a default value of 1e-5. More precisely, all computed pivots less than this value will be treated as zero pivots.\n\nUpdates\n\nThe function updates the monitoring variable of the Measurement type.\n\nExample\n\nsystem, monitoring, pseudo = ems(\"case14.h5\", \"monitoring.h5\", \"pseudo.h5\")\n\nstatusWattmeter!(monitoring; inservice = 10)\nislands = islandTopological(monitoring)\n\nrestorationGram!(monitoring, pseudo, islands)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.pmuPlacement","page":"State Estimation","title":"JuliaGrid.pmuPlacement","text":"pmuPlacement(system::PowerSystem, optimizer; bridge, name, verbose)\n\nThe function determines the optimal placement of PMUs through integer linear programming. It identifies the minimum set of PMUs required to ensure observability and a unique state estimator.\n\nThe function accepts a PowerSystem type as input to establish the framework for finding the optimal PMU placement. If the ac field within the PowerSystem type is not yet created, the function automatically initiates an update process.\n\nAdditionally, the optimizer argument is a crucial component for formulating and solving the optimization problem. Typically, using the HiGHS or GLPK solver is sufficient. For more detailed information, please refer to the JuMP documenatation.\n\nKeywords\n\nThe function accepts the following keywords:\n\nbridge: Controls the bridging mechanism (default: false).\nname: Handles the creation of string names (default: false).\nverbose: Controls the output display, ranging from silent mode (0) to detailed output (3).\n\nReturns\n\nThe function returns an instance of the PmuPlacement type.\n\nNote that if a PMU is understood as a device that measures the bus voltage phasor and all branch current phasors incident to the bus, users only need the results stored in the bus variable. However, if a PMU is considered to measure individual phasor, then all required phasor measurements can be found in the bus, from, and to variables.\n\nExample\n\nusing HiGHS, Ipopt\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis; current = true)\n\nplacement = pmuPlacement(system, HiGHS.Optimizer)\n\n@pmu(label = \"PMU ?: !\")\nfor (bus, i) in placement.bus\n    Vi, θi = analysis.voltage.magnitude[i], analysis.voltage.angle[i]\n    addPmu!(monitoring; bus = bus, magnitude = Vi, angle = θi)\nend\nfor branch in keys(placement.from)\n    Iij, ψij = fromCurrent(analysis; label = branch)\n    addPmu!(monitoring; from = branch, magnitude = Iij, angle = ψij)\nend\nfor branch in keys(placement.to)\n    Iji, ψji = toCurrent(analysis; label = branch)\n    addPmu!(monitoring; to = branch, magnitude = Iji, angle = ψji)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.pmuPlacement!","page":"State Estimation","title":"JuliaGrid.pmuPlacement!","text":"pmuPlacement!(monitoring::Measurement, analysis::AC, optimizer;\n    varianceMagnitudeBus, varianceAngleBus,\n    varianceMagnitudeFrom, varianceAngleFrom,\n    varianceMagnitudeTo, varianceAngleTo,\n    noise, correlated, polar,\n    bridge, name, verbose)\n\nThe function finds the optimal PMU placement by executing pmuPlacement function. Then, based on the results from the AC type, it generates phasor measurements and integrates them into the Measurement type. If current values are missing in the AC type, the function calculates the associated currents required to form measurement values.\n\nKeywords\n\nPMUs at the buses can be configured using:\n\nvarianceMagnitudeBus (pu or V): Variance of bus voltage magnitude measurements.\nvarianceAngleBus (rad or deg): Variance of bus voltage angle measurements.\n\nPMUs at the from-bus ends of the branches can be configured using:\n\nvarianceMagnitudeFrom (pu or A): Variance of current magnitude measurements.\nvarianceAngleFrom (rad or deg): Variance of current angle measurements.\n\nPMUs at the to-bus ends of the branches can be configured using:\n\nvarianceMagnitudeTo (pu or A): Variance of current magnitude measurements.\nvarianceAngleTo (rad or deg): Variance of current angle measurements.\n\nSettings for generating measurements include:\n\nnoise: Defines the method for generating the measurement means:\nnoise = true: adds white Gaussian noise to the phasor values, using the defined variances,\nnoise = false: uses the exact phasor values without adding noise.\n\nSettings for handling phasor measurements include:\n\ncorrelated: Specifies error correlation for PMUs for algorithms utilizing rectangular coordinates:\ncorrelated = true: considers correlated errors,\ncorrelated = false: disregards correlations between errors.\npolar: Chooses the coordinate system for including phasor measurements in AC state estimation:\npolar = true: adopts the polar coordinate system,\npolar = false: adopts the rectangular coordinate system.\n\nSettings for the optimization solver include:\n\nbridge: Controls the bridging mechanism (default: false).\nname: Handles the creation of string names (default: false).\nverbose: Controls the output display, ranging from silent mode (0) to detailed output (3).\n\nUpdates\n\nThe function updates the pmu field of the Measurement type.\n\nReturns\n\nThe function returns an instance of the PmuPlacement type.\n\nExample\n\nusing HiGHS, Ipopt\n\nsystem, monitoring = ems(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis; current = true)\n\npmuPlacement!(monitoring, analysis, HiGHS.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"api/stateEstimation/#AC-State-Estimation-2","page":"State Estimation","title":"AC State Estimation","text":"","category":"section"},{"location":"api/stateEstimation/#JuliaGrid.gaussNewton","page":"State Estimation","title":"JuliaGrid.gaussNewton","text":"gaussNewton(monitoring::Measurement, [method = LU])\n\nThe function sets up the Gauss-Newton method to solve the nonlinear or AC state estimation model, where the vector of state variables is given in polar coordinates. The Gauss-Newton method throughout iterations provided WLS estimator.\n\nArguments\n\nThis function requires the Measurement type to establish the WLS state estimation framework.\n\nMoreover, the presence of the method parameter is not mandatory. To address the WLS state estimation method, users can opt to utilize factorization techniques to decompose the gain matrix, such as LU, QR, or LDLt especially when the gain matrix is symmetric. For improved robustness in cases with ill-conditioned data or significant variance disparities, using the Orthogonal or PetersWilkinson method is recommended.\n\nIf the user does not provide the method, the default method for solving the estimation model will be LU factorization.\n\nUpdates\n\nIf the AC model has not been created, the function will automatically trigger an update of the ac field within the PowerSystem type.\n\nReturns\n\nThe function returns an instance of the AcStateEstimation type.\n\nExamples\n\nSet up the AC state estimation model to be solved using the default LU factorization:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\n\nSet up the AC state estimation model to be solved using the orthogonal method:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring, Orthogonal)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.acLavStateEstimation","page":"State Estimation","title":"JuliaGrid.acLavStateEstimation","text":"acLavStateEstimation(monitoring::Measurement, optimizer;\n    iteration, tolerance, bridge, name, magnitude, angle, positive, negative, verbose)\n\nThe function sets up the LAV method to solve the nonlinear or AC state estimation model, where the vector of state variables is given in polar coordinates.\n\nArguments\n\nThis function requires the Measurement type to establish the LAV state estimation model. The LAV method offers increased robustness compared to WLS, ensuring unbiasedness even in the presence of various measurement errors and outliers.\n\nUsers can employ the LAV method to find an estimator by choosing one of the available optimization solvers. Typically, Ipopt suffices for most scenarios.\n\nKeywords\n\nThe function accepts the following keywords:\n\niteration: Specifies the maximum number of iterations.\ntolerance: Specifies the allowed deviation from the optimal solution.\nbridge: Controls the bridging mechanism (default: false).\nname: Handles the creation of string names (default: true).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nAdditionally, users can modify variable names used for printing and writing through the keywords magnitude, angle, positive, and negative. For instance, users can choose magnitude = \"V\", angle = \"θ\", positive = \"u\", and negative = \"v\" to display equations in a more readable format.\n\nUpdates\n\nIf the AC model has not been created, the function will automatically trigger an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the AcStateEstimation type.\n\nExample\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = acLavStateEstimation(monitoring, Ipopt.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.increment!","page":"State Estimation","title":"JuliaGrid.increment!","text":"increment!(analysis::AcStateEstimation)\n\nBy solving the normal equation, this function computes the bus voltage magnitude and angle increments.\n\nUpdates\n\nThe function updates the residual, jacobian, and factorisation variables within the AcStateEstimation type. Using these results, it then computes and updates the increment variable within the same type. It should be used during the Gauss-Newton iteration loop before invoking the solve! function.\n\nReturns\n\nThe function returns the maximum absolute increment value, which can be used to terminate the iteration loop of the Gauss-Newton method applied to solve the AC state estimation problem.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nincrement!(analysis)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.solve!-Union{Tuple{AcStateEstimation{GaussNewton{T}}}, Tuple{T}} where T<:WlsMethod","page":"State Estimation","title":"JuliaGrid.solve!","text":"solve!(analysis::AcStateEstimation)\n\nBy computing the bus voltage magnitudes and angles, the function solves the AC state estimation. Note that if the Gauss-Newton method is employed to obtain the WLS estimator, this function simply updates the state variables using the obtained increments.\n\nUpdates\n\nThe resulting bus voltage magnitudes and angles are stored in the voltage field of the AcStateEstimation type.\n\nExamples\n\nSolving the AC state estimation model and obtaining the WLS estimator:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nfor iteration = 1:20\n    stopping = increment!(analysis)\n    if stopping < 1e-8\n        break\n    end\n    solve!(analysis)\nend\n\nSolving the AC state estimation model and obtaining the LAV estimator:\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = acLavStateEstimation(monitoring, Ipopt.Optimizer; verbose = 1)\nsolve!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/#JuliaGrid.setInitialPoint!-Tuple{AcStateEstimation}","page":"State Estimation","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(analysis::AcStateEstimation)\n\nThe function sets the initial point of the AC state estimation to the values from the PowerSystem type.\n\nUpdates\n\nThe function modifies the voltage field of the AcStateEstimation type.\n\nExample:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nresidualTest!(analysis; threshold = 1.0)\n\nsetInitialPoint!(analysis)\nstateEstimation!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/#JuliaGrid.setInitialPoint!-Tuple{AcStateEstimation, AC}","page":"State Estimation","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(target::AcStateEstimation, source::Analysis)\n\nThe function initializes the AC state estimation based on results from the Analysis type, whether from an AC or DC analysis.\n\nThe function assigns the bus voltage magnitudes and angles in the target argument, using data from the source argument. This allows users to initialize AC state estimation as needed.\n\nIf source comes from a DC analysis, only the bus voltage angles are assigned in the target argument, while the bus voltage magnitudes remain unchanged.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nsource = newtonRaphson(system)\npowerFlow!(source)\n\ntarget = gaussNewton(monitoring)\n\nsetInitialPoint!(target, source)\nstateEstimation!(target)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{AcStateEstimation{GaussNewton{T}}}, Tuple{T}} where T<:WlsMethod","page":"State Estimation","title":"JuliaGrid.stateEstimation!","text":"stateEstimation!(analysis::AcStateEstimation;\n    iteration, tolerance, power, current, verbose)\n\nThe function serves as a wrapper for solving AC state estimation and includes the functions:\n\nsolve!,\npower!,\ncurrent!.\n\nAdditionally, for the WLS model, it includes:\n\nincrement!.\n\nIt computes bus voltage magnitudes and angles using the WLS or LAV model with the option to compute powers and currents.\n\nKeywords\n\nUsers can use the following keywords:\n\niteration: Specifies the maximum number of iterations (default for WLS model: 40).\ntolerance: Defines the tolerance for the iteration stopping criterion (default for WLS model: 1e-8).\npower: Enables the computation of powers (default: false).\ncurrent: Enables the computation of currents (default: false).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nFor the WLS model, tolerance refers to the step size tolerance in the stopping criterion, whereas for the LAV model, it defines the allowed deviation from the optimal solution. If iteration and tolerance are not specified for the LAV model, the optimization solver settings are used.\n\nExamples\n\nUse the wrapper function to obtain the WLS estimator:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; tolerance = 1e-10, current = true, verbose = 3)\n\nUse the wrapper function to obtain the LAV estimator:\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = acLavStateEstimation(monitoring, Ipopt.Optimizer)\nstateEstimation!(analysis; iteration = 30, power = true, verbose = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"api/stateEstimation/#PMU-State-Estimation-2","page":"State Estimation","title":"PMU State Estimation","text":"","category":"section"},{"location":"api/stateEstimation/#JuliaGrid.pmuStateEstimation","page":"State Estimation","title":"JuliaGrid.pmuStateEstimation","text":"pmuStateEstimation(monitoring::Measurement, [method = LU])\n\nThe function establishes the linear WLS model for state estimation with PMUs only. In this model, the vector of state variables contains bus voltages, given in rectangular coordinates.\n\nArguments\n\nThis function requires the Measurement type to establish the WLS state estimation model.\n\nMoreover, the presence of the method parameter is not mandatory. To address the WLS state estimation method, users can opt to utilize factorization techniques to decompose the gain matrix, such as LU, QR, or LDLt especially when the gain matrix is symmetric. For improved robustness in cases with ill-conditioned data or significant variance disparities, using the Orthogonal or PetersWilkinson method is recommended.\n\nIf the user does not provide the method, the default method for solving the estimation model will be LU factorization.\n\nUpdates\n\nIf the AC model has not been created, the function will automatically trigger an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the PmuStateEstimation type.\n\nExamples\n\nSet up the PMU state estimation model to be solved using the default LU factorization:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = pmuStateEstimation(monitoring)\n\nSet up the PMU state estimation model to be solved using the orthogonal method:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = pmuStateEstimation(monitoring, Orthogonal)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.pmuLavStateEstimation","page":"State Estimation","title":"JuliaGrid.pmuLavStateEstimation","text":"pmuLavStateEstimation(monitoring::Measurement, optimizer;\n    iteration, tolerance, bridge, name, real, imag, positive, negative, verbose)\n\nThe function establishes the LAV model for state estimation with PMUs only. In this model, the vector of state variables contains bus voltages, given in rectangular coordinates.\n\nArguments\n\nThis function requires the Measurement type to establish the LAV state estimation model. The LAV method offers increased robustness compared to WLS, ensuring unbiasedness even in the presence of various measurement errors and outliers.\n\nUsers can employ the LAV method to find an estimator by choosing one of the available optimization solvers. Typically, Ipopt suffices for most scenarios.\n\nKeywords\n\nThe function accepts the following keywords:\n\niteration: Specifies the maximum number of iterations.\ntolerance: Specifies the allowed deviation from the optimal solution.\nbridge: Controls the bridging mechanism (default: false).\nname: Handles the creation of string names (default: true).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nAdditionally, users can modify variable names used for printing and writing through the keywords real, imag, positive, and negative. For instance, users can choose real = \"Vr\", imag = \"Vi\", positive = \"u\", and negative = \"v\" to display equations in a more readable format.\n\nUpdates\n\nIf the AC model has not been created, the function will automatically trigger an update of the ac field within the PowerSystem composite type.\n\nReturns\n\nThe function returns an instance of the PmuStateEstimation type.\n\nExample\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = pmuLavStateEstimation(monitoring, Ipopt.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.solve!-Tuple{PmuStateEstimation{WLS{Normal}}}","page":"State Estimation","title":"JuliaGrid.solve!","text":"solve!(analysis::PmuStateEstimation)\n\nBy computing the bus voltage magnitudes and angles, the function solves the PMU state estimation model.\n\nUpdates\n\nThe resulting bus voltage magnitudes and angles are stored in the voltage field of the PmuStateEstimation type.\n\nExamples\n\nSolving the PMU state estimation model and obtaining the WLS estimator:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = pmuStateEstimation(monitoring)\nsolve!(analysis)\n\nSolving the PMU state estimation model and obtaining the LAV estimator:\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = pmuLavStateEstimation(monitoring, Ipopt.Optimizer; verbose = 1)\nsolve!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{PmuStateEstimation{WLS{T}}}, Tuple{T}} where T<:WlsMethod","page":"State Estimation","title":"JuliaGrid.stateEstimation!","text":"stateEstimation!(analysis::PmuStateEstimation; iteration, tolerance, power, verbose)\n\nThe function serves as a wrapper for solving PMU state estimation and includes the functions:\n\nsolve!,\npower!,\ncurrent!.\n\nIt computes bus voltage magnitudes and angles using the WLS or LAV model with the option to compute powers and currents.\n\nKeywords\n\nUsers can use the following keywords:\n\niteration: Specifies the maximum number of iterations for the LAV model.\ntolerance: Specifies the allowed deviation from the optimal solution for the LAV model.\npower: Enables the computation of powers (default: false).\ncurrent: Enables the computation of currents (default: false).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nIf iteration and tolerance are not specified, the optimization solver settings are used.\n\nExamples\n\nUse the wrapper function to obtain the WLS estimator:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis; power = true, verbose = 3)\n\nUse the wrapper function to obtain the LAV estimator:\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = pmuLavStateEstimation(monitoring, Ipopt.Optimizer)\nstateEstimation!(analysis; iteration = 30, tolerance = 1e-6, verbose = 3)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"api/stateEstimation/#DC-State-Estimation-2","page":"State Estimation","title":"DC State Estimation","text":"","category":"section"},{"location":"api/stateEstimation/#JuliaGrid.dcStateEstimation","page":"State Estimation","title":"JuliaGrid.dcStateEstimation","text":"dcStateEstimation(monitoring::Measurement, [method = LU])\n\nThe function establishes the WLS model for DC state estimation, where the vector of state variables contains only bus voltage angles.\n\nArguments\n\nThis function requires the Measurement type to establish the WLS state estimation model.\n\nMoreover, the presence of the method parameter is not mandatory. To address the WLS state estimation method, users can opt to utilize factorization techniques to decompose the gain matrix, such as LU, QR, or LDLt especially when the gain matrix is symmetric. For improved robustness in cases with ill-conditioned data or significant variance disparities, using the Orthogonal or PetersWilkinson method is recommended.\n\nIf the user does not provide the method, the default method for solving the estimation model will be LU factorization.\n\nUpdates\n\nIf the DC model was not created, the function will automatically initiate an update of the dc field within the PowerSystem composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.\n\nReturns\n\nThe function returns an instance of the DcStateEstimation type.\n\nExamples\n\nSet up the DC state estimation model to be solved using the default LU factorization:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcStateEstimation(monitoring)\n\nSet up the DC state estimation model to be solved using the orthogonal method:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcStateEstimation(monitoring, Orthogonal)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.dcLavStateEstimation","page":"State Estimation","title":"JuliaGrid.dcLavStateEstimation","text":"dcLavStateEstimation(monitoring::Measurement, optimizer;\n    iteration, tolerance, bridge, name, angle, positive, negative, verbose)\n\nThe function establishes the LAV model for DC state estimation, where the vector of state variables contains only bus voltage angles.\n\nArguments\n\nThis function requires the Measurement type to establish the LAV state estimation model. The LAV method offers increased robustness compared to WLS, ensuring unbiasedness even in the presence of various measurement errors and outliers.\n\nUsers can employ the LAV method to find an estimator by choosing one of the available optimization solvers. Typically, Ipopt suffices for most scenarios.\n\nKeywords\n\nThe function accepts the following keywords:\n\niteration: Specifies the maximum number of iterations.\ntolerance: Specifies the allowed deviation from the optimal solution.\nbridge: Controls the bridging mechanism (default: false).\nname: Handles the creation of string names (default: true).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nAdditionally, users can modify variable names used for printing and writing through the keywords angle, positive, and negative. For instance, users can choose angle = \"θ\", positive = \"u\", and negative = \"v\" to display equations in a more readable format.\n\nUpdates\n\nIf the DC model was not created, the function will automatically initiate an update of the dc field within the PowerSystem composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.\n\nReturns\n\nThe function returns an instance of the DcStateEstimation type.\n\nExample\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.solve!-Tuple{DcStateEstimation{WLS{Normal}}}","page":"State Estimation","title":"JuliaGrid.solve!","text":"solve!(analysis::DcStateEstimation)\n\nBy computing the bus voltage angles, the function solves the DC state estimation model.\n\nUpdates\n\nThe resulting bus voltage angles are stored in the voltage field of the DcStateEstimation type.\n\nExamples\n\nSolving the DC state estimation model and obtaining the WLS estimator:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcStateEstimation(monitoring)\nsolve!(analysis)\n\nSolving the DC state estimation model and obtaining the LAV estimator:\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer; verbose = 1)\nsolve!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/#JuliaGrid.stateEstimation!-Union{Tuple{DcStateEstimation{WLS{T}}}, Tuple{T}} where T<:WlsMethod","page":"State Estimation","title":"JuliaGrid.stateEstimation!","text":"stateEstimation!(analysis::DcStateEstimation; iteration, tolerance, power, verbose)\n\nThe function serves as a wrapper for solving DC state estimation and includes the functions:\n\nsolve!,\npower!.\n\nIt computes bus voltage angles using the WLS or LAV model with the option to compute powers.\n\nKeywords\n\nUsers can use the following keywords:\n\niteration: Specifies the maximum number of iterations for the LAV model.\ntolerance: Specifies the allowed deviation from the optimal solution for the LAV model.\npower: Enables the computation of powers (default: false).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nIf iteration and tolerance are not specified, the optimization solver settings are used.\n\nExamples\n\nUse the wrapper function to obtain the WLS estimator:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis; power = true, verbose = 3)\n\nUse the wrapper function to obtain the LAV estimator:\n\nusing Ipopt\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer)\nstateEstimation!(analysis; iteration = 30, tolerance = 1e-6, verbose = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/stateEstimation/","page":"State Estimation","title":"State Estimation","text":"","category":"page"},{"location":"api/stateEstimation/#Bad-Data-Analysis-2","page":"State Estimation","title":"Bad Data Analysis","text":"","category":"section"},{"location":"api/stateEstimation/#JuliaGrid.chiTest","page":"State Estimation","title":"JuliaGrid.chiTest","text":"chiTest(analysis::StateEstimation; confidence)\n\nThe function performs a Chi-squared bad data detection test. This test can be applied after obtaining WLS estimator.\n\nArguments\n\nThe abstract type StateEstimation can have the following subtypes:\n\nAcStateEstimation: Conducts bad data analysis within AC state estimation.\nPmuStateEstimation: Conducts bad data analysis within PMU state estimation.\nDcStateEstimation: Conducts bad data analysis within DC state estimation.\n\nKeyword\n\nThe keyword confidence specifies the detection confidence level, with a default value of 0.95.\n\nReturns\n\nThe function returns an instance of the ChiTest type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nbad = chiTest(analysis; confidence = 0.96)\n\n\n\n\n\n","category":"function"},{"location":"api/stateEstimation/#JuliaGrid.residualTest!","page":"State Estimation","title":"JuliaGrid.residualTest!","text":"residualTest!(analysis::StateEstimation; threshold)\n\nThe function conducts bad data detection and identification using the largest normalized residual test, subsequently removing measurement outliers from the measurement set. It can be executed after obtaining WLS estimator.\n\nArguments\n\nThe abstract type StateEstimation can have the following subtypes:\n\nAcStateEstimation: Conducts bad data analysis within AC state estimation.\nPmuStateEstimation: Conducts bad data analysis within PMU state estimation.\nDcStateEstimation: Conducts bad data analysis within DC state estimation.\n\nKeyword\n\nThe keyword threshold establishes the identification threshold. If the largest normalized residual surpasses this threshold, the measurement is flagged as bad data. The default threshold value is set to threshold = 3.0.\n\nUpdates\n\nIf bad data is detected, the function flags the corresponding measurement within the Measurement type as out-of-service.\n\nMoreover, for DcStateEstimation and PmuStateEstimation types, the function removes the corresponding measurement from the coefficient matrix and mean vector. This facilitates direct progress to the function that solves the state estimation problem.\n\nReturns\n\nThe function returns an instance of the ResidualTest type.\n\nExample\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis)\n\noutlier = residualTest!(analysis; threshold = 4.0)\nstateEstimation!(analysis)\n\n\n\n\n\n","category":"function"},{"location":"examples/dcOptimalPowerFlow/#DCOptimalPowerFlowExamples","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"This example utilizes the power system shown in Figure 1. Similar to the AC optimal power flow, we adjust constraints and modify the topology to highlight JuliaGrid’s ability to efficiently handle such scenarios.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/acOptimalPowerFlow//4bus.svg\" width=\"400\" class=\"my-svg\"/>\n    <p>Figure 1: The 4-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We start by defining the unit system. Since DC optimal power flow considers only active powers and voltage angles, we specify the relevant units:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using JuliaGrid, Ipopt, JuMP # hide\n@default(template) # hide\n@default(unit) # hide\n\n@power(MW, pu)\n@voltage(pu, deg)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, we define bus parameters for the analysis. This includes setting the slack bus (type = 3), where the voltage angle is fixed at zero, and specifying active power loads and shunt elements with conductance values. With these definitions, we construct the power system model:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", active = 20.2)\naddBus!(system; label = \"Bus 3\", conductance = 0.1)\naddBus!(system; label = \"Bus 4\", active = 50.8)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We then define transmission line parameters by specifying reactance values. For phase-shifting transformer, we include the shift angle using the shiftAngle keyword. Additionally, we set bus voltage angle difference constraints between the from-bus and to-bus ends of each branch using minDiffAngle and maxDiffAngle keywords:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@branch(reactance = 0.2, minDiffAngle = -4.1, maxDiffAngle = 4.1)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 3\")\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\")\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\")\naddBranch!(system; label = \"Branch 4\", from = \"Bus 3\", to = \"Bus 4\", shiftAngle = -2.3)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"At this stage, no active power flow constraints are imposed, but they will be introduced later in the example.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, we define the active power outputs of the generators, which serve as initial values for the optimization variables. Generator outputs are constrained using minActive and maxActive keywords:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@generator(label = \"Generator ?\")\naddGenerator!(system; bus = \"Bus 1\", active = 63.1, minActive = 10.0, maxActive = 65.5)\naddGenerator!(system; bus = \"Bus 2\", active = 3.0, minActive = 7.0, maxActive = 20.5)\naddGenerator!(system; bus = \"Bus 2\", active = 4.1, minActive = 7.0, maxActive = 22.4)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Finally, we define the active power supply costs of the generators in polynomial form by setting active = 2. Then, we express the polynomial as a quadratic using the polynomial keyword:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"cost!(system; generator = \"Generator 1\", active = 2, polynomial = [0.04; 20.0; 0.0])\ncost!(system; generator = \"Generator 2\", active = 2, polynomial = [1.00; 20.0; 0.0])\ncost!(system; generator = \"Generator 3\", active = 2, polynomial = [1.00; 20.0; 0.0])\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Once the power system data is defined, we generate a DC model that includes key matrices and vectors for analysis, such as the nodal admittance matrix:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"examples/dcOptimalPowerFlow/#Display-Data-Settings","page":"DC Optimal Power Flow","title":"Display Data Settings","text":"","category":"section"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Before running simulations, we configure the numeric format for specific data type of interest including active power flow at branches and generator outputs:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"fmt = Dict(\"From-Bus Power\" => \"%.2f\", \"To-Bus Power\" => \"%.2f\", \"Power Output\" => \"%.2f\")\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"examples/dcOptimalPowerFlow/#Base-Case-Analysis","page":"DC Optimal Power Flow","title":"Base Case Analysis","text":"","category":"section"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The process starts by formulating the DC optimal power flow model and selecting the Ipopt solver. The optimization variables include bus voltage angles and generator active power outputs, denoted as θ and Pg:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer; angle = \"θ\", active = \"Pg\")\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The optimization problem being solved can then be printed:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.method.jump)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Solving the DC optimal power flow model provides the bus voltage angles and generator active power outputs. Then, active powers across buses and branches are computed:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!(analysis; power = true, verbose = 1)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution, bus-related results, including the optimal bus voltage angles, are examined:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBusData(analysis)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We observe that the voltage angle difference constraint at Branch 1 reaches its upper limit. This can also be confirmed by examining the branch constraint data, where the associated dual variable takes a nonzero value:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBranchConstraint(analysis; label = \"Branch 1\", header = true, footer = true)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The optimal active power outputs of the generators are:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printGeneratorData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"All generators operate within their active power limits, as confirmed by the generator constraint data, where all dual variables remain zero:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printGeneratorConstraint(analysis)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Furthermore, Generator 1, with the lowest cost, supplies most of the power, while Generator 2 and Generator 3 produce equal power amounts due to identical cost functions.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Finally, we review the results related to branch flows:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBranchData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Thus, we obtained the active power flows, as illustrated in Figure 2.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcOptimalPowerFlow/4bus_base.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 2: Active power flows in the 4-bus power system for the base case scenario.</p>\n</div>","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"examples/dcOptimalPowerFlow/#Modifying-Demands","page":"DC Optimal Power Flow","title":"Modifying Demands","text":"","category":"section"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Let us now introduce a new state by updating the active power demands of consumers. These updates modify both the power system model and the DC optimal power flow model simultaneously:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", active = 25.2)\nupdateBus!(analysis; label = \"Bus 4\", active = 43.3)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, we solve the DC optimal power flow again to compute the new solution without recreating the model. This step enables a warm start, as the initial primal and dual values correspond to those obtained in the base case:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Now, we observe the power output of the generators:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printGeneratorData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Compared to the base case, Generator 1 increases output, while Generator 2 and Generator 3 reduce production to their minimum limits. Meanwhile, all voltage angle difference constraints remain within limits:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBranchConstraint(analysis)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"At the end of this scenario, we can review branch-related results for a more comprehensive insight into power flows:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBranchData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The obtained results allow us to illustrate the active power flows in Figure 3.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcOptimalPowerFlow/4bus_demand.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 3: Active power flows in the 4-bus power system with modified demands.</p>\n</div>","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"examples/dcOptimalPowerFlow/#Modifying-Generator-Costs","page":"DC Optimal Power Flow","title":"Modifying Generator Costs","text":"","category":"section"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We adjust the cost functions for Generator 1 and Generator 3, making Generator 1 the highest-cost generator and Generator 3 the lowest-cost one in the system. By updating both the power system model and the DC optimal power flow model simultaneously, we enable a warm start for solving this new scenario:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"cost!(analysis; generator = \"Generator 1\", active = 2, polynomial = [2.0; 40.0; 0.0])\ncost!(analysis; generator = \"Generator 3\", active = 2, polynomial = [0.5; 10.0; 0.0])\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, we solve the updated problem and calculate the resulting powers:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The optimal active power outputs of the generators are as follows:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printGeneratorData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In this scenario, we observe that, due to the higher cost of Generator 1, its output decreases, while the outputs of Generator 2 and Generator 3 increase. Notably, Generator 3 now produces a higher amount of power compared to Generator 2 due to its lower cost. While one might expect Generator 1 to decrease supplies more drastically and Generator 3 to increase more dramatically, this is not the case due to the need to satisfy other constraints, such as active power balance at each bus.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We can also review the results related to branches for this scenario:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBranchData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Figure 4 illustrates the power flows for this scenario. Compared to the previous scenario, Figure 4 shows that Branch 2 has significantly lower active power flow, while Branch 3 has become considerably more loaded.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcOptimalPowerFlow/4bus_cost.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 4: Active power flows in the 4-bus power system with modified generator costs.</p>\n</div>","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"examples/dcOptimalPowerFlow/#Adding-Branch-Flow-Constraints","page":"DC Optimal Power Flow","title":"Adding Branch Flow Constraints","text":"","category":"section"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To limit active power flow, we introduce constraints on Branch 2 and Branch 3 by setting type = 1, where the active power flow at the from-bus end of these branches is limited using the maxFromBus keyword:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBranch!(analysis; label = \"Branch 2\", type = 1, maxFromBus = 15.0)\nupdateBranch!(analysis; label = \"Branch 3\", type = 1, maxFromBus = 15.0)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, we recalculate the DC optimal power flow:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Now, let us observe the generator outputs:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printGeneratorData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The power flow limit at Branch 3 forces Generator 1 to increase its active power output despite its higher cost compared to Generator 2 and Generator 3, due to the need to satisfy all constraints.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We can review the branch data and observe that the active power at the from-bus end of Branch 3 reaches the defined limit, while the power flow at Branch 2 stays within the specified limits:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBranchData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Based on the obtained results, we can illustrate the power flows in Figure 5.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcOptimalPowerFlow/4bus_flow.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 5: Active power flows in the 4-bus power system with added branch flow constraints.</p>\n</div>","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"examples/dcOptimalPowerFlow/#Modifying-Network-Topology","page":"DC Optimal Power Flow","title":"Modifying Network Topology","text":"","category":"section"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"At the end, we set Branch 2 out-of-service:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBranch!(analysis; label = \"Branch 2\", status = 0)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We then recalculate the DC optimal power flow:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We can now observe the updated generator outputs:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printGeneratorData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Due to the outage of Branch 2 and the flow limit at Branch 3, Generator 1 faces difficulties supplying load at Bus 2, reducing its output. Consequently, the only solution is to increase the output of Generator 2 and Generator 3.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Upon reviewing the branch data, we observe that the active power flows in the remaining in-service branches remain largely unchanged. This is because, following the outage of Branch 2, Generator 2 and Generator 3 have taken over the responsibility of supplying the load at Bus 2, effectively displacing Generator 1:","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBranchData(analysis; fmt)","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Figure 6 illustrates these results under the outage of Branch 2.","category":"page"},{"location":"examples/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcOptimalPowerFlow/4bus_service.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 6: Active power flows in the 4-bus power system with modified network topology.</p>\n</div>","category":"page"},{"location":"examples/dcPowerFlow/#ACPowerFlowExamples","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"DC power flow provides an approximate solution compared to AC power flow. We use the same power system model as in the AC power flow analysis, shown in Figure 1, to perform several DC power flow simulations. These simulations represent quasi-steady-state conditions where the system undergoes parameter and topology changes.","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/acPowerFlow/4bus.svg\" width=\"400\" class=\"my-svg\"/>\n    <p>Figure 1: The 4-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"We begin by defining the unit system. For DC power flow, only active power and voltage angle units are relevant:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(template) # hide\n@default(unit) # hide\n\n@power(MW, pu)\n@voltage(pu, deg)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, we define the bus parameters for DC power flow analysis. This includes specifying the slack bus as type = 3, the connected active power loads, and shunt elements with conductance values. The voltage angle at the slack bus is fixed to the specified value. With these definitions, we can build the power system model:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, angle = 0.0)\naddBus!(system; label = \"Bus 2\", active = 20.2)\naddBus!(system; label = \"Bus 3\", conductance = 0.1)\naddBus!(system; label = \"Bus 4\", active = 50.8)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, we define the transmission line parameters by specifying reactance values. For phase-shifting transformers, we include the shift angle using the shiftAngle keyword:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"@branch(reactance = 0.22)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 3\")\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\")\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\")\naddBranch!(system; label = \"Branch 4\", from = \"Bus 3\", to = \"Bus 4\", shiftAngle = -2.3)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, we define the active power outputs of the generators:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"addGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 60.1)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 18.2)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Once the power system data is defined, we generate a DC model that includes key vectors and matrices for analysis, such as the nodal admittance matrix. This model is automatically updated when data changes and can be shared across different analyses:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"examples/dcPowerFlow/#Display-Data-Settings","page":"DC Power Flow","title":"Display Data Settings","text":"","category":"section"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To follow the successful solving of the DC power flow, we set verbose to basic output (1):","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"@config(verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"examples/dcPowerFlow/#Base-Case-Analysis","page":"DC Power Flow","title":"Base Case Analysis","text":"","category":"section"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"At the start, we create a DC power flow model, then compute bus voltage angles and active powers:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis = dcPowerFlow(system)\npowerFlow!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Once the DC power flow is solved, we can analyze the bus-related results:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"printBusData(analysis)","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Similarly, the results for the branches are:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"printBranchData(analysis)","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Thus, using bus and branch data, we obtained the active power flows, as illustrated in Figure 2.","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcPowerFlow/4bus_base.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 2: Active power flows in the 4-bus power system for the base case scenario.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Note that the active power at the from-bus and to-bus ends of a branch is the same because the DC power flow model neglects losses.","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"examples/dcPowerFlow/#Modifying-Supplies-and-Demands","page":"DC Power Flow","title":"Modifying Supplies and Demands","text":"","category":"section"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"We will adjust the active power outputs of generators and the active power demands of consumers. Instead of creating a new power system model or simply updating the existing one, we update both the power system and DC power flow models simultaneously:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", active = 25.5)\nupdateBus!(analysis; label = \"Bus 4\", active = 42.0)\n\nupdateGenerator!(analysis; label = \"Generator 1\", active = 58.0)\nupdateGenerator!(analysis; label = \"Generator 2\", active = 23.0)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, we solve the DC power flow again to compute the new state of the power system without recreating the DC power flow model:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"powerFlow!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Since no modifications were made that affect the nodal admittance matrix, JuliaGrid reuses its factorization from the base case analysis, significantly reducing computational complexity.","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, we display the updated branch data:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"printBranchData(analysis)","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Compared to the base case, the directions of power flows remain unchanged, but the amounts of active power differ, as shown in Figure 3.","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcPowerFlow/4bus_power.svg\" width=\"400\" class=\"my-svg\"/>\n    <p>Figure 3: Active power flows in the 4-bus power system with modified supplies and demands.</p>\n</div>","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"examples/dcPowerFlow/#Modifying-Network-Topology","page":"DC Power Flow","title":"Modifying Network Topology","text":"","category":"section"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Now, we take Branch 3 out-of-service while updating both the power system and DC power flow models:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateBranch!(analysis; label = \"Branch 3\", status = 0)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"We then solve the DC power flow for this scenario:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"powerFlow!(analysis; power = true)\nnothing # hide","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To analyze how active power flows redistribute when a branch is out of service, we use:","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"printBranchData(analysis)","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, Figure 4 illustrates the active power flows in the case of a Branch 3 outage.","category":"page"},{"location":"examples/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/dcPowerFlow/4bus_service.svg\" width=\"400\" class=\"my-svg\"/>\n    <p>Figure 4: Active power flows in the 4-bus power system with modified network topology.</p>\n</div>","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerFlowManual","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similar to AC Optimal Power Flow, JuliaGrid utilizes the JuMP package to construct optimal power flow models, enabling users to manipulate these models using the standard functions provided by JuMP. JuliaGrid supports popular solvers mentioned in the JuMP documentation to solve the optimization problem.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To perform the DC optimal power flow, we first need to have the PowerSystem type that has been created with the DC model. After that, create the DcOptimalPowerFlow type to establish the DC optimal power flow framework using the function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"dcOptimalPowerFlow.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To solve the DC optimal power flow problem and acquire generator active power outputs and bus voltage angles, users can use of the following function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"solve!.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After solving the DC optimal power flow, JuliaGrid provides function for computing powers:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"power!.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Alternatively, instead of using functions responsible for solving optimal power flow and computing powers, users can use the wrapper function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can also access specialized functions for computing specific types of powers for individual buses, branches, or generators within the power system.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerFlowModelManual","page":"DC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To set up the DC optimal power flow, we begin by creating the model. To illustrate this, consider the following:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, Ipopt\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, angle = 0.17)\naddBus!(system; label = \"Bus 2\", active = 0.1, conductance = 0.04)\naddBus!(system; label = \"Bus 3\", active = 0.05)\n\n@branch(minDiffAngle = -3.1, maxDiffAngle = 3.1, minFromBus = -0.12, maxFromBus = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\n@generator(minActive = 0.0)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.6, maxActive = 0.8)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.1, maxActive = 0.3)\naddGenerator!(system; label = \"Generator 3\", bus = \"Bus 2\", active = 0.2, maxActive = 0.4)\n\ncost!(system; generator = \"Generator 1\", active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; generator = \"Generator 2\", active = 1, piecewise = [8.0 11.0; 14.0 17.0])\ncost!(system; generator = \"Generator 3\", active = 1, piecewise = [6 12.3; 8.7 16.8; 11 19])\n\ndcModel!(system)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, the dcOptimalPowerFlow function is utilized to formulate the DC optimal power flow problem:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nAll non-box two-sided constraints are modeled as intervals by default. However, users can choose to represent them as two separate constraints, one for the lower bound and one for the upper bound, by setting:analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer; interval = false)Although this approach may be less efficient in terms of model creation and could lead to longer execution times depending on the solver, it allows for precise definition of the starting dual values.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimizationVariablesManual","page":"DC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In DC optimal power flow, generator active power outputs are linear functions of bus voltage angles. Thus, the model's variables include generator active power outputs and bus voltage angles:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.all_variables(analysis.method.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"It is important to highlight that when dealing with piecewise linear cost functions comprising multiple segments, as exemplified in the case of Generator 3, JuliaGrid automatically generates helper optimization variables, such as actwise[3], and formulates a set of linear constraints to appropriately handle these cost functions.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"However, in instances where a piecewise linear cost function consists of only a single segment, as demonstrated by Generator 2, the function is modelled as a standard linear function, eliminating the necessity for additional helper optimization variables.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Please note that JuliaGrid keeps references to all variables categorized into three fields:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"fieldnames(typeof(analysis.method.variable.voltage))\nfieldnames(typeof(analysis.method.variable.power))","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Variable-Names","page":"DC Optimal Power Flow","title":"Variable Names","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users have the option to define custom variable names for printing equations, which can help present them in a more compact form. For example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis = dcOptimalPowerFlow(system, Ipopt.Optimizer; active = \"P\", angle = \"θ\")\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Add-Variables","page":"DC Optimal Power Flow","title":"Add Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Once the DcOptimalPowerFlow type is established, users can add new variables representing generator active power outputs by introducing additional generators. For example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"addGenerator!(analysis; label = \"Generator 4\", bus = \"Bus 1\", active = 0.1, maxActive = 0.2)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"This command adds both a new variable and the corresponding box constraint to the optimization model.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To confirm that the variable has been successfully added, you can use the following function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.is_valid(analysis.method.jump, analysis.method.variable.power.active[4])","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCConstraintFunctionsManual","page":"DC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuliGrid keeps track of all the references to internally formed constraints in the constraint field of the DcOptimalPowerFlow type. These constraints are divided into six fields:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"fieldnames(typeof(analysis.method.constraint))","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"They fall into two main categories: box constraints and non-box constraints.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nWe suggest that readers refer to the tutorial on DC Optimal Power Flow for insights into the implementation.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Box-Constraints","page":"DC Optimal Power Flow","title":"Box Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The slack constraint is represented as an equality tied to the fixed voltage angle at the slack bus.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The capability constraints define variable bounds on active power generation and are always implemented as two separate constraints: one for the lower bound and one for the upper bound. If the bounds are equal or the generator is out-of-service, JuliaGrid models the constraint as an equality instead.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Non-Box-Constraints","page":"DC Optimal Power Flow","title":"Non-Box Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The balance constraints correspond to active power balance equations defined at each bus and are modeled as equality constraints.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The voltage constraints are associated with the minimum and maximum voltage angle difference between the from-bus and to-bus ends of each branch and are modeled as interval constraints by default. If the bounds are equal, an equality constraint is used instead.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The flow constraints, which refer to active power flow limits at the from-bus end of each branch, are also modeled as interval constraints by default. If the bounds are equal, an equality constraint is used.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"If preferred, both voltage and flow constraints can be represented as two separate one-sided constraints, one for the lower and one for the upper bound, by setting the keyword argument interval = false when calling the dcOptimalPowerFlow function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Finally, the piecewise constraints are introduced when piecewise linear cost functions with multiple segments are defined, and they impose only upper bounds.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Slack-Bus-Constraint","page":"DC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The slack field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the addBus! function using the angle keyword:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.slack.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the updateBus! function, for example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBus!(analysis; label = \"Bus 1\", angle = -0.1)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated slack constraint can be inspected as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.slack.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Generator-Active-Power-Capability-Constraints","page":"DC Optimal Power Flow","title":"Generator Active Power Capability Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The capability field contains references to the box inequality constraints associated with the minimum and maximum active power outputs of the generators. These limits are specified using the minActive and maxActive keywords within the addGenerator! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.method.constraint.capability.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Let us now set Generator 2 out of service using the updateGenerator! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateGenerator!(analysis; label = \"Generator 2\", status = 0)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We can now observe that the updated constraints reflect the current state of the system:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.method.constraint.capability.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Bus-Active-Power-Balance-Constraints","page":"DC Optimal Power Flow","title":"Bus Active Power Balance Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The balance field contains references to the equality constraints associated with the active power balance equations defined for each bus. The constant terms in these equations are determined by the active and conductance keywords within the addBus! function. Additionally, if there are phase shift transformers in the system, the constant terms can also be affected by the shiftAngle keyword within the addBranch! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.balance.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system, for example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBus!(analysis; label = \"Bus 3\", active = 0.1)\nupdateGenerator!(analysis; label = \"Generator 2\", status = 1)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated set of active power balance constraints can be examined as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.balance.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Bus-Voltage-Angle-Difference-Constraints","page":"DC Optimal Power Flow","title":"Bus Voltage Angle Difference Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The voltage field contains references to the inequality constraints associated with the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch. These values are specified using the minDiffAngle and maxDiffAngle keywords within the addBranch! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nIf minDiffAngle = -2π and maxDiffAngle = 2π, or both are set to zero for a given branch, JuliaGrid will skip adding the corresponding inequality constraint.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Additionally, by employing the updateBranch! function, we have the ability to modify these constraints as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBranch!(analysis; label = \"Branch 1\", minDiffAngle = -1.7, maxDiffAngle = 1.7)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated set of voltage angle difference constraints can be examined as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Branch-Active-Power-Flow-Constraints","page":"DC Optimal Power Flow","title":"Branch Active Power Flow Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The flow field refers to the inequality constraints associated with active power flow limits at the from-bus end of each branch. These limits are set using the minFromBus and maxFromBus keywords in the addBranch! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.flow.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nIf the branch flow limits are set to minFromBus = 0.0 and maxFromBus = 0.0 for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"By employing the updateBranch! function, we have the ability to modify these specific constraints, for example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateBranch!(analysis; label = \"Branch 1\", status = 0)\nupdateBranch!(analysis; label = \"Branch 2\", reactance = 0.03, maxFromBus = 0.14)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Subsequently, the updated set of active power flow constraints can be examined as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.flow.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Piecewise-Constraints","page":"DC Optimal Power Flow","title":"Active Power Piecewise Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the context of active power modelling, the piecewise field serves as a reference to the inequality constraints related to linear piecewise cost functions. These constraints are created using the cost! function with active = 1 specified when dealing with piecewise linear cost functions comprising multiple segments. JuliaGrid takes care of establishing the appropriate inequality constraints for each segment of the piecewise linear cost:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.method.constraint.piecewise.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"It is worth noting that these constraints can also be automatically updated using the cost! function, and readers can find more details in the section about the objective function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Add-Constraints","page":"DC Optimal Power Flow","title":"Add Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can easily introduce new constraints into the DC optimal power flow by using the addBranch! function. For example, to add a new branch to an existing PowerSystem and corresponding DcOptimalPowerFlow model:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"addBranch!(analysis; label = \"Branch 4\", from = \"Bus 1\", to = \"Bus 2\", reactance = 1)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As a result, the flow constraints will be adjusted as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.flow.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similarly, the addGenerator! function adds both a new variable and its associated box constraint.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Delete-Constraints","page":"DC Optimal Power Flow","title":"Delete Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"When a branch or generator is taken out-of-service, JuliaGrid automatically adjusts the optimization problem to reflect that action, which may include removing certain constraints.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In some cases, it may also be useful to remove specific constraints manually. This can be done using the remove! function by specifying the constraint type: :slack, :capability, :balance, :voltage, :flow or :piecewise.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"For example, to delete the constraint associated with the voltage angle difference at Branch 2, use:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"remove!(analysis, :voltage; label = \"Branch 2\")\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Alternatively, instead of using a label, constraints can also be deleted by index:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"remove!(analysis, :voltage; index = 4)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After these operations, the remaining voltage angle difference constraints can be displayed as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nIn the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCObjectiveFunctionManual","page":"DC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The objective of the DC optimal power flow is constructed using polynomial and piecewise linear cost functions of the generators, which are defined using the cost! functions. Only polynomial cost functions of up to the second degree are included in the objective. Specifically, if a higher-degree polynomial is provided, JuliaGrid will discard all terms beyond the second degree and still include the resulting truncated polynomial in the objective function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the provided example, the objective function that needs to be minimized to obtain the optimal values of the active power outputs of the generators and the bus voltage angles is as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_function(analysis.method.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Additionally, JuliaGrid stores the objective function in a separate variable, allowing users to access it by referencing the variable analysis.objective.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Update-Objective-Function","page":"DC Optimal Power Flow","title":"Update Objective Function","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"By utilizing the cost! functions, users have the flexibility to modify the objective function by adjusting polynomial or piecewise linear cost coefficients or by changing the type of polynomial or piecewise linear function employed. For instance, consider Generator 3, which incorporates a piecewise cost structure with two segments. Now, we can define a polynomial function for this generator and activate it by specifying the keyword active = 2 as shown:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"cost!(analysis; generator = \"Generator 3\", active = 2, polynomial = [853.4; 257; 40])","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"This results in the updated objective function, which can be observed as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis.method.objective","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#SetupStartingPrimalValuesManual","page":"DC Optimal Power Flow","title":"Setup Initial Values","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In JuliaGrid, the assignment of initial primal and dual values for optimization variables takes place when the solve! function is executed.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Initial-Primal-Values","page":"DC Optimal Power Flow","title":"Initial Primal Values","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Initial primal values are determined based on the generator and voltage fields within the DcOptimalPowerFlow type. By default, these values are initially established using the active power outputs of the generators and the initial bus voltage angles:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users have the flexibility to adjust these values according to their specifications, which will then be used as the initial primal values when executing the solve! function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Using-DC-Power-Flow","page":"DC Optimal Power Flow","title":"Using DC Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In this perspective, users have the capability to conduct the DC power flow analysis and leverage the resulting solution to configure initial primal values. Here is an illustration of how this can be achieved:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"flow = dcPowerFlow(system)\npowerFlow!(flow; power = true)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution, we can use the active power outputs of the generators, along with bus voltage angles, to set the initial values:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"setInitialPoint!(analysis, flow)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Initial-Dual-Values","page":"DC Optimal Power Flow","title":"Initial Dual Values","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Dual variables, often referred to as Lagrange multipliers or Kuhn-Tucker multipliers, represent the shadow prices or marginal costs associated with constraints. The assignment of initial dual values occurs when the solve! function is executed. By default, dual values are undefined, but users can manually assign them using the addDual! function.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"If a constraint is defined as an equality, an interval, or has only a lower or upper bound, it corresponds to a single dual variable. In such cases, an initial value can be set using the dual keyword. For example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"addDual!(analysis, :balance; label = \"Bus 1\", dual = 1e-3)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"For constraints with both lower and upper bounds, users can assign initial dual values separately using the lower and upper keywords. For example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"addDual!(analysis, :capability; label = \"Generator 1\", lower = 500.0, upper = 0.0)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Alternatively, dual variables can be added by specifying the constraint index instead of a label:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"addDual!(analysis, :capability; index = 1, lower = 500.0, upper = 0.0)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerFlowSolutionManual","page":"DC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To establish the DC optimal power flow problem, we utilize the dcOptimalPowerFlow function. After setting up the problem, we can use the solve! function to compute the optimal values for the active power outputs of the generators and the bus voltage angles:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"By executing this function, we will obtain the solution with the optimal values for the active power outputs of the generators and the bus voltage angles:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Objective-Value","page":"DC Optimal Power Flow","title":"Objective Value","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To obtain the objective value of the optimal power flow solution, we can use the objective_value function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_value(analysis.method.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Dual-Variables","page":"DC Optimal Power Flow","title":"Dual Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The values of the dual variables are stored in the dual field of the DcOptimalPowerFlow type. For example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.method.dual.balance.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Wrapper-Function","page":"DC Optimal Power Flow","title":"Wrapper Function","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuliaGrid provides a wrapper function for DC optimal power flow analysis and also supports the computation of powers using the powerFlow! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"setInitialPoint!(analysis) # hide\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis; verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Print-Results-in-the-REPL","page":"DC Optimal Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can utilize the functions printBusData and printGeneratorData to display results. Additionally, the functions listed in the Print Constraint Data section allow users to print constraint data related to buses, branches, or generators in the desired units. For example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@power(MW, MVAr)\nprintBusConstraint(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, users can easily customize the print results for specific constraint, for example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"printBusConstraint(analysis; label = \"Bus 1\", header = true)\nprintBusConstraint(analysis; label = \"Bus 2\", footer = true)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Save-Results-to-a-File","page":"DC Optimal Power Flow","title":"Save Results to a File","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can also redirect print output to a file. For example, data can be saved in a text file as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"open(\"bus.txt\", \"w\") do file\n    printBusConstraint(analysis, file)\nend","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Save-Results-to-a-CSV-File","page":"DC Optimal Power Flow","title":"Save Results to a CSV File","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"For CSV output, users should first generate a simple table with style = false, and then save it to a CSV file:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using CSV\n\nio = IOBuffer()\nprintBusConstraint(analysis, io; style = false)\nCSV.write(\"constraint.csv\", CSV.File(take!(io); delim = \"|\"))","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Primal-and-Dual-Warm-Start","page":"DC Optimal Power Flow","title":"Primal and Dual Warm Start","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Utilizing the DcOptimalPowerFlow type and proceeding directly to the solver offers the advantage of a warm start. In this scenario, the initial primal and dual values for the subsequent solving step correspond to the solution obtained from the previous step.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Primal-Variables","page":"DC Optimal Power Flow","title":"Primal Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the previous example, the following solution was obtained, representing the values of the primal variables:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Dual-Variables-2","page":"DC Optimal Power Flow","title":"Dual Variables","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We also obtained all dual values. Here, we list only the dual variables for one type of constraint as an example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.branch.label, analysis.method.dual.flow.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Modify-Optimal-Power-Flow","page":"DC Optimal Power Flow","title":"Modify Optimal Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Now, let us introduce changes to the power system from the previous example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"updateGenerator!(analysis; label = \"Generator 2\", maxActive = 0.08)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, we want to solve this modified optimal power flow problem. If we use solve! at this point, the primal and dual initial values will be set to the previously obtained values:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As a result, we obtain a new solution:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.generator.label, analysis.power.generator.active)\nprint(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Reset-Primal-and-Dual-Values","page":"DC Optimal Power Flow","title":"Reset Primal and Dual Values","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users retain the flexibility to reset these initial primal values to their default configurations at any juncture. This can be accomplished by utilizing the active power outputs of the generators and the initial bus voltage angles extracted from the PowerSystem type, employing the setInitialPoint! function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"setInitialPoint!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The primal initial values will now be identical to those that would be obtained if the dcOptimalPowerFlow function were executed after all the updates have been applied, while all dual variable values will be removed.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DcExtendedFormulationManual","page":"DC Optimal Power Flow","title":"Extended Formulation","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The JuMP model created by JuliaGrid is stored in the method.jump field of the DcOptimalPowerFlow type. This allows users to modify the model directly using JuMP macros and functions as needed. However, when making such modifications, users become responsible for tasks like setting initial values and extracting solutions, since these changes operate outside the standard JuliaGrid workflow.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Beyond this approach, JuliaGrid also provides a way to extend the standard DC optimal power flow formulation within its own framework. This lets users take advantage of features such as warm start and automatic solution storage, as described below.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Add-Variable","page":"DC Optimal Power Flow","title":"Add Variable","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"User-defined variables can be added to the DC optimal power flow model using the @addVariable macro. It also allows immediate assignment of initial primal and dual values. For example:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@addVariable(analysis, 0.0 <= y <= 0.2, primal = 0.1, lower = 10.0, upper = 0.0)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We can also define collections of variables:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@addVariable(analysis, 0.0 <= x[i = 1:2] <= 0.4, primal = [0.1, 0.2], upper = [0.0; -2.5])\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Add-Constraints-2","page":"DC Optimal Power Flow","title":"Add Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Custom constraints can be added to the DC optimal power flow model using the @addConstraint macro. These constraints are not limited to user-defined variables; any optimization variable defined up to that point can be used. Let us focus on the voltage angle variables:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"θ = analysis.method.variable.voltage.angle\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Next, a new constraint can be defined, and at the same time, an initial dual value can be specified:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@addConstraint(analysis, 0.1 <= x[1] + 2 * x[2] + y + θ[2] <= 0.2, dual = 0.0)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Collections of constraints can also be defined:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@addConstraint(analysis, [i = 1:2], x[i] + 2 * θ[i] <= 0.6, dual = [0.0; 0.5])\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Delete-Constraints-2","page":"DC Optimal Power Flow","title":"Delete Constraints","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To remove a constraint, use the remove! function with the :constraint symbol. For example, to remove the first added constraint:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"remove!(analysis, :constraint; index = 1)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Objective-Function","page":"DC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can modify the objective function using the set_objective_function function from the JuMP package. Here is an example of how it can be achieved:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"expr = 1100.2 * analysis.method.variable.power.active[1]^2 - 50 * x[1] - x[2]^2 + y + 123\nJuMP.set_objective_function(analysis.method.jump, analysis.method.objective - expr)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"We can now observe the updated objective function as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_function(analysis.method.jump)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Optimal-Power-Flow-Solution","page":"DC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can now solve the extended formulation using:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"powerFlow!(analysis; verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After solving, users can access the optimal values as follows:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis.power.generator.active\nanalysis.voltage.angle\nanalysis.extended.solution","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#DCOptimalPowerAnalysisManual","page":"DC Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution from the DC optimal power flow, we can calculate powers related to buses and branches using the power! function. For instance, let us consider the power system for which we obtained the DC optimal power flow solution:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using JuliaGrid, JuMP # hide\nusing Ipopt\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, angle = 0.17)\naddBus!(system; label = \"Bus 2\", active = 0.1, conductance = 0.04)\naddBus!(system; label = \"Bus 3\", active = 0.05)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi, minFromBus = -0.12, maxFromBus = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\n@generator(minActive = 0.0)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2, maxActive = 0.5)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.2, maxActive = 0.2)\n\ncost!(system; generator = \"Generator 1\", active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; generator = \"Generator 2\", active = 1, piecewise = [10.8 12.3; 14.7 16.8])\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Now we can calculate the active powers using the following function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Finally, to display the active power injections and from-bus active power flows, we can use the following code:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.power.from.active)","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nTo better understand the powers associated with buses and branches that are calculated by the power! function, we suggest referring to the tutorials on DC Optimal Power Flow.","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Print-Results-in-the-REPL-2","page":"DC Optimal Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Users can utilize any of the print functions outlined in the Print Power System Data or Print Power System Summary. For example, to create a bus data with the desired units, users can use the following function:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"@voltage(pu, deg)\n@power(MW, MVAr)\nprintBusData(analysis)\n@default(unit) # hide\nnothing # hide","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Injection","page":"DC Optimal Power Flow","title":"Active Power Injection","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To calculate active power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"active = injectionPower(analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Injection-from-Generators","page":"DC Optimal Power Flow","title":"Active Power Injection from Generators","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To calculate active power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"active = supplyPower(analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"manual/dcOptimalPowerFlow/#Active-Power-Flow","page":"DC Optimal Power Flow","title":"Active Power Flow","text":"","category":"section"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similarly, we can compute the active power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"active = fromPower(analysis; label = \"Branch 2\")\nactive = toPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUStateEstimationTutorials","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To initiate the process, let us construct the PowerSystem type and formulate the AC model:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5)\naddBus!(system; label = 2, reactive = 0.3)\naddBus!(system; label = 3, active = 0.5)\n\n@branch(resistance = 0.02, susceptance = 0.04)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.6)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.7)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.2)\n\nacModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Following that, we will introduce the Measurement type and incorporate a set of PMUs mathcalM equiv barmathcalP into the graph mathcalG, that capture both bus voltage and branch current phasors. To construct the linear PMU state estimation model, we represent the vector of state variables, as well as phasor measurements, in the rectangular coordinate system. Thus, we initialize the Measurement type:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"monitoring = measurement(system)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"ukw: Notation\nHere, when referring to a vector mathbf a, we use the notation mathbf a = a_i or mathbf a = a_ij, where a_i represents the element related with bus i in mathcal N or measurement i in mathcal M, while a_ij denotes the element related with branch (ij) in mathcal E.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUSEModelTutorials","page":"PMU State Estimation","title":"State Estimation Model","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Initially, PMUs output phasor measurements in polar coordinates. However, these measurements can be interpreted in rectangular coordinates, where the real and imaginary parts of bus voltages and branch current phasors serve as measurements. Additionally, to obtain the linear system of equations, we observe a vector of state variables in rectangular coordinates mathbf x equivmathbf V_mathrmre mathbf V_mathrmim:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"mathbf V_mathrmre =bigRe(barV_1)dotsRe(barV_n)big^T, representing the real parts of complex bus voltages,\nmathbf V_mathrmim =bigIm(barV_1)dotsIm(barV_n)big^T, representing the imaginary parts of complex bus voltages.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Consequently, the total number of state variables is s = 2n. It is worth noting that in this approach to state estimation, we do not require the slack bus.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The primary drawback of this method stems from measurement errors, which are associated with polar coordinates. Consequently, the covariance matrix must be transformed from polar to rectangular coordinates. As a result, errors from a single PMU are correlated, leading to a non-diagonal covariance matrix. Despite this, the covariance matrix is commonly treated as diagonal, impacting the state estimation accuracy in such scenarios.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Hence, the model includes real and imaginary parts of bus voltage and current phasor measurements from the set mathcal M, contributing to the formulation of a linear system of equations:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbf z=mathbf h(mathbf x) + mathbf u","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Here, mathbf h(mathbf x)= h_1(mathbf x), dots, h_k(mathbf x)^T represents the vector of linear measurement functions, mathbf z = z_1 dots z_k^T denotes the vector of measurement values, and mathbf u = u_1 dots u_k^T represents the vector of measurement errors,  where k = 2barmathcal P.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"These errors are assumed to follow a Gaussian distribution with a zero mean and covariance matrix bm Sigma. The diagonal elements of bm Sigma correspond to the measurement variances mathbf v = v_1 dots v_k^T, while the off-diagonal elements represent the covariances between the measurement errors mathbf w = w_1 dots w_k^T.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"In summary, upon defining the PMU, each i-th PMU is associated with two measurement functions h_2i-1(mathbf x), h_2i(mathbf x), along with their respective measurement values z_2i-1, z_2i, as well as their variances v_2i-1, v_2i, and possibly covariances w_2i-1, w_2i.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Bus-Voltage-Phasor-Measurements","page":"PMU State Estimation","title":"Bus Voltage Phasor Measurements","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"When a PMU (V_i theta_i) in barmathcal P is introduced at bus i in mathcal N in this type of state estimation, users specify the measurement values, variances, and measurement functions of vectors as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbf z = z_Re(barV_i) z_Im(barV_i) \n  mathbf v = v_Re(barV_i) v_Im(barV_i) \n  mathbf h(mathbf x) = h_Re(barV_i)(mathbf x) h_Im(barV_i)(mathbf x)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"For example:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"addPmu!(\n  monitoring; label = \"V₂, θ₂\", bus = 2, magnitude = 0.9, angle = -0.1,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5\n)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Here, measurement values are obtained according to:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    z_Re(barV_i) = z_V_i cos z_theta_i\n    z_Im(barV_i) = z_V_i sin z_theta_i\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Utilizing the classical theory of propagation of uncertainty [22], the variances can be calculated as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    v_Re(barV_i) =\n    v_V_i left cfracmathrm partial mathrm partial z_V_i (z_V_i cos z_theta_i) right^2 +\n    v_theta_i left cfracmathrm partial mathrm partial z_theta_i (z_V_i cos z_theta_i)right^2 =\n    v_V_i (cos z_theta_i)^2 + v_theta_i (z_V_i sin z_theta_i)^2\n    v_Im(barV_i) =\n    v_V_i left cfracmathrm partial mathrm partial z_V_i (z_V_i sin z_theta_i) right^2 +\n    v_theta_i left cfracmathrm partial mathrm partial z_theta_i (z_V_i sin z_theta_i)right^2 =\n    v_V_i (sin z_theta_i)^2 + v_theta_i (z_V_i cos z_theta_i)^2\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Lastly, the functions defining the bus voltage phasor measurement are:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    h_Re(barV_i)(mathbf x) = Re(barV_i)\n    h_Im(barV_i)(mathbf x) = Im(barV_i)\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The coefficient expressions for measurement functions are as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  cfracmathrm partialh_Re(barV_i)(mathbf x)mathrm partial Re(barV_i) = 1 \n  cfracmathrm partialh_Im(barV_i)(mathbf x)mathrm partial Im(barV_i) = 1","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"In the previous example, the user neglected the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbf w = w_Re(barV_i) w_Im(barV_i)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"addPmu!(\n  monitoring; label = \"V₃, θ₃\", bus = 3, magnitude = 0.9, angle = -0.2,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Then, the covariances are obtained as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  w_Re(barV_i) = w_Im(barV_i) =\n  v_V_i cfracmathrm partial mathrm partial z_V_i (z_V_i cos z_theta_i)\n  cfracmathrm partial mathrm partial z_V_i (z_V_i sin z_theta_i)  +\n  v_theta_i cfracmathrm partial mathrm partial z_theta_i (z_V_i cos z_theta_i)\n  cfracmathrm partial mathrm partial z_theta_i (z_V_i sin z_theta_i)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"which results in the solution:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  w_Re(barV_i) = w_Im(barV_i) = cos z_theta_i sin z_theta_i(v_V_i - v_theta_i z_V_i^2)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#From-Bus-Current-Phasor-Measurements","page":"PMU State Estimation","title":"From-Bus Current Phasor Measurements","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"If the user chooses to include phasor measurement (I_ij psi_ij) in barmathcal P in the state estimation model, the user will specify the measurement values, variances, and measurement functions of vectors:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbf z = z_Re(barI_ij) z_Im(barI_ij) \n  mathbf v = v_Re(barI_ij) v_Im(barI_ij) \n  mathbf h(mathbf x) = h_Re(barI_ij)(mathbf x) h_Im(barI_ij)(mathbf x)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"For example:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"addPmu!(\n  monitoring; label = \"I₂₃, ψ₂₃\", from = 3, magnitude = 0.3, angle = 0.4,\n  varianceMagnitude = 1e-3, varianceAngle = 1e-4\n)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Here, measurement values are obtained according to:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    z_Re(barI_ij) = z_I_ij cos z_psi_ij\n    z_Im(barI_ij) = z_I_ij sin z_psi_ij\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Utilizing the classical theory of propagation of uncertainty [22], the variances can be calculated as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    v_Re(barI_ij)  = v_I_ij (cos z_psi_ij)^2 + v_psi_ij (z_I_ij sin z_psi_ij)^2 \n    v_Im(barI_ij) = v_I_ij (sin z_psi_ij)^2 + v_psi_ij (z_I_ij cos z_psi_ij)^2\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The functions defining the current phasor measurement at the from-bus end are:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    h_Re(barI_ij)(mathbf x) = ARe(barV_i) - BIm(barV_i) - left(Ccosphi_ij - Dsinphi_ijright) Re(barV_j) + left(Csinphi_ij + Dcosphi_ij right) Im(barV_j) \n    h_Im(barI_ij)(mathbf x) = BRe(barV_i) + AIm(barV_i) - left(Csin phi_ij + Dcosphi_ijright) Re(barV_j) - left(Ccosphi_ij - Dsinphi_ij right)Im(barV_j)\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"where:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  A = cfracg_ij + g_mathrmsijtau_ij^2\n  B = cfracb_ij+b_mathrmsij tau_ij^2\n  C = cfracg_ijtau_ij\n  D = cfracb_ijtau_ij","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The coefficient expressions for measurement functions are as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Re(barI_ij)(mathbf x)mathrm partial Re(barV_i) =\n    cfracmathrm partialh_Im(barI_ij)(mathbf x)mathrm partial Im(barV_i) = A \n    cfracmathrm partialh_Re(barI_ij)(mathbf x) mathrm partial Re(barV_j) =\n    cfracmathrm partialh_Im(barI_ij)(mathbf x) mathrm partial Im(barV_j) = - left(Ccosphi_ij - Dsinphi_ijright)\n    cfracmathrm partialh_Re(barI_ij)(mathbf x)mathrm partial Im(barV_i) =-\n    cfracmathrm partialh_Im(barI_ij)(mathbf x)mathrm partial Re(barV_i) = -B \n    cfracmathrm partialh_Re(barI_ij)(mathbf x)mathrm partial Im(barV_j) = -\n    cfracmathrm partialh_Im(barI_ij)(mathbf x)mathrm partialRe(barV_j) = left(Csinphi_ij + Dcosphi_ij right)\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"In the previous example, the user neglects the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbf w = w_Re(barI_ij) w_Im(barI_ij)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"addPmu!(\n  monitoring; label = \"I₁₃, ψ₁₃\", from = 2, magnitude = 0.3, angle = -0.5,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Then, the covariances are obtained as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"   w_Re(barI_ij) = w_Im(barI_ij) = sin z_psi_ij cos z_psi_ij(v_I_ij - v_psi_ij z_I_ij^2)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#To-Bus-Current-Phasor-Measurements","page":"PMU State Estimation","title":"To-Bus Current Phasor Measurements","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"If the user chooses to include phasor measurement (I_ji psi_ji) in barmathcal P in the state estimation model, the user will specify the measurement values, variances, and measurement functions of vectors:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"    mathbf z = z_Re(barI_ji) z_Im(barI_ji) \n    mathbf v = v_Re(barI_ji) v_Im(barI_ji) \n    mathbf h(mathbf x) = h_Re(barI_ji)(mathbf x) h_Im(barI_ji)(mathbf x)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"For example:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"addPmu!(\n  monitoring; label = \"I₃₂, ψ₃₂\", to = 3, magnitude = 0.3, angle = -2.9,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5\n)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Here, measurement values are obtained according to:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    z_Re(barI_ji) = z_I_ji cos z_psi_ji\n    z_Im(barI_ji) = z_I_ji sin z_psi_ji\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The variances can be calculated as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    v_Re(barI_ji) = v_I_ji (cos z_psi_ji)^2 + v_psi_ji (z_I_ji sin z_psi_ji)^2 \n    v_Im(barI_ji) = v_I_ji (sin z_psi_ji)^2 + v_psi_ji (z_I_ji cos z_psi_ji)^2\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The functions defining the current phasor measurement at the to-bus end are:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    h_Re(barI_ji)(mathbf x) = tau_ij^2 A Re(barV_j) - tau_ij^2 B Im(barV_j) - left(C cosphi_ij + D sin phi_ijright) Re(barV_i) - left( Csin phi_ij - Dcos phi_ij right) Im(barV_i)\n    h_Im(barI_ji)(mathbf x) = tau_ij^2 B Re(barV_j) + tau_ij^2 A Im(barV_j) + left(C sin phi_ij - D cosphi_ij right) Re(barV_i) - left(Ccos phi_ij + Dsin phi_ijright) Im(barV_i)\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The coefficient expressions for measurement functions are as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Re(barI_ji)(mathbf x)mathrm partial Re(barV_i) =\n    cfracmathrm partialh_Im(barI_ji)(mathbf x)mathrm partial Im(barV_i) = - left(C cosphi_ij + D sin phi_ijright)\n    cfracmathrm partialh_Re(barI_ji)(mathbf x) mathrm partial Re(barV_j) =\n    cfracmathrm partialh_Im(barI_ji)(mathbf x) mathrm partial Im(barV_j) = tau_ij^2A\n    cfracmathrm partialh_Re(barI_ji)(mathbf x)mathrm partial Im(barV_i) = -\n    cfracmathrm partialh_Im(barI_ji)(mathbf x)mathrm partial Re(barV_i) = -left(Csin phi_ij - Dcos phi_ij right) \n    cfracmathrm partialh_Re(barI_ji)(mathbf x)mathrm partial Im(barV_j) = -\n    cfracmathrm partialh_Im(barI_ji)(mathbf x)mathrm partial Re(barV_j) = -tau_ij^2B\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"As before, we are neglecting the covariances between the real and imaginary parts of the measurement. If desired, we can include them in the state estimation model by specifying the covariances of the vector:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"    mathbf w = w_Re(barI_ji) w_Im(barI_ji)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"addPmu!(\n  monitoring; label = \"I₃₁, ψ₃₁\", to = 2, magnitude = 0.3, angle = 2.5,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Then, the covariances are obtained as follows:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"   w_Re(barI_ji) = w_Im(barI_ji) = sin z_psi_ji cos z_psi_ji(v_I_ji - v_psi_ji z_I_ji^2)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUSEWLSStateEstimationTutorials","page":"PMU State Estimation","title":"Weighted Least-Squares Estimation","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The solution to the PMU state estimation problem is determined by solving the linear weighted least-squares (WLS) problem, represented by the following formula:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"\tmathbf H^T bm Sigma^-1 mathbf H mathbf x = mathbf H^T bm Sigma^-1 mathbf z","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Here, mathbf z in mathbbR^k denotes the vector of measurement values, mathbf H in mathbb R^k times 2n represents the coefficient matrix, and bm Sigma in mathbb R^k times k is the measurement error covariance matrix.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Implementation","page":"PMU State Estimation","title":"Implementation","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"JuliaGrid initiates the PMU state estimation framework by setting up the WLS model, as illustrated in the following:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Coefficient-Matrix","page":"PMU State Estimation","title":"Coefficient Matrix","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Using the above-described equations, JuliaGrid forms the coefficient matrix mathbf H:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐇 = analysis.method.coefficient","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"In this matrix, each row corresponds to a specific measurement in the rectangular coordinate system. Therefore, the i-th PMU is associated with the 2i - 1 index of the row, representing the real part of the phasor measurement, while the 2i row corresponds to the imaginary part of the phasor measurement. Columns are ordered based on how the state variables are defined mathbf x equivmathbfV_mathrmremathbfV_mathrmim.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Precision-Matrix","page":"PMU State Estimation","title":"Precision Matrix","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"JuliaGrid opts not to retain the covariance matrix bm Sigma but rather stores its inverse, the precision or weighting matrix denoted as mathbf W = bm Sigma^-1. The order of these values corresponds to the description provided for the coefficient matrix. Users can access these values using the following command:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐖 = analysis.method.precision","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The precision matrix does not maintain a diagonal form, indicating that correlations between the real and imaginary parts of the phasor measurements are included in the model. To ignore these correlations, simply omit the correlated keyword within the function that adds a PMU. For example:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"monitoring = measurement(system)\n\n@pmu(label = \"PMU ?\", noise = false)\naddPmu!(monitoring; bus = 1, magnitude = 1.0, angle = 0.0)\naddPmu!(monitoring; bus = 2, magnitude = 0.8745, angle = -0.1529)\naddPmu!(monitoring; from = 1, magnitude = 0.3033, angle = -0.7136)\naddPmu!(monitoring; from = 2, magnitude = 0.3142, angle = -0.4950)\naddPmu!(monitoring; to = 3, magnitude = 0.2809, angle = -2.8954)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Following this, we recreate the WLS state estimation model:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Upon inspection, it becomes evident that the precision matrix maintains a diagonal structure:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐖 = analysis.method.precision","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Mean-Vector","page":"PMU State Estimation","title":"Mean Vector","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To retrieve the vector mathbf z, containing the means of Gaussian distributions for each measurement, users can utilize:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐳 = analysis.method.mean","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"These values represent measurement values in the rectangular coordinate system as described earlier.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Estimate-of-State-Variables","page":"PMU State Estimation","title":"Estimate of State Variables","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, the WLS equation is solved to obtain the estimate of state variables:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"\thatmathbf x = mathbf H^T bm Sigma^-1 mathbf H^-1 mathbf H^T bm Sigma^-1 mathbf z","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"This process is executed using the solve! function:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"solve!(analysis)","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The initial step involves the LU factorization of the gain matrix:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"\tmathbf G = mathbf H^T bm Sigma^-1 mathbf H = mathbf L mathbf U","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"tip: Tip\nBy default, JuliaGrid utilizes LU factorization as the primary method to factorize the gain matrix. However, users maintain the flexibility to opt for alternative factorization methods such as LDLt or QR.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Access to the factorized gain matrix is available through:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Finally, JuliaGrid obtains the solution in the rectangular coordinate system and then transforms these solutions into the standard form given in the polar coordinate system.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The estimated bus voltage magnitudes hatmathbf V = hatV_i and angles hatbm Theta = hattheta_i, i in mathcal N, can be retrieved using the variables:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nIt is essential to note that the slack bus does not exist in the case of the PMU state estimation model.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUSEOrthogonalWLSStateEstimationTutorials","page":"PMU State Estimation","title":"Alternative Formulation","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from converging to a satisfactory solution. In such scenarios, users may choose to apply an alternative formulation of the WLS estimator.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Orthogonal-Method","page":"PMU State Estimation","title":"Orthogonal Method","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"One such alternative is the orthogonal method [6, Sec. 3.2], which offers increased numerical robustness, particularly in cases where measurement variances differ significantly:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring, Orthogonal)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To explain the method, we begin with the WLS equation:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"\tmathbf H^T mathbf W mathbf H mathbf x = mathbf H^T mathbf W mathbf z","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"where mathbf W = bm Sigma^-1. Subsequently, we can write:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  left(mathbf W^12 mathbf Hright)^T mathbf W^12 mathbf H  mathbf x = left(mathbf W^12 mathbf Hright)^T mathbf W^12 mathbf z","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Consequently, we have:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  barmathbf H^T  barmathbf H mathbf x = barmathbf H^T  barmathbf z","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"where:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  barmathbf H = mathbf W^12 mathbf H  barmathbf z = mathbf W^12 mathbf z","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"At this point, QR factorization is performed on the rectangular matrix:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  barmathbf H = mathbf W^12 mathbf H = mathbf Q mathbf R","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Executing this procedure involves the solve! function:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Access to the factorized matrix is possible through:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐐 = analysis.method.factorization.Q\n𝐑 = analysis.method.factorization.R","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To obtain the solution, JuliaGrid avoids materializing the orthogonal matrix mathbf Q and proceeds to solve the system, resulting in the estimate of bus voltage magnitudes hatmathbf V = hatV_i and angles hatbm Theta = hattheta_i, where i in mathcal N:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Peters-and-Wilkinson-Method","page":"PMU State Estimation","title":"Peters and Wilkinson Method","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Another option is the Peters and Wilkinson method [6, Sec. 3.4]:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring, PetersWilkinson)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"This method applies LU factorisation to the rectangular matrix barmathbfH:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  barmathbfH = mathbf W^12 mathbf H = mathbfLmathbfU","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Substituting this into the normal equation:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  barmathbfH^T  barmathbfH mathbf x = barmathbfH^T  barmathbfz","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"yields:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbfU^T mathbfL^T mathbfL mathbfU mathbf x = mathbfU^T mathbfL^T barmathbfz","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"By eliminating mathbfU^T from both sides and introducing a new vector mathbfy = mathbfU mathbf x,  we obtain:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbfL^T mathbfL mathbf y = mathbfL^T barmathbfz","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The Peters and Wilkinson method first solves this equation to compute mathbfy, and then obtains mathbf x by backward substitution using equation mathbfy = mathbfU mathbf x. The main advantage of this approach is that mathbfL^T mathbfL is generally less ill-conditioned than barmathbfH^T barmathbfH, which improves numerical stability.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To execute this procedure, use the solve! function:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Access to the factorised matrices is available via:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Finally, the estimates of bus voltage magnitudes hatmathbfV = hatV_i and angles hatbmTheta = hattheta_i, where i in mathcalN, can be obtained as:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUSELAVTutorials","page":"PMU State Estimation","title":"Least Absolute Value Estimation","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The least absolute value (LAV) method provides an alternative estimation approach that is considered more robust in comparison to the WLS method. The WLS state estimation problem relies on specific assumptions about measurement errors, whereas robust estimators aim to remain unbiased even in the presence of various types of measurement errors and outliers. This characteristic eliminates the need for bad data analysis, as discussed in [6, Ch. 6]. It is important to note that robustness often comes at the cost of increased computational complexity.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"It can be demonstrated that the problem can be expressed as a linear programming problem. This section outlines the method as described in [6, Sec. 6.5]. To revisit, we consider the system of linear equations:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  mathbfz=mathbfh(mathbf x)+mathbfu+mathbfw","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The LAV state estimator is then formulated as the solution to the following optimization problem:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    textminimize  sum_i in mathcal M r_i\n    textsubjectto  z_i - h_i(mathbf x) =  r_i  forall i in mathcal M\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"where r_i denotes the residual of the i-th measurement.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To explicitly handle absolute values, we introduce two nonnegative variables u_i ge 0 and v_i ge 0, referred to as positive and negative deviations. This allows the optimization problem to be rewritten as:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    textminimize  sum_i in mathcal M (u_i + v_i) \n    textsubjectto    z_i - h_i(mathbf x) = u_i - v_i  forall i in mathcal M \n                          u_i geq  0  v_i geq  0  forall i in mathcal M\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To form the above optimization problem, the user can call the following function:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using Ipopt\nusing JuMP # hide\n\nanalysis = pmuLavStateEstimation(monitoring, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Then the user can solve the optimization problem by:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"JuMP.set_silent(analysis.method.jump) # hide\nsolve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Users can retrieve the estimated bus voltage magnitudes hatmathbf V = hatV_i and angles hatbm Theta = hattheta_i, i in mathcalN, using:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUPowerAnalysisTutorials","page":"PMU State Estimation","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the power! function, which enables the calculation of powers associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses and branches:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Type Power Active Reactive\nBus Injections mathbf P = P_i mathbf Q = Q_i\nBus Generator injections mathbf P_mathrmp = P_mathrmpi mathbf Q_mathrmp = Q_mathrmpi\nBus Shunt elements mathbf P_mathrmsh = P_mathrmshi mathbf Q_mathrmsh = Q_mathrmshi\nBranch From-bus end flows mathbf P_mathrmi = P_ij mathbf Q_mathrmi = Q_ij\nBranch To-bus end flows mathbf P_mathrmj = P_ji mathbf Q_mathrmj = Q_ji\nBranch Shunt elements mathbf P_mathrms = P_mathrmsij mathbf Q_mathrms = P_mathrmsij\nBranch Series elements mathbf P_mathrml = P_mathrmlij mathbf Q_mathrml = Q_mathrmlij\n   ","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Power-Injections","page":"PMU State Estimation","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Active and reactive power injections are stored as the vectors mathbfP = P_i and mathbfQ = Q_i, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐏 = analysis.power.injection.active\n𝐐 = analysis.power.injection.reactive","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUGeneratorPowerInjectionsManual","page":"PMU State Estimation","title":"Generator Power Injections","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"We can calculate the active and reactive power injections supplied by generators at each bus i in mathcalN by summing the active and reactive power injections and the active and reactive power demanded by consumers at each bus:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"  beginaligned\n    P_textpi = P_i + P_textdi\n    Q_textpi = Q_i + Q_textdi\n  endaligned","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The active and reactive power injections from the generators at each bus are stored as vectors, denoted by mathbfP_textp = P_textpi and mathbfQ_textp = Q_textpi, which can be obtained using:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐏ₚ = analysis.power.supply.active\n𝐐ₚ = analysis.power.supply.reactive","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Power-at-Bus-Shunt-Elements","page":"PMU State Estimation","title":"Power at Bus Shunt Elements","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Active and reactive powers associated with the shunt elements at each bus are represented by the vectors mathbfP_textsh = P_textshi and mathbfQ_textsh = Q_textshi. To retrieve these powers in JuliaGrid, use the following commands:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐏ₛₕ = analysis.power.shunt.active\n𝐐ₛₕ = analysis.power.shunt.reactive","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Power-Flows","page":"PMU State Estimation","title":"Power Flows","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The resulting active and reactive power flows at each from-bus end are stored as the vectors mathbfP_texti = P_ij and mathbfQ_texti = Q_ij respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐏ᵢ = analysis.power.from.active\n𝐐ᵢ = analysis.power.from.reactive","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The vectors of active and reactive power flows at the to-bus end are stored as mathbfP_mathrmj = P_ji and mathbfQ_mathrmj = Q_ji, respectively, and can be retrieved using the following code:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐏ⱼ = analysis.power.to.active\n𝐐ⱼ = analysis.power.to.reactive","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Power-at-Branch-Shunt-Elements","page":"PMU State Estimation","title":"Power at Branch Shunt Elements","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Active and reactive powers associated with the branch shunt elements at each branch are represented by the vectors mathbfP_texts = P_textsij and mathbfQ_texts = Q_textsij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐏ₛ = analysis.power.charging.active\n𝐐ₛ = analysis.power.charging.reactive","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Power-at-Branch-Series-Elements","page":"PMU State Estimation","title":"Power at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Active and reactive powers associated with the branch series element at each branch are represented by the vectors mathbfP_textl = P_textlij and mathbfQ_textl = Q_textlij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐏ₗ = analysis.power.series.active\n𝐐ₗ = analysis.power.series.reactive","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#PMUCurrentAnalysisTutorials","page":"PMU State Estimation","title":"Current Analysis","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"JuliaGrid offers the current! function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"current!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Type Current Magnitude Angle\nBus Injections mathbf I = I_i bm psi = psi_i\nBranch From-bus end flows mathbf I_mathrmi = I_ij bm psi_mathrmi = psi_ij\nBranch To-bus end flows mathbf I_mathrmj = I_ji bm psi_mathrmj = psi_ji\nBranch Series elements mathbf I_mathrml = I_mathrmlij bm psi_mathrml = psi_mathrmlij\n   ","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Current-Injections","page":"PMU State Estimation","title":"Current Injections","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"In JuliaGrid, complex current injections are stored in the vector of magnitudes denoted as mathbfI = I_i and the vector of angles represented as bmpsi = psi_i. You can retrieve them using the following commands:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐈 = analysis.current.injection.magnitude\n𝛙 = analysis.current.injection.angle","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Current-Flows","page":"PMU State Estimation","title":"Current Flows","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To obtain the vectors of magnitudes mathbfI_texti = I_ij and angles bmpsi_texti = psi_ij for the resulting complex current flows, you can use the following commands:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐈ᵢ = analysis.current.from.magnitude\n𝛙ᵢ = analysis.current.from.angle","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Similarly, we can obtain the vectors of magnitudes mathbfI_textj = I_ji and angles bmpsi_textj = psi_ji of the resulting complex current flows using the following code:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐈ⱼ = analysis.current.to.magnitude\n𝛙ⱼ = analysis.current.to.angle","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"tutorials/pmuStateEstimation/#Current-at-Branch-Series-Elements","page":"PMU State Estimation","title":"Current at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To obtain the vectors of magnitudes mathbfI_textl = I_textlij and angles bmpsi_textl = psi_textlij of the resulting complex current flows, one can use the following code:","category":"page"},{"location":"tutorials/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"𝐈ₗ = analysis.current.series.magnitude\n𝛙ₗ = analysis.current.series.angle","category":"page"},{"location":"api/powerSystemModel/#powerSystemModelAPI","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For further information on this topic, please see the Power System Model section of the Manual. Below, we have provided a list of functions that can be used to create, save, and manipulate power system structures, as well as to build AC and DC models of power systems.","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To load power system model API functionalities into the current scope, utilize the following command:","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System","page":"Power System Model","title":"Power System","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem\nsavePowerSystem\nacModel!\ndcModel!","category":"page"},{"location":"api/powerSystemModel/#Bus","page":"Power System Model","title":"Bus","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!\nupdateBus!\n@bus","category":"page"},{"location":"api/powerSystemModel/#Branch","page":"Power System Model","title":"Branch","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBranch!\nupdateBranch!\n@branch","category":"page"},{"location":"api/powerSystemModel/#Generator","page":"Power System Model","title":"Generator","text":"","category":"section"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addGenerator!\nupdateGenerator!\ncost!\n@generator","category":"page"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Power-System-2","page":"Power System Model","title":"Power System","text":"","category":"section"},{"location":"api/powerSystemModel/#JuliaGrid.powerSystem","page":"Power System Model","title":"JuliaGrid.powerSystem","text":"powerSystem(file::String; optimal = true)\n\nThe function builds the composite type PowerSystem and populates bus, branch,  generator and base fields. Once the type PowerSystem has been created, it is possible  to add new buses, branches, or generators, or modify the parameters of existing ones.\n\nArgument\n\nIt requires a string path to:\n\nthe HDF5 file with the .h5 extension,\nthe Matpower file with the .m extension,\nthe PSSE v33 file with the .raw extension.\n\nKeyword\n\nSet optimal = false to skip importing data related to optimal power flow analysis. This reduces memory usage and speeds up the data import process if such analyses are not required.\n\nReturns\n\nThe PowerSystem composite type with the following fields:\n\nbus: Data related to buses.\nbranch: Data related to branches.\ngenerator: Data related to generators.\nbase: Base power and base voltages.\nmodel: Data associated with AC and DC analyses.\n\nUnits\n\nJuliaGrid stores all data in per-units and radians format which are fixed, the exceptions are base values in volt-amperes and volts. The prefixes for these base values can be changed using the @base macro.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\n\n\n\n\npowerSystem()\n\nAlternatively, the PowerSystem type can be initialized by calling the function without any arguments. This allows the model to be built from scratch and modified as needed. This generates an empty PowerSystem type, with only the base power initialized to 1.0e8 volt-amperes.\n\nExample\n\nsystem = powerSystem()\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.savePowerSystem","page":"Power System Model","title":"JuliaGrid.savePowerSystem","text":"savePowerSystem(system::PowerSystem; path::String, reference::String, note::String)\n\nThe function saves the power system's data in the HDF5 file using the fields bus, branch, generator, and base from the PowerSystem composite type.\n\nKeywords\n\nThe location and file name of the HDF5 file is specified by the mandatory keyword path in the format of \"path/name.h5\". Additional information can be provided by the optional keywords reference and note, which can be saved along with the power system data.\n\nView HDF5 File\n\nTo view the saved HDF5 file, you can use the HDFView software.\n\nExample\n\nsystem = powerSystem(\"case14.m\")\nsavePowerSystem(system; path = \"D:/case14.h5\")\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.acModel!","page":"Power System Model","title":"JuliaGrid.acModel!","text":"acModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with AC analyses.\n\nUpdates\n\nThe function updates the model.ac field within the PowerSystem type, populating the variables:\n\nnodalMatrix: The nodal matrix.\nnodalMatrixTranspose: The transpose of the nodal matrix.\nnodalFromFrom: The Y-parameters of the two-port branches.\nnodalFromTo: The Y-parameters of the two-port branches.\nnodalToTo: The Y-parameters of the two-port branches.\nnodalToFrom: The Y-parameters of the two-port branches.\nadmittance: The branch admittances.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.dcModel!","page":"Power System Model","title":"JuliaGrid.dcModel!","text":"dcModel!(system::PowerSystem)\n\nThe function generates vectors and matrices based on the power system topology and parameters associated with DC analyses.\n\nUpdates\n\nThe function updates the model.dc field within the PowerSystem type, populating the variables:\n\nnodalMatrix: The nodal matrix.\nadmittance: The branch admittances.\nshiftPower: The active powers related to phase-shifting transformers.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Bus-2","page":"Power System Model","title":"Bus","text":"","category":"section"},{"location":"api/powerSystemModel/#JuliaGrid.addBus!","page":"Power System Model","title":"JuliaGrid.addBus!","text":"addBus!(system::PowerSystem;\n    label, type, active, reactive, conductance, susceptance,\n    magnitude, angle, base, area, lossZone, minMagnitude, maxMagnitude)\n\nThe function adds a new bus to the PowerSystem type.\n\nKeywords\n\nThe main keywords used to define a bus are:\n\nlabel: Unique label for the bus.\ntype: Bus type:\ntype = 1: demand bus (PQ),\ntype = 2: generator bus (PV),\ntype = 3: slack bus (Vθ).\nactive (pu or W): Active power demand at the bus.\nreactive (pu or VAr): Reactive power demand at the bus.\nconductance (pu or W): Active power demanded of the shunt element.\nsusceptance (pu or VAr): Reactive power injected/demanded of the shunt element.\nmagnitude (pu or V): Initial value of the bus voltage magnitude.\nangle (rad or deg): Initial value of the bus voltage angle.\nbase (V): Line-to-line voltage base value.\narea: Area number.\nlossZone: Loss zone.\n\nThe following keywords are used only in optimal power flow analyses:\n\nminMagnitude (pu or V): Minimum bus voltage magnitude value.\nmaxMagnitude (pu or V): Maximum bus voltage magnitude value.\n\nNote that all voltage values, except for base voltages, are referenced to line-to-neutral voltages, while powers, when given in SI units, correspond to three-phase power.\n\nUpdates\n\nThe function updates the bus field of the PowerSystem type.\n\nDefault Settings\n\nThe default settings for certain keywords are as follows: type = 1, magnitude = 1.0, minMagnitude = 0.9, maxMagnitude = 1.1, and base = 138e3. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @bus macro.\n\nUnits\n\nBy default, the keyword parameters use per-units and radians as units, with the exception of the base keyword argument, which is in volts. However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nAdding a bus using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 0.25, angle = 0.175, base = 132e3)\n\nAdding a bus using a custom unit system:\n\n@power(MW, MVAr)\n@voltage(pu, deg, kV)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 25.0, angle = 10.026, base = 132.0)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateBus!","page":"Power System Model","title":"JuliaGrid.updateBus!","text":"updateBus!(system::PowerSystem; kwargs...)\n\nThe function allows for the alteration of parameters for an existing bus.\n\nKeywords\n\nTo update a specific bus, provide the necessary kwargs input arguments in accordance with the keywords specified in the addBus! function, along with their respective values. Ensure that the label keyword matches the label of the existing bus. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the bus field within the PowerSystem type, and in cases where parameters impact variables in the ac field, it automatically adjusts the field.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBus! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\nupdateBus!(system; label = \"Bus 1\", active = 0.15, susceptance = 0.15)\n\n\n\n\n\nupdateBus!(analysis::Analysis; kwargs...)\n\nThe function extends the updateBus! function. By passing the Analysis type, the function first updates the specific bus within the PowerSystem type using the provided kwargs, and then updates the Analysis type with all parameters associated with that bus.\n\nA key feature of this function is that any prior modifications made to the specified bus are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nanalysis = newtonRaphson(system)\n\nupdateBus!(analysis; label = \"Bus 2 HV\", active = 0.15, susceptance = 0.15)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@bus","page":"Power System Model","title":"JuliaGrid.@bus","text":"@bus(kwargs...)\n\nThe macro generates a template for a bus.\n\nKeywords\n\nTo define the bus template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBus! function, along with their corresponding values.\n\nUnits\n\nBy default, the keyword parameters use per-units and radians as units, with the exception of the base keyword argument, which is in volts. However, users have the option to use other units instead of per-units and radians, or to specify prefixes for base voltage by using the @power and @voltage macros.\n\nExamples\n\nAdding a bus template using the default unit system:\n\n@bus(type = 2, active = 0.25, angle = 0.1745)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", reactive = -0.04, base = 132e3)\n\nAdding a bus template using a custom unit system:\n\n@power(MW, MVAr)\n@voltage(pu, deg, kV)\n@bus(type = 2, active = 25.0, angle = 10.0, base = 132.0)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", reactive = -4.0)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Branch-2","page":"Power System Model","title":"Branch","text":"","category":"section"},{"location":"api/powerSystemModel/#JuliaGrid.addBranch!","page":"Power System Model","title":"JuliaGrid.addBranch!","text":"addBranch!(system::PowerSystem;\n    label, from, to, status,\n    resistance, reactance, conductance, susceptance, turnsRatio, shiftAngle,\n    minDiffAngle, maxDiffAngle, minFromBus, maxFromBus, minToBus, maxToBus, type)\n\nThe function adds a new branch to the PowerSystem type. A branch can be added between already defined buses.\n\nKeywords\n\nThe main keywords used to define a branch are:\n\nlabel: Unique label for the branch.\nfrom: From-bus label, corresponds to the bus label.\nto: To-bus label, corresponds to the bus label.\nstatus: Operating status of the branch:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\nresistance (pu or Ω): Series resistance.\nreactance (pu or Ω): Series reactance.\nconductance (pu or S): Total shunt conductance.\nsusceptance (pu or S): Total shunt susceptance.\nturnsRatio: Transformer off-nominal turns ratio, equal to one for a line.\nshiftAngle (rad or deg): Transformer phase shift angle, where positive value defines delay.\n\nThe following keywords are used only in optimal power flow analyses:\n\nminDiffAngle (rad or deg): Minimum voltage angle difference value between from-bus and to-bus ends.\nmaxDiffAngle (rad or deg): Maximum voltage angle difference value between from-bus and to-bus ends.\nminFromBus (pu, VA, W, or A): Minimum branch flow limit at the from-bus end.\nmaxFromBus (pu, VA, W, or A): Maximum branch flow limit at the from-bus end.\nminToBus (pu, VA, W, or A): Minimum branch flow limit at the to-bus end.\nmaxToBus (pu, VA, W, or A): Maximum branch flow limit at the to-bus end.\ntype: Types of minFromBus, maxFromBus, minToBus, and maxToBus branch flow limits:\ntype = 1: active power flow (pu or W),\ntype = 2: apparent power flow (pu or VA),\ntype = 3: apparent power flow (pu or VA) with a squared inequality constraint,\ntype = 4: current magnitude flow (pu or A),\ntype = 5: current magnitude flow (pu or A) with a squared inequality constraint.\n\nNote that when powers are given in SI units, they correspond to three-phase power.\n\nUpdates\n\nThe function updates the branch field within the PowerSystem type, and in cases where parameters impact variables in the ac and dc fields, it automatically adjusts the fields.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1, turnsRatio = 1.0, type = 3, minDiffAngle = -2pi, and maxDiffAngle = 2pi. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @branch macro.\n\nUnits\n\nThe default units for the keyword parameters are per-units and radians. However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, @current, and @parameter.\n\nExamples\n\nAdding a branch using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\n\nAdding a branch using a custom unit system:\n\n@voltage(pu, deg)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 10)\n\n\n\n\n\naddBranch!(analysis::Analysis; kwargs...)\n\nThe function extends the addBranch! function. When the Analysis type is passed, the function first adds the specified branch to the PowerSystem type using the provided kwargs, and then adds the same branch to the Analysis type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nanalysis = newtonRaphson(system)\n\naddBranch!(analysis; from = 13, to = 14, reactance = 0.21, susceptance = 0.06)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateBranch!","page":"Power System Model","title":"JuliaGrid.updateBranch!","text":"updateBranch!(system::PowerSystem; kwargs...)\n\nThe function allows for the alteration of parameters for an existing branch.\n\nKeywords\n\nTo update a specific branch, provide the necessary kwargs input arguments in accordance with the keywords specified in the addBranch! function, along with their respective values. Ensure that the label keyword matches the label of the existing branch. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the branch field within the PowerSystem type, and in cases where parameters impact variables in the ac and dc fields, it automatically adjusts the fields.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBranch! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\nupdateBranch!(system; label = \"Branch 1\", reactance = 0.22, susceptance = 0.06)\n\n\n\n\n\nupdateBranch!(analysis::Analysis; kwargs...)\n\nThe function extends the updateBranch! function. By passing the Analysis type, the function first updates the specific branch within the PowerSystem type using the provided kwargs, and then updates the Analysis type with all parameters associated with that branch.\n\nA key feature of this function is that any prior modifications made to the specified branch are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nanalysis = newtonRaphson(system)\n\naddBranch!(analysis; from = \"Bus 13 LV\", to = \"Bus 14 LV\", reactance = 0.21)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@branch","page":"Power System Model","title":"JuliaGrid.@branch","text":"@branch(kwargs...)\n\nThe macro generates a template for a branch.\n\nKeywords\n\nTo define the branch template, the kwargs input arguments must be provided in accordance with the keywords specified within the addBranch! function, along with their corresponding values.\n\nUnits\n\nThe default units for the keyword parameters are per-units and radians. However, the user can choose to use other units besides per-units and radians by utilizing macros such as @power, @voltage, and @parameter.\n\nExamples\n\nAdding a branch template using the default unit system:\n\n@branch(reactance = 0.12, shiftAngle = 0.1745)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\n\nAdding a branch template using a custom unit system:\n\n@voltage(pu, deg)\n@branch(shiftAngle = 10)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.25, reactive = -0.04)\naddBus!(system; label = \"Bus 2\", type = 1,  active = 0.15, reactive = 0.08)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\n\n\n\n\n","category":"macro"},{"location":"api/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"api/powerSystemModel/#Generator-2","page":"Power System Model","title":"Generator","text":"","category":"section"},{"location":"api/powerSystemModel/#JuliaGrid.addGenerator!","page":"Power System Model","title":"JuliaGrid.addGenerator!","text":"addGenerator!(system::PowerSystem;\n    label, bus, status, active, reactive, magnitude,\n    minActive, maxActive, minReactive, maxReactive,\n    lowActive, minLowReactive, maxLowReactive, upActive, minUpReactive, maxUpReactive)\n\nThe function adds a new generator to the PowerSystem type. The generator can be added to an already defined bus.\n\nKeywords\n\nThe main keywords used to define a generator are:\n\nlabel: Unique label for the generator.\nbus: Label of the bus to which the generator is connected.\nstatus: Operating status of the generator:\nstatus = 1: in-service,\nstatus = 0: out-of-service.\nactive (pu or W): Output active power.\nreactive (pu or VAr): Output reactive power.\nmagnitude (pu or V): Voltage magnitude setpoint.\nminReactive (pu or VAr): Minimum allowed reactive power output value.\nmaxReactive (pu or VAr): Maximum allowed reactive power output value.\n\nThe following keywords are used only in optimal power flow analyses:\n\nminActive (pu or W): Minimum allowed active power output value.\nmaxActive (pu or W): Maximum allowed active power output value.\nlowActive (pu or W): Lower allowed active power output value of PQ capability curve.\nminLowReactive (pu or VAr): Minimum allowed reactive power output value at lowActive value.\nmaxLowReactive (pu or VAr): Maximum allowed reactive power output value at lowActive value.\nupActive (pu or W): Upper allowed active power output value of PQ capability curve.\nminUpReactive (pu or VAr): Minimum allowed reactive power output value at upActive value.\nmaxUpReactive (pu or VAr): Maximum allowed reactive power output value at upActive value.\n\nNote that voltage magnitude values are referenced to line-to-neutral voltages, while powers, when given in SI units, correspond to three-phase power.\n\nUpdates\n\nThe function updates the generator field within the PowerSystem type, and in cases where parameters impact variables in the bus field, it automatically adjusts the field.\n\nDefault Settings\n\nBy default, certain keywords are assigned default values: status = 1, magnitude = 1.0, maxActive = 5 active, minReactive = -5 reactive, and maxReactive = 5 reactive. The rest of the keywords are initialized with a value of zero. However, the user can modify these default settings by utilizing the @generator macro.\n\nUnits\n\nBy default, the input units are associated with per-units as shown. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nAdding a generator using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.2, base = 132e3)\n\naddGenerator!(system; bus = \"Bus 1\", active = 0.5, magnitude = 1.1)\n\nAdding a generator using a custom unit system:\n\n@power(MW, MVAr)\n@voltage(kV, deg, kV)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 20, base = 132)\n\naddGenerator!(system; bus = \"Bus 1\", active = 50, magnitude = 145.2)\n\n\n\n\n\naddGenerator!(analysis::Analysis; kwargs...)\n\nThe function extends the addGenerator! function. When the Analysis type is passed, the function first adds the specified generator to the PowerSystem type using the provided kwargs, and then adds the same generator to the Analysis type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nanalysis = newtonRaphson(system)\n\naddGenerator!(analysis; bus = 1, active = 0.5, reactive = 0.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.updateGenerator!","page":"Power System Model","title":"JuliaGrid.updateGenerator!","text":"updateGenerator!(system::PowerSystem; kwargs...)\n\nThe function allows for the alteration of parameters for an existing generator.\n\nKeywords\n\nTo update a specific generator, provide the necessary kwargs input arguments in accordance with the keywords specified in the addGenerator! function, along with their respective values. Ensure that the label keyword matches the label of the existing generator. If any keywords are omitted, their corresponding values will remain unchanged.\n\nUpdates\n\nThe function updates the generator field within the PowerSystem type, and in cases where parameters impact variables in the bus field, it automatically adjusts the field.\n\nUnits\n\nUnits for input parameters can be changed using the same method as described for the addBranch! function.\n\nExample\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.2, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\nupdateGenerator!(system; label = \"Generator 1\", active = 0.6, reactive = 0.2)\n\n\n\n\n\nupdateGenerator!(analysis::Analysis; kwargs...)\n\nThe function extends the updateGenerator! function. By passing the Analysis type, the function first updates the specific generator within the PowerSystem type using the provided kwargs, and then updates the Analysis type with parameters associated with that generator.\n\nA key feature of this function is that any prior modifications made to the specified generator are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nanalysis = newtonRaphson(system)\n\naddGenerator!(analysis; bus = \"Bus 1 HV\", active = 0.5, reactive = 0.2)\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.cost!","page":"Power System Model","title":"JuliaGrid.cost!","text":"cost!(system::PowerSystem; generator, active, reactive, piecewise, polynomial)\n\nThe function either adds a new cost or modifies an existing one for the active or reactive power generated by the corresponding generator within the PowerSystem type. It has the capability to append a cost to an already defined generator.\n\nKeywords\n\nThe function accepts five keywords:\n\ngenerator: Corresponds to the already defined generator label.\nactive: Active power cost model:\nactive = 1: adding or updating cost, and piecewise linear is being used,\nactive = 2: adding or updating cost, and polynomial is being used.\nreactive: Reactive power cost model:\nreactive = 1: adding or updating cost, and piecewise linear is being used,\nreactive = 2: adding or updating cost, and polynomial is being used.\npiecewise: Cost model defined by input-output points given as Matrix{Float64}:\nfirst column (pu, W or VAr): active or reactive power output of the generator,\nsecond column ($/hr): cost for the specified active or reactive power output.\npolynomial: The n-th degree polynomial coefficients given as Vector{Float64}:\nfirst element ($/puⁿ-hr, $/Wⁿ-hr or $/VArⁿ-hr): coefficient of the n-th degree term, ....,\npenultimate element ($/pu-hr, $/W-hr or $/VAr-hr): coefficient of the first degree term,\nlast element ($/hr): constant coefficient.\n\nUpdates\n\nThe function updates the generator.cost field within the PowerSystem type.\n\nUnits\n\nBy default, the input units related with active powers are per-units, but they can be modified using the macro @power.\n\nExamples\n\nAdding a cost using the default unit system:\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 0.25, reactive = -0.04, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\ncost!(system; generator = \"Generator 1\", active = 2, polynomial = [1100.0; 500.0; 150.0])\n\nAdding a cost using a custom unit system:\n\n@power(MW, MVAr)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", active = 25, reactive = -4, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50, reactive = 10)\ncost!(system; generator = \"Generator 1\", active = 2, polynomial = [0.11; 5.0; 150.0])\n\n\n\n\n\ncost!(analysis::Analysis; kwargs...)\n\nThe function extends the cost! function. When the Analysis type is passed, the function first adds or modifies an existing cost in the PowerSystem type using the provided kwargs and then applies the same changes to the Analysis type.\n\nA key feature of this function is that any prior modifications to the specified cost are preserved and applied to the Analysis type when the function is executed, ensuring consistency throughout the update process.\n\nExample\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\ncost!(analysis; generator = 2, active = 2, polynomial = [1100.0; 500.0; 150.0])\n\n\n\n\n\n","category":"function"},{"location":"api/powerSystemModel/#JuliaGrid.@generator","page":"Power System Model","title":"JuliaGrid.@generator","text":"@generator(kwargs...)\n\nThe macro generates a template for a generator.\n\nKeywords\n\nTo define the generator template, the kwargs input arguments must be provided in accordance with the keywords specified within the addGenerator! function, along with their corresponding values.\n\nUnits\n\nBy default, the input units are associated with per-units. However, users have the option to use other units instead of per-units using the @power and @voltage macros.\n\nExamples\n\nAdding a generator using the default unit system:\n\n@generator(magnitude = 1.1)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 0.25, reactive = -0.04, base = 132e3)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5, reactive = 0.1)\n\nAdding a generator using a custom unit system:\n\n@power(MW, MVAr)\n@voltage(kV, deg, kV)\n@generator(magnitude = 145.2)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 2, active = 25, reactive = -4, base = 132)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 50, reactive = 10)\n\n\n\n\n\n","category":"macro"},{"location":"examples/pmuStateEstimation/#PMUStateEstimationExamples","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"This example examines a 6-bus power system, illustrated in Figure 1. The goal is to estimate bus voltage magnitudes and angles using only phasor measurements.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/pmuStateEstimation/6bus.svg\" width=\"360\" class=\"my-svg\"/>\n    <p>Figure 1: The 6-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"The power system is defined by specifying buses and branches, with the generator assigned to the slack bus:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"using JuliaGrid, HiGHS # hide\n@default(template) # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\naddBus!(system; label = \"Bus 4\")\naddBus!(system; label = \"Bus 5\")\naddBus!(system; label = \"Bus 6\")\n\n@branch(resistance = 0.02)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.23)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 3\", to = \"Bus 4\", reactance = 0.19)\naddBranch!(system; label = \"Branch 4\", from = \"Bus 4\", to = \"Bus 5\", reactance = 0.17)\naddBranch!(system; label = \"Branch 5\", from = \"Bus 5\", to = \"Bus 6\", reactance = 0.04)\naddBranch!(system; label = \"Branch 6\", from = \"Bus 1\", to = \"Bus 6\", reactance = 0.21)\naddBranch!(system; label = \"Branch 7\", from = \"Bus 2\", to = \"Bus 6\", reactance = 0.13)\naddBranch!(system; label = \"Branch 8\", from = \"Bus 5\", to = \"Bus 2\", reactance = 0.34)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\")\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Display-Data-Settings","page":"PMU State Estimation","title":"Display Data Settings","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Before running simulations, we configure the data display settings:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"show = Dict(\"Shunt Power\" => false, \"Status\" => false, \"Series Power\" => false)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Optimal-PMU-Placement","page":"PMU State Estimation","title":"Optimal PMU Placement","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, PMUs need to be assigned to the power system shown in Figure 1. The placement is determined using an optimal PMU placement strategy that ensures observability with the minimal number of PMUs:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"placement = pmuPlacement(system, HiGHS.Optimizer; verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"This provides the bus configuration where PMUs should be installed:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"placement.bus\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"PMUs installed at these buses will measure bus voltage phasors and all currents in branches connected to those buses. Specifically, current phasors will be measured in the following branches:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"placement.from\nplacement.to\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"If users choose to generate phasor measurement values using optimal power flow or power flow analysis, the integers within bus and branch labels indicate positions in vectors where these values are stored.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Hence, Figure 2 illustrates the phasor measurement configuration, which includes bus voltage and branch current phasor measurements.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/pmuStateEstimation/6bus_phasor.svg\" width=\"340\" class=\"my-svg\"/>\n    <p>Figure 2: The 6-bus power system with phasor measurement configuration.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Finally, phasor measurements need to be defined. The question is how to obtain measurement values. In this example, AC power flow results will be used to generate synthetic measurements.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Measurement-Model","page":"PMU State Estimation","title":"Measurement Model","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To begin, let us initialize the measurement variable:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"monitoring = measurement(system)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#AC-Power-Flow","page":"PMU State Estimation","title":"AC Power Flow","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"AC power flow analysis requires generator and load data. The system configuration is shown in Figure 3.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/pmuStateEstimation/6bus_acpf.svg\" width=\"450\" class=\"my-svg\"/>\n    <p>Figure 3: The 6-bus power system with generators and loads.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Data for loads and generators is added as follows:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"updateBus!(system; label = \"Bus 2\", type = 1, active = 0.217, reactive = 0.127)\nupdateBus!(system; label = \"Bus 3\", type = 1, active = 0.478, reactive = -0.039)\nupdateBus!(system; label = \"Bus 4\", type = 2, active = 0.076, reactive = 0.016)\nupdateBus!(system; label = \"Bus 5\", type = 1, active = 0.112, reactive = 0.075)\nupdateBus!(system; label = \"Bus 6\", type = 1, active = 0.295, reactive = 0.166)\n\nupdateGenerator!(system; label = \"Generator 1\", active = 2.324, reactive = -0.169)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 4\", active = 0.412, reactive = 0.234)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, AC power flow analysis is performed to obtain bus voltages:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"acModel!(system)\n\npowerFlow = newtonRaphson(system)\npowerFlow!(powerFlow; verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Bus-Voltage-Phasor-Measurements","page":"PMU State Estimation","title":"Bus Voltage Phasor Measurements","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To obtain bus voltage phasor measurements, the exact values and optimal PMU placement data are used. By setting noise = true, white Gaussian noise with a default variance of 1e-8 is added to the magnitude and angle values:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"@pmu(label = \"!\")\nfor (bus, idx) in placement.bus\n    Vᵢ, θᵢ = powerFlow.voltage.magnitude[idx], powerFlow.voltage.angle[idx]\n    addPmu!(monitoring; bus = bus, magnitude = Vᵢ, angle = θᵢ, noise = true)\nend\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Branch-Current-Phasor-Measurements","page":"PMU State Estimation","title":"Branch Current Phasor Measurements","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"To add branch current phasor measurements, the current magnitudes and angles are first computed. These values are then used to form measurements, where the exact values are used as the noise keyword is ignored:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"for branch in keys(placement.from)\n    Iᵢⱼ, ψᵢⱼ = fromCurrent(powerFlow; label = branch)\n    addPmu!(monitoring; from = branch, magnitude = Iᵢⱼ, angle = ψᵢⱼ)\nend\nfor branch in keys(placement.to)\n    Iⱼᵢ, ψⱼᵢ = toCurrent(powerFlow; label = branch)\n    addPmu!(monitoring; to = branch, magnitude = Iⱼᵢ, angle = ψⱼᵢ)\nend\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Current phasor measurements can also be generated in the same way as voltage phasors by invoking the current! function after AC state estimation has converged.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Note that the formation of bus voltage and branch current measurements can be performed by calling the pmuPlacement! function, as demonstrated in the PMU State Estimation manual.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Phasor-Measurements","page":"PMU State Estimation","title":"Phasor Measurements","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Finally, the complete set of phasor measurements is observed, as illustrated in Figure 2:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"printPmuData(monitoring; width = Dict(\"Label\" => 15))","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Base-Case-Analysis","page":"PMU State Estimation","title":"Base Case Analysis","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Once the measurements are obtained, the state estimation model is created:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, the model is solved to obtain the WLS estimator for bus voltages, and the results are used to compute powers:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"stateEstimation!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"This enables users to observe the estimated bus voltages along with the corresponding power values:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"printBusData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Users can also compare these results with those obtained from AC power flow:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"power!(powerFlow)\nprintBusData(powerFlow; show)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Additionally, estimated power flows at branches can be examined:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"printBranchData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Modifying-Measurement-Data","page":"PMU State Estimation","title":"Modifying Measurement Data","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Measurement values and variances are now updated. Instead of recreating the measurement set and the PMU state estimation model from the beginning, both are modified simultaneously:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"updatePmu!(analysis; label = \"From Branch 8\", magnitude = 1.1)\nupdatePmu!(analysis; label = \"From Branch 2\", angle = 0.2, noise = true)\n\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"These updates demonstrate the flexibility of JuliaGrid in modifying measurements. For the phasor measurement at From Branch 8, only the voltage magnitude is changed, while the angle measurement remains the same. For From Branch 2, only the angle value is updated by adding white Gaussian noise, while the magnitude remains unchanged.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, the PMU state estimation is solved again to compute the new estimate:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"stateEstimation!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Bus-related data can now be examined:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"printBusData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"With the updated measurement values, the estimated results deviate more significantly from the exact values obtained through AC power flow, as the modified measurements no longer align with them.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"","category":"page"},{"location":"examples/pmuStateEstimation/#Modifying-Measurement-Set","page":"PMU State Estimation","title":"Modifying Measurement Set","text":"","category":"section"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Excluding phasor measurements from the set, when obtained using optimal placement, should be done with caution, as it can easily render the system unobservable. In this example, two measurements will be taken out-of-service, and two additional measurements will be immediately included to maintain observability:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"updatePmu!(monitoring; label = \"From Branch 2\", status = 0)\nupdatePmu!(monitoring; label = \"From Branch 8\", status = 0)\n\naddPmu!(monitoring; to = \"Branch 2\", magnitude = 0.2282, angle = -2.9587)\naddPmu!(monitoring; to = \"Branch 8\", magnitude = 0.0414, angle = -0.2424)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Since new measurements are being added, analysis is not passed to these functions. Directly modifying the existing PMU state estimation model is not possible in this case. To achieve this, users should define the new measurements beforehand with status = 0 and then activate them by setting status = 1.","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Next, the PMU state estimation model is created and solved:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"analysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"Bus-related data can now be examined:","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"printBusData(analysis; show)\nnothing # hide","category":"page"},{"location":"examples/pmuStateEstimation/","page":"PMU State Estimation","title":"PMU State Estimation","text":"By taking certain measurements out-of-service, the estimation was affected. Adding more precise measurements while maintaining observability led to an estimation that more accurately reflects the exact power system state.","category":"page"},{"location":"examples/acOptimalPowerFlow/#ACOptimalPowerFlowExamples","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"This example performs multiple AC optimal power flow analyses on the power system shown in Figure 1. These simulations capture quasi-steady-state conditions under varying constraints and topology changes.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/acOptimalPowerFlow/4bus.svg\" width=\"400\" class=\"my-svg\"/>\n    <p>Figure 1: The 4-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We begin by defining the units for active and reactive powers, as well as voltage magnitudes and angles, which will be used throughout this example:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using JuliaGrid, Ipopt, JuMP # hide\n@default(template) # hide\n@default(unit) # hide\n\n@power(MW, MVAr)\n@voltage(pu, deg)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, we define bus parameters for the AC optimal power flow analysis. This includes specifying the slack bus (type = 3), where the bus voltage angle is set to zero by default, along with the corresponding active and reactive power loads, and shunt capacitor banks with conductance and susceptance values. The voltage magnitude limits for each bus are set using minMagnitude and maxMagnitude. With these definitions, we can begin building the power system model:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"system = powerSystem()\n\n@bus(minMagnitude = 0.95, maxMagnitude = 1.05)\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", active = 20.2, reactive = 10.5)\naddBus!(system; label = \"Bus 3\", conductance = 0.1, susceptance = 8.2)\naddBus!(system; label = \"Bus 4\", active = 50.8, reactive = 23.1)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We define the transmission line parameters by specifying resistance, reactance, and susceptance values. At this stage, we do not impose any branch flow constraints, but they will be introduced later in the example:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"@branch(label = \"Branch ?\", reactance = 0.22)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", resistance = 0.02, susceptance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", resistance = 0.05, susceptance = 0.04)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.04, susceptance = 0.04)\naddBranch!(system; from = \"Bus 3\", to = \"Bus 4\", turnsRatio = 0.98)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We define the active and reactive power outputs of the generators, which serve as initial primal values for the optimization variables related to generator outputs. Reactive power outputs of the generators are limited by minReactive and maxReactive, while active power outputs vary between minActive and maxActive:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"@generator(label = \"Generator ?\", minActive = 2.0, minReactive = -15.5, maxReactive = 15.5)\naddGenerator!(system; bus = \"Bus 1\", active = 63.1, reactive = 8.2, maxActive = 65.5)\naddGenerator!(system; bus = \"Bus 2\", active = 3.0, reactive = 6.2, maxActive = 20.5)\naddGenerator!(system; bus = \"Bus 2\", active = 4.1, reactive = 8.5, maxActive = 22.4)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Finally, we define the active power supply costs of the generators in polynomial form by setting active = 2. Then, we express the polynomial as a quadratic using the polynomial keyword:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"cost!(system; generator = \"Generator 1\", active = 2, polynomial = [0.04; 20.0; 0.0])\ncost!(system; generator = \"Generator 2\", active = 2, polynomial = [1.00; 20.0; 0.0])\ncost!(system; generator = \"Generator 3\", active = 2, polynomial = [1.00; 20.0; 0.0])\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After defining the power system data, we generate an AC model that includes essential vectors and matrices for analysis, such as the nodal admittance matrix:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"acModel!(system)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"examples/acOptimalPowerFlow/#Display-Data-Settings","page":"AC Optimal Power Flow","title":"Display Data Settings","text":"","category":"section"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Before running simulations, we configure the data display settings, including the selection of displayed data elements and the numeric format for relevant power values.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For bus-related data, we set:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"show1 = Dict(\"Power Injection\" => false)\nfmt1 = Dict(\"Power Generation\" => \"%.2f\", \"Power Demand\" => \"%.2f\", \"Shunt Power\" => \"%.2f\")\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, for branch-related data, we choose:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"show2 = Dict(\"Shunt Power\" => false, \"Status\" => false)\nfmt2 = Dict(\"From-Bus Power\" => \"%.2f\", \"To-Bus Power\" => \"%.2f\", \"Series Power\" => \"%.2f\")\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To display generator-related data, we also set:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"show3 = Dict(\"Reactive Power Capability\" => false)\nfmt3 = Dict(\"Power Output\" => \"%.2f\")\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"examples/acOptimalPowerFlow/#Base-Case-Analysis","page":"AC Optimal Power Flow","title":"Base Case Analysis","text":"","category":"section"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"First, we create the AC optimal power flow model and select the Ipopt solver. Next, we solve the model to determine bus voltage magnitudes and angles, along with the active and reactive power outputs of the generators. Afterward, we compute the remaining power values for buses and branches:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis, power = true, verbose = 1)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Once the AC optimal power flow is solved, we can review the bus-related results, including the optimal values of bus voltage magnitudes and angles:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBusData(analysis; show = show1, fmt = fmt1)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The optimal active and reactive outputs of the generators are as follows:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printGeneratorData(analysis; fmt = fmt3)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As we can observe from the generator data, the Generator 1, which has the lowest costs, generates power at the maximum value. Additionally, we can observe that Generator 2 and Generator 3 have the same cost functions, which dictate that these two will produce an equal amount of active power.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We enabled users to display bus, branch, or generator data related to the optimal power analysis. For instance, for generator data, we can observe that the dual variables related to Generator 1 are different from zero, indicating that the generator's output has reached its limit:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printGeneratorConstraint(analysis; show = show3)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Finally, we can also review the results related to branches:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBranchData(analysis; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Thus, we obtained the active and reactive power flows, as illustrated in Figure 2.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_base_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_base_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 2: Power flows in the 4-bus power system for the base case scenario.\n    </p>\n</div>","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"examples/acOptimalPowerFlow/#Modifying-Demands","page":"AC Optimal Power Flow","title":"Modifying Demands","text":"","category":"section"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Let us now introduce a new state by updating the active and reactive power demands of consumers. These updates modify both the power system model and the AC optimal power flow model simultaneously:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", active = 25.2, reactive = 13.5)\nupdateBus!(analysis; label = \"Bus 4\", active = 43.3, reactive = 18.6)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, we solve the AC optimal power flow again to compute the new solution without recreating the model. This step enables a warm start, as the initial primal and dual values correspond to those obtained in the base case:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"powerFlow!(analysis, power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Now, we observe the power output of the generators:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printGeneratorData(analysis; fmt = fmt3)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Compared to the base case, all generators have reduced power supplies due to lower demand. It is important to note that, although one might expect Generator 1 to continue producing at maximum output because of its lower cost, while only Generator 2 and Generator 3 reduce their production, this is not the case. The reason is that the optimal power flow must also satisfy power balance and bus voltage magnitude constraints.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"At the end of this scenario, we can review branch-related results for a more comprehensive insight into power flows:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBranchData(analysis; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The obtained results allow us to illustrate the active and reactive power flows in Figure 3.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_demand_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_demand_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 3: Power flows in the 4-bus power system with modified demands.\n    </p>\n</div>","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"examples/acOptimalPowerFlow/#Modifying-Generator-Costs","page":"AC Optimal Power Flow","title":"Modifying Generator Costs","text":"","category":"section"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We modify the cost functions for all generators, altering the objective function of the AC optimal power flow. By modifying the cost function of Generator 1, we shift it from being the lowest-cost to the highest-cost generator in the system. Updating both the power system model and the AC optimal power flow model simultaneously allows us to enable a warm start for the optimization problem:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"cost!(analysis; generator = \"Generator 1\", active = 2, polynomial = [2.0; 20.0; 0.0])\ncost!(analysis; generator = \"Generator 2\", active = 2, polynomial = [0.8; 20.0; 0.0])\ncost!(analysis; generator = \"Generator 3\", active = 2, polynomial = [0.8; 20.0; 0.0])\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, we solve the updated problem and calculate the resulting powers:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"powerFlow!(analysis, power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The optimal active and reactive power outputs of the generators are as follows:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printGeneratorData(analysis; fmt = fmt3)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this scenario, we observe that, due to the increased cost of Generator 1, both Generator 2 and Generator 3 have increased their production to the maximum possible values to capitalize on their lower costs. The remaining required active power is then supplied by Generator 1.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can also review the results related to branches for this scenario:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBranchData(analysis; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Figure 4 illustrates the power flows for this scenario. Compared to the previous scenario, Figure 4a shows that Branch 2 has significantly lower active power flow, while Branch 3 has become considerably more loaded.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_cost_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_cost_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 4: Power flows in the 4-bus power system with modified generator costs.\n    </p>\n</div>","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"examples/acOptimalPowerFlow/#Adding-Branch-Flow-Constraints","page":"AC Optimal Power Flow","title":"Adding Branch Flow Constraints","text":"","category":"section"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To limit active power flow, we introduce constraints on Branch 2 and Branch 3 by setting type = 1, where the active power flow at the from-bus end of these branches is limited using the maxFromBus keyword:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBranch!(analysis; label = \"Branch 2\", type = 1, maxFromBus = 15.0)\nupdateBranch!(analysis; label = \"Branch 3\", type = 1, maxFromBus = 15.0)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, we recalculate the AC optimal power flow:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"powerFlow!(analysis, power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Now, let us observe the generator outputs:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printGeneratorData(analysis; fmt = fmt3)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The power flow limit at Branch 3 forces Generator 1 to increase its active power output despite its higher cost compared to Generator 2 and Generator 3, due to the need to satisfy all constraints. Additionally, we also observe a significant redistribution in the production of reactive powers.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can review the branch data constraints and observe that the active power at the from-bus end of Branch 3 reaches the defined limit, which leads to the power redistribution described earlier, while the power flow at Branch 2 stays within the specified limits:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBranchConstraint(analysis)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Finally, we can review the branch-related data to examine the redistribution of powers in detail:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBranchData(analysis; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Based on the obtained results, we can illustrate the power flows in Figure 5.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_flow_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_flow_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 5: Power flows in the 4-bus power system with added branch flow constraints.\n    </p>\n</div>","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"examples/acOptimalPowerFlow/#Modifying-Network-Topology","page":"AC Optimal Power Flow","title":"Modifying Network Topology","text":"","category":"section"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"At the end, we set Branch 2 out-of-service:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBranch!(analysis; label = \"Branch 2\", status = 0)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We then recalculate the AC optimal power flow:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"powerFlow!(analysis; power = true, verbose = 1)\nnothing # hide","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can now observe the updated generator outputs:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printGeneratorData(analysis; fmt = fmt3)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Due to the outage of Branch 2 and the flow limit at Branch 3, Generator 1 faces difficulties supplying load at Bus 2, reducing its output. Consequently, the only solution is to increase the output of Generator 2 and Generator 3.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Upon reviewing the branch data, we observe that the active power flows in the remaining in-service branches remain largely unchanged. This is because, following the outage of Branch 2, Generator 2 and Generator 3 have taken over the responsibility of supplying the load at Bus 2, effectively displacing Generator 1:","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBranchData(analysis; show = show2, fmt = fmt2)","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Figure 6 illustrates these results under the outage of Branch 2.","category":"page"},{"location":"examples/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_service_active.svg\" class=\"my-svg\"/>\n        <p>(a) Active powers.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/examples/acOptimalPowerFlow/4bus_service_reactive.svg\" class=\"my-svg\"/>\n        <p>(b) Reactive powers.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 6: Power flows in the 4-bus power system with modified network topology.\n    </p>\n</div>","category":"page"},{"location":"api/setupPrint/#setupPrintAPI","page":"Setup and Print","title":"Setup and Print","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"For further information on this topic, please see the Power System Model or Measurement Model sections of the Manual. Various macros are available for setting units or defining label types. Print functions allow results to be displayed in the REPL, or users can redirect the output to a file.","category":"page"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"To load power system model API functionalities into the current scope, utilize the following command:","category":"page"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"using JuliaGrid","category":"page"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#Base-Units","page":"Setup and Print","title":"Base Units","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"@base","category":"page"},{"location":"api/setupPrint/#Input-Units","page":"Setup and Print","title":"Input Units","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"@power\n@voltage\n@current\n@parameter","category":"page"},{"location":"api/setupPrint/#Configuration-Settings","page":"Setup and Print","title":"Configuration Settings","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"@config\n@default","category":"page"},{"location":"api/setupPrint/#Print-Power-System-Data","page":"Setup and Print","title":"Print Power System Data","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"printBusData\nprintBranchData\nprintGeneratorData","category":"page"},{"location":"api/setupPrint/#Print-Power-System-Summary","page":"Setup and Print","title":"Print Power System Summary","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"printBusSummary\nprintBranchSummary\nprintGeneratorSummary","category":"page"},{"location":"api/setupPrint/#Print-Measurement-Data","page":"Setup and Print","title":"Print Measurement Data","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"printVoltmeterData\nprintAmmeterData\nprintWattmeterData\nprintVarmeterData\nprintPmuData","category":"page"},{"location":"api/setupPrint/#Print-Constraint-Data","page":"Setup and Print","title":"Print Constraint Data","text":"","category":"section"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"printBusConstraint\nprintBranchConstraint\nprintGeneratorConstraint","category":"page"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#Base-Units-2","page":"Setup and Print","title":"Base Units","text":"","category":"section"},{"location":"api/setupPrint/#JuliaGrid.@base","page":"Setup and Print","title":"JuliaGrid.@base","text":"@base(system::PowerSystem, power, voltage)\n\nBy default, the units for base power and base voltages are set to volt-ampere (VA) and volt (V), but users can modify the prefixes using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of power (VA) or unit of voltage (V). Keep in mind that the macro must be used after creating the type PowerSystem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n@base(system, MVA, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#Input-Units-2","page":"Setup and Print","title":"Input Units","text":"","category":"section"},{"location":"api/setupPrint/#JuliaGrid.@power","page":"Setup and Print","title":"JuliaGrid.@power","text":"@power(active, reactive, apparent)\n\nJuliaGrid stores all data related with powers in per-units, and these cannot be altered. However, the power units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of active power (W), reactive power (VAr), or apparent power (VA). Also, it is a possible to combine SI units with/without prefixes with per-units (pu).\n\nChanging the unit of active power is reflected in the following quantities:\n\naddBus!, updateBus!, @bus:\n\nactive, conductance;\n\naddBranch!, updateBranch!, @branch: if type = 2: minFromBus, maxFromBus, minToBus, maxToBus;\naddGenerator!, updateGenerator!, @generator: active, minActive, maxActive, lowActive, upActive;\ncost!: if active: piecewise, polynomial;\naddWattmeter!, updateWattmeter!: active, variance;\n@wattmeter: , varianceBus, varianceFrom, varianceTo.\n\nChanging the unit of reactive power unit is reflected in the following quantities:\n\naddBus!, updateBus!, @bus: reactive, susceptance;\naddGenerator!, updateGenerator!, @generator: reactive, minReactive, maxReactive, minLowReactive, maxLowReactive, minUpReactive, maxUpReactive;\ncost!: if reactive: piecewise, polynomial;\naddVarmeter!, updateVarmeter!: reactive, variance;\n@varmeter: varianceBus, varianceFrom, varianceTo.\n\nChanging the unit of apparent power unit is reflected in the following quantities:\n\naddBranch!, updateBranch!, @branch: if type = 1: minFromBus, maxFromBus, minToBus, maxToBus.\n\nExample\n\n@power(MW, kVAr, VA)\n\n\n\n\n\n","category":"macro"},{"location":"api/setupPrint/#JuliaGrid.@voltage","page":"Setup and Print","title":"JuliaGrid.@voltage","text":"@voltage(magnitude, angle, base)\n\nJuliaGrid stores all data related with voltages in per-units and radians, and these cannot be altered. However, the voltage magnitude and angle units of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of voltage, either magnitude (V) or base (V). Alternatively, the unit of voltage magnitude can be expressed in per-unit (pu). The unit of voltage angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of voltage magnitude is reflected in the following quantities:\n\naddBus!, updateBus!, @bus: magnitude, minMagnitude, maxMagnitude;\naddGenerator!, updateGenerator!, @generator: magnitude;\naddVoltmeter!, updateVoltmeter!, @voltmeter: magnitude, variance;\naddPmu!, updatePmu!: if bus: magnitude, varianceMagnitude;\n@pmu: varianceMagnitudeBus.\n\nChanging the unit of voltage angle is reflected in the following quantities:\n\naddBus!, updateBus!, @bus: angle;\naddBranch!, updateBranch!, @branch: shiftAngle, minDiffAngle, maxDiffAngle;\naddPmu!, updatePmu!: if bus: angle, varianceAngle;\n@pmu: varianceAngleBus.\n\nChanging the unit prefix of voltage base is reflected in the following quantity:\n\naddBus!, updateBus!, @bus: base.\n\nExample\n\n@voltage(pu, deg, kV)\n\n\n\n\n\n","category":"macro"},{"location":"api/setupPrint/#JuliaGrid.@current","page":"Setup and Print","title":"JuliaGrid.@current","text":"@current(magnitude, angle)\n\nJuliaGrid stores all data related with currents in per-units and radians, and these cannot be altered. However, the current magnitude and angle units of the built-in functions used to add or modified measurement devices can be modified using the macro.\n\nThe prefixes must adhere to the SI prefixes and should be specified along with the unit of current magnitude (V). Alternatively, the unit of current magnitude can be expressed in per-unit (pu). The unit of current angle should be in radians (rad) or degrees (deg).\n\nChanging the unit of current magnitude is reflected in the following quantities:\n\naddBranch!, updateBranch!, @branch: if type = 3: minFromBus, maxFromBus, minToBus, maxToBus.\naddAmmeter!, updateAmmeter!: magnitude, variance;\n@ammeter: varianceFrom, varianceTo;\naddPmu!, updatePmu!: if from or to: magnitude, varianceMagnitude;\n@pmu: varianceMagnitudeFrom, varianceMagnitudeTo.\n\nChanging the unit of current angle is reflected in the following quantities:\n\naddPmu!, updatePmu!: if from or to: angle, varianceAngle;\n@pmu: varianceAngleFrom, varianceAngleTo.\n\nExample\n\n@current(pu, deg)\n\n\n\n\n\n","category":"macro"},{"location":"api/setupPrint/#JuliaGrid.@parameter","page":"Setup and Print","title":"JuliaGrid.@parameter","text":"@parameter(impedance, admittance)\n\nJuliaGrid stores all data related with impedances and admittancies in per-units, and these cannot be altered. However, units of impedance and admittance of the built-in functions used to add or modified power system elements can be modified using the macro.\n\nPrefixes must be specified according to the SI prefixes and should be included with the unit of impedance (Ω) or unit of admittance (S). The second option is to define the units in per-unit (pu).\n\nIn the case where impedance and admittance are being used in SI units (Ω and S) and these units are related to the transformer, the assignment must be based on the primary side of the transformer.\n\nChanging the units of impedance is reflected in the following quantities in specific functions:\n\naddBranch!, updateBranch!, @branch: resistance, reactance.\n\nChanging the units of admittance is reflected in the following quantities:\n\naddBranch!, updateBranch!, @branch: conductance, susceptance.\n\nExample\n\n@parameter(Ω, pu)\n\n\n\n\n\n","category":"macro"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#Configuration-Settings-2","page":"Setup and Print","title":"Configuration Settings","text":"","category":"section"},{"location":"api/setupPrint/#JuliaGrid.@config","page":"Setup and Print","title":"JuliaGrid.@config","text":"@config(label, verbose)\n\nThe macro defines general configuration settings for JuliaGrid.\n\nBy default, JuliaGrid stores all labels as strings in ordered dictionaries. However, users can choose to store labels as integers, which can be a more efficient option for large-scale systems.\n\nUsers can also adjust the level of printed information for the algorithms used in JuliaGrid. The verbose setting is multilevel and can take the following values:\n\nverbose = 0: Silent mode (default).\nverbose = 1: Prints exit messages.\nverbose = 2: Prints algorithm solver progress data.\nverbose = 3: Prints detailed data.\n\nExamples\n\nSet labels as integers and print only basic data:\n\n@config(label = Integer, verbose = 1)\n\nSet labels as strings and enable detailed data printing:\n\n@config(label = String, verbose = 3)\n\n\n\n\n\n","category":"macro"},{"location":"api/setupPrint/#JuliaGrid.@default","page":"Setup and Print","title":"JuliaGrid.@default","text":"@default(mode)\n\nThe macro is designed to reset various settings to their default values.\n\nThe mode argument can take on the following values:\n\nunit: Restores all units to their default settings.\npower: Converts active, reactive, and apparent power to per-unit values.\nvoltage: Expresses voltage magnitude in per-unit and voltage angle in radians.\nparameter: Converts impedance and admittance to per-unit values.\nbus: Resets the bus template to its default configuration.\nbranch: Resets the branch template to its default configuration.\ngenerator: Resets the generator template to its default configuration.\nvoltmeter: Resets the voltmeter template to its default configuration.\nammeter: Resets the ammeter template to its default configuration.\nwattmeter: Resets the wattmeter template to its default configuration.\nvarmeter: Resets the varmeter template to its default configuration.\npmu: Resets the PMU template to its default configuration.\ntemplate: Restores all templates and configurations to their default settings.\n\nExample\n\n@default(template)\n\n\n\n\n\n","category":"macro"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#PrintPowerSystemDataAPI","page":"Setup and Print","title":"Print Power System Data","text":"","category":"section"},{"location":"api/setupPrint/#JuliaGrid.printBusData","page":"Setup and Print","title":"JuliaGrid.printBusData","text":"printBusData(analysis::Analysis, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints voltages, powers, and currents related to buses. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding bus.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all buses:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\nfmt = Dict(\"Power Demand\" => \"%.2f\", \"Voltage Magnitude\" => \"%.2f\", \"Label\" => \"%s\")\nshow = Dict(\"Power Injection\" => false, \"Power Generation Reactive\" => false)\n\nprintBusData(analysis; fmt, show, repeat = 10)\n\nPrint data for specific buses:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\ndelimiter = \" \"\nwidth = Dict(\"Voltage\" => 9, \"Power Injection Active\" => 9)\n\nprintBusData(analysis; label = \"Bus 2 HV\", delimiter, width, title = true, header = true)\nprintBusData(analysis; label = \"Bus 10 LV\", delimiter, width)\nprintBusData(analysis; label = \"Bus 12 LV\", delimiter, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printBranchData","page":"Setup and Print","title":"JuliaGrid.printBranchData","text":"printBranchData(analysis::Analysis, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints powers and currents related to branches. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding branch.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all branches:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\nfmt = Dict(\"Shunt Power\" => \"%.2f\", \"Series Power Reactive\" => \"%.2f\")\nshow = Dict(\"From-Bus Power\" => false, \"To-Bus Power Reactive\" => false)\n\nprintBranchData(analysis; fmt, show, repeat = 11, title = false)\n\nPrint data for specific branches:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\ndelimiter = \" \"\nwidth = Dict(\"From-Bus Power\" => 9, \"To-Bus Power Active\" => 9)\n\nprintBranchData(analysis; label = 2, delimiter, width, header = true)\nprintBranchData(analysis; label = 12, delimiter, width)\nprintBranchData(analysis; label = 14, delimiter, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printGeneratorData","page":"Setup and Print","title":"JuliaGrid.printGeneratorData","text":"printGeneratorData(analysis::Analysis, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints powers related to generators. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding generator.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all generators:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\nfmt = Dict(\"Power Output Active\" => \"%.2f\")\nshow = Dict(\"Power Output Reactive\" => false)\n\nprintGeneratorData(analysis; fmt, show, title = false)\n\nPrint data for specific generators:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\ndelimiter = \" \"\nwidth = Dict(\"Power Output Active\" => 7)\n\nprintGeneratorData(analysis; label = 1, delimiter, width, header = true)\nprintGeneratorData(analysis; label = 4, delimiter, width)\nprintGeneratorData(analysis; label = 5, delimiter, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#PrintPowerSystemSummaryAPI","page":"Setup and Print","title":"Print Power System Summary","text":"","category":"section"},{"location":"api/setupPrint/#JuliaGrid.printBusSummary","page":"Setup and Print","title":"JuliaGrid.printBusSummary","text":"printBusSummary(analysis::Analysis, [io::IO];\n    fmt, width, show, delimiter, title, header, footer, style)\n\nThe function prints a summary of the electrical quantities related to buses. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\nshow = Dict(\"In-Use\" => false)\n\nprintBusSummary(analysis; show, delimiter = \" \", title = false)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printBranchSummary","page":"Setup and Print","title":"JuliaGrid.printBranchSummary","text":"printBranchSummary(analysis::Analysis, [io::IO];\n    fmt, width, show, delimiter, title, header, footer, style))\n\nThe function prints a summary of the electrical quantities related to branches. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\nshow = Dict(\"Total\" => false)\n\nprintBranchSummary(analysis; show, delimiter = \" \", title = false)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printGeneratorSummary","page":"Setup and Print","title":"JuliaGrid.printGeneratorSummary","text":"printGeneratorSummary(analysis::Analysis, [io::IO];\n    fmt, width, show, delimiter, title, header, footer, style)\n\nThe function prints a summary of the electrical quantities related to generators. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true)\n\nshow = Dict(\"Minimum\" => false)\n\nprintGeneratorSummary(analysis; show, delimiter = \" \", title = false)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#Print-Measurement-Data-2","page":"Setup and Print","title":"Print Measurement Data","text":"","category":"section"},{"location":"api/setupPrint/#JuliaGrid.printVoltmeterData","page":"Setup and Print","title":"JuliaGrid.printVoltmeterData","text":"printVoltmeterData(data::Union{Measurement, Analysis}, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints data related to voltmeters. Optionally, an IO may be passed as the last argument to redirect the output. Users may choose to print only measurement data by passing the Measurement type, or both measurement data and analysis results by passing the Analysis type.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding voltmeter.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all voltmeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nfmt = Dict(\"Voltage Magnitude\" => \"%.2f\", \"Voltage Magnitude Estimate\" => \"%.6f\")\nshow = Dict(\"Voltage Magnitude Residual\" => false)\n\nprintVoltmeterData(analysis; fmt, show, delimiter = \" \", repeat = 10)\n\nPrint data for specific voltmeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\n\nwidth = Dict(\"Voltage Magnitude Estimate\" => 11)\n\nprintVoltmeterData(analysis; label = 1, width, header = true)\nprintVoltmeterData(analysis; label = 6, width)\nprintVoltmeterData(analysis; label = 8, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printAmmeterData","page":"Setup and Print","title":"JuliaGrid.printAmmeterData","text":"printAmmeterData(data::Union{Measurement, Analysis}, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints data related to ammeters. Optionally, an IO may be passed as the last argument to redirect the output. Users may choose to print only measurement data by passing the Measurement type, or both measurement data and analysis results by passing the Analysis type.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding ammeter.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all ammeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; current = true)\n\nfmt = Dict(\"Current Magnitude\" => \"%.2f\", \"Current Magnitude Estimate\" => \"%.6f\")\nshow = Dict(\"Current Magnitude Residual\" => false)\n\nprintAmmeterData(analysis; fmt, show, delimiter = \" \", repeat = 10)\n\nPrint data for specific ammeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; current = true)\n\nwidth = Dict(\"Current Magnitude\" => 10)\n\nprintAmmeterData(analysis; label = \"From 1\", width, header = true)\nprintAmmeterData(analysis; label = \"From 4\", width)\nprintAmmeterData(analysis; label = \"From 6\", width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printWattmeterData","page":"Setup and Print","title":"JuliaGrid.printWattmeterData","text":"printWattmeterData(data::Union{Measurement, Analysis}, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints data related to wattmeters. Optionally, an IO may be passed as the last argument to redirect the output. Users may choose to print only measurement data by passing the Measurement type, or both measurement data and analysis results by passing the Analysis type.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding wattmeter.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all wattmeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; power = true)\n\nfmt = Dict(\"Active Power\" => \"%.2f\", \"Active Power Estimate\" => \"%.6f\")\nshow = Dict(\"Active Power Status\" => false)\n\nprintWattmeterData(analysis; fmt, show, delimiter = \" \", repeat = 14)\n\nPrint data for specific wattmeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; power = true)\n\nwidth = Dict(\"Active Power Residual\" => 11)\n\nprintWattmeterData(analysis; label = 2, width, header = true)\nprintWattmeterData(analysis; label = 5, width)\nprintWattmeterData(analysis; label = 9, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printVarmeterData","page":"Setup and Print","title":"JuliaGrid.printVarmeterData","text":"printVarmeterData(data::Union{Measurement, Analysis}, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints data related to varmeters. Optionally, an IO may be passed as the last argument to redirect the output. Users may choose to print only measurement data by passing the Measurement type, or both measurement data and analysis results by passing the Analysis type.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding varmeter.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all varmeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; power = true)\n\nfmt = Dict(\"Reactive Power\" => \"%.2f\", \"Reactive Power Estimate\" => \"%.6f\")\nshow = Dict(\"Reactive Power Status\" => false)\n\nprintVarmeterData(analysis; fmt, show, delimiter = \" \", repeat = 14)\n\nPrint data for specific varmeters:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; power = true)\n\nwidth = Dict(\"Reactive Power Residual\" => 11)\n\nprintVarmeterData(analysis; label = 2, width, header = true)\nprintVarmeterData(analysis; label = 5, width)\nprintVarmeterData(analysis; label = 9, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printPmuData","page":"Setup and Print","title":"JuliaGrid.printPmuData","text":"printPmuData(data::Union{Measurement, Analysis}, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints data related to PMUs. Optionally, an IO may be passed as the last argument to redirect the output. Users may choose to print only measurement data by passing the Measurement type, or both measurement data and analysis results by passing the Analysis type.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding PMU.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all PMUs:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; current = true)\n\nfmt = Dict(\"Current Magnitude\" => \"%.2f\", \"Current Magnitude Variance\" => \"%.5f\")\nshow = Dict(\"Current Angle\" => false, \"Current Magnitude Status\" => false)\n\nprintPmuData(analysis; fmt, show, delimiter = \" \", repeat = 10)\n\nPrint data for specific PMUs:\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\")\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; current = true)\n\nwidth = Dict(\"Current Magnitude\" => 10, \"Current Angle Status\" => 8)\n\nprintPmuData(analysis; label = \"From 1\", width, header = true)\nprintPmuData(analysis; label = \"From 4\", width)\nprintPmuData(analysis; label = \"From 6\", width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/","page":"Setup and Print","title":"Setup and Print","text":"","category":"page"},{"location":"api/setupPrint/#PrintConstraintDataAPI","page":"Setup and Print","title":"Print Constraint Data","text":"","category":"section"},{"location":"api/setupPrint/#JuliaGrid.printBusConstraint","page":"Setup and Print","title":"JuliaGrid.printBusConstraint","text":"printBusConstraint(analysis::OptimalPowerFlow, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints constraint data related to buses. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding bus.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all buses:\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nfmt = Dict(\"Active Power Balance\" => \"%.2e\", \"Reactive Power Balance Dual\" => \"%.4e\")\nshow = Dict(\"Voltage Magnitude\" => false, \"Reactive Power Balance Solution\" => false)\n\nprintBusConstraint(analysis; fmt, show, repeat = 10)\n\nPrint data for specific buses:\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\ndelimiter = \" \"\nwidth = Dict(\"Voltage Magnitude\" => 8, \"Active Power Balance Solution\" => 12)\n\nprintBusConstraint(analysis; label = \"Bus 2 HV\", delimiter, width, header = true)\nprintBusConstraint(analysis; label = \"Bus 10 LV\", delimiter, width)\nprintBusConstraint(analysis; label = \"Bus 14 LV\", delimiter, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printBranchConstraint","page":"Setup and Print","title":"JuliaGrid.printBranchConstraint","text":"printBranchConstraint(analysis::OptimalPowerFlow, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints constraint data related to branches. Optionally, an IO may be passed as the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding branch.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all branches:\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nupdateBranch!(system; label = 3, minDiffAngle = 0.05, maxDiffAngle = 1.5)\nupdateBranch!(system; label = 9, minFromBus = 0.1, maxFromBus = 0.3)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nfmt = Dict(\"Voltage Angle Difference\" => \"%.2f\")\nshow = Dict(\"To-Bus Apparent Power Flow Dual\" => false)\n\nprintBranchConstraint(analysis; fmt, show)\n\nPrint data for specific branches:\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\nupdateBranch!(system; label = 3, minDiffAngle = 0.05, maxDiffAngle = 1.5)\nupdateBranch!(system; label = 9, minFromBus = 0.1, maxFromBus = 0.3)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\ndelimiter = \" \"\nwidth = Dict(\"From-Bus Apparent Power Flow\" => 13, \"Voltage Angle Difference Dual\" => 12)\n\nprintBranchConstraint(analysis; label = 3, delimiter, width, header = true)\nprintBranchConstraint(analysis; label = 9, delimiter, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"api/setupPrint/#JuliaGrid.printGeneratorConstraint","page":"Setup and Print","title":"JuliaGrid.printGeneratorConstraint","text":"printGeneratorConstraint(analysis::OptimalPowerFlow, [io::IO];\n    label, fmt, width, show, delimiter, title, header, footer, repeat, style)\n\nThe function prints constraint data related to generators. Optionally, an IO may be passed asn the last argument to redirect the output.\n\nKeywords\n\nThe following keywords control the printed data:\n\nlabel: Prints only the data for the corresponding generator.\nfmt: Specifies the preferred numeric formats or alignments for the columns.\nwidth: Specifies the preferred widths for the columns.\nshow: Toggles the printing of the columns.\ndelimiter: Sets the column delimiter.\ntitle: Toggles the printing of the table title.\nheader: Toggles the printing of the header.\nfooter: Toggles the printing of the footer.\nrepeat: Prints the header again after a specified number of lines have been printed.\nstyle: Prints either a stylish table or a simple table suitable for easy export.\n\ncompat: Julia 1.10\nThe function requires Julia 1.10 or later.\n\nExamples\n\nPrint data for all generators:\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nfmt = Dict(\"Active Power Capability\" => \"%.2f\")\nshow = Dict(\"Reactive Power Capability\" => false, \"Active Power Capability Dual\" => false)\n\nprintGeneratorConstraint(analysis; fmt, show, repeat = 3)\n\nPrint data for specific generator:\n\nusing Ipopt\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\ndelimiter = \" \"\nwidth = Dict(\"Active Power Capability\" => 11, \"Reactive Power Capability Dual\" => 10)\n\nprintGeneratorConstraint(analysis; label = 2, delimiter, width, header = true)\nprintGeneratorConstraint(analysis; label = 3, delimiter, width)\nprintGeneratorConstraint(analysis; label = 5, delimiter, width, footer = true)\n\n\n\n\n\n","category":"function"},{"location":"#JuliaGrid","page":"Introduction","title":"JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is a fast, flexible, and easy-to-use open-source tool for steady-state power system analysis, developed in the Julia programming language. The framework enables easy modification of power system configurations and measurement data, allowing efficient quasi-steady-state analyses. It is available as a Julia package under the MIT License. JuliaGrid is primarily designed for researchers and academics, offering various state-of-the-art algorithms.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The framework's architecture centres around code-reusability paradigm, allowing users a high level of customization for their experiments. To simplify, the overall logic for setting the experiments and its analysis can be as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Users define a power system with/without measurement data.\nUsers select between the AC or DC model.\nUsers define the specific type of required analysis.\nFinally, they solve the generated power system model.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid offers comprehensive support for importing power system data from both Matpower and PSSE case files. In addition to data import, it provides tools for constructing detailed models of power systems and associated measurements. To accelerate future data access, it also enables saving processed data in the efficient HDF5 format.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Installation-Guide","page":"Introduction","title":"Installation Guide","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid is compatible with Julia version 1.9 and later. To get started with JuliaGrid, users should first install Julia and consider using a code editor for a smoother coding experience. For detailed instructions, please consult the Installation Guide.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To get the JuliaGrid package installed, execute the following Julia command:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"JuliaGrid\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Documentation-Structure","page":"Introduction","title":"Documentation Structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaGrid documentation consists of four main parts:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The manual provides users with guidance on how to use available functions, its return values, and offers instructions for modifying power system configurations, measurement data, and other user specific analysis.\nThe tutorials delve deeper into the theoretical underpinnings of state-of-the-art algorithms, allowing users to gain an in-depth understanding of the equations used in various functions.\nThe examples section contains various power system datasets and uses toy examples to highlight JuliaGrid's abilities in steady-state and quasi-steady-state analyses.\nAPI references offer a comprehensive list of objects, functions and methods within the package, categorised according to specific use-cases.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Getting-Started","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Below, we have provided a list of exhaustive examples in order to ease users in getting started with the JuliaGrid package. These examples highlight some of the functionalities that the framework offers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#AC-Power-Flow","page":"Introduction","title":"AC Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid\n\nsystem = powerSystem(\"case14.h5\") # Build the power system model\n\nanalysis = newtonRaphson(system)  # Build the power flow model\npowerFlow!(analysis; verbose = 3) # Compute voltages\n\npower!(analysis)                  # Compute powers\ncurrent!(analysis)                # Compute currents\n\nprintBusData(analysis)            # Print bus data","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#DC-Power-Flow","page":"Introduction","title":"DC Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid\n\n@power(MW, MVAr)                   # Specify the power units\nsystem = powerSystem(\"case14.h5\")  # Build the power system model\n\nanalysis = dcPowerFlow(system)     # Build the power flow model\npowerFlow!(analysis; power = true) # Compute powers and voltage angles\n\n@generator(active = 20.0)          # Define the template\naddGenerator!(analysis; bus = 1)   # Add the new generator\n\npowerFlow!(analysis; power = true) # Recompute powers and voltage angles\n\nprintBusSummary(analysis)          # Print bus summary data","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#AC-Optimal-Power-Flow","page":"Introduction","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid, Ipopt\n\nsystem = powerSystem(\"case14.h5\")                      # Build the power system model\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer) # Build the optimal power flow model\npowerFlow!(analysis; current = true, verbose = 3)      # Compute voltages and currents\n\n@branch(resistance = 0.01, reactance = 0.2)            # Define the template\naddBranch!(analysis; from = 1, to = 5)                 # Add the new branch\n\npowerFlow!(analysis; current = true, verbose = 3)      # Recompute voltages and currents","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#DC-Optimal-Power-Flow","page":"Introduction","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid, HiGHS\n\nsystem = powerSystem(\"case14.h5\")                      # Build the power system model\n\nanalysis = dcOptimalPowerFlow(system, HiGHS.Optimizer) # Build the optimal power flow model\npowerFlow!(analysis; power = true)                     # Compute powers and voltage angles\n\nprintBranchData(analysis)                              # Print branch data","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#AC-State-Estimation","page":"Introduction","title":"AC State Estimation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\") # Build the energy management system\n\nanalysis = gaussNewton(monitoring)                     # Build the state estimation model\nstateEstimation!(analysis; power = true, verbose = 3)  # Estimate voltages and powers\n\nprintWattmeterData(analysis)                           # Print wattmeter data","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#PMU-State-Estimation","page":"Introduction","title":"PMU State Estimation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\") # Build the energy management system\n\nanalysis = pmuStateEstimation(monitoring)              # Build the state estimation model\nstateEstimation!(analysis)                             # Estimate voltages\n\nprintPmuData(analysis)                                 # Print PMU data","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#DC-State-Estimation","page":"Introduction","title":"DC State Estimation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using JuliaGrid\n\nsystem, monitoring = ems(\"case14.h5\", \"monitoring.h5\") # Build the energy management system\n\nanalysis = dcStateEstimation(monitoring)               # Build the state estimation model\nstateEstimation!(analysis)                             # Estimate voltage angles\n\nresidualTest!(analysis)                                # Perform bad data analysis\nstateEstimation!(analysis)                             # Recompute voltage angles\n\nprintBusData(analysis)                                 # Print bus data","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Citing-JuliaGrid","page":"Introduction","title":"Citing JuliaGrid","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please consider citing the following preprint if JuliaGrid contributes to your research or projects:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{juliagrid,\n   title={JuliaGrid: An Open-Source Julia-Based Framework for Power System State Estimation},\n   author={M. Cosovic, O. Kundacina, M. Delalic, A. Teskeredzic, D. Raca,\n           A. Mesanovic, D. Miskovic, D. Vukobratovic, A. Monti},\n   journal={arXiv preprint arXiv:2502.18229},\n   year={2025}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Contributors","page":"Introduction","title":"Contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Ognjen Kundacina - The Institute for Artificial Intelligence Research and Development of Serbia\nMuhamed Delalic - University of Sarajevo, Bosnia and Herzegovina\nArmin Teskeredzic - RWTH Aachen University, Germany\nMirsad Cosovic - University of Sarajevo, Bosnia and Herzegovina","category":"page"},{"location":"background/installation/#InstallationGuide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"JuliaGrid is compatible with Julia version 1.9 and later. To get started with JuliaGrid, users should first install Julia and consider using a code editor for a smoother coding experience.","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"","category":"page"},{"location":"background/installation/#Install-Julia","page":"Installation Guide","title":"Install Julia","text":"","category":"section"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"Begin by downloading and installing Julia. We can choose either the Current Stable Release or the Long-term Support Release.","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"The Current Stable Release is the most recent version of Julia, providing access to the latest features and typically offering better performance. For most users, we recommend installing the Current Stable Release. The Long-term Support Release is an older version of Julia that has continued to receive bug and security fixes. However, it may not have the latest features or performance improvements.","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"","category":"page"},{"location":"background/installation/#Install-Code-Editor","page":"Installation Guide","title":"Install Code Editor","text":"","category":"section"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"For a smoother development experience, we recommend using a code editor. While you can write Julia code in any text editor, using an integrated development environment (IDE) makes coding easier and more efficient. We suggest installing Visual Studio Code, which provides excellent support for Julia through its dedicated Julia extension. Visual Studio Code offers features like syntax highlighting, debugging, and autocompletion, making it an ideal choice for both beginners and experienced users.","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"The Julia extension for Visual Studio Code includes built-in dynamic autocompletion, inline results, plot pane, integrated REPL, variable view, code navigation, and many other advanced language features.  For a step-by-step guide on how to use Julia in Visual Studio Code, you can follow the tutorial available here.","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"","category":"page"},{"location":"background/installation/#Install-JuliaGrid","page":"Installation Guide","title":"Install JuliaGrid","text":"","category":"section"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"To get the JuliaGrid package installed, execute the following Julia command:","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"JuliaGrid\")","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"When a new version of JuliaGrid is released, you can update it with the following command:","category":"page"},{"location":"background/installation/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.update(\"JuliaGrid\")","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowTutorials","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To begin, let us generate the PowerSystem type, as illustrated by the following example:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, Ipopt\n@default(unit) # hide\n@default(template) # hide\n\n@config(label = Integer)\n\nsystem = powerSystem()\n\n@bus(minMagnitude = 0.95, maxMagnitude = 1.05)\naddBus!(system; label = 1, type = 3, active = 0.1, angle = -0.1)\naddBus!(system; label = 2, reactive = 0.01, magnitude = 1.1)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi, reactance = 0.5, type = 1)\naddBranch!(system; label = 1, from = 1, to = 2, maxFromBus = 0.15, maxToBus = 0.15)\n\n@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1)\naddGenerator!(system; label = 1, bus = 1, active = 0.4, reactive = 0.2)\naddGenerator!(system; label = 2, bus = 2, active = 0.2, reactive = 0.1)\n\ncost!(system; generator = 1, active = 2, polynomial = [900.0; 500.0; 80.0; 5.0])\ncost!(system; generator = 2, active = 1, piecewise =  [10.8 12.3; 14.7 16.8; 18 18.1])\n\ncost!(system; generator = 1, reactive = 1, piecewise = [10.0 20.0; 20.0 40.0])\ncost!(system; generator = 2, reactive = 2, polynomial = [2.0])\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Moreover, we identify the set of generators as mathcalS = 1 dots n_mathrmg within the power system:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝒮 = collect(keys(system.generator.label))","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"ukw: Notation\nHere, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i represents the element related with bus i in mathcalN or generator i in mathcalS, while a_ij denotes the element related with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowModelTutorials","page":"AC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the AC optimal power flow model, the active and reactive power outputs of the generators, denoted as mathbf P_mathrmg = P_mathrmgi and mathbf Q_mathrmg = Q_mathrmgi, where i in mathcal S, are expressed as nonlinear functions of the bus voltage magnitudes and angles, denoted as mathbf V = V_i and bmTheta = theta_i, where i in mathcal N. Consequently, the optimization variables encompass the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The AC optimal power flow problem can be formulated as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n     textminimize    sum_i in mathcal S leftf_i(P_mathrmgi) + f_i(Q_mathrmgi) right 10pt\n     textsubject to   -4pt\n        left\n    beginaligned\n         theta_i - theta_mathrms = 0\n    endaligned\n    phantom\n    right i in mathcalN_mathrmsb -1pt\n       left\n    beginaligned\n         h_P_i(mathbf P_mathrmg mathbf V bm Theta) = 0  \n         h_Q_i(mathbf Q_mathrmg mathbf V bm Theta) = 0  \n         V_i^mathrmmin leq V_i leq V_i^mathrmmax\n    endaligned\n    phantom\n    right i in mathcal N 8pt\n        left\n    beginaligned\n         theta_ij^mathrmmin leq theta_i - theta_j leq theta_ij^mathrmmax  \n         F_ij^mathrmmin leq h_ij(mathbf V bm Theta) leq F_ij^mathrmmax  \n         F_ji^mathrmmin leq h_ji(mathbf V bm Theta) leq F_ji^mathrmmax\n    endaligned\n    phantom\n    right (ij) in mathcal E 8pt\n        left\n    beginaligned\n         P_mathrmgi^mathrmmin leq P_mathrmgi leq P_mathrmgi^mathrmmax  \n         Q_mathrmgi^mathrmmin leq Q_mathrmgi leq Q_mathrmgi^mathrmmax\n    endaligned\n    phantom\n    right i in mathcal S\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In essence, the AC optimal power flow aims to minimize the objective function associated with the costs of generator's active and reactive power output while ensuring the fulfillment of all constraints. This optimization task plays a pivotal role in effectively managing electrical power systems. By striking a balance between cost reduction and constraint adherence, the AC optimal power flow contributes to efficient and reliable electricity supply in complex grid environments.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Build-Optimal-Power-Flow-Model","page":"AC Optimal Power Flow","title":"Build Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To build the AC optimal power flow model, we must first load the power system and establish the AC model:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"acModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Afterward, the AC optimal power flow model is created using the acOptimalPowerFlow function:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis = acOptimalPowerFlow(\n  system, Ipopt.Optimizer; active = \"Pg\", reactive = \"Qg\", magnitude = \"V\", angle = \"θ\"\n)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Optimization-Variables","page":"AC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The variables within this model encompass the active and reactive power outputs of the generators, denoted as mathbf P_mathrmg = P_mathrmgi and mathbf Q_mathrmg = Q_mathrmgi, where i in mathcal S, and the bus voltage magnitudes and angles represented by mathbf V = V_i and bm Theta = theta_i, where i in mathcal N. We can access these variables using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₒ = analysis.method.variable.power.active\n𝐐ₒ = analysis.method.variable.power.reactive\n𝐕 = analysis.method.variable.voltage.magnitude\n𝚯 = analysis.method.variable.voltage.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Objective-Function","page":"AC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The objective function represents the sum of the active and reactive power cost functions f_i(P_mathrmgi) and f_i(Q_mathrmgi), where i in mathcal S, for each generator, where these cost functions can be polynomial or piecewise linear. Typically, the AC optimal power flow focuses on minimizing the cost of active power outputs only, but for comprehensive analysis, we also consider the costs associated with reactive power outputs.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Polynomial-Cost-Function","page":"AC Optimal Power Flow","title":"Polynomial Cost Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the following analysis, we will focus on the cost function of generating active power, denoted as f_i(P_mathrmgi). However, please note that the same analysis can be applied to the cost function f_i(Q_mathrmgi) for reactive power.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the AC optimal power flow, the cost function f_i(P_mathrmgi) can be represented as an m-th degree polynomial:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"f_i(P_mathrmgi) = sum_k=0^m a_k P_mathrmgi^k","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Typically, cost functions are represented as linear, quadratic, or cubic, as shown in Figure 1:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n  f_i(P_mathrmgi) = a_1 P_mathrmgi + a_0 \n  f_i(P_mathrmgi) = a_2 P_mathrmgi^2 + a_1 P_mathrmgi + a_0 \n  f_i(P_mathrmgi) = a_3 P_mathrmgi^3 + a_2 P_mathrmgi^2 + a_1P_mathrmgi + a_0 \nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item-three\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_linear.svg\" width=\"85%\" class=\"my-svg\"/>\n        <p>(a) The linear function.</p>\n    </div>\n    <div class=\"image-item-three\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_quadratic.svg\" width=\"85%\" class=\"my-svg\"/>\n        <p>(b) The quadratic function.</p>\n    </div>\n    <div class=\"image-item-three\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_cubic.svg\" width=\"85%\" class=\"my-svg\"/>\n        <p>(c) The cubic function.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 1: Different types of polynomial cost functions that are typically used.\n    </p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"When using the cost! function in JuliaGrid and specifying the polynomial keyword, the polynomial is constructed with coefficients arranged in descending order of their degrees, from the highest degree to the lowest. For example, in the case study provided, we generated a cubic polynomial cost function for the active output power of Generator 1, which is represented as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n  f_1(P_mathrmg1) = 900 P_mathrmg1^3 + 500 P_mathrmg1^2 + 80 P_mathrmg1 + 5\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To access these coefficients, users can utilize the variable:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"f₁ = system.generator.cost.active.polynomial[1]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Piecewise-Linear-Cost-Function","page":"AC Optimal Power Flow","title":"Piecewise Linear Cost Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The second option for defining cost functions in the AC optimal power flow is to use piecewise linear functions as approximations of the polynomial functions, as illustrated in Figure 2.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item-three\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_one.svg\" width=\"85%\" class=\"my-svg\"/>\n        <p>(a) One-segment function.</p>\n    </div>\n    <div class=\"image-item-three\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_two.svg\" width=\"85%\" class=\"my-svg\"/>\n        <p>(b) Two-segment function.</p>\n    </div>\n    <div class=\"image-item-three\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_three.svg\" width=\"85%\" class=\"my-svg\"/>\n        <p>(c) Three-segment function.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 2: Different types of piecewise linear cost functions that are typically used.\n    </p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To define piecewise linear functions in JuliaGrid, users can utilize the cost! function with the piecewise keyword. The piecewise linear function is constructed using a matrix where each row defines a single point. The first column holds the generator's active or reactive power output, while the second column corresponds to the associated cost value. For example, in the provided case study, a piecewise linear function is created and can be accessed as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"f₂ = system.generator.cost.active.piecewise[2]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid handles convex piecewise linear functions using a constrained cost variable method. In this approach, the piecewise linear cost function is replaced by a helper variable and a set of linear inequality constraints for each segment of the function defined by two neighboring points along the line. However, for piecewise linear functions that have only one segment defined by two points, JuliaGrid transforms it into a standard linear function without introducing a helper variable.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Hence, for a piecewise cost function denoted as f_i(P_mathrmgi) with k segments (where k  1), the j-th segment, defined by the points P_mathrmgij f_i(P_mathrmgij) and P_mathrmgij+1 f_i(P_mathrmgij+1), is characterized by the following inequality constraints:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"cfracf_i(P_mathrmgij+1) - f_i(P_mathrmgij)P_mathrmgij+1 - P_mathrmgij(P_mathrmgi - P_mathrmgij) + f_i(P_mathrmgij) leq H_i  i in mathcalS  j = 1dotsk","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where H_i represents the helper variable. To finalize this method, we simply need to include the helper variable H_i in the objective function. This approach efficiently handles piecewise linear cost functions, providing the flexibility to capture nonlinear characteristics while still benefiting from the advantages of linear optimization techniques.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As an example, in the provided case study, the helper variable is defined as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"H₂ = analysis.method.variable.power.actwise[2]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Lastly, the set of constraints introduced by the piecewise linear cost function is displayed as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.piecewise.active)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Objective-Function-2","page":"AC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As previously explained, the objective function relies on the defined polynomial or piecewise linear cost functions and represents the sum of these costs. In the provided example, the objective function that must be minimized to obtain the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes and angles can be accessed using the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.method.jump)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Constraint-Functions","page":"AC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the following section, we will examine the various constraints defined within the AC optimal power flow model.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Slack-Bus-Constraint","page":"AC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as theta_i is fixed to a constant value theta_mathrms. It can be expressed as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"theta_i - theta_mathrms = 0 i in mathcalN_mathrmsb","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where the set mathcalN_mathrmsb contains the index of the slack bus. To access the equality constraint from the model, we can utilize the variable:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.slack.angle)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Bus-Power-Balance-Constraints","page":"AC Optimal Power Flow","title":"Bus Power Balance Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The second equality constraint in the optimization problem is associated with the active power balance equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\nh_P_i(mathbf P_mathrmg mathbf V bm Theta) = 0  i in mathcal N\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As elaborated in the Bus Injections section, we can express the equation as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"h_P_i(mathbf P_mathrmg mathbf V bm Theta) = V_i sumlimits_j=1^n (G_ijcostheta_ij + B_ijsintheta_ij) V_j - sum_k in mathcalS_i P_mathrmgk + P_mathrmdi","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this equation, the set mathcalS_i subseteq mathcal S encompasses all generators connected to bus i in mathcal N, and P_mathrmgk represents the active power output of the k-th generator within the set mathcalS_i. More precisely, the variable P_mathrmgk represents the optimization variable, along with the bus voltage angles theta_ij = theta_i - theta_j and the bus voltage magnitudes V_i and V_j.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constant term is determined by the active power demand P_mathrmdi at bus i in mathcalN. The values representing this constant term, denoted as mathbfP_mathrmd = P_mathrmdi can be accessed using the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₒ = system.bus.demand.active","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can access the references to the active power balance constraints using the following snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.balance.active)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the next constraint in the optimization problem is associated with the reactive power balance equation:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\nh_Q_i(mathbf Q_mathrmg mathbf V bm Theta) = 0 i in mathcal N\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As elaborated in the Bus Injections section, we can express the equation as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"h_Q_i(mathbf Q_mathrmg mathbf V bm Theta ) = V_i sumlimits_j=1^n (G_ijsintheta_ij - B_ijcostheta_ij) V_j - sum_k in mathcalS_i Q_mathrmgk + Q_mathrmdi","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As mentioned earlier for active power, Q_mathrmgk represents the reactive power output of the k-th generator within the set mathcalS_i. The variable Q_mathrmgk serves as an optimization variable, as well as the bus voltage angles theta_ij = theta_i - theta_j, and the bus voltage magnitudes V_i and V_j.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constant term is determined by the reactive power demand Q_mathrmdi at bus i in mathcalN. The values representing this constant term, denoted as mathbfQ_mathrmd = Q_mathrmdi can be accessed using the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐐ₒ = system.bus.demand.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can access the references to the reactive power balance constraints using the following snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.balance.reactive)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Bus-Voltage-Constraints","page":"AC Optimal Power Flow","title":"Bus Voltage Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The inequality constraints associated with the voltage magnitude ensure that the bus voltage magnitudes are within specified limits:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"V_i^mathrmmin leq V_i leq V_i^mathrmmax i in mathcal N","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where V_i^mathrmmin represents the minimum voltage magnitude, and V_i^mathrmmax represents the maximum voltage magnitude for bus i in mathcal N. The values representing these voltage magnitude limits, denoted as mathbf V_mathrmlm = V_i^mathrmmin V_i^mathrmmax can be accessed using the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐕ₗₘ = [system.bus.voltage.minMagnitude system.bus.voltage.maxMagnitude]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To retrieve this inequality constraint from the model, we can use the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.voltage.magnitude)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The inequality constraint related to the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch is defined as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"theta_ij^mathrmmin leq theta_i - theta_j leq theta_ij^mathrmmax (ij) in mathcalE","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where theta_ij^mathrmmin represents the minimum, while theta_ij^mathrmmax represents the maximum of the angle difference between adjacent buses of the branch (ij) in mathcalE. The values representing the voltage angle difference, denoted as bm Theta_mathrmlm = theta_ij^mathrmmin theta_ij^mathrmmax, are provided as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝚯ₗₘ = [system.branch.voltage.minDiffAngle system.branch.voltage.maxDiffAngle]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To retrieve this inequality constraint from the model, we can use the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.voltage.angle)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Branch-Flow-Constraints","page":"AC Optimal Power Flow","title":"Branch Flow Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The inequality constraints related to the branch flows can be associated with the limits on apparent power flow, active power flow, or current magnitude at the from-bus and to-bus ends of each branch. The type of constraint applied is determined by the type keyword within the addBranch! function.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The type value defines the constraint as follows: type = 1 applies to active power flow; type = 2 and type = 3 apply to apparent power flow; and type = 4 and type = 5 apply to current magnitude. When type = 3 or type = 5 is selected, squared inequality constraints are used. These constraints typically provide a more numerically robust optimization problem but often result in slower convergence compared to the non-squared versions.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These constraints are mathematically expressed through the equations h_ij(mathbf V bm Theta) and h_ji(mathbf V bm Theta), representing the flow constraints at the from-bus and to-bus ends of each branch, respectively:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    F_ij^mathrmmin leq h_ij(mathbf V bm Theta) leq F_ij^mathrmmax (ij) in mathcalE \n    F_ji^mathrmmin leq h_ji(mathbf V bm Theta) leq F_ji^mathrmmax (ij) in mathcalE\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The branch flow limits at the from-bus and to-bus ends of the branch (ij) in mathcalE, denoted as mathbfF_mathrmf = F_ij^mathrmmin F_ij^mathrmmax and mathbfF_mathrmt = F_ji^mathrmmin F_ji^mathrmmax, can be retrieved as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐅ₒ = [system.branch.flow.minFromBus system.branch.flow.maxFromBus]\n𝐅ₜ = [system.branch.flow.minToBus system.branch.flow.maxToBus]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The first option is to define the limit keywords for active power flow constraints (type = 1) at the from-bus and to-bus ends of each branch:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"  beginaligned\n    h_ij(mathbf V bm Theta) = cfracg_ij + g_mathrmsijtau_ij^2 V_i^2 -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)right V_i V_j \n    h_ji(mathbf V bmTheta) = (g_ij + g_mathrmsij) V_j^2 -\n    cfrac1tau_ij leftg_ij cos(theta_ij - phi_ij) - b_ij sin(theta_ij- phi_ij)right V_i V_j\n  endaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In our example, we have chosen to utilize this type of flow constraints. To access the flow constraints of branches at the from-bus end, users can use the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.flow.from)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, to access the to-bus end flow constraints of branches users can use the following code snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.flow.to)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The second option applies constraints to the apparent power flow (type = 2). This constraint at the from-bus is specified as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    h_ij(mathbf V bm Theta) =\n    sqrtA_ij V_i^4 + B_ij V_i^2 V_j^2 - 2 C_ij cos(theta_ij - phi_ij) - D_ij sin(theta_ij - phi_ij) V_i^3 V_j","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"  begingathered\n    A_ij = cfrac(g_ij + g_mathrmsi)^2 + (b_ij + b_mathrmsi)^2tau_ij^4 \n    B_ij = cfracg_ij^2 + b_ij^2tau_ij^2 \n    C_ij = cfracg_ij(g_ij + g_mathrmsi) + b_ij(b_ij + b_mathrmsi)tau_ij^3 \n    D_ij = cfracg_ijb_mathrmsi - b_ijg_mathrmsitau_ij^3\n  endgathered","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Furthermore, this constraint at the to-bus is specified as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    h_ji(mathbf V bmTheta) =\n    sqrtA_ji V_j^4 + B_ji V_i^2 V_j^2 - 2 C_ji cos(theta_ij - phi_ij) + D_ji sin(theta_ij - phi_ij) V_i V_j^3  ","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"  begingathered\n    A_ji = (g_ij + g_mathrmsi)^2 + (b_ij + b_mathrmsi)^2 \n    B_ji = cfracg_ij^2 + b_ij^2tau_ij^2 \n    C_ji = cfracg_ij(g_ij + g_mathrmsi) + b_ij(b_ij + b_mathrmsi)tau_ij \n    D_ji = cfracg_ijb_mathrmsi - b_ijg_mathrmsitau_ij\n  endgathered","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"If users choose type = 3, it means that the equations are squared (i.e., the square root is omitted), and the limit values will also be squared accordingly.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The last option involves defining the limit keywords for current magnitude constraints (type = 4) at the from-bus and to-bus ends of each branch. In this case, the constraints are implemented as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"  beginaligned\n    h_ij(mathbf V bm Theta) = sqrtA_ijV_i^2 + B_ijV_j^2 - 2C_ij cos(theta_ij - phi_ij) - D_ijsin(theta_ij - phi_ij) V_iV_j \n    h_ji(mathbf V bm Theta) = sqrtA_jiV_j^2 + B_jiV_i^2 - 2C_ji cos(theta_ij - phi_ij) + D_jisin(theta_ij - phi_ij) V_iV_j\n  endaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"If users choose type = 5, it means that the equations are squared (i.e., the square root is omitted), and the limit values will also be squared accordingly.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACPowerCapabilityConstraintsTutorials","page":"AC Optimal Power Flow","title":"Generator Power Capability Constraints","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The next set of constraints pertains to the minimum and maximum limits of active and reactive power outputs of the generators. These constraints ensure that the power outputs of the generators remain within specified bounds:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"P_mathrmgi^mathrmmin leq P_mathrmgi leq P_mathrmgi^mathrmmax  i in mathcalS","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this representation, the lower and upper limits are determined by the vector mathbf P_mathrmm = P_mathrmgi^mathrmmin P_mathrmgi^mathrmmax, i in mathcalS. We can access these bounds using the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₘ = [system.generator.capability.minActive, system.generator.capability.maxActive]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To access these constraints, you can utilize the following snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.capability.active)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, constraints related to the minimum and maximum limits of reactive power outputs of the generators ensure that the reactive powers remain within specified boundaries:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Q_mathrmgi^mathrmmin leq Q_mathrmgi leq Q_mathrmgi^mathrmmax  i in mathcalS","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Thus, the lower and upper limits are determined by the vector mathbf Q_mathrmm = Q_mathrmgi^mathrmmin Q_mathrmgi^mathrmmax, i in mathcal S. We can access these bounds using the following:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐐ₘ = [system.generator.capability.minReactive system.generator.capability.maxReactive]","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To access these constraints, you can use the following snippet:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(analysis.method.constraint.capability.reactive)","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These capability limits of the generators define the feasible region, represented as a gray area in Figure 3, which forms the solution space for the active and reactive output powers of the generators.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/tutorials/acOptimalPowerFlow/pq_curve.svg\" width=\"350\" class=\"my-svg\"/>\n    <p>Figure 3: Feasible region defined by power capability constraints.</p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"However, this representation might not be the most accurate depiction of the generator's output power behavior. In reality, there exists a tradeoff between the active and reactive power outputs of the generators [9]. Specifically, when a generator operates at its maximum active power P_mathrmgi^mathrmmax, it may not be able to produce the maximum Q_mathrmgi^mathrmmax or minimum Q_mathrmgi^mathrmmin reactive power. To capture this tradeoff, we introduce the ability to include additional upper and lower constraints on the feasible region, leading to its reduction as shown in Figure 4.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/tutorials/acOptimalPowerFlow/pq_curve_sloped.svg\" width=\"350\" class=\"my-svg\"/>\n    <p>Figure 4: Feasible region defined by power capability and boundary constraints.</p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"If a user wishes to incorporate the tradeoff between active and reactive power outputs into the optimization model, they can define the points shown in Figure 4 within the addGenerator! function using the following keywords:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Keyword Coordinate\nlowActive P_mathrmgi^mathrmlow\nminLowReactive Q_mathrmgimathrmlow^mathrmmin\nmaxLowReactive Q_mathrmgimathrmlow^mathrmmax\nupActive P_mathrmgi^mathrmup\nminUpReactive Q_mathrmgimathrmup^mathrmmin\nmaxUpReactive Q_mathrmgimathrmup^mathrmmax","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"When using these points, JuliaGrid constructs two additional capability constraints per generator as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    (Q_mathrmgimathrmlow^mathrmmax - Q_mathrmgimathrmup^mathrmmax)P_mathrmgi +\n    (P_mathrmgi^mathrmup - P_mathrmgi^mathrmlow)Q_mathrmgi\n    leq (Q_mathrmgimathrmlow^mathrmmax - Q_mathrmgimathrmup^mathrmmax)P_mathrmgi^mathrmlow +\n    (P_mathrmgi^mathrmup - P_mathrmgi^mathrmlow)Q_mathrmgimathrmlow^mathrmmax \n    (Q_mathrmgimathrmup^mathrmmin - Q_mathrmgimathrmlow^mathrmmin)P_mathrmgi +\n    (P_mathrmgi^mathrmlow - P_mathrmgi^mathrmup)Q_mathrmgi\n    leq (Q_mathrmgimathrmup^mathrmmin - Q_mathrmgimathrmlow^mathrmmin)P_mathrmgi^mathrmlow +\n    (P_mathrmgi^mathrmlow - P_mathrmgi^mathrmup)Q_mathrmgimathrmlow^mathrmmin\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To ensure numerical stability, these constraints are normalized by introducing two scaling factors:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"beginaligned\n    s_1 = sqrt(Q_mathrmgimathrmlow^mathrmmax - Q_mathrmgimathrmup^mathrmmax)^2 +\n    (P_mathrmgi^mathrmup - P_mathrmgi^mathrmlow)^2\n    s_2 = sqrt(Q_mathrmgimathrmup^mathrmmin - Q_mathrmgimathrmlow^mathrmmin)^2 +\n    (P_mathrmgi^mathrmlow - P_mathrmgi^mathrmup)^2\nendaligned","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"When these constraints exist in the system, users can access them using the following variables:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis.method.constraint.capability.upper\nanalysis.method.constraint.capability.lower\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These additional capability constraints allow us to accurately represent the tradeoff between active and reactive power outputs of the generators while maintaining numerical stability.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowSolutionTutorials","page":"AC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the optimal values of active and reactive power outputs for generators and the bus voltage magnitudes and angles, the user needs to invoke the following function:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.set_silent(analysis.method.jump) # hide\nsolve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After solving the AC optimal power flow problem, you can retrieve the vectors of output active and reactive power for generators, denoted as mathbf P_mathrmg = P_mathrmgi and mathbf Q_mathrmg = Q_mathrmgi, where i in mathcal S, using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₒ = analysis.power.generator.active\n𝐐ₒ = analysis.power.generator.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the resulting bus voltage magnitudes and angles, represented by mathbf V = V_i and bm Theta = theta_i, where i in mathcal N, are stored in the vectors as follows:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By accessing these vectors, you can analyze and utilize the optimal power flow solution for further studies or operational decision-making in the power system.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#ACOptimalPowerAnalysisTutorials","page":"AC Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the power! function, which enables the calculation of powers associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses and branches:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Type Power Active Reactive\nBus Injections mathbf P = P_i mathbf Q = Q_i\nBus Generator injections mathbf P_mathrmp = P_mathrmpi mathbf Q_mathrmp = Q_mathrmpi\nBus Shunt elements mathbf P_mathrmsh = P_mathrmshi mathbf Q_mathrmsh = Q_mathrmshi\nBranch From-bus end flows mathbf P_mathrmi = P_ij mathbf Q_mathrmi = Q_ij\nBranch To-bus end flows mathbf P_mathrmj = P_ji mathbf Q_mathrmj = Q_ji\nBranch Shunt elements mathbf P_mathrms = P_mathrmsij mathbf Q_mathrms = Q_mathrmsij\nBranch Series elements mathbf P_mathrml = P_mathrmlij mathbf Q_mathrml = Q_mathrmlij\n   ","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Power-Injections","page":"AC Optimal Power Flow","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Active and reactive power injections are stored as the vectors mathbf P = P_i and mathbf Q = Q_i, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏 = analysis.power.injection.active\n𝐐 = analysis.power.injection.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#OptGeneratorPowerInjectionsManual","page":"AC Optimal Power Flow","title":"Generator Power Injections","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The power! function in JuliaGrid also provides the computation of active and reactive power injections from the generators at each bus. To calculate the active power supplied by generators to the buses, one can simply sum the active power outputs of the generators obtained from the AC optimal power flow. This can be represented as:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    P_mathrmpi = sum_k in mathcal S_i P_mathrmgk i in mathcal N","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"where the set mathcalS_i subseteq mathcal S encompasses all generators connected to bus i in mathcal N. The active power injections from the generators at each bus are stored as a vector denoted by mathbf P_mathrmp = P_mathrmpi, and can be obtained using:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₚ = analysis.power.supply.active","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, we can obtain the reactive power supplied by generators to the buses:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"    Q_mathrmpi = sum_k in mathcal S_i Q_mathrmgk i in mathcal N","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The vector of these reactive power injections by the generators to the buses, denoted by mathbf Q_mathrmp = Q_mathrmpi, can be retrieved using the following command:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐐ₚ = analysis.power.supply.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Power-at-Bus-Shunt-Elements","page":"AC Optimal Power Flow","title":"Power at Bus Shunt Elements","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Active and reactive powers associated with the shunt elements at each bus are represented by the vectors mathbf P_mathrmsh = P_mathrmshi and mathbf Q_mathrmsh = Q_mathrmshi. To retrieve these powers in JuliaGrid, use the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₛₕ = analysis.power.shunt.active\n𝐐ₛₕ = analysis.power.shunt.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Power-Flows","page":"AC Optimal Power Flow","title":"Power Flows","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The resulting active and reactive power flows at each from-bus end are stored as the vectors mathbf P_mathrmi = P_ij and mathbf Q_mathrmi = Q_ij respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ᵢ = analysis.power.from.active\n𝐐ᵢ = analysis.power.from.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the vectors of active and reactive power flows at each to-bus end are stored as mathbf P_mathrmj = P_ji and mathbf Q_mathrmj = Q_ji, respectively, and can be retrieved using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ⱼ = analysis.power.to.active\n𝐐ⱼ = analysis.power.to.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Power-at-Branch-Shunt-Elements","page":"AC Optimal Power Flow","title":"Power at Branch Shunt Elements","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Active and reactive powers associated with the branch shunt elements at each branch are represented by the vectors mathbf P_mathrms = P_mathrmsij and mathbf Q_mathrms = Q_mathrmsij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₛ = analysis.power.charging.active\n𝐐ₛ = analysis.power.charging.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Power-at-Branch-Series-Elements","page":"AC Optimal Power Flow","title":"Power at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Active and reactive powers associated with the branch series element at each branch are represented by the vectors mathbf P_mathrml = P_mathrmlij and mathbf Q_mathrml = Q_mathrmlij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐏ₗ = analysis.power.series.active\n𝐐ₗ = analysis.power.series.reactive","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-Analysis","page":"AC Optimal Power Flow","title":"Current Analysis","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid offers the current! function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"current!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Type Current Magnitude Angle\nBus Injections mathbf I = I_i bm psi = psi_i\nBranch From-bus end flows mathbf I_mathrmi = I_ij bm psi_mathrmi = psi_ij\nBranch To-bus end flows mathbf I_mathrmj = I_ji bm psi_mathrmj = psi_ji\nBranch Series elements mathbf I_mathrml = I_mathrmlij bm psi_mathrml = psi_mathrmlij\n   ","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-Injections","page":"AC Optimal Power Flow","title":"Current Injections","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In JuliaGrid, complex current injections are stored in the vector of magnitudes denoted as mathbf I = I_i and the vector of angles represented as bm psi = psi_i. You can retrieve them using the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈 = analysis.current.injection.magnitude\n𝛙 = analysis.current.injection.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-Flows","page":"AC Optimal Power Flow","title":"Current Flows","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the vectors of magnitudes mathbf I_mathrmi = I_ij and angles bm psi_mathrmi = psi_ij for the resulting complex current flows, you can use the following commands:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈ᵢ = analysis.current.from.magnitude\n𝛙ᵢ = analysis.current.from.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, we can obtain the vectors of magnitudes mathbf I_mathrmj = I_ji and angles bm psi_mathrmj = psi_ji of the resulting complex current flows using the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈ⱼ = analysis.current.to.magnitude\n𝛙ⱼ = analysis.current.to.angle","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/acOptimalPowerFlow/#Current-at-Branch-Series-Elements","page":"AC Optimal Power Flow","title":"Current at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the vectors of magnitudes mathbf I_mathrml = I_mathrmlij and angles bm psi_mathrml = psi_mathrmlij of the resulting complex current flows, one can use the following code:","category":"page"},{"location":"tutorials/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"𝐈ₗ = analysis.current.series.magnitude\n𝛙ₗ = analysis.current.series.angle","category":"page"},{"location":"manual/observabilityAnalysis/#ObservabilityAnalysisManual","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Observability analysis can typically be performed prior to executing the state estimation algorithm, and its primary task is to ensure the existence of a unique state estimator. In other words, the system of equations used in the state estimation algorithm should be solvable.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Traditionally, observability analysis, which involves identifying observable islands and restoring observability using set of pseudo-measurements, can be performed before both AC and DC state estimation. In this context, users can detect two types of observable islands: flow islands and maximal islands:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islandTopologicalFlow,\nislandTopological.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Once observable islands are identified, observability can be restored by applying:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"restorationGram!.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Additionally, the optimal PMU placement algorithm can also be viewed from the perspective of observability, as it determines the minimal set of PMUs required to make the system observable and guarantee a unique solution in AC and PMU state estimation, regardless of other measurements:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"pmuPlacement.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"manual/observabilityAnalysis/#Identification-of-Observable-Islands","page":"Observability Analysis","title":"Identification of Observable Islands","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The first step in the process is to define observable islands. JuliaGrid offers two distinct options for identifying these islands: flow-observable islands and maximal-observable islands. The choice depends on the power system's structure and available measurements. Identifying only flow-observable islands simplifies the island detection process but makes the restoration function more complex.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Let us begin by defining a power system with measurements at specific locations:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\naddBus!(system; label = \"Bus 4\")\naddBus!(system; label = \"Bus 5\")\naddBus!(system; label = \"Bus 6\")\naddBus!(system; label = \"Bus 7\")\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.002)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 5\", reactance = 0.02)\naddBranch!(system; label = \"Branch 4\", from = \"Bus 3\", to = \"Bus 4\", reactance = 0.03)\naddBranch!(system; label = \"Branch 5\", from = \"Bus 5\", to = \"Bus 6\", reactance = 0.05)\naddBranch!(system; label = \"Branch 6\", from = \"Bus 3\", to = \"Bus 5\", reactance = 0.05)\naddBranch!(system; label = \"Branch 7\", from = \"Bus 6\", to = \"Bus 7\", reactance = 0.05)\n\naddWattmeter!(monitoring; label = \"Wattmeter 1\", from = \"Branch 1\", active = 1.15)\naddVarmeter!(monitoring; label = \"Varmeter 1\", from = \"Branch 1\", reactive = -0.50)\n\naddWattmeter!(monitoring; label = \"Wattmeter 2\", from = \"Branch 4\", active = 0.20)\naddVarmeter!(monitoring; label = \"Varmeter 2\", from = \"Branch 4\", reactive = -0.02)\n\naddWattmeter!(monitoring; label = \"Wattmeter 3\", from = \"Branch 5\", active = -0.20)\naddVarmeter!(monitoring; label = \"Varmeter 3\", from = \"Branch 5\", reactive = 0.02)\n\naddWattmeter!(monitoring; label = \"Wattmeter 4\", bus = \"Bus 2\", active = -0.1)\naddVarmeter!(monitoring; label = \"Varmeter 4\", bus = \"Bus 2\", reactive = -0.01)\n\naddWattmeter!(monitoring; label = \"Wattmeter 5\", bus = \"Bus 3\", active = -0.30)\naddVarmeter!(monitoring; label = \"Varmeter 5\", bus = \"Bus 3\", reactive = 0.66)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Attempting to solve this system directly using AC or DC state estimation may not be feasible, as the gain matrix would be singular. To prevent this issue, users can first conduct an observability analysis.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"JuliaGrid employs standard observability analysis performed on the linear decoupled measurement model. Active power measurements from wattmeters are utilized to estimate bus voltage angles, while reactive power measurements from varmeters are used to estimate bus voltage magnitudes. This necessitates that measurements of active and reactive power come in pairs.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"note: Info\nWe suggest that readers refer to the tutorial on Observability Analysis for insights into the implementation.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"manual/observabilityAnalysis/#Flow-Observable-Islands","page":"Observability Analysis","title":"Flow-Observable Islands","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Now, let us identify flow-observable islands:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopologicalFlow(monitoring)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"As a result, four flow-observable islands are identified: Bus 1 and Bus 2 form the first island, Bus 3 and Bus 4 form the second island, Bus 5 and Bus 6 constitute the third island, while Bus 7 forms the fourth island:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.island\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"manual/observabilityAnalysis/#Maximal-Observable-Islands","page":"Observability Analysis","title":"Maximal-Observable Islands","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Following that, we will instruct the user on obtaining maximal-observable islands:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopological(monitoring)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The outcome reveals the identification of two maximal-observable islands:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.island\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"It is evident that upon comparing this result with the flow-observable islands, the merging of the two injection measurements at Bus 2 and Bus 3 consolidated the first, second, and third flow-observable islands into a single island.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"manual/observabilityAnalysis/#Observability-Restoration","page":"Observability Analysis","title":"Observability Restoration","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Before commencing the restoration of observability in the context of the linear decoupled measurement model and observability analysis, it is imperative to ensure that the system possesses one bus voltage magnitude measurement. This necessity arises from the fact that observable islands are identified based on wattmeters, where wattmeters are tasked with estimating voltage angles. Since one voltage angle is already known from the slack bus, the same principle should be applied to bus voltage magnitudes. Therefore, to address this requirement, we add:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"addVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 1.0)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Subsequently, the user needs to establish a set of pseudo-measurements, where measurements must come in pairs as well. Let us create that set:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"pseudo = measurement(system)\n\naddWattmeter!(pseudo; label = \"Pseudo-Wattmeter 1\", bus = \"Bus 1\", active = 0.31)\naddVarmeter!(pseudo; label = \"Pseudo-Varmeter 1\", bus = \"Bus 1\", reactive = -0.19)\n\naddWattmeter!(pseudo; label = \"Pseudo-Wattmeter 2\", from = \"Branch 7\", active = 0.10)\naddVarmeter!(pseudo; label = \"Pseudo-Varmeter 2\", from = \"Branch 7\", reactive = 0.01)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"note: Info\nThe labels for specific pseudo-measurements must differ from those defined in the measurements stored in the monitoring set. This is necessary because the next step involves adding pseudo-measurements to the monitoring set.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Subsequently, the user can execute the restorationGram! function:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"restorationGram!(monitoring, pseudo, islands)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"This function attempts to restore observability using pseudo-measurements. As a result, the inclusion of measurements from Pseudo-Wattmeter 2 and Pseudo-Varmeter 2 facilitates observability restoration, and these measurements are subsequently added to the monitoring variable:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"monitoring.wattmeter.label\nmonitoring.varmeter.label\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Consequently, the power system becomes observable, allowing the user to proceed with forming the AC state estimation model and solving it. Ensuring the observability of the system does not guarantee obtaining accurate estimates of the state variables. Numerical ill-conditioning may adversely impact the state estimation algorithm. However, in most cases, efficient estimation becomes feasible when the system is observable [3].","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"It is also important to note that restoration may face challenges if an inappropriate zero pivot threshold value is selected. By default, this threshold is set to 1e-5, but it can be adjusted using the restorationGram! function.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"note: Info\nDuring the restoration step, if users define bus phasor measurements, these measurements will be considered. Consequently, the system may achieve observability even if multiple islands persist.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"manual/observabilityAnalysis/#Optimal-PMU-Placement","page":"Observability Analysis","title":"Optimal PMU Placement","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"First, we define the power system:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"manual/observabilityAnalysis/#Optimal-Solution","page":"Observability Analysis","title":"Optimal Solution","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Upon defining the PowerSystem type, JuliaGrid provides the possibility to determine the minimal number of PMUs required for system observability using the pmuPlacement function:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"using GLPK\n\nplacement = pmuPlacement(system, GLPK.Optimizer; verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The placement variable contains data regarding the optimal placement of measurements. In this instance, installing a PMU at Bus 2 renders the system observable:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"keys(placement.bus)","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"This PMU installed at Bus 2 will measure the bus voltage phasor at the corresponding bus and all current phasors at the branches incident to Bus 2 located at the from-bus or to-bus ends:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"keys(placement.from)\nkeys(placement.to)","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"note: Info\nWe suggest that readers refer to the tutorial on Optimal PMU Placement for insights into the implementation.","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"manual/observabilityAnalysis/#Phasor-Measurements","page":"Observability Analysis","title":"Phasor Measurements","text":"","category":"section"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Using the obtained data, phasor measurements can be created to provide a unique state estimator for both AC and PMU state estimation:","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"monitoring = measurement(system)\n\naddPmu!(monitoring; bus = \"Bus 2\", magnitude = 1.02, angle = 0.01)\naddPmu!(monitoring; from = \"Branch 3\", magnitude = 0.49, angle = 0.07)\naddPmu!(monitoring; to = \"Branch 1\", magnitude = 0.47, angle = -0.54)\naddPmu!(monitoring; to = \"Branch 2\", magnitude = 1.17, angle = 0.16)","category":"page"},{"location":"manual/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"note: Info\nFor different approaches to defining measurements after determining the optimal PMU placement, refer to the PMU State Estimation manual or the API documentation for the pmuPlacement! function.","category":"page"},{"location":"tutorials/observabilityAnalysis/#ACObservabilityAnalysisTutorials","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"section"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The state estimation algorithm aims to estimate the values of the state variables based on the measurement model described as a system of equations. Prior to applying the state estimation algorithm, the observability analysis determines the existence and uniqueness of the solution for the underlying system of equations.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Typical observability analysis, in cases where a unique solution is not guaranteed, identifies observable islands and prescribes an additional set of equations (pseudo-measurements) to ensure a unique solution [17]. In addition, optimal PMU placement can also be considered from an observability perspective, determining the placement of PMUs to achieve system observability using only phasor measurements.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"To initiate the process, let us construct the PowerSystem type:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n@config(label = Integer)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2)\naddBus!(system; label = 3)\naddBus!(system; label = 4)\naddBus!(system; label = 5)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05)\naddBranch!(system; label = 2, from = 2, to = 3, reactance = 0.01)\naddBranch!(system; label = 3, from = 2, to = 4, reactance = 0.02)\naddBranch!(system; label = 4, from = 3, to = 4, reactance = 0.03)\naddBranch!(system; label = 5, from = 4, to = 5, reactance = 0.05)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcal G = (mathcal N mathcal E), where we have the set of buses mathcal N = 1 dots n, and the set of branches mathcal E subseteq mathcal N times mathcal N within the power system:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"𝒩 = collect(keys(system.bus.label))\nℰ = hcat([𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]])","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"tutorials/observabilityAnalysis/#Identification-of-Observable-Islands","page":"Observability Analysis","title":"Identification of Observable Islands","text":"","category":"section"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"JuliaGrid employs standard observability analysis performed on the linear decoupled measurement model [14, Ch. 7]. Active power measurements from wattmeters are utilized to estimate bus voltage angles, while reactive power measurements from varmeters are used to estimate bus voltage magnitudes. This necessitates that measurements of active and reactive power come in pairs.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Let us illustrate this concept with the following example, where measurements form an unobservable system:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"monitoring = measurement(system)\n\naddWattmeter!(monitoring; label = 1, from = 1, active = 0.93)\naddVarmeter!(monitoring; label = 1, from = 1, reactive = -0.41)\n\naddWattmeter!(monitoring; label = 2, bus = 2, active = -0.1)\naddVarmeter!(monitoring; label = 2, bus = 2, reactive = -0.01)\n\naddWattmeter!(monitoring; label = 3, bus = 3, active = -0.30)\naddVarmeter!(monitoring; label = 3, bus = 3, reactive = 0.52)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"If the system lacks observability, the observability analysis needs to identify all potential observable islands that can be independently solved. An observable island is defined as follows: It is a segment of the power system where the flows across all branches within that island can be calculated solely from the available measurements. This independence holds regardless of the values chosen for the bus voltage angle at the slack bus [14, Sec. 7.1.1]. Within this context, two types of observable islands are evident:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"flow-observale islands,\nmaximal-observable islands.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The selection between them relies on the power system's structure and the available measurements. Opting for detecting only flow observable islands simplifies the island detection function's complexity but increases the complexity in the restoration function compared to identifying maximal-observable islands.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"tutorials/observabilityAnalysis/#Flow-Observale-Islands","page":"Observability Analysis","title":"Flow-Observale Islands","text":"","category":"section"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"To identify flow-observable islands, JuliaGrid employs a topological method outlined in [18]. The process begins with the examination of all active power flow measurements from wattmeters, aiming to determine the largest sets of connected buses within the network linked by branches with active power flow measurements. Subsequently, the analysis considers individual boundary or tie active power injection measurements, involving two islands that may potentially be merged into a single observable island. The user can initiate this process by calling the function:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopologicalFlow(monitoring)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"As a result, four flow-observable islands are identified. The first island includes buses 1 and 2, while the second, third, and fourth islands consist of buses 3, 4, and 5, respectively:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.island","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Additionally, users can inspect the tie buses and branches resulting from the observability analysis we conducted:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.tie.bus\nislands.tie.branch","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"This tie data will be utilized throughout the restoration step, where we introduce pseudo-measurements to merge the observable flow islands obtained.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"tutorials/observabilityAnalysis/#Maximal-Observale-Islands","page":"Observability Analysis","title":"Maximal-Observale Islands","text":"","category":"section"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"To identify maximal-observable islands, we extend the analysis with an additional processing step. After processing individual injection tie measurements, we are left with a series of injection measurements that are not entirely contained within any observable zone. In this set of remaining tie injections, we now examine pairs involving three and only three previously determined observable zones (including individual buses). If we find such a pair, the three islands will be merged, and all injection measurements related exclusively to these three islands are no longer considered. The procedure then restarts at the stage where we process tie active power injection measurements involving two and only two islands. If no mergers are possible with pairs, we then consider sets of three injection measurements involving four islands, and so on [18]. The user can initiate this by calling the function:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopological(monitoring)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The outcome reveals the identification of two maximal-observable islands:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.island","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Comparing this result with the flow-observable islands clearly shows that the injection measurements at buses 2 and 3 merge the first, second, and third flow-observable islands into a single island.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Here we can observe tie data:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.tie.bus\nislands.tie.branch","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Compared to the tie data obtained after detecting flow-observable islands, we now have a smaller set, indicating that the restoration step will be more computationally efficient.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"tutorials/observabilityAnalysis/#Observability-Restoration","page":"Observability Analysis","title":"Observability Restoration","text":"","category":"section"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Before commencing the restoration of observability in the context of the linear decoupled measurement model and observability analysis, it is imperative to ensure that the system possesses one bus voltage magnitude measurement. This necessity arises from the fact that observable islands are identified based on wattmeters, where wattmeters are tasked with estimating voltage angles. Since one voltage angle is already known from the slack bus, the same principle should be applied to bus voltage magnitudes. Therefore, to address this requirement, we add:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"addVoltmeter!(monitoring; bus = 1, magnitude = 1.0)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"After determining the islands, the observability analysis merges these islands in a manner that protect previously determined observable states from being altered by the new set of equations defined by the additional measurements, called pseudo-measurements. In general, this can be achieved by ensuring that the set of new measurements forms a non-redundant set [14, Sec. 7.3.2], i.e., the set of equations must be linearly independent with respect to the global system. The goal of observability restoration is to find this non-redundant set.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The outcome of the island detection step results in the power system being divided into m islands. Subsequently, we focus on the set of measurements mathcal M_mathrmr subset mathcal M, which exclusively consists of:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"active power injection measurements at tie buses,\nbus voltage phasor measurements.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"These measurements are retained from the phase where we identify observable islands, and are crucial in determining whether we need additional pseudo-measurements to be included in the measurement set mathcal M. In this specific example, we do not have active power injection measurements at tie buses remaining after the identification of maximal-observable islands. However, if we proceed with flow-observable islands to the restoration step, we will have two injection measurements at buses 2 and 3.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"However, let us introduce the matrix mathbf M_mathrmr in mathbbR^r times m, where r = mathcal M_mathrmr. This matrix can be conceptualized as the coefficient matrix of a reduced network, with m columns corresponding to islands and r rows associated with the set mathcal M_mathrmr. More precisely, if we construct the coefficient matrix mathbf H_mathrmr linked to the set mathcal M_mathrmr in the DC framework, the matrix mathbf M_mathrmr can be constructed by summing the columns of mathbf H_mathrmr that belong to a specific island [19].","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Subsequently, the user needs to establish a set of pseudo-measurements, where measurements must come in pairs as well. Let us create that set:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"pseudo = measurement(system)\n\naddWattmeter!(pseudo; label = 4, bus = 1, active = 0.93)\naddVarmeter!(pseudo; label = 4, bus = 1, reactive = -0.41)\n\naddWattmeter!(pseudo; label = 5, from = 5, active = 0.30)\naddVarmeter!(pseudo; label = 5, from = 5, reactive = 0.03)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"From this set, the restoration step will only utilize the following:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"active power flow measurements between tie buses,\nactive power injection measurements at tie buses,\nbus voltage phasor measurements.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"These pseudo-measurements mathcal M_mathrmp will define the reduced coefficient matrix mathbf M_mathrmp in mathbbR^p times m, where p = mathcal M_mathrmp. In this example, only the fifth wattmeter will contribute to the construction of the matrix mathbf M_mathrmp. Similar to the previous case, measurement functions linked to the set mathcal M_mathrmp define the coefficient matrix mathbf H_mathrmp, and the matrix mathbf M_mathrmp can be viewed as the sum of the columns of mathbf H_mathrmp belonging to a specific observable island.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Additionally, users have the option to include bus voltage angle measurements from PMUs. In this scenario, restoration can be conducted without merging observable islands into one island, as each island becomes globally observable when one angle is known. It is important to note that during the restoration step, JuliaGrid initially processes active power measurements and subsequently handles bus voltage angle measurements if they are present in the set of pseudo-measurements.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Users can execute the observability restoration procedure with the following:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"restorationGram!(monitoring, pseudo, islands; threshold = 1e-6)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The function constructs the reduced coefficient matrix as follows:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"  mathbf M = beginbmatrix mathbf M_textr  mathbf M_textp endbmatrix","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"and forms the corresponding Gram matrix:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"  mathbf D = mathbf M mathbf M^T","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The decomposition of mathbf D into its mathbf Q and mathbf R factors is achieved through QR factorization. Non-redundant measurements are identified by non-zero diagonal elements in mathbf R. Specifically, if the diagonal element satisfies:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"    R_ii  epsilon","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"JuliaGrid designates the corresponding measurement as redundant, where epsilon represents a pre-determined zero pivot threshold, set to 1e-6 in this example. The minimal set of pseudo-measurements for observability restoration corresponds to the non-zero diagonal elements at positions associated with the candidate pseudo-measurements. It is essential to note that an inappropriate choice of the zero pivot threshold may adversely affect observability restoration. Additionally, there is a possibility that the set of pseudo-measurements mathcalM_textp may not be sufficient for achieving observability restoration.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Finally, the fifth wattmeter, and consequently the fifth varmeter successfully restore observability, and these measurements are added to the monitoring variable, which stores actual measurements:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"monitoring.wattmeter.label\nmonitoring.varmeter.label","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Here, we can confirm that the new measurement set establishes the observable system formed by a single island:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopological(monitoring);\n\nislands.island","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"tutorials/observabilityAnalysis/#optimalpmu","page":"Observability Analysis","title":"Optimal PMU Placement","text":"","category":"section"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"JuliaGrid utilizes the optimal PMU placement algorithm proposed in [20]. The optimal positioning of PMUs is framed as an integer linear programming problem, expressed as:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"  beginaligned\n    textminimize  sum_i=1^n d_i\n    textsubjectto  sum_j=1^n a_ijd_j  i = 1 dots n\n  endaligned","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"where d_i in mathbbF = 01 is the PMU placement decision variable associated with bus i in mathcalN. The binary parameter a_ij in mathbbF indicates the connectivity of the power system network, where a_ij can be directly derived from the nodal admittance matrix by converting its entries into binary form [21]. This linear programming problem is implemented using JuMP package allowing compatibility with different type of optimization solvers.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Consequently, we obtain the binary vector mathbf d = d_1dotsd_n^T, where d_i = 1, i in mathcalN, suggests that a PMU should be placed at bus i. The primary aim of PMU placement in the power system is to determine a minimal set of PMUs such that the entire system is observable without relying on legacy measurements [20]. Specifically, when we observe d_i = 1, it indicates that the PMU is installed at bus i in mathcalN to measure bus voltage phasor as well as all current phasors across branches incident to bus i.","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Now, we will determine the optimal PMU placement for our power system:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"using HiGHS\n@default(unit) # hide\n\nplacement = pmuPlacement(system, HiGHS.Optimizer)\nnothing # hide","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The placement variable contains data regarding the optimal placement of measurements. It lists all buses i in mathcalN that satisfy d_i = 1:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"keys(placement.bus)","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The PMUs installed at buses 2 and 4 will measure the voltage phasors at these buses, along with all current phasors on the branches connected to them. These measurements are stored in the following variables:","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"keys(placement.from)\nkeys(placement.to)","category":"page"},{"location":"tutorials/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Consequently, the PMUs will measure the current phasors at the from-bus ends of branches 2, 3, and 5, as well as the current phasors at the to-bus ends of branches 1, 3, and 4.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowTutorials","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To begin, let us generate the PowerSystem  type, as illustrated by the following example:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, HiGHS\n@default(template) # hide\n@default(unit) # hide\n\n@config(label = Integer)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, angle = 0.17)\naddBus!(system; label = 2, type = 2, active = 0.1, conductance = 0.04)\naddBus!(system; label = 3, type = 1, active = 0.05)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.05, maxFromBus = 0.15)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.01, maxFromBus = 0.10)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.01, maxFromBus = 0.25)\n\n@generator(minActive = 0.0)\naddGenerator!(system; label = 1, bus = 1, active = 3.2, maxActive = 0.5)\naddGenerator!(system; label = 2, bus = 2, active = 0.2, maxActive = 0.3)\n\ncost!(system; generator = 1, active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; generator = 2, active = 1, piecewise =  [10.85 12.3; 14.77 16.8; 18 18.1])\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Moreover, we identify the set of generators as mathcalS = 1 dots n_textg within the power system:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝒮 = collect(keys(system.generator.label))","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"ukw: Notation\nHere, when referring to a vector mathbf a, we use the notation mathbf a = a_i or mathbf a = a_ij, where a_i represents the element related with bus i in mathcal N or generator i in mathcal S, while a_ij denotes the element related with branch (ij) in mathcal E.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowModelTutorials","page":"DC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the DC optimal power flow, the active power outputs of the generators mathbf P_mathrmg = P_mathrmgi, i in mathcal S, are represented as linear functions of the bus voltage angles bm Theta = theta_i, i in mathcal N. Thus, the optimization variables in this model are the active power outputs of the generators and the bus voltage angles.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The DC optimal power flow model has the form:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"beginaligned\n     textminimize    sum_i in mathcal S f_i(P_mathrmgi)  10pt\n     textsubject to   -4pt\n        left\n    beginaligned\n         theta_i - theta_mathrms = 0\n    endaligned\n    phantom\n    right i in mathcalN_mathrmsb -1pt\n       left\n    beginaligned\n         h_P_i(mathbf P_mathrmg bm Theta) = 0\n    endaligned\n    phantom\n    right i in mathcal N -1pt\n        left\n    beginaligned\n         theta_ij^mathrmmin leq theta_i - theta_j leq theta_ij^mathrmmax  \n         P_ij^mathrmmin leq h_P_ij(theta_i theta_j) leq P_ij^mathrmmax\n    endaligned\n    phantom\n    right (ij) in mathcal E 8pt\n        left\n    beginaligned\n         P_mathrmgi^mathrmmin leq P_mathrmgi leq P_mathrmgi^mathrmmax\n    endaligned\n    phantom\n    right i in mathcal S\nendaligned","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Essentially, the DC optimal power flow is focused on the minimization of the objective function related to the costs associated with the active power output of generators, all while ensuring the satisfaction of various constraints. This optimization task holds a crucial role in the efficient and timely management of electrical power systems. However, it is important to note that the solutions provided by the DC optimal power flow are approximate in nature.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Build-Optimal-Power-Flow-Model","page":"DC Optimal Power Flow","title":"Build Optimal Power Flow Model","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To build the DC optimal power flow model, we must first load the power system and establish the DC model using:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Afterward, the DC optimal power flow model is created using the dcOptimalPowerFlow function:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"analysis = dcOptimalPowerFlow(system, HiGHS.Optimizer; active = \"Pg\", angle = \"θ\")\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Optimization-Variables","page":"DC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Hence, the variables in this model encompass the active power outputs of the generators denoted as mathbf P_mathrmg = P_mathrmgi, where i in mathcal S, and the bus voltage angles represented by bm Theta = theta_i, where i in mathcal N. Users can access these variables using the following:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₒ = analysis.method.variable.power.active\n𝚯 = analysis.method.variable.voltage.angle","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Objective-Function","page":"DC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The objective function represents the sum of the active power cost functions f_i(P_mathrmgi), i in mathcal S, for each generator, where these cost functions can be polynomial or piecewise linear functions. Only polynomial cost functions of up to the second degree are included in the objective. Specifically, if a higher-degree polynomial is provided, JuliaGrid will discard all terms beyond the second degree and still include the resulting truncated polynomial in the objective function.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Polynomial-Active-Power-Cost-Function","page":"DC Optimal Power Flow","title":"Polynomial Active Power Cost Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The DC optimal power flow in JuliaGrid allows the cost function f_i(P_mathrmgi) to be represented as a polynomial of up to the second degree, making it possible to express the cost function as linear or quadratic. The possible representations are as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"beginaligned\n    f_i(P_mathrmgi) = a_1 P_mathrmgi + a_0 \n    f_i(P_mathrmgi) = a_2 P_mathrmgi^2 + a_1 P_mathrmgi + a_0\nendaligned","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Furthermore, it is worth noting that the function can be given simply as a constant with only the coefficient a_0, which implies that the cost of the generator remains constant regardless of the active power outputs. In conclusion, as illustrated in Figure 1, typical scenarios involve linear or quadratic cost functions, resulting in a best-case scenario for a linear optimization problem and a worst-case scenario for a quadratic optimization problem.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_linear.svg\" width=\"65%\" class=\"my-svg\"/>\n        <p>(a) The linear function.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_quadratic.svg\" width=\"65%\" class=\"my-svg\"/>\n        <p>(b) The quadratic function.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 1: Different types of polynomial cost functions that are typically used.\n    </p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"When utilizing the cost! function within JuliaGrid, employing the polynomial keyword results in the polynomial being constructed with coefficients ordered from the highest degree to the lowest. For instance, in the provided case study, we created a quadratic polynomial represented as:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"beginaligned\n    f_1(P_mathrmg1) = 11002 P_mathrmg1^2 + 500 P_mathrmg1 + 80\nendaligned","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To access these coefficients, users can utilize the variable:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"f₁ = system.generator.cost.active.polynomial[1]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Piecewise-Linear-Active-Power-Cost-Function","page":"DC Optimal Power Flow","title":"Piecewise Linear Active Power Cost Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The DC optimal power flow in JuliaGrid offers another option for defining cost functions by using piecewise linear functions as approximations of the polynomial functions, as depicted in Figure 2.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"<div class=\"image-container\">\n    <div class=\"image-item\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_one.svg\" width=\"65%\" class=\"my-svg\"/>\n        <p>(a) One-segment function.</p>\n    </div>\n    <div class=\"image-item\">\n        <img src=\"../../assets/tutorials/acOptimalPowerFlow/cost_function_piecewise_two.svg\" width=\"65%\" class=\"my-svg\"/>\n        <p>(b) Two-segment function.</p>\n    </div>\n    <p style=\"text-align: center; margin-top: -5px;\">\n    Figure 2: Different types of piecewise linear cost functions that are typically used.\n    </p>\n</div>\n&nbsp;","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To define piecewise linear functions in JuliaGrid, users can utilize the cost! function with the piecewise keyword. The piecewise linear function is constructed using a matrix where each row defines a single point. The first column holds the generator's active power output, while the second column corresponds to the associated cost value. For example, in the provided case study, a piecewise linear function is created and can be accessed as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"f₂ = system.generator.cost.active.piecewise[2]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similar to how convex piecewise linear functions are treated in the AC Optimal Power Flow, JuliaGrid adopts a constrained cost variable method for the piecewise linear functions. In this method, the piecewise linear cost function is converted into a series of linear inequality constraints for each segment, which are defined by two adjacent points along the line, along with a helper variable specific to the piecewise function. However, for piecewise linear functions that have only one segment defined by two points, JuliaGrid simplifies it into a standard linear function without requiring a helper variable.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Consequently, for a piecewise cost function denoted as f_i(P_mathrmgi) with k segments (where k  1), the j-th segment, defined by the points P_mathrmgij f_i(P_mathrmgij) and P_mathrmgij+1 f_i(P_mathrmgij+1), is characterized by the following inequality constraints:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"cfracf_i(P_mathrmgij+1) - f_i(P_mathrmgij)P_mathrmgij+1 - P_mathrmgij\n(P_mathrmgi - P_mathrmgij) + f_i(P_mathrmgij) leq H_i  i in mathcal S  j = 1 dots k","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"where H_i represents the helper variable. To finalize this method, we simply need to include the helper variable H_i in the objective function. This approach efficiently handles piecewise linear cost functions, providing the flexibility to capture nonlinear characteristics while still benefiting from the advantages of linear optimization techniques.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As an example, in the provided case study, the helper variable is defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"H₂ = analysis.method.variable.power.actwise[2]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Lastly, the set of constraints introduced by the piecewise linear cost function is displayed as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.method.constraint.piecewise.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Objective-Function-2","page":"DC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As previously explained, the objective function relies on the defined polynomial or piecewise linear cost functions and represents the sum of these costs. In the provided example, the objective function that must be minimized to obtain the optimal values for the active power output of the generators and the bus voltage angles can be accessed using the following code:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.objective_function(analysis.method.jump)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Constraint-Functions","page":"DC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In the following section, we will examine the various constraints defined within the DC optimal power flow model.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Slack-Bus-Constraint","page":"DC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The first equality constraint is linked to the slack bus, where the bus voltage angle denoted as theta_i is fixed to a constant value theta_mathrms. It can be expressed as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"theta_i - theta_mathrms = 0 i in mathcal N_mathrmsb","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"where the set mathcal N_mathrmsb contains the index of the slack bus. To access the equality constraint from the model, we can utilize the variable:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.method.constraint.slack.angle)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Bus-Active-Power-Balance-Constraints","page":"DC Optimal Power Flow","title":"Bus Active Power Balance Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The second equality constraint in the optimization problem is associated with the active power balance equation:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"h_P_i(mathbf P_mathrmg bm Theta) = 0 i in mathcal N","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"As elaborated in the Nodal Network Equations section, we can express the equation as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"h_P_i(mathbf P_mathrmg bm Theta) = sum_k in mathcal S_i P_mathrmgk - sum_k = 1^n B_ik theta_k - P_mathrmdi - P_mathrmshi - P_mathrmtri","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In this equation, the set mathcalS_i subseteq mathcal S encompasses all generators connected to bus i in mathcal N, and P_mathrmgk represents the active power output of the k-th generator within the set mathcalS_i. More precisely, the variable P_mathrmgk represents the optimization variable, as well as the bus voltage angle theta_k.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The constant terms in these equations are determined by the active power demand at bus P_mathrmdi, the active power demanded by the shunt element P_mathrmshi, and power related to the shift angle of the phase transformers P_mathrmtri. The values representing these constant terms mathbf P_mathrmd = P_mathrmdi, mathbf P_mathrmsh = P_mathrmshi, and mathbf P_mathrmtr = P_mathrmtri, i in mathcal N, can be accessed:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₒ = system.bus.demand.active\n𝐏ₛₕ = system.bus.shunt.conductance\n𝐏ₜᵣ = system.model.dc.shiftPower","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve constraints from the model, we can use:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.method.constraint.balance.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Bus-Voltage-Angle-Difference-Constraints","page":"DC Optimal Power Flow","title":"Bus Voltage Angle Difference Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The inequality constraint related to the minimum and maximum bus voltage angle difference between the from-bus and to-bus ends of each branch is defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"theta_ij^mathrmmin leq theta_i - theta_j leq theta_ij^mathrmmax (ij) in mathcal E","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"where theta_ij^mathrmmin represents the minimum, while theta_ij^mathrmmax represents the maximum of the angle difference between adjacent buses. The values representing the voltage angle difference, denoted as bmTheta_mathrmlm = theta_ij^mathrmmin theta_ij^mathrmmax, (ij) in mathcal E, are provided as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝚯ₗₘ = [system.branch.voltage.minDiffAngle system.branch.voltage.maxDiffAngle]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve constraints from the model, we can use:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.method.constraint.voltage.angle)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Branch-Active-Power-Flow-Constraints","page":"DC Optimal Power Flow","title":"Branch Active Power Flow Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The inequality constraint related to active power flow is used to represent thermal limits on power transmission. This constraint is defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"P_ij^mathrmmin leq h_P_ij(theta_i theta_j) leq P_ij^mathrmmax  (ij) in mathcal E","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The branch flow limits at the from-bus, denoted as mathbf P_mathrmf = P_ij^mathrmmin P_ij^mathrmmax , can be retrieved as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₒ = [system.branch.flow.minFromBus system.branch.flow.maxFromBus]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The active power flow at branch (ij) in mathcal E can be derived using the Branch Network Equations and is given by:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"h_P_ij(theta_i theta_j) = frac1tau_ij x_ij (theta_i - theta_j - phi_ij)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve constraints from the model, we can use:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.method.constraint.flow.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Generator-Active-Power-Capability-Constraints","page":"DC Optimal Power Flow","title":"Generator Active Power Capability Constraints","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The inequality constraints associated with the minimum and maximum active power outputs of the generators are defined as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"P_mathrmgi^mathrmmin leq P_mathrmgi leq P_mathrmgi^mathrmmax   i in mathcalS","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"In this representation, the lower and upper bounds are determined by the vector mathbf P_mathrmm = P_mathrmgi^mathrmmin P_mathrmgi^mathrmmax, i in mathcalS. We can access these bounds using the following variable:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₘ = [system.generator.capability.minActive system.generator.capability.maxActive]","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To retrieve constraints from the model, we can use:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"print(analysis.method.constraint.capability.active)","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerFlowSolutionTutorials","page":"DC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"To acquire the output active power of generators and the bus voltage angles, the user must invoke the function:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"JuMP.set_silent(analysis.method.jump) # hide\nsolve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Therefore, to get the vector of output active power of generators mathbf P_mathrmg = P_mathrmgi, i in mathcal S, we can use:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₒ = analysis.power.generator.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Further, the resulting bus voltage angles bm Theta = theta_i, i in mathcal N, are saved in the vector as follows:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#DCOptimalPowerAnalysisTutorials","page":"DC Optimal Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"After obtaining the solution from the DC optimal power flow, we can calculate the powers related to buses and branches using the power! function:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Power-Injections","page":"DC Optimal Power Flow","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Active power injections are stored as the vector mathbf P = P_i, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏 = analysis.power.injection.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Generator-Power-Injections","page":"DC Optimal Power Flow","title":"Generator Power Injections","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The active power supplied by generators to the buses can be calculated by summing the active power outputs of the generators obtained from the optimal DC power flow. This can be expressed as:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"    P_mathrmpi = sum_k=1^n_mathrmgi P_mathrmgk i in mathcal N","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Here, P_mathrmgk represents the active power output of the k-th generator connected to bus i in mathcalN, and n_mathrmgi denotes the total number of generators connected to the same bus. We can obtain the vector of active powers injected by generators into the buses, denoted as mathbf P_mathrmp = P_mathrmpi, using the following command:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ₚ = analysis.power.supply.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/#Power-Flows","page":"DC Optimal Power Flow","title":"Power Flows","text":"","category":"section"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"The resulting from-bus active power flows are stored as the vector mathbf P_mathrmi = P_ij, which can be retrieved using:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ᵢ = analysis.power.from.active","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"Similarly, the resulting to-bus active power flows are stored as the vector mathbf P_mathrmj = P_ji, which can be retrieved using:","category":"page"},{"location":"tutorials/dcOptimalPowerFlow/","page":"DC Optimal Power Flow","title":"DC Optimal Power Flow","text":"𝐏ⱼ = analysis.power.to.active","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerFlowManual","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To perform the DC power flow, we first need to have the PowerSystem type that has been created with the DC model. Following that, we can construct the power flow model encapsulated within the DcPowerFlow type by employing the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"dcPowerFlow.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To solve the DC power flow problem and acquire bus voltage angles, users can use the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Once the DC power flow solution is obtained, JuliaGrid provides a function for computing powers:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Alternatively, instead of using functions responsible for solving power flow and computing powers, users can use the wrapper function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"powerFlow!.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Users can also access specialized functions for computing specific types of powers for individual buses, branches, or generators within the power system.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerFlowSolutionManual","page":"DC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To solve the DC power flow problem using JuliaGrid, we start by creating the PowerSystem type and defining the DC model with the dcModel! function. Here is an example:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The dcPowerFlow function can be used to establish the DC power flow problem:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis = dcPowerFlow(system)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"tip: Tip\nBy default, the user activates LU factorization to solve the system of linear equations. Users may also choose the LDLt, QR or KLU factorization methods explicitly:analysis = dcPowerFlow(system, KLU)The KLU method, using the Gilbert-Peierls algorithm, can significantly speed up power flow computations [1].","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To obtain the bus voltage angles, we can call the solve! function as follows:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Once the solution is obtained, the bus voltage angles can be accessed using:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"print(system.bus.label, analysis.voltage.angle)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nFor implementation insights, we suggest referring to the tutorial on DC Power Flow Analysis.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Wrapper-Function","page":"DC Power Flow","title":"Wrapper Function","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid provides a wrapper function for DC power flow analysis and also supports the computation of powers using the powerFlow! function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis = dcPowerFlow(system)\npowerFlow!(analysis; verbose = 2)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Print-Results-in-the-REPL","page":"DC Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Users have the option to print the results in the REPL using any units that have been configured, such as:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"@voltage(pu, deg)\nprintBusData(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, users can easily customize the print results for specific buses, for example:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"printBusData(analysis; label = \"Bus 1\", header = true)\nprintBusData(analysis; label = \"Bus 2\")\nprintBusData(analysis; label = \"Bus 3\", footer = true)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Save-Results-to-a-File","page":"DC Power Flow","title":"Save Results to a File","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Users can also redirect print output to a file. For example, data can be saved in a text file as follows:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"open(\"bus.txt\", \"w\") do file\n    printBusData(analysis, file)\nend","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Save-Results-to-a-CSV-File","page":"DC Power Flow","title":"Save Results to a CSV File","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"For CSV output, users should first generate a simple table with style = false, and then save it to a CSV file:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using CSV\n\nio = IOBuffer()\nprintBusData(analysis, io; style = false)\nCSV.write(\"bus.csv\", CSV.File(take!(io); delim = \"|\"))","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerSystemAlterationManual","page":"DC Power Flow","title":"Power System Update","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"We begin by creating the PowerSystem type with the powerSystem function. The DC model is then configured using dcModel! function. After that, we initialize the DcPowerFlow type through the dcPowerFlow function and solve the resulting power flow problem:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2, active = 2.1)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, we modify the existing PowerSystem type within the DC model using add and update functions. Then, we create a new DcPowerFlow type based on the modified system and solve the power flow problem:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateBus!(system; label = \"Bus 2\", active = 0.4)\n\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.3)\nupdateBranch!(system; label = \"Branch 1\", status = 0)\n\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 1.5)\nupdateGenerator!(system; label = \"Generator 1\", active = 1.9)\n\nanalysis = dcPowerFlow(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nThis concept removes the need to restart and recreate the PowerSystem within the dc field from the beginning when implementing changes to the existing power system.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerFlowUpdateManual","page":"DC Power Flow","title":"Power Flow Update","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"An advanced methodology involves users establishing the DcPowerFlow type just once. After this initial setup, users can integrate new branches and generators, and also have the capability to modify buses, branches, and generators, all without the need to recreate the DcPowerFlow type. This is particularly beneficial when the previously computed nodal matrix factorization can be reused.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Let us now revisit our defined PowerSystem and DcPowerFlow types:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 2, active = 2.1)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, we modify the existing PowerSystem within the DC model as well as the DcPowerFlow type using add and update functions. We then immediately proceed to solve the power flow problem:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", active = 0.4)\n\naddBranch!(analysis; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.3)\nupdateBranch!(analysis; label = \"Branch 1\", status = 0)\n\naddGenerator!(analysis; label = \"Generator 2\", bus = \"Bus 2\", active = 1.5)\nupdateGenerator!(analysis; label = \"Generator 1\", active = 1.9)\n\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nThis concept removes the need to restart and recreate both the PowerSystem within the dc field and the DcPowerFlow from the beginning when implementing changes to the existing power system. Additionally, JuliaGrid can reuse symbolic factorizations of LU or LDLt, as long as the nonzero pattern of the nodal matrix remains consistent between power system configurations.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Reusing-Matrix-Factorization","page":"DC Power Flow","title":"Reusing Matrix Factorization","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Drawing from the preceding example, our focus now shifts to finding a solution involving modifications that entail adjusting the active power demand at Bus 2, introducing a new generator at Bus 2, and fine-tuning the output power of Generator 1. It is important to note that these adjustments do not impact the branches, leaving the nodal matrix unchanged. To resolve this updated system, users can simply execute the powerFlow! function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"\nupdateBus!(analysis; label = \"Bus 2\", active = 0.2)\naddGenerator!(analysis; label = \"Generator 3\", bus = \"Bus 2\", active = 0.3)\nupdateGenerator!(analysis; label = \"Generator 1\", active = 2.1)\n\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In this scenario, JuliaGrid will recognize instances where the user has not modified branch parameters affecting the nodal matrix. Consequently, JuliaGrid will leverage the previously performed nodal matrix factorization, resulting in a significantly faster solution compared to recomputing the factorization.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Limitations","page":"DC Power Flow","title":"Limitations","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Attempting to change the slack bus or leaving the existing slack bus without a connected generator, and then proceeding directly to the power flow calculation, is not feasible. In such cases, JuliaGrid will raise an error:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateGenerator!(analysis; label = \"Generator 1\", status = 0)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To resolve this, the user must recreate the DcPowerFlow type rather than attempting to reuse the existing one:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"updateGenerator!(system; label = \"Generator 1\", status = 0)\n\nanalysis = dcPowerFlow(system)\npowerFlow!(analysis)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#DCPowerAnalysisManual","page":"DC Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"After obtaining the solution, we can calculate powers related to buses, branches, and generators using the power! function. For example, let us consider the power system for which we obtained the DC power flow solution:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.01)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2)\n\nanalysis = dcPowerFlow(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Now we can calculate the active powers using the following function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Next, let us convert the base power unit to megavolt-amperes (MVA):","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"@base(system, MVA, V)\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, here are the calculated active power values in megawatts (MW) corresponding to buses and branches:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"print(system.bus.label, system.base.power.value * analysis.power.injection.active)\nprint(system.branch.label, system.base.power.value * analysis.power.from.active)","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nTo better understand the powers associated with buses, branches, and generators that are calculated by the power! function, we suggest referring to the tutorials on DC Power Flow Analysis.","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Print-Results-in-the-REPL-2","page":"DC Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Users can utilize any of the print functions outlined in the Print Power System Data or Print Power System Summary. For example, users have the option to print the results in the REPL using any units that have been configured:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"@power(MW, pu)\nprintBranchData(analysis)\n@default(unit) # hide\nnothing # hide","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Injection","page":"DC Power Flow","title":"Active Power Injection","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To calculate active power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = injectionPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Injection-from-Generators","page":"DC Power Flow","title":"Active Power Injection from Generators","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To calculate active power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = supplyPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Active-Power-Flow","page":"DC Power Flow","title":"Active Power Flow","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Similarly, we can compute the active power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = fromPower(analysis; label = \"Branch 2\")\nactive = toPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"manual/dcPowerFlow/#Generator-Active-Power-Output","page":"DC Power Flow","title":"Generator Active Power Output","text":"","category":"section"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, we can compute the active power output of a particular generator using the function:","category":"page"},{"location":"manual/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"active = generatorPower(analysis; label = \"Generator 1\")\n@voltage(pu, pu, V) # hide\n@power(pu, pu, pu) # hide","category":"page"},{"location":"examples/powerSystemDatasets/#PowerSystemDataExamples","page":"Power System Datasets","title":"Power System Datasets","text":"","category":"section"},{"location":"examples/powerSystemDatasets/","page":"Power System Datasets","title":"Power System Datasets","text":"The table below showcases a range of widely used power system datasets that users can leverage for analysis. These datasets vary in size and complexity, providing flexibility for different applications. For instructions on how to load these models into JuliaGrid, please refer to the Build Model section of the manual.","category":"page"},{"location":"examples/powerSystemDatasets/","page":"Power System Datasets","title":"Power System Datasets","text":"Power System Buses Branches Generators Download Links\nIEEE 14-bus test case 14 20 5 [hdf5] [matpower] [built-in]\nIEEE 30-bus test case 30 41 6 [hdf5] [matpower] [built-in]\nIEEE 118-bus test case 118 186 54 [hdf5] [matpower]\nIEEE 300-bus test case 300 411 69 [hdf5] [matpower]\nPart of the European transmission network 1354 1991 260 [hdf5]\nFrench transmission network 1951 2596 392 [hdf5]\nSynthetic US WECC model 10000 12706 2485 [hdf5]\nSynthetic US NE/Mid-Atlantic model 25000 32230 4834 [hdf5]\nSynthetic Eastern US model 70000 88207 10390 [hdf5]\nSynthetic US model 82000 104121 13419 [hdf5]","category":"page"},{"location":"examples/powerSystemDatasets/","page":"Power System Datasets","title":"Power System Datasets","text":"Once users have established a power system model, they can proceed with the various types of analyses offered by JuliaGrid. While these power systems contain a comprehensive data structure for different analyses, only specific parameters are needed for certain types of analysis. For more information on power system parameters, refer to the Power System Model section in the API documentation.","category":"page"},{"location":"examples/observabilityAnalysis/#ObservabilityAnalysisExamples","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"section"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"In this example, we analyze a 6-bus power system, shown in Figure 1. The initial objective is to conduct an observability analysis to identify observable islands and restore observability. Later, we examine optimal PMU placement to ensure system observability using only phasor measurements.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/observability/6bus.svg\" width=\"410\" class=\"my-svg\"/>\n    <p>Figure 1: The 6-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"note: Info\nUsers can download a Julia script containing the scenarios from this section using the following link.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"We define the power system, specify buses and branches, and assign the generator to the slack bus:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"using JuliaGrid, HiGHS # hide\n@default(template) # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\naddBus!(system; label = \"Bus 4\")\naddBus!(system; label = \"Bus 5\")\naddBus!(system; label = \"Bus 6\")\n\n@branch(reactance = 0.22)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\")\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 4\")\naddBranch!(system; label = \"Branch 4\", from = \"Bus 3\", to = \"Bus 5\")\naddBranch!(system; label = \"Branch 5\", from = \"Bus 3\", to = \"Bus 4\")\naddBranch!(system; label = \"Branch 6\", from = \"Bus 4\", to = \"Bus 6\")\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Notably, observability analysis and optimal PMU placement are independent of branch parameters, as well as measurement values and variances.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"examples/observabilityAnalysis/#Identification-of-Observable-Islands","page":"Observability Analysis","title":"Identification of Observable Islands","text":"","category":"section"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Next, we define the measurement model. JuliaGrid employs standard observability analysis based on the linear decoupled measurement model. Active power measurements from wattmeters are used to estimate bus voltage angles, while reactive power measurements from varmeters estimate bus voltage magnitudes. In this example, the 6-bus power system is monitored by four meters, as shown in Figure 2.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/observability/6bus_meter.svg\" width=\"420\" class=\"my-svg\"/>\n    <p>Figure 2: The 6-bus power system monitoring with four power meters.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Notably, the island detection step relies only on wattmeters, meaning that if the goal is simply to identify observable islands, defining wattmeters alone is sufficient. However, for observability restoration followed by state estimation, varmeters are also needed. Therefore, the four meters represent both wattmeters and varmeters:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"monitoring = measurement(system)\n\naddWattmeter!(monitoring; label = \"Meter 1\", from = \"Branch 1\", active = 1.1)\naddVarmeter!(monitoring; label = \"Meter 1\", from = \"Branch 1\", reactive = -0.5)\n\naddWattmeter!(monitoring; label = \"Meter 2\", bus = \"Bus 2\", active = -0.1)\naddVarmeter!(monitoring; label = \"Meter 2\", bus = \"Bus 2\", reactive = -0.1)\n\naddWattmeter!(monitoring; label = \"Meter 3\", bus = \"Bus 4\", active = -0.3)\naddVarmeter!(monitoring; label = \"Meter 3\", bus = \"Bus 4\", reactive = 0.6)\n\naddWattmeter!(monitoring; label = \"Meter 4\", to = \"Branch 6\", active = 0.2)\naddVarmeter!(monitoring; label = \"Meter 4\", to = \"Branch 6\", reactive = 0.3)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Attempting to solve AC state estimation with these measurements would not be possible, as the gain matrix would be singular. The same issue arises with DC state estimation. To prevent this, users can perform observability analysis, which adds non-redundant measurements to ensure a nonsingular gain matrix and a unique state estimator.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Observability analysis begins with identifying observable islands. We have the ability to identify both flow-observable and maximal-observable islands, each of which can be used as the foundation for the restoration step. To provide a comprehensive analysis, we will explore both types of islands.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"In the first step, we focus on determining the flow-observable islands:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopologicalFlow(monitoring)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"As the result, four flow-observable islands are identified:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.island\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The first observable island consists of Bus 1 and Bus 2, the second island is formed by Bus 3, the third island includes Bus 4 and Bus 6, while Bus 5 constitutes the fourth island, as shown in Figure 3.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/observability/6bus_flow.svg\" width=\"430\" class=\"my-svg\"/>\n    <p>Figure 3: Flow-observable islands in the 6-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"In addition to flow islands, we can also identify maximal-observable islands:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopological(monitoring)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The results reveal the identification of two-maximal observable islands:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.island\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"As observed, the monitorings Meter 2 and Meter 3 together merge the first, second, and third flow-observable islands into one, as shown in Figure 4.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/observability/6bus_maximal.svg\" width=\"430\" class=\"my-svg\"/>\n    <p>Figure 4: Maximal-observable islands in the 6-bus power system.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"From the standpoint of island identification, detecting flow-observable islands requires less computational effort compared to identifying maximal-observable islands. However, when it comes to restoring observability, the process involving flow islands tends to be more computationally demanding than with maximal islands.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"examples/observabilityAnalysis/#Observability-Restoration","page":"Observability Analysis","title":"Observability Restoration","text":"","category":"section"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"To perform the observability restoration step, a new set of measurements, called pseudo-measurements, is needed. These typically hold historical data about electrical quantities. Let us define this set:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"pseudo = measurement(system)\n\naddWattmeter!(pseudo; label = \"Pseudo 1\", from = \"Branch 5\", active = 0.3)\naddVarmeter!(pseudo; label = \"Pseudo 1\", from = \"Branch 5\", reactive = 0.1)\n\naddWattmeter!(pseudo; label = \"Pseudo 2\", bus = \"Bus 5\", active = 0.3)\naddVarmeter!(pseudo; label = \"Pseudo 2\", bus = \"Bus 5\", reactive = -0.2)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Next, we can invoke the observability restoration function:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"restorationGram!(monitoring, pseudo, islands)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"This function identifies the minimal set of pseudo-measurements needed to make the system observable, which in this case is Pseudo 2. This pseudo-measurement is then transferred to the measurement model.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"As a result, the final set of wattmeters used for measuring active power consists of:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"printWattmeterData(monitoring)","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Likewise, the final set of varmeters used for measuring reactive power consists of:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"printVarmeterData(monitoring)","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"As we can see, adding the Pseudo 2 measurement makes the system observable, which we can confirm by identifying observable islands with only one island:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands = islandTopological(monitoring)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"islands.island\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"To proceed with the AC state estimation algorithm, we need one additional step to make the state estimation solvable. Specifically, it is crucial to ensure that the system has at least one bus voltage magnitude measurement. This requirement stems from the fact that observable islands are identified using wattmeters, which estimate voltage angles. Since the voltage angle at the slack bus is already known, the same approach should be applied to bus voltage magnitudes. To fulfill this condition, we add the following measurement:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"addVoltmeter!(monitoring; label = \"Pseudo 3\", bus = \"Bus 1\", magnitude = 1.0)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Figure 5 illustrates the measurement configuration that makes our 6-bus power system observable and ensures a unique state estimator.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/observability/6bus_pseudo.svg\" width=\"420\" class=\"my-svg\"/>\n    <p>Figure 5: Measurement configuration that makes the 6-bus power system observable.</p>\n</div>","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"","category":"page"},{"location":"examples/observabilityAnalysis/#Optimal-PMU-Placement","page":"Observability Analysis","title":"Optimal PMU Placement","text":"","category":"section"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The goal of the PMU placement algorithm is to determine the minimal number of PMUs required to make the system observable. In this case, we analyze a 6-bus power system without power meters and identify the smallest set of PMUs needed for full observability, ensuring a unique state estimator:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"placement = pmuPlacement(system, HiGHS.Optimizer)","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The optimal PMU locations can be retrieved with:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"keys(placement.bus)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"Figure 6 illustrates the PMU configuration that ensures observability and guarantees a unique state estimator. Each installed PMU measures the bus voltage phasor and the current phasors of all connected branches.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/observability/6bus_pmu.svg\" width=\"420\" class=\"my-svg\"/>\n    <p>Figure 6: PMU configuration that makes the 6-bus power system observable.</p>\n</div>\n&nbsp;","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"The configuration of phasor measurements includes voltage phasor measurements at Bus 2, Bus 3, and Bus 4. Additionally, there is a set of current phasor measurements at the from-bus ends of the branches, as shown below:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"keys(placement.from)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"To complete the measurement setup, the set should also include current phasor measurements at the to-bus ends of the branches, as specified in the following:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"keys(placement.to)\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"These variables provide users with a convenient way to define phasor measurement values, whether based on AC power flow or AC optimal power flow analyses, which have been explored in PMU state estimation example.","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"However, users have the option to manually specify phasor measurement values:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"pmu = measurement(system)\n\naddPmu!(pmu; label = \"PMU 1-1\", bus = \"Bus 2\", magnitude = 1.1, angle = -0.2)\naddPmu!(pmu; label = \"PMU 1-2\", to = \"Branch 1\", magnitude = 1.2, angle = -2.7)\naddPmu!(pmu; label = \"PMU 1-3\", from = \"Branch 2\", magnitude = 0.6, angle = 0.3)\naddPmu!(pmu; label = \"PMU 1-4\", from = \"Branch 3\", magnitude = 0.6, angle = 0.7)\n\naddPmu!(pmu; label = \"PMU 2-1\", bus = \"Bus 3\", magnitude = 1.2, angle = -0.3)\naddPmu!(pmu; label = \"PMU 2-2\", to = \"Branch 2\", magnitude = 0.6, angle = -2.8)\naddPmu!(pmu; label = \"PMU 2-3\", from = \"Branch 4\", magnitude = 0.3, angle = -2.8)\n\naddPmu!(pmu; label = \"PMU 3-1\", bus = \"Bus 4\", magnitude = 1.2, angle = -0.3)\naddPmu!(pmu; label = \"PMU 3-2\", to = \"Branch 3\", magnitude = 0.6, angle = -2.3)\naddPmu!(pmu; label = \"PMU 3-3\", to = \"Branch 4\", magnitude = 0.3, angle = 0.3)\naddPmu!(pmu; label = \"PMU 3-4\", from = \"Branch 6\", magnitude = 0.2, angle = 1.9)\n\nnothing # hide","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"This set of phasor measurements ensures system observability and guarantees a unique state estimator. The defined phasor measurements can be displayed using:","category":"page"},{"location":"examples/observabilityAnalysis/","page":"Observability Analysis","title":"Observability Analysis","text":"printPmuData(pmu)","category":"page"},{"location":"background/bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"background/bibliography/","page":"Bibliography","title":"Bibliography","text":"T. A. Davis and E. Palamadai Natarajan. Algorithm 907: KLU, A Direct Sparse Solver for Circuit Simulation Problems. ACM Trans. Math. Softw. 37 (2010).\n\n\n\nA. Gomez-Exposito, A. Abur, P. Rousseaux, A. de la Villa Jaen and C. Gomez-Quiles. On the use of PMUs in power system state estimation. In: 17th power system computation conference (2011).\n\n\n\nG. N. Korres. Observability analysis based on Echelon form of a reduced dimensional Jacobian matrix. IEEE Transactions on Power Systems 26, 2572–2573 (2011).\n\n\n\nM. Zhou, V. A. Centeno, J. S. Thorp and A. G. Phadke. An alternative for including phasor measurements in state estimators. IEEE transactions on power systems 21, 1930–1937 (2006).\n\n\n\nG. Korres and N. Manousakis. State estimation and observability analysis for phasor measurement unit measured systems. IET generation, transmission & distribution 6, 902–913 (2012).\n\n\n\nA. Abur and A. G. Exposito. Power system state estimation: theory and implementation (CRC press, 2004).\n\n\n\nG. Andersson. Power system analysis. EEH-Power Systems Laboratory, ETH Zurich, Lecture Notes, 227–0526 (2012).\n\n\n\nJ. J. Grainger and W. D. Stevenson. Power system analysis (McGraw-Hill, 1994).\n\n\n\nR. D. Zimmerman and C. E. Murillo-Sánchez. Matpower 6.0 users manual. Power Systems Engineering Research Center 9 (2016).\n\n\n\nA. J. Wood, B. F. Wollenberg and G. B. Sheblé. Power generation, operation, and control (John Wiley & Sons, 2013).\n\n\n\nR. A. Van Amerongen. A general-purpose version of the fast decoupled load flow. IEEE Transactions on Power Systems 4, 760–770 (1989).\n\n\n\nD. P. Chassin, P. R. Armstrong, D. G. Chavarrı́a-Miranda and R. T. Guttromson. Gauss-Seidel accelerated: implementing flow solvers on field programmable gate arrays. In: 2006 IEEE Power Engineering Society General Meeting (IEEE, 2006); p. 5–pp.\n\n\n\nF. C. Schweppe and D. B. Rom. Power system static-state estimation, Part II: Approximate model. IEEE Transactions on Power Apparatus and Systems, 125–130 (1970).\n\n\n\nA. Monticelli. State estimation in electric power systems: a generalized approach (Springer Science & Business Media, 2012).\n\n\n\nA. G. Phadke and J. S. Thorp. Synchronized phasor measurements and their applications. Vol. 1 no. 2017 (Springer, 2008).\n\n\n\nD. Barber. Bayesian reasoning and machine learning (Cambridge University Press, 2012).\n\n\n\nM. Cosovic, M. Delalic, D. Raca and D. Vukobratovic. Observability analysis for large-scale power systems using factor graphs. IEEE Transactions on Power Systems 36, 4791–4799 (2021).\n\n\n\nH. Horisberger. Observability analysis for power systems with measurement deficiencies. IFAC Proceedings Volumes 18, 51–58 (1985).\n\n\n\nN. M. Manousakis and G. N. Korres. Observability analysis for power systems including conventional and phasor measurements. IET Conference Proceedings, 158-158(1) (2010).\n\n\n\nB. Gou. Optimal placement of PMUs by integer linear programming. IEEE Transactions on power systems 23, 1525–1526 (2008).\n\n\n\nB. Xu and A. Abur. Observability analysis and measurement placement for systems with PMUs. In: IEEE PES Power Systems Conference and Exposition, 2004. (IEEE, 2004); pp. 943–946.\n\n\n\nI. ISO. and B. OIML. Guide to the Expression of Uncertainty in Measurement (Aenor, 1993).\n\n\n\nY. Weng, Q. Li, R. Negi and M. Ilić. Semidefinite programming for power system state estimation. In: 2012 IEEE Power and Energy Society General Meeting (IEEE, 2012); pp. 1–8.\n\n\n\nP. C. Hansen, V. Pereyra and G. Scherer. Least squares data fitting with applications (JHU Press, 2013).\n\n\n\nG. N. Korres. A distributed multiarea state estimation. IEEE Transactions on Power Systems 26, 73–84 (2010).\n\n\n\n","category":"page"},{"location":"manual/acPowerFlow/#ACPowerFlowManual","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To perform the AC power flow analysis, we will first need the PowerSystem type that has been created with the AC model. Following that, we can construct the power flow model encapsulated within the AcPowerFlow type by employing one of the following functions:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"newtonRaphson,\nfastNewtonRaphsonBX,\nfastNewtonRaphsonXB,\ngaussSeidel.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain bus voltages and solve the power flow problem, users can implement an iterative process using functions:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"mismatch!,\nsolve!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After solving the AC power flow, JuliaGrid provides functions for computing powers and currents:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!,\ncurrent!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Alternatively, instead of designing their own iteration process and computing powers and currents, users can use the wrapper function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"powerFlow!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Users can also access specialized functions for computing specific types of powers and currents for individual buses, branches, or generators within the power system.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, the package provides two functions for reactive power limit validation of generators and adjusting the voltage angles to match an arbitrary bus angle:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"reactiveLimit!,\nadjustAngle!.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#SetupInitialVoltagesManual","page":"AC Power Flow","title":"Setup Initial Voltages","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Let us create the PowerSystem type and select the Newton-Raphson method:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; bus = \"Bus 1\", magnitude = 1.3)\naddGenerator!(system; bus = \"Bus 2\", magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 3\", magnitude = 1.2)\n\nanalysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, the function newtonRaphson initializes voltages in polar coordinates.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The initial voltage magnitudes are set to:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This vector is created based on the bus types by selecting voltage magnitude values from the PowerSystem type, using the vectors:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[system.bus.voltage.magnitude system.generator.voltage.magnitude]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The initial voltage angles are set to:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This vector is derived from the voltage angle values in the PowerSystem type:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe rule governing the specification of initial voltage magnitudes is simple. If a bus has an in-service generator and is declared the generator bus (type = 2), then the initial voltage magnitudes are specified using the setpoint provided within the generator. This is because the generator bus has known values of voltage magnitude that are specified within the generator.On the other hand, the slack bus (type = 3) always requires an in-service generator. The initial value of the voltage magnitude at the slack bus is determined exclusively by the setpoints provided within the generators connected to it. This is a result of the slack bus having a known voltage magnitude that must be maintained.If there are multiple generators connected to the generator or slack bus, the initial voltage magnitude will align with the magnitude setpoint specified for the first in-service generator in the list.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Custom-Initial-Voltages","page":"AC Power Flow","title":"Custom Initial Voltages","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This method of specifying initial values has a significant advantage in that it allows the user to easily change the initial voltage magnitudes and angles, which play a crucial role in iterative methods. For instance, suppose we define our power system as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.0, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 0.9, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 2, magnitude = 0.8, angle = -0.2)\n\naddGenerator!(system; bus = \"Bus 1\", magnitude = 1.1)\naddGenerator!(system; bus = \"Bus 3\", magnitude = 1.2)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Now, the user can initiate a flat start, this can be easily done as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for i = 1:system.bus.number\n    system.bus.voltage.magnitude[i] = 1.0\n    system.bus.voltage.angle[i] = 0.0\nend\n\nanalysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The initial voltage values are:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Consequently, the iteration begins with a fixed set of voltage magnitude values that remain constant throughout the iteration process. The remaining values are initialized as part of the flat start approach.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerFlowSolutionManual","page":"AC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To start, we will create a power system and define the AC model by invoking the acModel! function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\naddBus!(system; label = \"Bus 3\", type = 1, active = 0.5, magnitude = 1.0, angle = -0.2)\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.01)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\n\n@generator(active = 3.2)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", magnitude = 1.1)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", magnitude = 1.2)\n\nacModel!(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the AC model is defined, we can choose the method to solve the power flow problem. JuliaGrid provides four methods: newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, and gaussSeidel.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"For example, to use the Newton-Raphson method to solve the power flow problem, we can use:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"tip: Tip\nBy default, the user activates LU factorization to solve the system of linear equations within each iteration of the Newton-Raphson method. Users may also choose the QR or KLU factorization methods explicitly:analysis = newtonRaphson(system, KLU)The KLU method, based on the Gilbert-Peierls algorithm, can considerably speed up power flow computations [1]. This option to select a factorization method is available only for the Newton-Raphson and fast Newton-Raphson methods.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This function sets up the desired method for an iterative process based on two functions: mismatch! and solve!. The mismatch! function calculates the active and reactive power injection mismatches using the given voltage magnitudes and angles, while solve! computes the voltage magnitudes and angles.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To perform an iterative process with the Newton-Raphson or fast Newton-Raphson methods in JuliaGrid, the mismatch! function must be included inside the iteration loop. For instance:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 1:100\n    mismatch!(analysis)\n    solve!(analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Upon completion of the AC power flow analysis, the solution is conveyed through the bus voltage magnitudes and angles. Here are the values corresponding to the buses:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In contrast, the iterative loop of the Gauss-Seidel method does not require the mismatch! function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = gaussSeidel(system)\nfor iteration = 1:100\n    solve!(analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In these examples, the algorithms run until the specified number of iterations is reached.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nWe recommend that the reader refer to the tutorial on AC Power Flow Analysis, where we explain the implementation of the methods and algorithm structures in detail.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Breaking-the-Iterative-Process","page":"AC Power Flow","title":"Breaking the Iterative Process","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can terminate the iterative process using the mismatch! function. The following code shows an example of how to use the function to break out of the iteration loop:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"@voltage(pu, rad, V) # hide\nanalysis = newtonRaphson(system)\nfor iteration = 1:100\n    stopping = mismatch!(analysis)\n    if all(stopping .< 1e-8)\n        println(\"Solution found in $(analysis.method.iteration) iterations.\")\n        break\n    end\n    solve!(analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The mismatch! function returns the maximum absolute values of active and reactive power injection mismatches, which are commonly used as a convergence criterion in iterative AC power flow algorithms.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Wrapper-Function","page":"AC Power Flow","title":"Wrapper Function","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid provides a wrapper function for AC power flow analysis that manages the iterative solution process and also supports the computation of powers and currents using the powerFlow! function. Hence, it offers a way to solve AC power flow with reduced implementation effort:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"setInitialPoint!(analysis) # hide\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; verbose = 3)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nUsers can choose any of the approaches presented in this section to solve AC power flow based on their needs. Additionally, users can review the algorithm used in the wrapper function within the AC Power Flow tutorial section. For example, they can refer to the Newton-Raphson algorithm.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Combining-Methods","page":"AC Power Flow","title":"Combining Methods","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The PowerSystem type, once created, can be shared among different methods, offering several advantages.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"For instance, while the Gauss-Seidel method is commonly used to swiftly derive an approximate solution, the Newton-Raphson method is favored for obtaining precise final solutions. Hence, a strategy involves employing the Gauss-Seidel method for a limited number of iterations, followed by initializing the Newton-Raphson method with the voltages obtained from the Gauss-Seidel method, leveraging it as a starting point for further refinement:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"gs = gaussSeidel(system)\nfor iteration = 1:5\n    solve!(gs)\nend","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we can initialize the Newton-Raphson method with the voltages obtained from the Gauss-Seidel method and start the algorithm from that point:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\n\nsetInitialPoint!(analysis, gs)\npowerFlow!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Print-Results-in-the-REPL","page":"AC Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Users have the option to print the results in the REPL using any units that have been configured, such as:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"@voltage(pu, deg)\nprintBusData(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, users can easily customize the print results for specific buses, for example:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"printBusData(analysis; label = \"Bus 1\", header = true)\nprintBusData(analysis; label = \"Bus 2\")\nprintBusData(analysis; label = \"Bus 3\", footer = true)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Save-Results-to-a-File","page":"AC Power Flow","title":"Save Results to a File","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Users can also redirect print output to a file. For example, data can be saved in a text file as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"open(\"bus.txt\", \"w\") do file\n    printBusData(analysis, file)\nend","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Save-Results-to-a-CSV-File","page":"AC Power Flow","title":"Save Results to a CSV File","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"For CSV output, users should first generate a simple table with style = false, and then save it to a CSV file:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using CSV\n\nio = IOBuffer()\nprintBusData(analysis, io; style = false)\nCSV.write(\"bus.csv\", CSV.File(take!(io); delim = \"|\"))","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerSystemAlterationManual","page":"AC Power Flow","title":"Power System Update","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We begin by creating the PowerSystem type with the powerSystem function. The AC model is then configured using acModel! function. After that, we initialize the AcPowerFlow type through the newtonRaphson function and solve the resulting power flow problem:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", magnitude = 1.1, active = 3.2)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we modify the existing PowerSystem type within the AC model using add and update functions. Then, we create a new AcPowerFlow type based on the modified system and solve the power flow problem:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBus!(system; label = \"Bus 2\", active = 0.2)\n\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.3)\nupdateBranch!(system; label = \"Branch 1\", status = 0)\n\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\", active = 0.2)\nupdateGenerator!(system; label = \"Generator 1\", active = 0.3)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThis concept removes the need to restart and recreate the PowerSystem within the ac field from the beginning when implementing changes to the existing power system.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerFlowUpdateManual","page":"AC Power Flow","title":"Power Flow Update","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"An advanced methodology involves users establishing the AcPowerFlow type just once. After this initial setup, users can integrate new branches and generators, and also have the capability to modify buses, branches, and generators, all without the need to recreate the AcPowerFlow type. This is particularly beneficial when previously constructed Jacobian matrices or factorizations can be reused, especially in combination with the fast Newton-Raphson method.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Let us now revisit our defined PowerSystem and AcPowerFlow types:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, magnitude = 0.9, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, magnitude = 1.1, angle = -0.1)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", magnitude = 1.1, active = 3.2)\n\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we modify the existing PowerSystem within the AC model as well as the AcPowerFlow type using add and update functions. We then immediately proceed to solve the power flow problem:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", active = 0.2)\n\naddBranch!(analysis; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.3)\nupdateBranch!(analysis; label = \"Branch 1\", status = 0)\n\naddGenerator!(analysis; label = \"Generator 2\", bus = \"Bus 1\", active = 0.2)\nupdateGenerator!(analysis; label = \"Generator 1\", active = 0.3)\n\npowerFlow!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThis concept removes the need to restart and recreate both the PowerSystem within the ac field and the AcPowerFlow from the beginning when implementing changes to the existing power system.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Warm-Start","page":"AC Power Flow","title":"Warm Start","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This approach of reusing AcPowerFlow offers the advantage of a warm start, where the initial voltages for the next power flow computation step match the solution from the previous run. This alignment enables a more efficient continuation of the power flow analysis.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As a result, for the next power flow run, the initial voltage magnitudes and angles will be:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"If users prefer to reset the initial voltages and instead use the values defined in the PowerSystem type, they can do so using the setInitialPoint! function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"setInitialPoint!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Now, the initial voltages are set exclusively based on the values defined in the PowerSystem type:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Users also have the flexibility to adjust these initial values manually using the magnitude and angle keywords in the updateBus! and updateGenerator! functions:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateGenerator!(analysis; label = \"Generator 1\", magnitude = 1.15)\nupdateBus!(analysis; label = \"Bus 2\", magnitude = 1.08, angle = -0.1)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The updated initial point for the next power flow run is then:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Fast-Newton-Raphson-Using-Reused-Jacobian-Matrix-Factorizations","page":"AC Power Flow","title":"Fast Newton-Raphson Using Reused Jacobian Matrix Factorizations","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"One of the key advantages of reusing the AcPowerFlow type becomes evident when applying the fast Newton-Raphson method. Continuing from the previous example, we first create the fast Newton-Raphson model and perform the power flow calculation:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = fastNewtonRaphsonBX(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, we modify the supply and demand values and solve the power flow again:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", active = 0.2, reactive = 0.02)\nupdateGenerator!(analysis; label = \"Generator 1\", active = 3.1, reactive = 0.1)\n\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In this scenario, JuliaGrid detects that the parameters affecting the Jacobian matrices remain unchanged. As a result, it reuses the previously computed factorizations, leading to significantly faster power flow computation compared to recomputing the factorization from scratch.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Limitations","page":"AC Power Flow","title":"Limitations","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Attempting to change bus types or leaving generator buses without a generator and then proceeding directly to the iteration process is not viable. In such scenarios, JuliaGrid will raise an error:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", type = 2)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To resolve this, the user must recreate the AcPowerFlow type rather than attempting to reuse the existing one:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"updateBus!(system; label = \"Bus 2\", type = 2)\n\nanalysis = fastNewtonRaphsonBX(system)\npowerFlow!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#ACPowerCurrentAnalysisManual","page":"AC Power Flow","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After obtaining the solution from the AC power flow, we can calculate various electrical quantities related to buses, branches, and generators using the power! and current! functions. For instance, let us consider the power system for which we obtained the AC power flow solution:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.6)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.1, susceptance = 0.03)\naddBus!(system; label = \"Bus 3\", type = 1, conductance = 0.02)\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.5)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.1)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.4)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 1.0, reactive = 0.2)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can now utilize the provided functions to compute powers and currents:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!(analysis)\ncurrent!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"For instance, if we want to show the active power injections and the to-bus current angles, we can employ the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.current.to.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nFor a better understanding of the powers and currents from buses, branches, and generators obtained by the power! and current! functions, refer to the AC Power Flow Analysis.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Print-Results-in-the-REPL-2","page":"AC Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Users can utilize any of the print functions outlined in the Print Power System Data or Print Power System Summary. For example, to create a bus summary with the desired units, users can use the following function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"@voltage(pu, deg)\n@power(MW, MVAr)\nprintBusSummary(analysis)\n@default(unit) # hide\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Injection","page":"AC Power Flow","title":"Active and Reactive Power Injection","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = injectionPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Injection-from-Generators","page":"AC Power Flow","title":"Active and Reactive Power Injection from Generators","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = supplyPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Shunt-Element","page":"AC Power Flow","title":"Active and Reactive Power at Shunt Element","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = shuntPower(analysis; label = \"Bus 3\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-Flow","page":"AC Power Flow","title":"Active and Reactive Power Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the functions provided below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = fromPower(analysis; label = \"Branch 2\")\nactive, reactive = toPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC Power Flow","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = chargingPower(analysis; label = \"Branch 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active powers indicate active losses within the branch's charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Active-and-Reactive-Power-at-Series-Impedance","page":"AC Power Flow","title":"Active and Reactive Power at Series Impedance","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the active and reactive power across the series impedance of the branch, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = seriesPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance's inductive characteristics.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Generator-Active-and-Reactive-Power-Output","page":"AC Power Flow","title":"Generator Active and Reactive Power Output","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can compute the active and reactive power output of a particular generator using the function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"active, reactive = generatorPower(analysis; label = \"Generator 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Injection","page":"AC Power Flow","title":"Current Injection","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the current injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = injectionCurrent(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Flow","page":"AC Power Flow","title":"Current Flow","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can compute the current flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = fromCurrent(analysis; label = \"Branch 2\")\nmagnitude, angle = toCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#Current-Through-Series-Impedance","page":"AC Power Flow","title":"Current Through Series Impedance","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"magnitude, angle = seriesCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#GeneratorReactivePowerLimitsManual","page":"AC Power Flow","title":"Generator Reactive Power Limits","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The function reactiveLimit! can be used to check if the generators' output of reactive power is within the defined limits after obtaining the solution from the AC power flow analysis:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\naddBus!(system; label = \"Bus 3\", type = 2, reactive = 0.05)\naddBus!(system; label = \"Bus 4\", type = 2, reactive = 0.05)\n\n@branch(resistance = 0.015)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 4\", reactance = 0.004)\n\n@generator(minReactive = -0.4, maxReactive = 0.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\")\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 3\", reactive = 0.8)\naddGenerator!(system; label = \"Generator 3\", bus = \"Bus 4\", reactive = 0.9)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nviolate = reactiveLimit!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The output reactive power of the observed generators is subject to limits which are defined as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"[system.generator.capability.minReactive system.generator.capability.maxReactive]","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After obtaining the solution of the AC power flow analysis, the reactiveLimit! function is used to internally calculate the output powers of the generators and verify if these values exceed the defined limits. Consequently, the variable violate indicates whether there is a violation of limits.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In the provided example, it can be observed that the Generator 2 and Generator 3 violate the maximum limit:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.generator.label, violate)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Due to these violations of limits, the PowerSystem type undergoes modifications, and the output reactive power at the limit-violating generators is adjusted as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.generator.label, system.generator.output.reactive)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To ensure that these values stay within the limits, the bus type must be changed from the generator bus (type = 2) to the demand bus (type = 1), as shown below:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, system.bus.layout.type)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After modifying the PowerSystem type as described earlier, we can run the simulation again with the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the simulation is complete, we can verify that all generator reactive power outputs now satisfy the limits by checking the violate variable again:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"violate = reactiveLimit!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nThe reactiveLimit! function changes the PowerSystem type deliberately because it is intended to help users create the power system where all reactive power outputs of the generators are within limits.","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"manual/acPowerFlow/#New-Slack-Bus","page":"AC Power Flow","title":"New Slack Bus","text":"","category":"section"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Looking at the following code example, we can see that the output limits of the generator are set only for Generator 1 that is connected to the slack bus:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.5, reactive = 0.05)\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\naddBus!(system; label = \"Bus 3\", type = 2)\naddBus!(system; label = \"Bus 4\", type = 2)\n\n@branch(resistance = 0.01)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; from = \"Bus 1\", to = \"Bus 3\", reactance = 0.01)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", reactance = 0.04)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 4\", reactance = 0.004)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", maxReactive = 0.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 4\", reactive = 0.3)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Upon checking the limits, we can observe that the slack bus has been transformed by executing the following code:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"violate = reactiveLimit!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, the generator connected to the slack bus is violating the minimum reactive power limit, which indicates the need to convert the slack bus. It is important to note that the new slack bus can be created only from the generator bus (type = 2). We will now perform another AC power flow analysis on the modified system using the following:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"analysis = newtonRaphson(system)\npowerFlow!(analysis)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After examining the bus voltages, we will focus on the angles:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We can observe that the angles have been calculated based on the new slack bus. JuliaGrid offers the function to adjust these angles to match the original slack bus as follows:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"adjustAngle!(analysis; slack = \"Bus 1\")","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After executing the above code, the updated results can be viewed:","category":"page"},{"location":"manual/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"print(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/badDataAnalysis/#BadDataManual","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"section"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"After computing the weighted least-squares (WLS) estimator, users can perform bad data analysis. There are two tests available: the Chi-squared test for detecting bad data, and the largest normalized residual test, which can be used not only for detection but also for identifying and removing bad data:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"chiTest,\nresidualTest!.","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"manual/badDataAnalysis/#ChiTestManual","page":"Bad Data Analysis","title":"Chi-Squared Test","text":"","category":"section"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"The Chi-squared test is the method used to detect the presence of bad data or outliers in the measurement set. If the Chi-squared test indicates the presence of bad data, users can proceed with the largest normalized residual test, which will identify and remove outlier from the measurement set.","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"note: Info\nReaders can refer to the Chi-Squared Test tutorial for implementation insights.","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"To begin, we will define the PowerSystem and Measurement types:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\n@branch(resistance = 0.14, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.25)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.35)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.16)\n\naddWattmeter!(monitoring; label = \"Wattmeter 1\", from = \"Branch 1\", active = 0.71)\naddWattmeter!(monitoring; label = \"Wattmeter 2\", bus = \"Bus 3\", active = -1.50)\n\naddVarmeter!(monitoring; label = \"Varmeter 1\", from = \"Branch 1\", reactive = 0.21)\naddVarmeter!(monitoring; label = \"Varmeter 2\", bus = \"Bus 3\", reactive = -0.20)\n\naddPmu!(monitoring; label = \"PMU 1\", bus = \"Bus 2\", magnitude = 0.84, angle = -0.17)\naddPmu!(monitoring; label = \"PMU 2\", bus = \"Bus 3\", magnitude = 0.85, angle = -0.17)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Now, let us create the state estimation model AcStateEstimation and compute the WLS estimator:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"analysis = gaussNewton(monitoring)\nstateEstimation!(analysis; verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Next, we aim to detect bad data in the measurement set using the Chi-squared test:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"chi = chiTest(analysis)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"We obtained the detection flag for bad data:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"chi.detect\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"It indicates the presence of outliers in the measurement set. At this point, it is advisable to proceed with the largest normalized residual test. The same test can also be performed for DC state estimation, as well as for state estimation using only PMUs.","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"manual/badDataAnalysis/#ResidualTestManual","page":"Bad Data Analysis","title":"Largest Normalized Residual Test","text":"","category":"section"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"The largest normalized residual test identifies bad data based on a predefined threshold. Specifically, if the largest normalized residual exceeds the threshold, the corresponding measurement is flagged as bad data, marked as out of service within the Measurement type, and removed from the state estimation model. This allows users to solve the state estimation problem immediately without rebuilding the state estimation model.","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"note: Info\nReaders can refer to the Largest Normalized Residual Test tutorial for implementation insights.","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"After using the Chi-squared test to detect the presence of bad data in the measurement set, let us now identify outliers and remove them:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier = residualTest!(analysis; threshold = 4.0)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Bad data detection is determined by the threshold keyword. If the largest normalized residual value exceeds the threshold, the measurement will be identified as bad data and removed from the AC state estimation model. As a result, we have the following information:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.detect\noutlier.maxNormalizedResidual\noutlier.label","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Hence, upon detecting bad data, the detect variable will be set to true. The maxNormalizedResidual variable will store the value of the largest normalized residual, and the label will contain the label of the measurement identified as bad data. JuliaGrid will mark the corresponding measurement as out-of-service within the Measurement type:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"print(monitoring.wattmeter.label, monitoring.wattmeter.active.status)","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Moreover, JuliaGrid resets the non-zero elements to zero in the Jacobian matrix and mean vector within the state estimation type for measurements now designated as out-of-service, effectively removing the impact of the corresponding measurement:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"analysis.method.jacobian\nanalysis.method.mean","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"After removing bad data, a new estimate can be computed without considering the specific measurement, allowing direct continuation to the iteration loop. In this case, the Gauss-Newton method would take the initial point using voltages obtained with outlier presence, which could significantly impede algorithm convergence. To avoid this undesirable outcome, the user should first establish a new initial point and then commence the iteration procedure:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"setInitialPoint!(analysis)\nstateEstimation!(analysis; verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"manual/badDataAnalysis/#PMU-State-Estimation","page":"Bad Data Analysis","title":"PMU State Estimation","text":"","category":"section"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"In general, the procedures for AC state estimation also apply to PMU state estimation. Let us highlight some specific aspects of this estimation type. First, new phasor measurements are added to the system, and the WLS estimator is obtained using PMU data only:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"addPmu!(monitoring; label = \"PMU 3\", from = \"Branch 1\", magnitude = 0.73, angle = 0.35)\naddPmu!(monitoring; label = \"PMU 4\", bus = \"Bus 1\", magnitude = 1.0, angle = 0.01)\n\nanalysis = pmuStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Next, perform bad data analysis:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier = residualTest!(analysis; threshold = 4.0)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Users can examine the results of the bad data analysis:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.detect\noutlier.label","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"As before, the identified measurement is set out-of-service within the Measurement type. This corresponds to resetting non-zero elements to zero in the coefficient matrix and mean vector, effectively removing its impact:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"analysis.method.mean\nanalysis.method.coefficient","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"This allows the WLS estimator to be recomputed without the influence of the outlier phasor measurement:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"stateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"manual/badDataAnalysis/#DC-State-Estimation","page":"Bad Data Analysis","title":"DC State Estimation","text":"","category":"section"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"For DC state estimation, users can follow the same steps as previously described. To illustrate, let us restore Wattmeter 2 and perform bad data analysis:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"updateWattmeter!(monitoring; label = \"Wattmeter 2\", status = 1)\n\nanalysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis)\n\noutlier = residualTest!(analysis; threshold = 2.0)\nnothing # hide","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Detecting bad data:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.detect\noutlier.label","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"As before, the state estimation model is updated, enabling the user to recompute the WLS estimator:","category":"page"},{"location":"manual/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"analysis.method.mean\nanalysis.method.coefficient\n\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/#ACStateEstimationManual","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To perform nonlinear or AC state estimation, the initial requirement is to have the PowerSystem type configured with the AC model, along with the Measurement type storing measurement data. Next, we can develop either the weighted least-squares (WLS) model, utilizing the Gauss-Newton method, or the least absolute value (LAV) model. These models are encapsulated within the AcStateEstimation type:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"gaussNewton,\nacLavStateEstimation.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To obtain bus voltages and solve the state estimation problem, users need to implement the Gauss-Newton iterative process for the WLS model using:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"increment!,\nsolve!.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Alternatively, to obtain the LAV estimator, simply execute the second function.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"After solving the AC state estimation, JuliaGrid provides functions for computing powers and currents:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"power!,\ncurrent!.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Alternatively, instead of designing their own iteration process for the Gauss-Newton method or using the function responsible for solving the LAV model, and computing powers and currents, users can use the wrapper function:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"stateEstimation!.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Users can also access specialized functions for computing specific types of powers or currents for individual buses, branches, or generators within the power system.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Setup-Initial-Voltages","page":"AC State Estimation","title":"Setup Initial Voltages","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Let us create the PowerSystem and Measurement type:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.1, angle = 0.0)\naddBus!(system; label = \"Bus 2\", type = 1, magnitude = 1.2, angle = -0.1, active = 0.6)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.2)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 1.2)\n\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 1.0)\naddVoltmeter!(monitoring; bus = \"Bus 2\", magnitude = 0.9)\n\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.6)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, we can instantiate the weighted least-squares or least absolute value state estimation models. Let us choose the weighted least-squares model for this example:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The initial voltage values for each model are derived from the voltage magnitudes and angles defined in the PowerSystem type:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"print(system.bus.label, system.bus.voltage.magnitude, system.bus.voltage.angle)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"These values are passed to the AcStateEstimation object during the execution of the gaussNewton or acLavStateEstimation function. Thus, the initial voltages are:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Custom-Initial-Voltages","page":"AC State Estimation","title":"Custom Initial Voltages","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Users may adjust the initial voltages according to their needs. One practical approach is to perform an AC power flow analysis and then apply the resulting solution as the starting point for state estimation:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"pf = newtonRaphson(system)\npowerFlow!(pf)\n\nsetInitialPoint!(analysis, pf)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This approach enables the state estimation process to start from a realistic operating condition, based on the power flow solution.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#ACLSStateEstimationSolutionManual","page":"AC State Estimation","title":"Weighted Least-Squares Estimator","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To begin, we will define the PowerSystem and Measurement types:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\n@branch(resistance = 0.14, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.25)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.35)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.16)\n\n@voltmeter(label = \"Voltmeter ? (!)\")\naddVoltmeter!(monitoring; bus = \"Bus 1\", magnitude = 1.0, variance = 1e-5)\n\n@ammeter(label = \"Ammeter ? (!)\")\naddAmmeter!(monitoring; from = \"Branch 3\", magnitude = 0.0356, variance = 1e-3)\naddAmmeter!(monitoring; to = \"Branch 2\", magnitude = 0.5892, variance = 1e-3)\n\n@wattmeter(label = \"Wattmeter ? (!)\")\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.7067, variance = 1e-4)\naddWattmeter!(monitoring; bus = \"Bus 2\", active = -0.6, variance = 2e-4)\n\n@varmeter(label = \"Varmeter ? (!)\")\naddVarmeter!(monitoring; from = \"Branch 1\", reactive = 0.2125, variance = 1e-4)\naddVarmeter!(monitoring; bus = \"Bus 2\", reactive = -0.1, variance = 1e-5)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, to establish the AC state estimation model, we will utilize the gaussNewton function:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"tip: Tip\nHere, the user triggers LU factorization as the default method for solving the system of linear equations within each iteration of the Gauss-Newton method. However, the user also has the option to select alternative factorization methods such as KLU, LDLt or QR:analysis = gaussNewton(monitoring, LDLt)","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To conduct an iterative process using the Gauss-Newton method, it is essential to include the increment! and solve! functions inside the iteration loop. For example:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"for iteration = 1:20\n    increment!(analysis)\n    solve!(analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Once the state estimator is obtained, users can access the bus voltage magnitudes and angles using:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Breaking-the-Iterative-Process","page":"AC State Estimation","title":"Breaking the Iterative Process","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The iterative process can be terminated using the increment! function. The following code demonstrates how to utilize this function to break out of the iteration loop:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring)\nfor iteration = 1:20\n    stopping = increment!(analysis)\n    if stopping < 1e-8\n        println(\"Solution found in $(analysis.method.iteration) iterations.\")\n        break\n    end\n    solve!(analysis)\nend\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The increment! function returns the maximum absolute values of the state variable increment, which are commonly used as a convergence criterion in the iterative Gauss-Newton algorithm.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nReaders can refer to the AC State Estimation tutorial for implementation insights.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Wrapper-Function","page":"AC State Estimation","title":"Wrapper Function","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"JuliaGrid provides a wrapper function for AC state estimation analysis that manages the iterative solution process and also supports the computation of powers and currents using the stateEstimation! function. Hence, it offers a way to solve AC state estimation with reduced implementation effort:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"setInitialPoint!(analysis) # hide\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis; verbose = 3)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nUsers can choose any approach in this section to obtain the WLS estimator based on their needs. Additionally, users can review the Gauss-Newton Algorithm used in the wrapper function within the tutorial section.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Inclusion-of-PMUs-in-Rectangular-Coordinates","page":"AC State Estimation","title":"Inclusion of PMUs in Rectangular Coordinates","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In the example above, our focus is solely on solving the AC state estimation using SCADA measurements. However, users have the option to also integrate PMUs into the AC state estimation, either in the rectangular or polar coordinate system.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The default approach is to include PMUs in the rectangular coordinate system:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"@pmu(label = \"PMU ? (!)\")\naddPmu!(monitoring; to = \"Branch 1\", magnitude = 0.7466, angle = 2.8011)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In the case of the rectangular system, inclusion resolves ill-conditioned problems arising in polar coordinates due to small values of current magnitudes. However, this approach's main disadvantage is related to measurement errors, as measurement errors correspond to polar coordinates. Therefore, the covariance matrix must be transformed from polar to rectangular coordinates [4]. As a result, measurement errors of a single PMU are correlated, and the covariance matrix does not have a diagonal form. Despite that, the measurement error covariance matrix is usually considered as a diagonal matrix, affecting the accuracy of the state estimation.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In the example above, we specifically include PMUs where measurement error correlations are disregarded. This is evident through the precision matrix, which maintains a diagonal form:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring);\nanalysis.method.precision","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Lastly, we incorporate correlation into our model by adding a new PMU with the desired error correlation:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(monitoring; bus = \"Bus 3\", magnitude = 0.846, angle = -0.1712, correlated = true)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Now, we can observe the precision matrix that does not hold a diagonal form:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring);\nanalysis.method.precision","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Inclusion-of-PMUs-in-Polar-Coordinates","page":"AC State Estimation","title":"Inclusion of PMUs in Polar Coordinates","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The second approach involves incorporating these measurements into the polar coordinate system. For instance:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(monitoring; from = \"Branch 1\", magnitude = 0.7379, angle = -0.2921, polar = true)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This inclusion of PMUs provides more accurate state estimates compared to rectangular inclusion, but demands longer computing time. PMUs are handled in the same manner as SCADA measurements. However, this approach is susceptible to ill-conditioned problems arising in polar coordinates due to small values of current magnitudes [4, 5].","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"tip: Tip\nIt is important to note that with each individual phasor measurement, we can set the coordinate system, providing flexibility to include some in polar and some in rectangular systems. This flexibility is particularly valuable because bus voltage phasor measurements are preferably included in a polar coordinate system, while current phasor measurements are best suited to a rectangular coordinate system.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Print-Results-in-the-REPL","page":"AC State Estimation","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Users have the option to print the results in the REPL using any units that have been configured, such as:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"@voltage(pu, deg)\nprintBusData(analysis)\n@default(unit) # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, users can easily customize the print results for specific buses, for example:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"printBusData(analysis; label = \"Bus 1\", header = true)\nprintBusData(analysis; label = \"Bus 2\")\nprintBusData(analysis; label = \"Bus 3\", footer = true)","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Save-Results-to-a-File","page":"AC State Estimation","title":"Save Results to a File","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Users can also redirect print output to a file. For example, data can be saved in a text file as follows:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"open(\"bus.txt\", \"w\") do file\n    printBusData(analysis, file)\nend","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"tip: Tip\nWe also provide functions to print or save state estimation results, such as estimated values and residuals. For more details, users can consult the Power and Current Analysis section of this manual.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Alternative-Formulations","page":"AC State Estimation","title":"Alternative Formulations","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from finding a satisfactory solution. In such scenarios, users may choose to apply an alternative formulation of the WLS estimator.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"These alternative methods are applicable when measurement errors are uncorrelated and the precision matrix is diagonal. Therefore, as a preliminary step, we need to eliminate the correlation, as we did previously:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"updatePmu!(monitoring; label = \"PMU 2 (Bus 3)\", correlated = false)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nReaders can refer to the Alternative Formulation tutorial for implementation insights.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Orthogonal-Method","page":"AC State Estimation","title":"Orthogonal Method","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"One alternative is the orthogonal method [6, Sec. 3.2], which provides increased numerical robustness, especially with widely varying measurement variances. It solves the WLS problem using QR factorisation on a rectangular matrix formed by multiplying the square root of the precision matrix with the Jacobian in each Gauss-Newton iteration. Enable it by passing the Orthogonal argument to the gaussNewton function:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring, Orthogonal)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Peters-and-Wilkinson-Method","page":"AC State Estimation","title":"Peters and Wilkinson Method","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Another option is the Peters and Wilkinson method [6, Sec. 3.4], which uses LU factorisation on the same rectangular matrix built from the square root of the precision matrix and the Jacobian in each Gauss-Newton iteration. It can be selected by passing the PetersWilkinson argument to the gaussNewton function:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring, PetersWilkinson)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#PMULAVtateEstimationSolutionManual","page":"AC State Estimation","title":"Least Absolute Value Estimator","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data analysis procedures [6, Ch. 6]. However, it is important to note that achieving robustness typically involves increased computational complexity.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To obtain an LAV estimator, users need to employ one of the solvers listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using Ipopt\nusing JuMP  # hide\n\nanalysis = acLavStateEstimation(monitoring, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To solve the formulated LAV state estimation model, simply execute the following function:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"stateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Upon obtaining the solution, access the bus voltage magnitudes and angles using:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nReaders can refer to the Least Absolute Value Estimation tutorial for implementation insights.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#ACMeasurementsAlterationManual","page":"AC State Estimation","title":"Measurement Set Update","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"We begin by creating the PowerSystem and Measurement types with the ems function. The AC model is then configured using acModel! function. After that, we initialize the AcStateEstimation type through the gaussNewton function and solve the resulting state estimation problem:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\n\n@branch(resistance = 0.1, susceptance = 0.02)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.25)\n\nacModel!(system)\n\naddWattmeter!(monitoring; label = \"Wattmeter 1\", from = \"Branch 1\", active = 0.6)\naddWattmeter!(monitoring; label = \"Wattmeter 2\", bus = \"Bus 2\", active = -0.6)\n\naddVarmeter!(monitoring; label = \"Varmeter 1\", from = \"Branch 1\", reactive = 0.2)\naddVarmeter!(monitoring; label = \"Varmeter 2\", bus = \"Bus 2\", reactive = -0.1)\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, we modify the existing Measurement type using add and update functions. Then, we create the new AcStateEstimation type based on the modified system and solve the state estimation problem:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addWattmeter!(monitoring; label = \"Wattmeter 3\", to = \"Branch 1\", active = -0.7)\nupdateWattmeter!(monitoring; label = \"Wattmeter 2\", status = 0)\n\naddVarmeter!(monitoring; label = \"Varmeter 3\", to = \"Branch 1\", reactive = -0.1)\nupdateVarmeter!(monitoring; label = \"Varmeter 2\", variance = 1e-2)\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nThis concept removes the need to restart and recreate the Measurement type from the beginning when implementing changes to the existing measurement set.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#ACStateEstimationUpdateManual","page":"AC State Estimation","title":"State Estimation Update","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"An advanced methodology involves users establishing the AcStateEstimation type using gaussNewton or acLavStateEstimation just once. After this initial setup, users can seamlessly modify existing measurement devices without the need to recreate the AcStateEstimation type.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This advancement extends beyond the previous scenario where recreating the Measurement type was unnecessary, to now include the scenario where AcStateEstimation also does not need to be recreated.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"tip: Tip\nThe addition of new measurements after the creation of AcStateEstimation is not practical in terms of reusing this type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Let us now revisit our defined PowerSystem, Measurement and AcStateEstimation types:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\n\n@branch(resistance = 0.1, susceptance = 0.02)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.25)\n\nacModel!(system)\n\naddWattmeter!(monitoring; label = \"Wattmeter 1\", from = \"Branch 1\", active = 0.6)\naddWattmeter!(monitoring; label = \"Wattmeter 2\", bus = \"Bus 2\", active = -0.6)\naddWattmeter!(monitoring; label = \"Wattmeter 3\", to = \"Branch 1\", active = -0.7, status = 0)\n\naddVarmeter!(monitoring; label = \"Varmeter 1\", from = \"Branch 1\", reactive = 0.2)\naddVarmeter!(monitoring; label = \"Varmeter 2\", bus = \"Bus 2\", reactive = -0.1)\naddVarmeter!(monitoring; label = \"Varmeter 3\", to = \"Branch 1\", reactive = -0.1, status = 0)\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, we modify the existing Measurement type as well as the AcStateEstimation type using add and update functions. We then immediately proceed to solve the state estimation problem:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"updateWattmeter!(analysis; label = \"Wattmeter 3\", status = 1)\nupdateWattmeter!(analysis; label = \"Wattmeter 2\", status = 0)\n\nupdateVarmeter!(analysis; label = \"Varmeter 3\", status = 0)\nupdateVarmeter!(analysis; label = \"Varmeter 2\", variance = 1e-2)\n\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nThis concept removes the need to rebuild both the Measurement and the AcStateEstimation from the beginning when implementing changes to the existing measurement set. In the scenario of employing the WLS model, JuliaGrid can reuse the symbolic factorizations of LU or LDLt, provided that the nonzero pattern of the gain matrix remains unchanged.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#ACSEPowerCurrentAnalysisManual","page":"AC State Estimation","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"After obtaining the solution from the AC state estimation, we can calculate various electrical quantities related to buses and branches using the power! and current! functions. For instance, let us consider the model for which we obtained the AC state estimation solution:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3, susceptance = 0.002)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\n@branch(resistance = 0.02, conductance = 1e-4, susceptance = 0.04)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.05)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.03)\n\naddWattmeter!(monitoring; from = \"Branch 1\", active = 1.046, variance = 1e-2)\naddWattmeter!(monitoring; bus = \"Bus 2\", active = -0.1, variance = 1e-3)\naddWattmeter!(monitoring; from = \"Branch 3\", active = 0.924, variance = 1e-3)\n\naddVarmeter!(monitoring; from = \"Branch 1\", reactive = 0.059, variance = 1e-3)\naddVarmeter!(monitoring; bus = \"Bus 2\", reactive = -0.01, variance = 1e-2)\naddVarmeter!(monitoring; to = \"Branch 3\", reactive = -0.044, variance = 1e-3)\n\nanalysis = gaussNewton(monitoring)\nstateEstimation!(analysis)","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"We can now utilize the provided functions to compute powers and currents:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"power!(analysis)\ncurrent!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For instance, if we want to show the active power injections and the from-bus current angles, we can employ the following code:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.current.from.angle)","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nTo better understand the powers and currents associated with buses and branches that are calculated by the power! and current! functions, we suggest referring to the tutorials on AC State Estimation.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Print-Results-in-the-REPL-2","page":"AC State Estimation","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Users can utilize any of the print functions outlined in the Print API. For example, to print state estimation data related to wattmeters, we can use:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"@power(MW, pu)\nprintWattmeterData(analysis)\n@default(unit) # hide\nnothing # hide","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Save-Results-to-a-CSV-File","page":"AC State Estimation","title":"Save Results to a CSV File","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For CSV output, users should first generate a simple table with style = false, and then save it to a CSV file:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using CSV\n\nio = IOBuffer()\nprintWattmeterData(analysis, io; style = false)\nCSV.write(\"bus.csv\", CSV.File(take!(io); delim = \"|\"))","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Active-and-Reactive-Power-Injection","page":"AC State Estimation","title":"Active and Reactive Power Injection","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To calculate the active and reactive power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"active, reactive = injectionPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Active-and-Reactive-Power-Injection-from-Generators","page":"AC State Estimation","title":"Active and Reactive Power Injection from Generators","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"active, reactive = supplyPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Active-and-Reactive-Power-at-Shunt-Element","page":"AC State Estimation","title":"Active and Reactive Power at Shunt Element","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"active, reactive = shuntPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Active-and-Reactive-Power-Flow","page":"AC State Estimation","title":"Active and Reactive Power Flow","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"active, reactive = fromPower(analysis; label = \"Branch 2\")\nactive, reactive = toPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC State Estimation","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To calculate the active and reactive power linked with branch charging admittances of the particular branch, the function can be used:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"active, reactive = chargingPower(analysis; label = \"Branch 1\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Active powers indicate active losses within the branch's charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Active-and-Reactive-Power-at-Series-Impedance","page":"AC State Estimation","title":"Active and Reactive Power at Series Impedance","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To calculate the active and reactive power across the series impedance of the branch, the function can be used:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"active, reactive = seriesPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance's inductive characteristics.","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Current-Injection","page":"AC State Estimation","title":"Current Injection","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To calculate the current injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"magnitude, angle = injectionCurrent(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Current-Flow","page":"AC State Estimation","title":"Current Flow","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"We can compute the current flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"magnitude, angle = fromCurrent(analysis; label = \"Branch 2\")\nmagnitude, angle = toCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"manual/acStateEstimation/#Current-Through-Series-Impedance","page":"AC State Estimation","title":"Current Through Series Impedance","text":"","category":"section"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:","category":"page"},{"location":"manual/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"magnitude, angle = seriesCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"tutorials/dcStateEstimation/#DCStateEstimationTutorials","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To initiate the process, let us construct the PowerSystem type and formulate the DC model:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, angle = 0.0)\naddBus!(system; label = 2, active = 0.1)\naddBus!(system; label = 3, active = 1.3)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.2)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.1)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.3)\n\ndcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Following that, we will introduce the Measurement type and incorporate a set of measurement devices mathcalM into the graph mathcalG. In typical scenarios, the DC state estimation model relies solely on active power measurements  originating from the set of wattmeters mathcalP. However, we provide the option for users to include measurements from the set of PMUs barmathcalP. Specifically, we utilize only the PMUs installed at the buses barmathcalP_textb subset barmathcalP that measure bus voltage angles. This process of adding measurement devices will be carried out in the State Estimation Model section. Currently, we are only initializing the Measurement type:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"monitoring = measurement(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"ukw: Notation\nHere, when referring to a vector mathbfa, we use the notation mathbfa = a_i or mathbfa = a_ij, where a_i represents the element related with bus i in mathcalN or measurement i in mathcalM, while a_ij denotes the element related with branch (ij) in mathcalE.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#DCSEModelTutorials","page":"DC State Estimation","title":"State Estimation Model","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"In accordance with the DC Model, the DC state estimation is derived through the linearization of the non-linear model. In this linearized model, all bus voltage magnitudes are assumed to be V_i approx 1, i in mathcalN. Additionally, shunt elements and branch resistances are neglected. This simplification implies that the DC model disregards reactive powers and transmission losses, focusing solely on active powers. Consequently, the DC state estimation considers only bus voltage angles, represented as mathbf x equiv bm Theta, as the state variables. As a result, the total number of state variables is n-1, with one voltage angle corresponding to the slack bus.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Within the JuliaGrid framework for DC state estimation, the methodology encompasses both active power flow and injection measurements from the set mathcalP, along with bus voltage angle measurements represented by the set barmathcalP_textb. These measurements contribute to the construction of a linear system of equations:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    mathbfz=mathbfh(bm Theta)+mathbfu","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"where mathbfh(bm Theta)= h_1(bm Theta), dots, h_k(bm Theta)^T is the vector of linear measurement functions, mathbfz = z_1dotsz_k^mathrmT is the vector of measurement values, and mathbfu = u_1dotsu_k^mathrmT is the vector of uncorrelated measurement errors, and this defines the vector of measurement variances mathbfv = v_1dotsv_k^mathrmT, where k = mathcalM.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Therefore, the linear system of equations can be represented based on the specific devices from which measurements originate, whether wattmeters or PMUs:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    beginbmatrix\n      mathbfz_mathcalP3pt\n      mathbfz_barmathcalP_textb\n    endbmatrix =\n    beginbmatrix\n      mathbfh_mathcalP(bm Theta)3pt\n      mathbfh_barmathcalP_textb(bm Theta)\n    endbmatrix +\n    beginbmatrix\n      mathbfu_mathcalP3pt\n      mathbfu_barmathcalP_textb\n    endbmatrix","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"In summary, upon user definition of the measurement devices, each i-th measurement device is linked to the measurement function h_i(bm Theta), the corresponding measurement value z_i, and the measurement variance v_i.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Active-Power-Injection-Measurements","page":"DC State Estimation","title":"Active Power Injection Measurements","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"When adding a wattmeter P_i in mathcalP at bus i in mathcalN, users specify that the wattmeter measures active power injection and define measurement value, variance and measurement function of vectors:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    mathbfz_mathcalP = z_P_i  mathbfv_mathcalP = v_P_i  mathbfh_mathcalP(bm Theta) = h_P_i(bm Theta)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"addWattmeter!(monitoring; label = \"P₃\", bus = 3, active = -1.30, variance = 1e-3)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Here, utilizing the DC Model, we derive the function defining the active power injection as follows:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"   h_P_i(bm Theta) = B_iitheta_i + sum_j in mathcalN_i setminus i B_ij theta_j + P_texttri + P_textshi","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"where mathcalN_i setminus i contains buses incident to bus i, excluding bus i, with the following coefficient expressions:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_i(bm Theta)mathrm partial theta_i = B_ii \n  cfracmathrm partialh_P_i(bm Theta)mathrm partial theta_j = B_ij\n  endaligned","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#From-Bus-End-Active-Power-Flow-Measurements","page":"DC State Estimation","title":"From-Bus End Active Power Flow Measurements","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Additionally, when introducing a wattmeter at branch (ij) in mathcalE, users specify that the wattmeter measures active power flow. It can be positioned at the from-bus end, denoted as P_ij in mathcalP, specifying the measurement value, variance and measurement function of vectors:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    mathbfz_mathcalP = z_P_ij  mathbfv_mathcalP = v_P_ij  mathbfh_mathcalP(bm Theta) = h_P_ij(bm Theta)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"addWattmeter!(monitoring; label = \"P₁₂\", from = 1, active = 0.28, variance = 1e-4)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Here, the function describing active power flow at the from-bus end is defined as follows:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  h_P_ij(bm Theta) = cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"with the following coefficient expressions:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_ij(bm Theta)mathrm partial theta_i = cfrac1tau_ij x_ij \n    cfracmathrm partialh_P_ij(bm Theta)mathrm partial theta_j = -cfrac1tau_ij x_ij\n  endaligned","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#To-Bus-End-Active-Power-Flow-Measurements","page":"DC State Estimation","title":"To-Bus End Active Power Flow Measurements","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Similarly, a wattmeter can be placed at the to-bus end, denoted as P_ji in mathcalP, specifying the measurement value, variance and measurement function of vectors:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    mathbfz_mathcalP = z_P_ji  mathbfv_mathcalP = v_P_ji  mathbfh_mathcalP(bm Theta) = h_P_ji(bm Theta)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"addWattmeter!(monitoring; label = \"P₂₁\", to = 1, active = -0.28, variance = 1e-4)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Thus, the function describing active power flow at the to-bus end is defined as follows:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  h_P_ji(bm Theta) = -cfrac1tau_ij x_ij (theta_i -theta_j-phi_ij)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"with the following coefficient expressions:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  cfracmathrm partialh_P_ji(bm Theta)mathrm partial theta_i = -cfrac1tau_ij x_ij \n  cfracmathrm partialh_P_ji(bm Theta)mathrm partial theta_j = cfrac1tau_ij x_ij","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Bus-Voltage-Angle-Measurements","page":"DC State Estimation","title":"Bus Voltage Angle Measurements","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"If the user opts to include phasor measurements that measure bus voltage angle at bus i in mathcalN, denoted as theta_i in barmathcalP_textb, the user will specify the measurement values, variances, and measurement functions of vectors:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    mathbfz_barmathcalP_textb = z_theta_i  mathbfv_barmathcalP_textb = v_theta_i  mathbfh_barmathcalP_textb(bm Theta) = h_theta_i(bm Theta)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"addPmu!(\n  monitoring; label = \"V₁, θ₁\", bus = 1, magnitude = 1.0, angle = 0,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-6\n)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Here, the function defining the bus voltage angle measurement is straightforward:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    h_theta_i(bm Theta) = theta_i","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"with the following coefficient expression:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  cfracmathrm partialh_theta_i(bm Theta)mathrm partial theta_i=1","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#DCSEWLSStateEstimationTutorials","page":"DC State Estimation","title":"Weighted Least-Squares Estimation","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The solution to the DC state estimation problem is determined by solving the linear weighted least-squares (WLS) problem, represented by the following formula:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"\tmathbf H^T bm Sigma^-1 mathbf H bm Theta = mathbf H^T bm Sigma^-1 (mathbf z - mathbfc)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Here, mathbf z in mathbb R^k denotes the vector of measurement values, the vector mathbf c in mathbb R^k holds constant terms, mathbf H in mathbb R^k times (n-1) represents the coefficient matrix, and bm Sigma in mathbb R^k times k is the measurement error covariance matrix, where the diagonal elements hold measurement variances.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The inclusion of the vector mathbfc is necessary due to the fact that measurement functions associated with active power measurements may include constant terms, especially when there are non-zero shift angles of transformers or shunt elements in the system consuming active powers, as evident from the provided measurement functions.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Implementation","page":"DC State Estimation","title":"Implementation","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"JuliaGrid initiates the DC state estimation framework by setting up the WLS model, as illustrated in the following:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Coefficient-Matrix","page":"DC State Estimation","title":"Coefficient Matrix","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Using the above-described equations, JuliaGrid forms the coefficient matrix mathbfH in mathbbR^k times (n-1):","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐇 = analysis.method.coefficient","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Each row in the matrix corresponds to a specific measurement. The first mathcalP rows correspond to wattmeters, ordered as users add wattmeters, while the last barmathcalP_textb rows correspond to PMUs, also in the order users add PMUs.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Precision-Matrix","page":"DC State Estimation","title":"Precision Matrix","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"JuliaGrid opts not to retain the covariance matrix bm Sigma but rather stores its inverse, the precision or weighting matrix denoted as mathbf W = bm Sigma^-1. The order of these values corresponds to the description provided for the coefficient matrix. Users can access these values using the following command:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐖 = analysis.method.precision","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Mean-Vector","page":"DC State Estimation","title":"Mean Vector","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Users can access the vector mathbf z - mathbfc, which contains the means of Gaussian distributions describing each measurement, using the following command:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐳 = analysis.method.mean","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"In the context of the power system, where phase-shifting transformers and shunt elements consuming active powers are absent, and the slack angle has a zero value, the vector mathbfc= mathbf0. Consequently, the vector of means holds values that are equal to the measurement values.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Estimate-of-State-Variables","page":"DC State Estimation","title":"Estimate of State Variables","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Once the model is established, we solve the WLS equation to derive the estimate of bus voltage angles:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"\thatbm Theta = mathbf H^T bm Sigma^-1 mathbf H^-1 mathbf H^T bm Sigma^-1 (mathbf z - mathbfc)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"This process is executed using the solve! function:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"solve!(analysis)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The initial step involves the LU factorization of the gain matrix:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"\tmathbf G = mathbf H^T bm Sigma^-1 mathbf H = mathbf L mathbf U","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"tip: Tip\nBy default, JuliaGrid utilizes LU factorization as the primary method to factorize the gain matrix. However, users maintain the flexibility to opt for alternative factorization methods such as LDLt or QR.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Access to the factorized gain matrix is available through:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Finally, the estimated bus voltage angles hatbm Theta = hattheta_i, i in mathcalN, can be retrieved using the variable:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"It is essential to note that the slack bus voltage angle is temporarily excluded from the gain matrix mathbf G during computation. It is important to emphasize that this internal handling does not alter the stored elements.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#DCSEOrthogonalWLSStateEstimationTutorials","page":"DC State Estimation","title":"Alternative Formulations","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from converging to a satisfactory solution. In such scenarios, users may choose to apply an alternative formulation of the WLS estimator.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Orthogonal-Method","page":"DC State Estimation","title":"Orthogonal Method","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"One such alternative is the orthogonal method [6, Sec. 3.2], which offers increased numerical robustness, particularly in cases where measurement variances differ significantly:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring, Orthogonal)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To explain the method, we begin with the WLS equation:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"\tmathbf H^T mathbf W mathbf H bm Theta = mathbf H^T mathbf W (mathbf z - mathbfc)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"where mathbf W = bm Sigma^-1. Subsequently, we can write:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  left(mathbf W^12 mathbf Hright)^T  mathbf W^12 mathbf H  bm Theta = left(mathbf W^12 mathbf Hright)^T mathbf W^12 (mathbf z - mathbfc)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Consequently, we have:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  barmathbfH^T  barmathbfH bm Theta = barmathbfH^T  barmathbfz","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"where:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  barmathbfH = mathbf W^12 mathbf H  barmathbfz = mathbf W^12 (mathbf z - mathbfc)","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"At this point, QR factorization is performed on the rectangular matrix:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  barmathbfH = mathbf W^12 mathbf H = mathbfQmathbfR","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Executing this procedure involves the solve! function:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Access to the factorized matrix is possible through:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐐 = analysis.method.factorization.Q\n𝐑 = analysis.method.factorization.R","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To obtain the solution, JuliaGrid avoids materializing the orthogonal matrix mathbfQ and proceeds to solve the system, resulting in the estimate of state variables hatbm Theta = hattheta_i, where i in mathcalN:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Peters-and-Wilkinson-Method","page":"DC State Estimation","title":"Peters and Wilkinson Method","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Another option is the Peters and Wilkinson method [6, Sec. 3.4]:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring, PetersWilkinson)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"This method applies LU factorisation to the rectangular matrix barmathbfH:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  barmathbfH = mathbf W^12 mathbf H = mathbfLmathbfU","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Substituting this into the normal equation:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  barmathbfH^T  barmathbfH bm Theta = barmathbfH^T  barmathbfz","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"yields:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  mathbfU^T mathbfL^T mathbfL mathbfU bm Theta = mathbfU^T mathbfL^T barmathbfz","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"By eliminating mathbfU^T from both sides and introducing a new vector mathbfy = mathbfU bm Theta,  we obtain:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  mathbfL^T mathbfL mathbf y = mathbfL^T barmathbfz","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The Peters and Wilkinson method first solves this equation to compute mathbfy, and then obtains bmTheta by backward substitution using equation mathbfy = mathbfU bm Theta. The main advantage of this approach is that mathbfL^T mathbfL is generally less ill-conditioned than barmathbfH^T barmathbfH, which improves numerical stability.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To execute this procedure, use the solve! function:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Access to the factorised matrices is available via:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Finally, the estimated state variables hatbmTheta = hattheta_i, where i in mathcalN, can be obtained as:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#DCSELAVTutorials","page":"DC State Estimation","title":"Least Absolute Value Estimation","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The least absolute value (LAV) method provides an alternative estimation approach that is considered more robust in comparison to the WLS method. The WLS state estimation problem relies on specific assumptions about measurement errors, whereas robust estimators aim to remain unbiased even in the presence of various types of measurement errors and outliers. This characteristic eliminates the need for bad data analysis, as discussed in [6, Ch. 6]. It is important to note that robustness often comes at the cost of increased computational complexity.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"It can be demonstrated that the problem can be expressed as a linear programming problem. This section outlines the method as described in [6, Sec. 6.5]. To revisit, we consider the system of linear equations:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  mathbfz=mathbfh(bm Theta)+mathbfu","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The LAV state estimator is then formulated as the solution to the following optimization problem:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  beginaligned\n    textminimize  sum_i in mathcal M r_i\n    textsubjectto  z_i - h_i(bm Theta) =  r_i  forall i in mathcal M\n  endaligned","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"where r_i denotes the residual of the i-th measurement.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To explicitly handle absolute values, we introduce two nonnegative variables u_i ge 0 and v_i ge 0, referred to as positive and negative deviations. This allows the optimization problem to be rewritten as:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"  beginaligned\n    textminimize  sum_i in mathcal M (u_i + v_i) \n    textsubjectto    z_i - h_i(bm Theta) = u_i - v_i  forall i in mathcal M \n                          u_i geq  0  v_i geq  0  forall i in mathcal M\n  endaligned","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To form the above optimization problem, the user can call the following function:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using Ipopt\nusing JuMP # hide\n\nanalysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Then the user can solve the optimization problem by:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"JuMP.set_silent(analysis.method.jump) # hide\nsolve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Users can retrieve the estimated bus voltage angles hatbm Theta = hattheta_i, i in mathcalN, using the variable:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#DCSEPowerAnalysisTutorials","page":"DC State Estimation","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"After obtaining the solution from the DC state estimation, we can calculate powers related to buses and branches using the power! function:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Power-Injections","page":"DC State Estimation","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Active power injections are stored as the vector mathbfP = P_i, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐏 = analysis.power.injection.active","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Generator-Power-Injections","page":"DC State Estimation","title":"Generator Power Injections","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"We can determine the active power supplied by generators to the buses by summing the active power injections and the active power demanded by consumers at each bus:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"    P_textpi = P_i + P_textdi i in mathcalN","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The vector of active power injected by generators into the buses, denoted by mathbfP_textp = P_textpi, can be obtained using:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐏ₚ = analysis.power.supply.active","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"tutorials/dcStateEstimation/#Power-Flows","page":"DC State Estimation","title":"Power Flows","text":"","category":"section"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The resulting active power flows are stored as the vector mathbfP_texti = P_ij, which can be retrieved using:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐏ᵢ = analysis.power.from.active","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Similarly, the resulting active power flows are stored as the vector mathbfP_textj = P_ji, which can be retrieved using:","category":"page"},{"location":"tutorials/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"𝐏ⱼ = analysis.power.to.active","category":"page"},{"location":"manual/powerSystemModel/#PowerSystemModelManual","page":"Power System Model","title":"Power System Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports the type PowerSystem to preserve power system data, with the following fields: bus, branch, generator, base, and model. The bus, branch, and generator fields hold data related to buses, branches, and generators, respectively. The base field stores base values for power and voltages, with the default being three-phase power measured in volt-amperes for the base power and line-to-line voltages measured in volts for base voltages. Within the model field, the ac and dc subfields store vectors and matrices pertinent to the power system's topology and parameters, and these are utilized in either the AC or DC framework.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The type PowerSystem can be created using a function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"powerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid supports four modes for populating the PowerSystem type: using built-in functions, using HDF5 file format, using Matpower case files, and using PSSE version 33 case files.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is recommended to use the HDF5 format for large-scale systems. To facilitate this, JuliaGrid has the function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon creation of the PowerSystem type, users can generate vectors and matrices based on the power system topology and parameters using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"acModel!,\ndcModel!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type is created, users can add buses, branches, generators, or manage costs associated with the output powers of the generators, using the following functions:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!,\naddBranch!,\naddGenerator!,\ncost!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"JuliaGrid also provides macros @bus, @branch, and @generator to define templates that aid in creating buses, branches, and generators. These templates help avoid entering the same parameters repeatedly.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Moreover, it is feasible to modify the parameters of buses, branches, and generators. When these functions are executed, all relevant fields within the PowerSystem type will be automatically updated, encompassing the ac and dc fields as well. These functions include:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBus!,\nupdateBranch!,\nupdateGenerator!.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nThe functions addBranch!, addGenerator!, updateBus!, updateBranch!, updateGenerator!, and cost! serve a dual purpose. While their primary function is to modify the PowerSystem type, they are also designed to accept various analysis models like AC or DC power flow models. When feasible, these functions not only modify the PowerSystem type but also adapt the analysis model, often resulting in improved computational efficiency. Detailed instructions on utilizing this feature can be found in dedicated manuals for specific analyses.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#BuildModelManual","page":"Power System Model","title":"Build Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The powerSystem function generates the PowerSystem type and requires a string-formatted path to either Matpower cases or HDF5 files as input. Alternatively, the PowerSystem can be created without any initial data by initializing it as empty, allowing the user to construct the power system from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"info: Info\nWhile building the model, users can manage bus, branch, and generator labels in several ways. For more details, see the Labels section.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Matpower-File","page":"Power System Model","title":"Matpower File","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, to create the PowerSystem type using the Matpower case file for the IEEE 14-bus test case, which is named case14.m and located in the folder C:\\matpower, the following Julia code can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/matpower/case14.m\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#PSSE-File","page":"Power System Model","title":"PSSE File","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, to create the PowerSystem type using a PSSE version 33 case file for the IEEE 14-bus test case, named case14.raw and located in the folder C:\\psse, use the following Julia code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/psse/case14.raw\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#HDF5-File","page":"Power System Model","title":"HDF5 File","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In order to use the HDF5 file as input to create the PowerSystem type, it is necessary to have saved the data using the savePowerSystem function beforehand. As an example, let us say we saved the power system as case14.h5 in the directory C:\\hdf5. In this case, the following Julia code can be used to construct the PowerSystem type:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/hdf5/case14.h5\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is recommended to load the power system from the HDF5 file to reduce the loading time.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#PartialLoadFasterImportManual","page":"Power System Model","title":"Partial Load for Faster Import","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"A significant portion of data in input files may relate to optimal power flow analysis. If AC or DC optimal power flow is not needed, users can skip importing this additional data by setting the optimal keyword to false. For example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem(\"C:/matpower/case14.m\"; optimal = false)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This reduces memory usage and speeds up data loading, which is especially useful for large-scale systems.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Model-from-Scratch","page":"Power System Model","title":"Model from Scratch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Alternatively, the model can be built from scratch using built-in functions, for example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05, base = 345e3)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.05)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Internal-Unit-System","page":"Power System Model","title":"Internal Unit System","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The PowerSystem type stores all electrical quantities in per-units and radians, except for the base values of power and voltages. The base power value is expressed in volt-amperes, while the base voltages are given in volts.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Base-Unit-Prefixes","page":"Power System Model","title":"Change Base Unit Prefixes","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The user can retrieve the base power and base voltage values along with their respective units:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By using the @base macro, users can change the prefixes of the base units. For instance, if users wish to convert base power and base voltage values to megavolt-amperes (MVA) and kilovolts (kV) respectively, they can execute the following macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, MVA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After executing the macro, the base power and voltage values and their units will be modified accordingly:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.power.value, system.base.power.unit\nsystem.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#SaveModelManual","page":"Power System Model","title":"Save Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once the PowerSystem type has been created using one of the methods outlined in Build Model, the data can be stored in the HDF5 file by using the savePowerSystem function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"savePowerSystem(system; path = \"C:/matpower/case14.h5\", reference = \"IEEE 14-bus test case\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"All electrical quantities saved in the HDF5 file are in per-units and radians, except for base values for power and voltages, which are given in volt-amperes and volts. Note that even if the user modifies the base units using the @base macro, the units will still be saved with the default settings.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBusManual","page":"Power System Model","title":"Add Bus","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The buses can be added both to the loaded power system, or to the one created from scratch. As an illustration, we can initiate the PowerSystem type and then incorporate two buses by utilizing the addBus! function:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, base = 345e3)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.034907, base = 345e3)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, we have created two buses where the active power demanded by the consumer at Bus 1 is specified in per-units, which are the same units used to store electrical quantities:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is worth noting that the base keyword is used to specify the base voltages, and its default input unit is in volts (V):","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Also, we have defined the bus voltage angle in radians for Bus 2 as its initial value:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users can also display information for a specific bus with:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"print(system; bus = \"Bus 1\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nWe recommend reading the documentation for the addBus! function, where we have provided a list of all the keywords that can be used.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units","page":"Power System Model","title":"Customizing Input Units","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Typically, all keywords associated with electrical quantities are expected to be provided in per-units and radians by default, with the exception of base voltages, which should be specified in volts. However, users can choose to use different units than the default per-units and radians or modify the prefix of the base voltage unit by using macros such as the following:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\n@power(MW, MVAr, pu)\n@voltage(pu, deg, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This practical example showcases the customization approach. For keywords tied to active powers, the unit is set as megawatts (MW), while reactive powers employ megavolt-amperes reactive (MVAr). Apparent power, on the other hand, employs per-units (pu). As for keywords concerning voltage magnitude, per-units (pu) remain the choice, but voltage angle mandates degrees (deg). Lastly, the input unit for base voltage is elected to be kilovolts (kV).","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now we can create identical two buses as before using new system of units as follows:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 10.0, base = 345.0)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -2.0, base = 345.0)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As can be observed, electrical quantities will continue to be stored in per-units and radians format:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active\nsystem.bus.voltage.angle","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The base voltage values will still be stored in volts (V) since we only changed the input unit prefix, and did not modify the internal unit prefix, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To modify the internal unit prefix, the following macro can be used:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@base(system, VA, kV)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After executing this macro, the base voltage values will be stored in kilovolts (kV):","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.base.voltage.value, system.base.voltage.unit","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, the user can check the unit system in use for bus-related keywords:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@info(unit, bus)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddBranchManual","page":"Power System Model","title":"Add Branch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The branch connecting two buses can be added once those buses are defined, and from and to keywords must correspond to labels of those buses. For example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Here, we created the branch from Bus 1 to Bus 2 with following parameter:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users can also display information for a specific branch with:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"print(system; branch = \"Branch 1\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to consult the documentation for the addBranch! function, where we have provided a list of all the keywords that can be used.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-2","page":"Power System Model","title":"Customizing Input Units","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To use units other than per-units and radians, macros can be employed to change the input units. For example, if there is a need to use ohms (Ω), the macros below can be employed:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@parameter(Ω, pu)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 22.8528)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Still, all electrical quantities are stored in per-units, and the same branch as before is created:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"It is important to note that, when working with impedance and admittance values in ohms (Ω) and siemens (S) that are related to a transformer, the assignment must be based on the primary side of the transformer.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, the user can check the unit system in use for branch-related keywords:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@info(unit, branch)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddGeneratorManual","page":"Power System Model","title":"Add Generator","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The generator connected to a bus can be added once the bus is defined. Each generator must have a unique label, and the bus keyword should correspond to the unique label of the bus it is connected to. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 0.5, reactive = 0.1)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the above code, we add the generator to the Bus 2, with active and reactive power outputs set to:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.output.active\nsystem.generator.output.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similar to buses and branches, the input units for generators can be set to values other than per-unit using appropriate macros. The unit system in use for generator-related data can be checked by using the macro @info(unit, generator).","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users can also display information for a specific generator with:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"print(system; generator = \"Generator 1\")","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is recommended to refer to the documentation for the addGenerator! function, where we have provided a list of all the keywords that can be used.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddTemplatesManual","page":"Power System Model","title":"Add Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The functions addBus!, addBranch!, and addGenerator! are used to add bus, branch, and generator to the power system, respectively. If certain keywords are not specified, default values are assigned to parameters.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Default-Keyword-Values","page":"Power System Model","title":"Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Regarding the addBus! function, the bus type is automatically configured as a demand bus with type = 1. The initial bus voltage magnitude is set to magnitude = 1.0 per-unit, while the base voltage is established as base = 138e3 volts. Additionally, the minimum and maximum bus voltage magnitudes are set to minMagnitude = 0.9 per-unit and maxMagnitude = 1.1 per-unit, respectively.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Transitioning to the addBranch! function, the default operational status is status = 1, indicating that the branch is in-service. The off-nominal turns ratio for the transformer is specified as turnsRatio = 1.0, and the phase shift angle is set to shiftAngle = 0.0, collectively defining the line configuration with these standard settings. The flow rating is also configured as type = 3. Moreover, the minimum and maximum voltage angle differences between the from-bus and to-bus ends are set to minDiffAngle = -2pi and maxDiffAngle = 2pi, respectively.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the addGenerator! function designates an operational generator by employing status = 1, and it sets magnitude = 1.0 per-unit, denoting the desired voltage magnitude setpoint. By default, the generator's output is constrained with limits: minActive = 0.0, maxActive = 5 active, minReactive = -5 reactive, and maxReactive = 5 reactive, where active and reactive refer to the generator’s output powers.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The remaining parameters are initialized with default values of zero.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Change-Default-Keyword-Values","page":"Power System Model","title":"Change Default Keyword Values","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In JuliaGrid, users have the flexibility to adjust default values and assign customized values using the @bus, @branch, and @generator macros. These macros create bus, branch, and generator templates that are used every time the addBus!, addBranch!, and addGenerator! functions are called. For instance, the code block shows an example of creating bus, branch, and generator templates with customized default values:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\n@bus(type = 2, active = 0.1)\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\", type = 1, active = 0.5)\n\n@branch(reactance = 0.12)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\")\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.06)\n\n@generator(magnitude = 1.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.6)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\", active = 0.2)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This code example involves two uses of the addBus! and addBranch! functions. In the first use, the functions rely on the default values set by the templates created with the @bus and @branch macros. In contrast, the second use passes specific values that match the keywords used in the templates. As a result, the templates are ignored:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.layout.type\nsystem.bus.demand.active\nsystem.branch.parameter.reactance","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the given example, the @generator macro is utilized instead of repeatedly specifying the magnitude keyword in the addGenerator! function. This macro creates a generator template with a default value for magnitude, which is automatically applied every time the addGenerator! function is called. Therefore, it eliminates the requirement to set the magnitude value for each individual generator:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.voltage.magnitude","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users can view the templates associated with the bus, branch, or generators keywords. For example, to check templates related to bus keywords, use:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@info(template, bus)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-3","page":"Power System Model","title":"Customizing Input Units","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Templates can also be defined using a custom unit system, for example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\n@power(MW, MVAr)\n@bus(active = 100, reactive = 200)\naddBus!(system; label = \"Bus 1\")\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, we create the bus template and one bus using SI power units. The resulting power values are:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.demand.active\nsystem.bus.demand.reactive","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Multiple-Templates","page":"Power System Model","title":"Multiple Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In the case of calling the @bus, @branch, or @generator macros multiple times, the provided keywords and values will be combined into a single template for the corresponding component (bus, branch, or generator), which will be used for generating the component.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Reset-Templates","page":"Power System Model","title":"Reset Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To reset the bus, branch, and generator templates to their default settings, users can utilize the following macros:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(bus)\n@default(branch)\n@default(generator)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, users can reset all templates using the macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#LabelsManual","page":"Power System Model","title":"Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we have shown, JuliaGrid mandates a distinctive label for every bus, branch, or generator. These labels are stored in ordered dictionaries, functioning as pairs of strings and integers. The string signifies the exclusive label for the specific component, whereas the integer maintains an internal numbering of buses, branches, or generators.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nString labels improve readability, but in larger models, the overhead from using strings can become substantial. To reduce memory usage, users can configure ordered dictionaries to accept and store integers as labels:@config(label = Integer)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Integer-Based-Labeling","page":"Power System Model","title":"Integer-Based Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Instead of using strings for labels, Julia provides the @config macro to enable storing labels as integers:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n@config(label = Integer)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.1)\naddBus!(system; label = 2, type = 1, angle = -0.2)\n\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; label = 1, bus = 2, active = 0.5, reactive = 0.1)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Note that the @config macro must be executed first. Otherwise, even if integers are passed to the functions, labels will be stored as strings. In this example, two buses are created with integer labels 1 and 2. A branch connects them and is assigned label 1, while a generator is added to bus 2, also labeled 1.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Integer-String-Based-Labeling","page":"Power System Model","title":"Integer-String-Based Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In addition to using only strings or only integers, JuliaGrid also supports mixed labeling. For example, you can assign string labels to buses while keeping integer labels for branches and generators:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(unit) # hide\n@default(template) # hide\n@branch(label = Integer)\n@generator(label = Integer)\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, angle = -0.2)\n\naddBranch!(system; label = 1, from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\n\naddGenerator!(system; label = 1, bus = \"Bus 2\", active = 0.5, reactive = 0.1)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this case, the two buses are labeled with strings Bus 1 and Bus 2. A branch connects them using an integer label 1, and a generator is placed on Bus 2, also with an integer label 1. The same configuration can also be achieved by using the @config macro together with the @bus macro:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@config(label = Integer)\n@bus(label = String)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Automated-Labeling","page":"Power System Model","title":"Automated Labeling","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Users also possess the option to omit the label keyword, allowing JuliaGrid to independently allocate unique labels for buses, branches, or generators. In such instances, JuliaGrid employs an ordered set of incremental integers for labeling components. To illustrate, consider the subsequent example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; type = 3, active = 0.1)\naddBus!(system; type = 1, angle = -0.2)\n\naddBranch!(system; from = 1, to = 2, reactance = 0.12)\n\naddGenerator!(system; bus = 2, active = 0.5, reactive = 0.1)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, two buses are created with automatically assigned string labels 1 and 2. A branch connects them with label 1, and a generator is added to bus 2, also labeled 1. Since the @config macro is not used, labels are stored as strings by default. To ensure automated labels are stored as integers, users should either set label = Integer in the @config macro or customize label types using the @bus, @branch, and @generator macros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Automated-Labeling-Using-Templates","page":"Power System Model","title":"Automated Labeling Using Templates","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Additionally, users have the ability to generate labels through templates and employ the symbol ? to insert an incremental set of integers at any location. For instance:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\n@bus(label = \"Bus ? HV\")\naddBus!(system; type = 3, active = 0.1)\naddBus!(system; type = 1, angle = -0.2)\n\n@branch(label = \"Branch ?\")\naddBranch!(system; from = \"Bus 1 HV\", to = \"Bus 2 HV\", reactance = 0.12)\n\n@generator(label = \"Generator ?\")\naddGenerator!(system; bus = \"Bus 2 HV\", active = 0.5, reactive = 0.1)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In this example, two buses are generated and labeled as Bus 1 HV and Bus 2 HV, along with one branch and one generator labeled as Branch 1 and Generator 1, respectively.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Retrieving-Labels","page":"Power System Model","title":"Retrieving Labels","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we will outline how users can retrieve stored labels. Let us consider the following power system:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 3\")\n\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 1\", reactance = 0.8)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.5)\n\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\")\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 3\")\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For instance, the bus labels can be accessed using the variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If the objective is to obtain only labels, users can utilize the following:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label = collect(keys(system.bus.label))","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This approach can also be extended to branch and generator labels by making use of the variables present within the PowerSystem type, namely system.branch.label or system.generator.label.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Moreover, the from and to keywords associated with branches are stored based on internally assigned numerical values linked to bus labels. These values are stored in variables:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[system.branch.layout.from system.branch.layout.to]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To recover the original from and to labels, we can utilize:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"[label[system.branch.layout.from] label[system.branch.layout.to]]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, the bus keywords related to generators are saved based on internally assigned numerical values corresponding to bus labels and can be accessed using:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.layout.bus","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To recover the original bus labels, we can utilize:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"label[system.generator.layout.bus]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nJuliaGrid offers the capability to print labels alongside various types of data, such as power system parameters, voltages, powers, currents, or constraints used in optimal power flow analyses. For instance:print(system.branch.label, system.branch.parameter.reactance)","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Managing-Labels-in-Matpower-and-PSSE-Imports","page":"Power System Model","title":"Managing Labels in Matpower and PSSE Imports","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"When importing a power system from a Matpower or PSSE file, JuliaGrid stores all labels as strings by default. If the file contains bus names, these names are used as bus labels. In contrast, branch and generator labels are automatically assigned as incremental integers.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"This default labeling behavior can be modified using macros. For example, in the case5.m file, bus names are included. The following code shows how to load the system while generating custom branch labels and storing generator labels as integers:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template) # hide\n@branch(label = \"Branch ?\")\n@generator(label = Integer)\n\nsystem = powerSystem(\"case5.m\")\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As a result, bus labels are read directly from the case5.m file:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Branch labels are generated based on the specified template:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.branch.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Generator labels are automatically assigned as a sequential set of integers and stored as such:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In cases where bus names are not included in the input file, as is the case with case4.m, users can define a label template to generate bus labels manually. For example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template) # hide\n@bus(label = \"Bus ?\")\n\nsystem = powerSystem(\"case4.m\")\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As a result, JuliaGrid uses the integer bus indices from case4.m to create labels according to the template:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"If the goal is to work directly with the integer bus labels provided in case4.m and preserve them as integers, users can specify that explicitly:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@default(template) # hide\n@bus(label = Integer)\n\nsystem = powerSystem(\"case4.m\")\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As a result, bus labels are imported and stored as integers:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.label","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Managing-Labels-in-HDF5-Imports","page":"Power System Model","title":"Managing Labels in HDF5 Imports","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"When saving the power system to an HDF5 file, the label type (strings or integers) will match the type chosen during system setup. Similarly, when loading a system from an HDF5 file, JuliaGrid preserves the stored label types without applying any overrides from the @config, @bus, @branch, or @generator macros.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#ACDCModelManual","page":"Power System Model","title":"AC and DC Model","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"When we constructed the power system, we can create an AC and/or DC model, which include vectors and matrices related to the power system's topology and parameters. The following code snippet demonstrates this:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.008, reactance = 0.05)\n\nacModel!(system)\ndcModel!(system)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIn many instances throughout the JuliaGrid documentation, we explicitly mention these functions by their names, although it is not mandatory. If a user begins any of the various AC or DC analyses without having previously established the AC or DC model using the acModel! or dcModel! function, the respective function for setting the analysis will automatically create the AC or DC model.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The nodal matrices are one of the components of both the AC and DC models and are stored in the variables:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix\nsystem.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nThe AC model is used for performing AC power flow, AC optimal power flow, AC state estimation, or state estimation with PMUs, whereas the DC model is essential for various DC or linear analyses. Consequently, once these models are developed, they can be applied to various types of simulations. We recommend that the reader refers to the tutorial on AC and DC models.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Branch-Triggers-Model-Update","page":"Power System Model","title":"New Branch Triggers Model Update","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can execute the acModel! and dcModel! functions after defining the final number of buses, and each new branch added will trigger an update of the AC and DC matrices and vectors. Here is an example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1)\naddBus!(system; label = \"Bus 2\", type = 1, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\nacModel!(system)\ndcModel!(system)\n\naddBranch!(system; from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12, shiftAngle = 0.1745)\naddBranch!(system; from = \"Bus 2\", to = \"Bus 3\", resistance = 0.008, reactance = 0.05)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For example, the nodal matrix in the DC framework has the same values as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nIt is not fully recommended to create AC and DC models before adding a large number of branches if the execution time of functions is important. Instead, triggering updates to the AC and DC models using the addBranch! function is useful for power systems that require the addition of several branches. This update avoids the need to recreate vectors and matrices from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#New-Bus-Triggers-Model-Erasure","page":"Power System Model","title":"New Bus Triggers Model Erasure","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The AC and DC models must be defined once a finite number of buses has been defined, otherwise, adding a new bus will delete them. For example, if we attempt to add a new bus to the PowerSystem type that was previously created, the current AC and DC models will be completely erased:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"addBus!(system; label = \"Bus 4\", type = 2)\nsystem.model.ac.nodalMatrix\nsystem.model.dc.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#UpdateBusManual","page":"Power System Model","title":"Update Bus","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once a bus has been added to the PowerSystem type, users have the flexibility to modify all parameters defined within the addBus! function. This means that when the updateBus! function is used, the PowerSystem type within AC and DC models that have been created is updated. This eliminates the need to recreate the AC and DC models from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To illustrate, let us consider the following power system:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, conductance = 0.01)\naddBus!(system; label = \"Bus 2\", type = 2, reactive = 0.05)\naddBus!(system; label = \"Bus 3\", type = 1, susceptance = 0.05)\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.12)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.05)\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.5)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 1\", active = 0.2)\n\nacModel!(system)\ndcModel!(system)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"For instance, the nodal matrix in the AC framework has the following form:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now, let us add a shunt element to Bus 2:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBus!(system; label = \"Bus 2\", conductance = 0.4, susceptance = 0.5)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we can observe, executing the function triggers an update of the AC nodal matrix:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#UpdateBranchManual","page":"Power System Model","title":"Update Branch","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Once a branch has been added to the PowerSystem type, users have the flexibility to modify all parameters defined within the addBranch! function. This means that when the updateBranch! function is used, the PowerSystem type within AC and DC models that have been created is updated. This eliminates the need to recreate the AC and DC models from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To illustrate, let us continue with the previous example and modify the parameters of Branch 1 as follows:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBranch!(system; label = \"Branch 1\", resistance = 0.012, reactance = 0.3)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can observe the update in the AC nodal matrix:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Next, let us switch the status of Branch 2 from in-service to out-of-service:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateBranch!(system; label = \"Branch 2\", status = 0)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As before, the updated AC nodal matrix takes the following form:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.model.ac.nodalMatrix","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Drop-Zeros","page":"Power System Model","title":"Drop Zeros","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After the last execution of the updateBranch! function, the nodal matrices will contain zeros, as demonstrated in the code example. If needed, the user can remove these zeros using the dropZeros! function, as shown below:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"dropZeros!(system.model.ac)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"note: Info\nIt is worth mentioning that in simulations conducted with the JuliaGrid package, the precision of the outcomes remains unaffected even if zero entries are retained. However, we recommend users utilize this function instead of dropzeros! from the SuiteSparse package to ensure seamless functioning of all JuliaGrid functionalities.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#UpdateGeneratorManual","page":"Power System Model","title":"Update Generator","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, users can update all generator parameters defined within the addGenerator! function using the updateGenerator! function. The execution of this function will affect all variables within the PowerSystem type.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In short, in addition to the generator field, JuliaGrid also retains variables associated with generators within the bus field. As an example, let us examine one of these variables and its values derived from a previous example:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Next, we will change the active output power of Generator 1:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"updateGenerator!(system; label = \"Generator 1\", active = 0.9)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"As we can see, executing the function triggers an update of the observed variable:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.bus.supply.active","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Hence, this function ensures the adjustment of generator parameters and updates all fields of the PowerSystem type affected by them.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#AddUpdateCostsManual","page":"Power System Model","title":"Add and Update Costs","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The cost! function is responsible for adding and updating costs associated with the active or reactive power produced by the corresponding generator. These costs are added only if the corresponding generator is defined.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"To start, let us create an example of a power system using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"using JuliaGrid # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = \"Bus 1\")\naddBus!(system; label = \"Bus 2\")\n\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 2\", active = 1.0, reactive = 0.4)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Polynomial-Cost","page":"Power System Model","title":"Polynomial Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Let us define a quadratic polynomial cost function for the active power produced by the Generator 1:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; generator = \"Generator 1\", active = 2, polynomial = [1100.0; 500.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"In essence, what we have accomplished is the establishment of a cost function depicted as f(P_textg1) = 1100 P_textg1^2 + 500 P_textg1 + 150 through the code provided. In general, when constructing a polynomial cost function, the coefficients must be ordered from the highest degree to the lowest.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The default input units are in per-units, with coefficients of the cost function having units of currency/pu²-hr for 1100, currency/pu-hr for 500, and currency/hr for 150. Therefore, the coefficients are stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial[1]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"By setting active = 2 within the function, we express our intent to specify the active power cost using the active key. By using a value of 2, we signify our preference for employing a polynomial cost model for the associated generator. This flexibility is neccessary when we have also previously defined a piecewise linear cost function for the same generator. In such cases, we can set active = 1 to utilize the piecewise linear cost function to represent the cost of the corresponding generators. Thus, we retain the freedom to choose between these two cost functions according to the requirements of our simulation. Additionally, users have the option to define both piecewise and polynomial costs within a single function call, further enhancing the versatility of the implementation.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Piecewise-Linear-Cost","page":"Power System Model","title":"Piecewise Linear Cost","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"We can also create a piecewise linear cost function, for example, let us create the reactive power cost function for the same generator using the following code:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; generator = \"Generator 1\", reactive = 1, piecewise = [0.11 12.3; 0.15 16.8])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"The first column denotes the generator's output reactive powers in per-units, while the second column specifies the corresponding costs for the specified reactive power in currency/hr. Thus, the data is stored exactly as entered:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.reactive.piecewise[1]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"","category":"page"},{"location":"manual/powerSystemModel/#Customizing-Input-Units-4","page":"Power System Model","title":"Customizing Input Units","text":"","category":"section"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Changing input units from per-units can be particularly useful since cost functions are usually related to SI units. Let us set active powers in megawatts (MW) and reactive powers in megavolt-amperes reactive (MVAr):","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"@power(MW, MVAr)\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Now, we can add the quadratic polynomial function using megawatts:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; generator = \"Generator 1\", active = 2, polynomial = [0.11; 5.0; 150.0])","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"After inspecting the resulting cost data, we can see that it is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.active.polynomial[1]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Similarly, we can define the linear piecewise cost using megavolt-amperes reactive:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"cost!(system; generator = \"Generator 1\", reactive = 1, piecewise = [11.0 12.3; 15.0 16.8])\nnothing # hide","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Upon inspection, we can see that the stored data is the same as before:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"system.generator.cost.reactive.piecewise[1]","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"tip: Tip\nThe cost! function not only adds costs but also allows users to update previously defined cost functions. This functionality is particularly valuable in optimal power flow analyses, as it allows users to modify generator power costs without the need to recreate models from scratch.","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"Finally, we can inspect data for the specific generator using:","category":"page"},{"location":"manual/powerSystemModel/","page":"Power System Model","title":"Power System Model","text":"print(system; generator = \"Generator 1\")","category":"page"},{"location":"api/powerFlow/#PowerFlowAPI","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"For further information on this topic, please see the AC Power Flow or DC Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for power flow analysis.","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"To load power flow API functionalities into the current scope, utilize the following command:","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"using JuliaGrid","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#AC-Power-Flow","page":"Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"newtonRaphson\nfastNewtonRaphsonBX\nfastNewtonRaphsonXB\ngaussSeidel\nmismatch!\nsolve!\nsetInitialPoint!\nreactiveLimit!\nadjustAngle!\npowerFlow!","category":"page"},{"location":"api/powerFlow/#DC-Power-Flow","page":"Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"dcPowerFlow\nsolve!\npowerFlow!","category":"page"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#AC-Power-Flow-2","page":"Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/#JuliaGrid.newtonRaphson","page":"Power Flow","title":"JuliaGrid.newtonRaphson","text":"newtonRaphson(system::PowerSystem, [factorization::Factorization = LU])\n\nThe function sets up the Newton-Raphson method to solve the AC power flow.\n\nArguments\n\nThe function requires the PowerSystem type to establish the framework. Next, the Factorization argument, while optional, determines the method used to solve the linear system of equations within each iteration. It can take one of the following values:\n\nLU: Utilizes LU factorization (default).\nKLU: Utilizes KLU factorization.\nQR: Utilizes QR factorization.\n\nUpdates\n\nIf the AC model has not been created, the function automatically initiates an update within the ac field of the PowerSystem type. It also performs a check on bus types and rectifies any mistakes present.\n\nReturns\n\nThe function returns an instance of the AcPowerFlow type.\n\nExamples\n\nSet up the Newton-Raphson method utilizing LU factorization:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\n\nSet up the Newton-Raphson method utilizing KLU factorization:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system, KLU)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonBX","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonBX","text":"fastNewtonRaphsonBX(system::PowerSystem, [factorization::Factorization = LU])\n\nThe function sets up the fast Newton-Raphson method of version BX to solve the AC power flow.\n\nArguments\n\nThe function requires the PowerSystem type to establish the framework. Next, the Factorization argument, while optional, determines the method used to solve the linear system of equations within each iteration. It can take one of the following values:\n\nLU: Utilizes LU factorization (default).\nKLU: Utilizes KLU factorization.\nQR: Utilizes QR factorization.\n\nUpdates\n\nIf the AC model has not been created, the function automatically initiates an update within the ac field of the PowerSystem type. It also performs a check on bus types and rectifies any mistakes present.\n\nReturns\n\nThe function returns an instance of the AcPowerFlow type.\n\nExamples\n\nSet up the fast Newton-Raphson method utilizing LU factorization:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonBX(system)\n\nSet up the fast Newton-Raphson method utilizing KLU factorization:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonBX(system, KLU)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.fastNewtonRaphsonXB","page":"Power Flow","title":"JuliaGrid.fastNewtonRaphsonXB","text":"fastNewtonRaphsonXB(system::PowerSystem, [factorization::Factorization = LU])\n\nThe function sets up the fast Newton-Raphson method of version XB to solve the AC power flow.\n\nArguments\n\nThe function requires the PowerSystem type to establish the framework. Next, the Factorization argument, while optional, determines the method used to solve the linear system of equations within each iteration. It can take one of the following values:\n\nLU: Utilizes LU factorization (default).\nKLU: Utilizes KLU factorization.\nQR: Utilizes QR factorization.\n\nUpdates\n\nIf the AC model has not been created, the function automatically initiates an update within the ac field of the PowerSystem type. It also performs a check on bus types and rectifies any mistakes present.\n\nReturns\n\nThe function returns an instance of the AcPowerFlow type.\n\nExamples\n\nSet up the fast Newton-Raphson method utilizing LU factorization:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonXB(system)\n\nSet up the fast Newton-Raphson method utilizing KLU factorization:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = fastNewtonRaphsonXB(system, KLU)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.gaussSeidel","page":"Power Flow","title":"JuliaGrid.gaussSeidel","text":"gaussSeidel(system::PowerSystem)\n\nThe function sets up the Gauss-Seidel method to solve the AC power flow.\n\nArgument\n\nThe function requires the PowerSystem type to establish the framework.\n\nUpdates\n\nIf the AC model has not been created, the function automatically initiates an update within the ac field of the PowerSystem type. It also performs a check on bus types and rectifies any mistakes present.\n\nReturns\n\nThe function returns an instance of the AcPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = gaussSeidel(system)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.mismatch!-Tuple{AcPowerFlow{NewtonRaphson}}","page":"Power Flow","title":"JuliaGrid.mismatch!","text":"mismatch!(analysis::AcPowerFlow)\n\nThe function calculates both active and reactive power injection mismatches.\n\nUpdates\n\nThis function updates the mismatch variables in the Newton-Raphson and fast Newton-Raphson methods. It should be employed during the iteration loop before invoking the solve! function.\n\nReturns\n\nThe function returns maximum absolute values of the active and reactive power injection mismatches, which can be utilized to terminate the iteration loop of the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel methods employed to solve the AC power flow problem.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nmismatch!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{AcPowerFlow{NewtonRaphson}}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(analysis::AcPowerFlow)\n\nThe function employs the Newton-Raphson, fast Newton-Raphson, or Gauss-Seidel method to solve the AC power flow and calculate bus voltage magnitudes and angles.\n\nAfter the mismatch! function is executed, the execution of this function will perform a single iteration of one of the methods.\n\nUpdates\n\nThe calculated voltages are stored in the voltage field of the AcPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\nfor i = 1:10\n    stopping = mismatch!(analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(analysis)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.setInitialPoint!-Tuple{AcPowerFlow}","page":"Power Flow","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(analysis::AcPowerFlow)\n\nThe function sets the initial point of the AC power flow to the values from the PowerSystem type.\n\nUpdates\n\nThe function modifies the voltage field of the AcPowerFlow type.\n\nExample:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; tolerance = 1e-10)\n\nupdateBranch!(analysis; label = 14, reactance = 0.2, resistance = 0.01)\n\nsetInitialPoint!(analysis)\npowerFlow!(analysis; tolerance = 1e-10)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.setInitialPoint!-Tuple{AcPowerFlow, AC}","page":"Power Flow","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(target::AcPowerFlow, source::Analysis)\n\nThe function initializes the AC power flow based on results from the Analysis type, whether from an AC or DC analysis.\n\nThe function assigns the bus voltage magnitudes and angles in the target argument, using data from the source argument. This allows users to initialize AC power flow as needed.\n\nIf source comes from a DC analysis, only the bus voltage angles are assigned in the target argument, while the bus voltage magnitudes remain unchanged.\n\nUpdates\n\nThe function modifies the voltage field of the AcPowerFlow type.\n\nExample\n\nInitialize the Newton-Raphson method with values from the Gauss-Seidel method:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nsource = gaussSeidel(system)\npowerFlow!(source; iteration = 10)\n\ntarget = newtonRaphson(system)\n\nsetInitialPoint!(target, source)\npowerFlow!(target; tolerance = 1e-10)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.reactiveLimit!","page":"Power Flow","title":"JuliaGrid.reactiveLimit!","text":"reactiveLimit!(analysis::AcPowerFlow)\n\nThe function verifies whether the generators in a power system exceed their reactive power limits. This is done by setting the reactive power of the generators to within the limits if they are violated after determining the bus voltage magnitudes and angles. If the limits are violated, the corresponding generator buses or the slack bus are converted to demand buses.\n\nUpdates\n\nThe function assigns values to the generator.output.active and bus.supply.active variables of the PowerSystem type.\n\nAdditionally, it examines the reactive powers of the generators and adjusts them to their maximum or minimum values if they exceed the specified threshold. This results in the modification of the variable generator.output.reactive of the PowerSystem type accordingly.\n\nAs a result of this adjustment, the bus.supply.reactive variable is also updated, and the bus types specified in bus.layout.type are modified. If the slack bus is converted, the bus.layout.slack field is correspondingly adjusted.\n\nReturns\n\nThe function returns the variable to indicate which buses violate the limits, with -1 indicating a violation of the minimum limits and 1 indicating a violation of the maximum limits.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nviolate = reactiveLimit!(analysis)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.adjustAngle!","page":"Power Flow","title":"JuliaGrid.adjustAngle!","text":"adjustAngle!(analysis::AcPowerFlow; slack)\n\nThe function modifies the bus voltage angles based on a different slack bus than the one identified by the bus.layout.slack field.\n\nFor instance, if the reactive power of the generator exceeds the limit on the slack bus, the reactiveLimit! function will change that bus to the demand bus and designate the first generator bus in the sequence as the new slack bus. After obtaining the updated AC power flow solution based on the new slack bus, it is possible to adjust the voltage angles to align with the angle of the original slack bus.\n\nKeyword\n\nThe slack keyword specifies the bus label for which we want to adjust voltage angles.\n\nUpdates\n\nThis function only updates the voltage.angle variable of the AcPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nreactiveLimit!(analysis)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis)\n\nadjustAngle!(analysis; slack = \"Bus 1 HV\")\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.powerFlow!-Tuple{AcPowerFlow}","page":"Power Flow","title":"JuliaGrid.powerFlow!","text":"powerFlow!(analysis::AcPowerFlow; iteration, tolerance, power, current, verbose)\n\nThe function serves as a wrapper for solving AC power flow and includes the functions:\n\nmismatch!,\nsolve!,\npower!,\ncurrent!.\n\nIt computes bus voltage magnitudes and angles using an iterative algorithm with the option to compute powers and currents.\n\nKeywords\n\nUsers can use the following keywords:\n\niteration: Specifies the maximum number of iterations (default: 20).\ntolerance: Defines the step size tolerance for the iteration stopping criterion (default: 1e-8).\npower: Enables power computation upon convergence or reaching the iteration limit (default: false).\ncurrent: Enables current computation upon convergence or reaching the iteration limit (default: false).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = newtonRaphson(system)\npowerFlow!(analysis; power = true, iteration = 30, tolerance = 1e-10, verbose = 3)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/","page":"Power Flow","title":"Power Flow","text":"","category":"page"},{"location":"api/powerFlow/#DC-Power-Flow-2","page":"Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"api/powerFlow/#JuliaGrid.dcPowerFlow","page":"Power Flow","title":"JuliaGrid.dcPowerFlow","text":"dcPowerFlow(system::PowerSystem, [factorization::Factorization = LU])\n\nThe function sets up the framework to solve the DC power flow.\n\nArguments\n\nThe function requires the PowerSystem type to establish the framework. Next, the Factorization argument, while optional, determines the method used to solve the linear system of equations. It can take one of the following values:\n\nLU: Utilizes LU factorization (default).\nKLU: Utilizes KLU factorization.\nLDLt: Utilizes LDLt factorization.\nQR: Utilizes QR factorization.\n\nUpdates\n\nIf the DC model was not created, the function will automatically initiate an update of the dc field within the PowerSystem composite type. Additionally, if the slack bus lacks an in-service generator, JuliaGrid considers it a mistake and defines a new slack bus as the first generator bus with an in-service generator in the bus type list.\n\nReturns\n\nThe function returns an instance of the DcPowerFlow type.\n\nExamples\n\nSet up the DC power flow utilizing LU factorization:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\n\nSet up the DC power flow utilizing KLU factorization:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system, KLU)\n\n\n\n\n\n","category":"function"},{"location":"api/powerFlow/#JuliaGrid.solve!-Tuple{DcPowerFlow}","page":"Power Flow","title":"JuliaGrid.solve!","text":"solve!(analysis::DcPowerFlow)\n\nThe function solves the DC power flow model and calculates bus voltage angles.\n\nUpdates\n\nThe calculated voltage angles are stored in the voltage field of the DcPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\nsolve!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/powerFlow/#JuliaGrid.powerFlow!-Tuple{DcPowerFlow}","page":"Power Flow","title":"JuliaGrid.powerFlow!","text":"powerFlow!(analysis::DcPowerFlow; power, verbose)\n\nThe function serves as a wrapper for solving DC power flow and includes the functions:\n\nsolve!,\npower!.\n\nIt computes bus voltage angles and optionally calculates power values.\n\nKeywords\n\nUsers can use the following keywords:\n\npower: Enables the computation of powers (default: false).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcPowerFlow(system)\npowerFlow!(analysis; power = true, verbose = 1)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/acStateEstimation/#ACStateEstimationTutorials","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To initiate the process, let us construct the PowerSystem type and formulate the AC model:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5)\naddBus!(system; label = 2, reactive = 0.3)\naddBus!(system; label = 3, active = 0.5)\n\n@branch(resistance = 0.02, susceptance = 0.04)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.6)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.7)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.2)\n\nacModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcal G = (mathcal N mathcal E), where we have the set of buses mathcal N = 1 dots n, and the set of branches mathcal E subseteq mathcal N times mathcal N within the power system:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Following that, we will introduce the Measurement type and incorporate a set of measurement devices mathcal M into the graph mathcal G. The AC state estimation includes a set of voltmeters mathcal V, ammeters mathcal I, wattmeters mathcal P, varmeters mathcal Q, and PMUs barmathcal P, with PMUs being able to integrate into AC state estimation in either rectangular coordinates or polar coordinates. To start, we initialize the Measurement type:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"monitoring = measurement(system)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"ukw: Notation\nHere, when referring to a vector mathbf a, we use the notation mathbf a = a_i or mathbf a = a_ij, where a_i represents the element related with bus i in mathcal N or measurement i in mathcal M, while a_ij denotes the element related with branch (ij) in mathcal E.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#ACSEModelTutorials","page":"AC State Estimation","title":"State Estimation Model","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In accordance with the AC Model, the AC state estimation treats bus voltages as state variables, which we denoted by mathbf x equiv bm Theta mathbf V^T. The state vector encompasses two components:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"bm Theta in mathbbR^n-1, representing bus voltage angles,\nmathbf V in mathbbR^n, representing bus voltage magnitudes.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Consequently, the total number of state variables is s = 2n-1, accounting for the fact that the voltage angle for the slack bus is known.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Within the JuliaGrid framework for AC state estimation, the methodology encompasses bus voltage magnitudes, branch current magnitudes, active powers, reactive powers, and phasor measurements. These measurements contribute to the construction of a nonlinear system of equations:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz=mathbfh(mathbf x) + mathbfu","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, mathbf h(mathbf x)= h_1(mathbf x), dots, h_k(mathbf x)^T represents the vector of nonlinear measurement functions, where k is the number of measurements, mathbf z = z_1 dots z_k^T denotes the vector of measurement values, and mathbf u = u_1 dots u_k^T represents the vector of measurement errors. It is worth noting that the number of equations in the system is equal to k = mathcal V cup mathcal I cup mathcal P cup mathcal Q + 2barmathcal P.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"These errors are assumed to follow a Gaussian distribution with a zero mean and covariance matrix bm Sigma. The diagonal elements of bm Sigma correspond to the measurement variances mathbf v = v_1 dots v_k^T, while the off-diagonal elements represent the covariances between the measurement errors mathbf w = w_1 dots w_k^T. These covariances exist only if PMUs are observed in rectangular coordinates and correlation is required.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Hence, the nonlinear system of equations is structured according to the specific devices:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    beginbmatrix\n      mathbf z_mathcal V3pt\n      mathbf z_mathcal I3pt\n      mathbf z_mathcal P3pt\n      mathbf z_mathcal Q3pt\n      mathbf z_barmathcal P\n    endbmatrix =\n    beginbmatrix\n      mathbf h_mathcal V(mathbf x)3pt\n      mathbf h_mathcal I(mathbf x)3pt\n      mathbf h_mathcal P(mathbf x)3pt\n      mathbf h_mathcal Q(mathbf x)3pt\n      mathbf h_barmathcal P(mathbf x)\n    endbmatrix +\n    beginbmatrix\n      mathbf u_mathcal V3pt\n      mathbf u_mathcal I3pt\n      mathbf u_mathcal P3pt\n      mathbf u_mathcal Q3pt\n      mathbf u_barmathcal P\n    endbmatrix","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Please note that each error vector, denoted as mathbfu_i, where i in mathcal V mathcal I mathcal P mathcal Q, is associated with the variance vector mathbfv_i.  However, for PMUs, the error vector mathbfu_barmathcal P, along with its variance vector mathbfv_barmathcal P, can also be associated with the covariance vector mathbfw_barmathcal P.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In summary, upon user definition of the measurement devices, each i-th legacy measurement device is linked to the measurement function h_i(mathbf x), the corresponding measurement value z_i, and the measurement variance v_i. Meanwhile, each i-th PMU is associated with two measurement functions h_2i-1(mathbf x), h_2i(mathbf x), along with their respective measurement values z_2i-1, z_2i, as well as their variances v_2i-1, v_2i, and possibly covariances w_2i-1, w_2i.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Typically, the AC state estimator is obtained using the Gauss-Newton method or its variation, which involves constructing the Jacobian matrix. Therefore, in addition to the aforementioned elements, we also need Jacobian expressions corresponding to the measurement functions, which are also provided below.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Bus-Voltage-Magnitude-Measurements","page":"AC State Estimation","title":"Bus Voltage Magnitude Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"When introducing a voltmeter V_i in mathcal V at bus i in mathcal N, users specify the measurement value, variance, and measurement function of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalV = z_V_i  mathbfv_mathcalV = v_V_i  mathbfh_mathcalV(mathbf x) = h_V_i(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addVoltmeter!(monitoring; label = \"V₁\", bus = 1, magnitude = 1.0, variance = 1e-3)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, the bus voltage magnitude measurement function is simply defined as:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_V_i(mathbf x) = V_i","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"with the following Jacobian expression:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"   \tcfracmathrm partialh_V_i(mathbf x) mathrm partial V_i = 1","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#FromCurrentMagnitudeMeasurements","page":"AC State Estimation","title":"From-Bus Current Magnitude Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"When introducing an ammeter at branch (ij) in mathcal E, it can be placed at the from-bus end, denoted as I_ij in mathcal I, specifying the measurement value, variance, and measurement function of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalI = z_I_ij  mathbfv_mathcalI = v_I_ij  mathbfh_mathcalI(mathbf x) = h_I_ij(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addAmmeter!(monitoring; label = \"I₁₂\", from = 1, magnitude = 0.3, variance = 1e-2)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, following the guidelines outlined in the AC Model, the function defining the current magnitude at the from-bus end is expressed as:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_I_ij(mathbf x) = sqrtA_I_ijV_i^2 + B_I_ijV_j^2 - 2C_I_ij cos(theta_ij - phi_ij) - D_I_ijsin(theta_ij - phi_ij)V_iV_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  begingathered\n    A_I_ij = cfrac(g_ij + g_mathrmsi)^2 + (b_ij + b_mathrmsi)^2tau_ij^4 \n    B_I_ij = cfracg_ij^2 + b_ij^2tau_ij^2 \n    C_I_ij = cfracg_ij(g_ij + g_mathrmsi) + b_ij(b_ij + b_mathrmsi)tau_ij^3 \n    D_I_ij = cfracg_ijb_mathrmsi - b_ijg_mathrmsitau_ij^3\n  endgathered","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Jacobian expressions corresponding to the measurement function h_I_ij(mathbf x) are defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_I_ij(mathbf x)mathrm partial theta_i =-\n    cfracmathrm partialh_I_ij(mathbf x)mathrm partial theta_j =\n    cfrac C_I_ijsin(theta_ij - phi_ij) + D_I_ijcos(theta_ij - phi_ij)V_i V_jh_I_ij(mathbf x) \n    cfracmathrm partialh_I_ij(mathbf x)mathrm partial V_i =\n    cfracA_I_ijV_i - C_I_ijcos(theta_ij - phi_ij) - D_I_ijsin(theta_ij - phi_ij)V_jh_I_ij(mathbf x) \n    cfracmathrm partialh_I_ij(mathbf x)mathrm partial V_j =\n    cfracB_I_ijV_j - C_I_ijcos(theta_ij - phi_ij) - D_I_ijsin(theta_ij - phi_ij)V_ih_I_ij(mathbf x)\n\tendaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The next option is to introduce this measurement in squared form. In this case, the measurement function and value will be squared, while the variance will be doubled:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalI = z_I_ij^2  mathbfv_mathcalI = 2v_I_ij  mathbfh_mathcalI(mathbf x) = h_I_ij^2(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addAmmeter!(\n  monitoring; label = \"I²₁₂\", from = 1, magnitude = 0.3, variance = 1e-2, square = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This approach improves numerical robustness when integrating current magnitude measurements into the AC state estimation model. The resulting model includes a measurement function where the square root disappears, while the Jacobian expressions are doubled, and the denominator is eliminated.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#ToCurrentMagnitudeMeasurements","page":"AC State Estimation","title":"To-Bus Current Magnitude Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In addition to the scenario where we add ammeters at the from-bus end, an ammeter can also be positioned at the to-bus end, denoted as I_ji in mathcal I, specifying the measurement value, variance, and measurement function of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalI = z_I_ji  mathbfv_mathcalI = v_I_ji  mathbfh_mathcalI(mathbf x) = h_I_ji(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addAmmeter!(monitoring; label = \"I₂₁\", to = 1, magnitude = 0.3, variance = 1e-3)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Now, the measurement function is as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_I_ji(mathbf x) = sqrtA_I_jiV_i^2 + B_I_jiV_j^2 - 2C_I_ji cos(theta_ij - phi_ij) + D_I_jisin(theta_ij - phi_ij)V_iV_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  begingathered\n    A_I_ji = cfracg_ij^2 + b_ij^2tau_ij^2 \n    B_I_ji = (g_ij + g_mathrmsi)^2 + (b_ij + b_mathrmsi)^2 \n    C_I_ji = cfracg_ij(g_ij + g_mathrmsi) + b_ij(b_ij + b_mathrmsi)tau_ij \n    D_I_ji = cfracg_ijb_mathrmsi - b_ijg_mathrmsitau_ij\n  endgathered","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Jacobian expressions corresponding to the measurement function h_I_ji(mathbf x) are defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_I_ji(mathbf x)mathrm partial theta_i =-\n    cfracmathrm partialh_I_ji(mathbf x)mathrm partial theta_j =\n    cfracC_I_jisin(theta_ij - phi_ij) - D_I_jicos(theta_ij- phi_ij)V_i V_jh_I_ji(mathbf x) \n    cfracmathrm partialh_I_ji(mathbf x)mathrm partial V_i =\n    cfracA_I_jiV_i - C_I_jicos(theta_ij - phi_ij) + D_I_jisin(theta_ij - phi_ij)V_jh_I_ji(mathbf x) \n    cfracmathrm partialh_I_ji(mathbf x)mathrm partial V_j =\n    cfracB_I_jiV_j - C_I_jicos(theta_ij - phi_ij) + D_I_jisin(theta_ij - phi_ij)V_ih_I_ji(mathbf x) \n\tendaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"As explained for the current magnitude measurement from the bus, we can also introduce this measurement in squared form:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalI = z_I_ji^2  mathbfv_mathcalI = 2v_I_ji  mathbfh_mathcalI(mathbf x) = h_I_ji^2(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addAmmeter!(\n  monitoring; label = \"I²₂₁\", to = 1, magnitude = 0.3, variance = 1e-3, square = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To recall, the resulting model includes a measurement function where the square root disappears, while the Jacobian expressions are doubled, and the denominator is eliminated.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Active-Power-Injection-Measurements","page":"AC State Estimation","title":"Active Power Injection Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"When adding a wattmeter P_i in mathcal P at bus i in mathcal N, users specify that the wattmeter measures active power injection and define measurement value, variance, and measurement function of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalP = z_P_i  mathbfv_mathcalP = v_P_i  mathbfh_mathcalP(mathbf x) = h_P_i(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addWattmeter!(monitoring; label = \"P₃\", bus = 3, active = -0.5, variance = 1e-3)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, utilizing the AC Model, we derive the function defining the active power injection as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"   h_P_i(mathbf x) = V_isumlimits_j in mathcalN_i (G_ijcostheta_ij + B_ijsintheta_ij) V_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where mathcalN_i contains buses incident to bus i, including bus i, with the following Jacobian expressions:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_i(mathbf x)mathrm partial theta_i =\n    V_isum_j in mathcalN_i (-G_ijsintheta_ij + B_ijcostheta_ij)V_j - B_iiV_i^2\n    cfracmathrm partialh_P_i(mathbf x)mathrm partial theta_j =\n    (G_ijsintheta_ij - B_ijcostheta_ij)V_iV_j \n    cfracmathrm partialh_P_i(mathbf x)mathrm partial V_i =\n    sum_j in mathcalN_i (G_ijcostheta_ij + B_ijsintheta_ij)V_j + G_iiV_i\n    cfracmathrm partialh_P_i(mathbf x)mathrm partial V_j =\n    (G_ijcostheta_ij + B_ijsintheta_ij)V_i\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#From-Bus-Active-Power-Flow-Measurements","page":"AC State Estimation","title":"From-Bus Active Power Flow Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Additionally, when introducing a wattmeter at branch (ij) in mathcal E, users specify that the wattmeter measures active power flow. It can be positioned at the from-bus end, denoted as P_ij in mathcal P, specifying the measurement value, variance, and measurement function of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalP = z_P_ij  mathbfv_mathcalP = v_P_ij  mathbfh_mathcalP(mathbf x) = h_P_ij(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addWattmeter!(monitoring; label = \"P₁₂\", from = 1, active = 0.2, variance = 1e-4)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, the function describing active power flow at the from-bus end is defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_P_ij(mathbf x) = cfracg_ij + g_mathrmsitau_ij^2 V_i^2 - cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)rightV_iV_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"with the following Jacobian expressions:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_ij(mathbf x)mathrm partial theta_i =-\n    cfracmathrm partialh_P_ij(mathbf x)mathrm partial theta_j =\n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_P_ij(mathbf x)mathrm partial V_i =\n    2cfracg_ij + g_mathrmsitau_ij^2 V_i -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)right V_j \n    cfracmathrm partialh_P_ij(mathbf x)mathrm partial V_j = -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)right V_i\n\tendaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#To-Bus-Active-Power-Flow-Measurements","page":"AC State Estimation","title":"To-Bus Active Power Flow Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Similarly, a wattmeter can be placed at the to-bus end, denoted as P_ji in mathcalP, specifying the measurement value, variance, and measurement function of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalP = z_P_ji  mathbfv_mathcalP = v_P_ji  mathbfh_mathcalP(mathbf x) = h_P_ji(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addWattmeter!(monitoring; label = \"P₂₁\", to = 1, active = -0.2, variance = 1e-4)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Thus, the function describing active power flow at the to-bus end is defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_P_ji(mathbf x) = (g_ij + g_mathrmsi) V_j^2 - cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) - b_ijsin(theta_ij - phi_ij)right V_iV_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"with the following Jacobian expressions:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_P_ji(mathbf x)mathrm partial theta_i = -\n    cfracmathrm partialh_P_ji(mathbf x)mathrm partial theta_j =\n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) + b_ijcos(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_P_ji(mathbf x)mathrm partial V_i =  -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) - b_ijsin(theta_ij - phi_ij)right V_j \n    cfracmathrm partialh_P_ji(mathbf x)mathrm partial V_j = 2(g_ij + g_mathrmsi) V_j -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) - b_ijsin(theta_ij - phi_ij)right V_i\n\tendaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Reactive-Power-Injection-Measurements","page":"AC State Estimation","title":"Reactive Power Injection Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"When adding a varmeter Q_i in mathcal Q at bus i in mathcal N, users specify that the varmeter measures reactive power injection and define the measurement value, variance, and measurement function of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalQ = z_Q_i  mathbfv_mathcalQ = v_Q_i  mathbfh_mathcalQ(mathbf x) = h_Q_i(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addVarmeter!(monitoring; label = \"Q₃\", bus = 3, reactive = 0, variance = 1e-3)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, utilizing the AC Model, we derive the function defining the reactive power injection as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"   h_Q_i(mathbf x) = V_isumlimits_j in mathcalN_i (G_ijsintheta_ij - B_ijcostheta_ij)V_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where mathcalN_i contains buses incident to bus i, including bus i, with the following Jacobian expressions:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Q_i(mathbf x)mathrm partial theta_i =\n    V_isum_j in mathcalN_i (G_ijcostheta_ij + B_ijsintheta_ij)V_j - G_iiV_i^2\n    cfracmathrm partialh_Q_i(mathbf x)mathrm partial theta_j =\n    -(G_ijcostheta_ij + B_ijsintheta_ij)V_iV_j \n    cfracmathrm partialh_Q_i(mathbf x)mathrm partial V_i =\n    sum_j in mathcalN_i (G_ijsintheta_ij - B_ijcostheta_ij)V_j - B_iiV_i\n    cfracmathrm partialh_Q_i(mathbf x)mathrm partial V_j =\n    (G_ijsintheta_ij - B_ijcostheta_ij)V_i\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#From-Bus-Reactive-Power-Flow-Measurements","page":"AC State Estimation","title":"From-Bus Reactive Power Flow Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Additionally, when introducing a varmeter at branch (ij) in mathcal E, users specify that the varmeter measures reactive power flow. It can be positioned at the from-bus end, denoted as Q_ij in mathcal Q, with its measurement value, variance, and measurement function included in vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalQ = z_Q_ij  mathbfv_mathcalQ = v_Q_ij  mathbfh_mathcalQ(mathbf x) = h_Q_ij(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addVarmeter!(monitoring; label = \"Q₁₂\", from = 1, reactive = 0.2, variance = 1e-4)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, the function describing reactive power flow at the from-bus end is defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_Q_ij(mathbf x) = -cfracb_ij + b_mathrmsitau_ij^2 V_i^2 - cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_iV_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"with the following Jacobian expressions:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Q_ij(mathbf x)mathrm partial theta_i = -\n    cfracmathrm partialh_Q_ij(mathbf x)mathrm partial theta_j = -\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) + b_ijsin(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_Q_ij(mathbf x)mathrm partial V_i = -\n    2cfracb_ij + b_mathrmsitau_ij^2 V_i -\n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_j\n    cfracmathrm partialh_Q_ij(mathbf x)mathrm partial V_j = -\n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) - b_ijcos(theta_ij - phi_ij)right V_i\n\tendaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#To-Bus-Reactive-Power-Flow-Measurements","page":"AC State Estimation","title":"To-Bus Reactive Power Flow Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Similarly, a varmeter can be placed at the to-bus end, denoted as Q_ji in mathcal Q, with its own measurement value, variance, and measurement function included in vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_mathcalQ = z_Q_ji  mathbfv_mathcalQ = v_Q_ji  mathbfh_mathcalQ(mathbf x) = h_Q_ji(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addVarmeter!(monitoring; label = \"Q₂₁\", to = 1, reactive = -0.2, variance = 1e-4)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Thus, the function describing reactive power flow at the to-bus end is defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_Q_ji(mathbf x) = -(b_ij + b_mathrmsi) V_j^2 + cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) + b_ijcos(theta_ij - phi_ij)right V_iV_j","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"with the following Jacobian expressions:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Q_ji(mathbf x)mathrm partial theta_i = -\n    cfracmathrm partialh_Q_ji(mathbf x)mathrm partial theta_j =\n    cfrac1tau_ij leftg_ijcos(theta_ij - phi_ij) - b_ijsin(theta_ij - phi_ij)right V_iV_j \n    cfracmathrm partialh_Q_ji(mathbf x)mathrm partial V_i =\n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) + b_ijcos(theta_ij - phi_ij)right V_j\n    cfracmathrm partialh_Q_ji(mathbf x)mathrm partial V_j =\n    -2(b_ij + b_mathrmsi) V_j +\n    cfrac1tau_ij leftg_ijsin(theta_ij - phi_ij) + b_ijcos(theta_ij - phi_ij)right V_i\n\tendaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Polar-Bus-Voltage-Phasor-Measurements","page":"AC State Estimation","title":"Polar Bus Voltage Phasor Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To include phasor measurement (V_i theta_i) in barmathcal P at bus i in mathcal N in polar coordinates in the AC state estimation model, users will specify the measurement values, variances, and measurement functions as vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_barmathcal P = z_V_i z_theta_i  mathbfv_barmathcal P = v_V_i v_theta_i \n    mathbfh_barmathcal P(mathbf x) = h_V_i(mathbf x) h_theta_i(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"V₁, θ₁\", bus = 1, magnitude = 1.0, angle = 0,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-6, polar = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, the functions defining the bus voltage phasor measurement are straightforward:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    h_V_i(mathbf x) = V_i\n    h_theta_i(mathbf x) = theta_i\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"with the following Jacobian expressions:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_V_i(mathbf x)mathrm partial V_i = 1 \n    cfracmathrm partialh_theta_i(mathbf x)mathrm partial theta_i = 1\n    endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Rectangular-Bus-Voltage-Phasor-Measurements","page":"AC State Estimation","title":"Rectangular Bus Voltage Phasor Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"When a PMU (V_i theta_i) in barmathcal P is introduced at bus i in mathcal N, it will be incorporated into the AC state estimation model using rectangular coordinates by default. It will define the measurement values, variances, and measurement functions of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_barmathcal P = z_Re(barV_i) z_Im(barV_i) \n    mathbfv_barmathcal P = v_Re(barV_i) v_Im(barV_i) \n    mathbfh_barmathcal P(mathbf x) = h_Re(barV_i)(mathbf x) h_Im(barV_i)(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"V₂, θ₂\", bus = 2, magnitude = 0.9, angle = -0.1,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, measurement values are obtained according to:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    z_Re(barV_i) = z_V_i cos z_theta_i\n    z_Im(barV_i) = z_V_i sin z_theta_i\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Utilizing the classical theory of propagation of uncertainty [22], the variances can be calculated as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    v_Re(barV_i) =\n    v_V_i left cfracmathrm partial mathrm partial z_V_i (z_V_i cos z_theta_i) right^2 +\n    v_theta_i left cfracmathrm partial mathrm partial z_theta_i (z_V_i cos z_theta_i)right^2 =\n    v_V_i (cos z_theta_i)^2 + v_theta_i (z_V_i sin z_theta_i)^2\n    v_Im(barV_i) =\n     v_V_i left cfracmathrm partial mathrm partial z_V_i (z_V_i sin z_theta_i) right^2 +\n    v_theta_i left cfracmathrm partial mathrm partial z_theta_i (z_V_i sin z_theta_i)right^2 =\n    v_V_i (sin z_theta_i)^2 + v_theta_i (z_V_i cos z_theta_i)^2\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Lastly, the functions defining the bus voltage phasor measurement are:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    h_Re(barV_i)(mathbf x) = V_i cos theta_i\n    h_Im(barV_i)(mathbf x) = V_i sin theta_i\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Jacobian expressions corresponding to the measurement function h_Re(barV_i)(mathbf x) are defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_Re(barV_i)(mathbf x)mathrm partial theta_i = -V_i sin theta_i \n   \tcfracmathrm partialh_Re(barV_i)(mathbf x)mathrm partial V_i = cos theta_i\n    endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"while Jacobian expressions corresponding to the measurement function h_Im(barV_i)(mathbf x) are:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n   \tcfracmathrm partialh_Im(barV_i)(mathbf x)mathrm partial theta_i = V_i cos theta_i\n   \tcfracmathrm partialh_Im(barV_i)(mathbf x)mathrm partial V_i = sin theta_i\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In the previous example, the user neglects the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfw_barmathcal P = w_Re(barV_i) w_Im(barV_i)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"V₃, θ₃\", bus = 3, magnitude = 0.9, angle = -0.2,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true\n  )\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Then, the covariances are obtained as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    w_Re(barV_i) = w_Im(barV_i) =\n    v_V_i cfracmathrm partial mathrm partial z_V_i (z_V_i cos z_theta_i)\n    cfracmathrm partial mathrm partial z_V_i (z_V_i sin z_theta_i)  +\n    v_theta_i cfracmathrm partial mathrm partial z_theta_i (z_V_i cos z_theta_i)\n    cfracmathrm partial mathrm partial z_theta_i (z_V_i sin z_theta_i)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"which results in the solution:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    w_Re(barV_i) = w_Im(barV_i) = cos z_theta_i sin z_theta_i(v_V_i - v_theta_i z_V_i^2)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Polar-From-Bus-Current-Phasor-Measurements","page":"AC State Estimation","title":"Polar From-Bus Current Phasor Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To include phasor measurement (I_ij psi_ij) in barmathcal P at branch (ij) in mathcal E in polar coordinates in the AC state estimation model, users will specify the measurement values, variances, and measurement functions as vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_barmathcal P = z_I_ij z_psi_ij \n    mathbfv_barmathcal P = v_I_ij v_psi_ij \n    mathbfh_barmathcal P(mathbf x) = h_I_ij(mathbf x) h_psi_ij(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"I₁₂, ψ₁₂\", from = 1, magnitude = 0.3, angle = -0.7,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-4, polar = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, the function and corresponding Jacobian expressions associated with the branch current magnitude at the from-bus end remains identical to the one provided in From-Bus Current Magnitude Measurements. Additionally, by using square = true, the current magnitude measurement can also be incorporated in squared form into the state estimation model.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"However, the function defining the branch current angle measurement is expressed as:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_psi_ij(mathbf x) = mathrmatan Bigg\n    cfrac(A_psi_ij sintheta_i + B_psi_ij costheta_i)V_i - C_psi_ij sin(theta_j + phi_ij) + D_psi_ijcos(theta_j + phi_ij)V_j\n    (A_psi_ij costheta_i - B_psi_ij sintheta_i)V_i - C_psi_ij cos(theta_j + phi_ij) - D_psi_ij sin(theta_j + phi_ij)V_j Bigg","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    A_psi_ij = cfracg_ij + g_mathrmsitau_ij^2 \n    B_psi_ij = cfracb_ij+b_mathrmsitau_ij^2 \n    C_psi_ij = cfracg_ijtau_ij \n    D_psi_ij = cfracb_ijtau_ij","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Jacobian expressions corresponding to the measurement function h_psi_ij(mathbf x) are defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_psi_ij(mathbf x)mathrm partial theta_i =\n    cfracA_I_ij V_i^2- C_I_ij cos(theta_ij- phi_ij) - D_I_ij sin (theta_ij - phi_ij)V_iV_jh_I_ij^2(mathbf x) \n    cfracmathrm partialh_psi_ij(mathbf x)mathrm partial theta_j =\n    cfracB_I_ij V_j^2 - C_I_ij cos (theta_ij - phi_ij) - D_I_ij sin(theta_ij- phi_ij)V_iV_jh_I_ij^2(mathbf x) \n    cfracmathrm partialh_psi_ij(mathbf x)mathrm partial V_i = -\n    cfracC_I_ij sin (theta_ij - phi_ij) + D_I_ij cos(theta_ij- phi_ij)V_j h_I_ij^2(mathbf x)\n    cfracmathrm partialh_psi_ij(mathbf x)mathrm partial V_j =\n    cfracC_I_ij sin (theta_ij - phi_ij) + D_I_ij cos(theta_ij- phi_ij)V_i h_I_ij^2(mathbf x)\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Rectangular-From-Bus-Current-Phasor-Measurements","page":"AC State Estimation","title":"Rectangular From-Bus Current Phasor Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"When introducing a PMU at branch (ij) in mathcal E, it can be placed at the from-bus end, denoted as (I_ij psi_ij) in barmathcal P, and it will be integrated into the AC state estimation model using rectangular coordinates by default. Incorporating current phasor measurements in the polar coordinate system is highly susceptible to ill-conditioned problems, especially when dealing with small values of current magnitudes. This is the reason why we typically include PMUs in the rectangular coordinate system by default.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Therefore, here we specify the measurement values, variances, and measurement functions of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_barmathcal P = z_Re(barI_ij) z_Im(barI_ij) \n    mathbfv_barmathcal P = v_Re(barI_ij) v_Im(barI_ij) \n    mathbfh_barmathcal P(mathbf x) = h_Re(barI_ij)(mathbf x) h_Im(barI_ij)(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"I₂₃, ψ₂₃\", from = 3, magnitude = 0.3, angle = 0.4,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-4\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, measurement values are obtained according to:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    z_Re(barI_ij) = z_I_ij cos z_psi_ij\n    z_Im(barI_ij) = z_I_ij sin z_psi_ij\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Utilizing the classical theory of propagation of uncertainty [22], the variances can be calculated as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    v_Re(barI_ij)  = v_I_ij (cos z_psi_ij)^2 + v_psi_ij (z_I_ij sin z_psi_ij)^2 \n    v_Im(barI_ij) = v_I_ij (sin z_psi_ij)^2 + v_psi_ij (z_I_ij cos z_psi_ij)^2\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The functions defining the current phasor measurement at the from-bus end are:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    h_Re(barI_ij)(mathbf x) = (A_psi_ij costheta_i - B_psi_ij sintheta_i)V_i - C_psi_ij cos(theta_j + phi_ij) - D_psi_ij sin(theta_j + phi_ij)V_j \n    h_Im(barI_ij)(mathbf x) = (A_psi_ij sintheta_i + B_psi_ij costheta_i)V_i - C_psi_ij sin(theta_j + phi_ij) + D_psi_ij cos(theta_j + phi_ij)V_j\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Jacobian expressions corresponding to the measurement function h_Re(barI_ij)(mathbf x) are defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Re(barI_ij)(mathbf x)mathrm partial theta_i =\n    -(A_psi_ij sintheta_i + B_psi_ij costheta_i)V_i\n    cfracmathrm partialh_Re(barI_ij)(mathbf x)mathrm partial theta_j =\n    C_psi_ij sin(theta_j + phi_ij) + D_psi_ij cos(theta_j + phi_ij) V_j \n    cfracmathrm partialh_Re(barI_ij)(mathbf x)mathrm partial V_i =\n     A_psi_ij  costheta_i - B_psi_ij sintheta_i\n    cfracmathrm partialh_Re(barI_ij)(mathbf x)mathrm partial V_j =\n    -C_psi_ij cos(theta_j + phi_ij) + D_psi_ij  sin(theta_j + phi_ij)\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"while Jacobian expressions corresponding to the measurement function h_Im(barI_ij)(mathbf x) are:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Im(barI_ij)(mathbf x)mathrm partial theta_i =\n    (A_psi_ij cos theta_i - B_psi_ij sin theta_i)V_i\n    cfracmathrm partialh_Im(barI_ij)(mathbf x)mathrm partial theta_j =\n    -C_psi_ij cos(theta_j + phi_ij) + D_psi_ij sin(theta_j + phi_ij) V_j \n    cfracmathrm partialh_Im(barI_ij)(mathbf x)mathrm partial V_i =\n     A_psi_ij  sin theta_i + B_psi_ij costheta_i\n    cfracmathrm partialh_Im(barI_ij)(mathbf x)mathrm partial V_j =\n    -C_psi_ij sin(theta_j + phi_ij) - D_psi_ij  cos(theta_j + phi_ij)\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In the previous example, the user neglects the covariances between the real and imaginary parts of the measurement. However, if desired, the user can also include them in the state estimation model by specifying the covariances of the vector:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfw_barmathcalP = w_Re(barI_ij) w_Im(barI_ij)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"I₁₃, ψ₁₃\", from = 2, magnitude = 0.3, angle = -0.5,\n  varianceMagnitude = 1e-4, varianceAngle = 1e-5, correlated = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Then, the covariances are obtained as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"   w_Re(barI_ij) = w_Im(barI_ij) = sin z_psi_ij cos z_psi_ij(v_I_ij  - v_psi_ij z_I_ij^2)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Polar-To-Bus-Current-Phasor-Measurements","page":"AC State Estimation","title":"Polar To-Bus Current Phasor Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To include phasor measurement (I_ji psi_ji) in barmathcal P at branch (ij) in mathcal E in polar coordinates in the AC state estimation model, users will specify the measurement values, variances, and measurement functions as vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_barmathcal P = z_I_ji z_psi_ji \n    mathbfv_barmathcal P = v_I_ji v_psi_ji \n    mathbfh_barmathcal P(mathbf x) = h_I_ji(mathbf x) h_psi_ji(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"I₂₁, ψ₂₁\", to = 1, magnitude = 0.3, angle = 2.3,\n  varianceMagnitude = 1e-2, varianceAngle = 1e-3, polar = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, the function and corresponding Jacobian expressions associated with the branch current magnitude at the to-bus end remains identical to the one provided in To-Bus Current Magnitude Measurements. Additionally, by using square = true, the current magnitude measurement can also be incorporated in squared form into the state estimation model.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"However, the function defining the branch current angle measurement is expressed as:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    h_psi_ji(mathbf x) = mathrmatanBigg\n    cfrac(A_psi_ji sintheta_j + B_psi_ji costheta_j)V_j - C_psi_ji sin(theta_i - phi_ij) + D_psi_jicos(theta_i - phi_ij)V_i\n    (A_psi_ji costheta_j - B_psi_ji sintheta_j)V_j - C_psi_ji cos(theta_i - phi_ij) - D_psi_ji sin(theta_i - phi_ij)V_i Bigg","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    A_psi_ji = g_ij + g_mathrmsi \n    B_psi_ji = b_ij + b_mathrmsi \n    C_psi_ji = cfracg_ijtau_ij \n    D_psi_ji = cfracb_ijtau_ij","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Jacobian expressions corresponding to the measurement function h_psi_ji(mathbf x) are defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_psi_ji(mathbf x)mathrm partial theta_i =\n    cfracA_I_ji V_i^2- C_I_ji cos(theta_ij- phi_ij) + D_I_ji sin (theta_ij - phi_ij) V_iV_jh_I_ji^2(mathbf x) \n    cfracmathrm partialh_psi_ji(mathbf x)mathrm partial theta_j =\n    cfracB_I_ji V_j^2 - C_I_ji cos (theta_ij - phi_ij) + D_I_ji sin(theta_ij- phi_ij)V_iV_jh_I_ji^2(mathbf x) \n    cfracmathrm partialh_psi_ji(mathbf x)mathrm partial V_i =\n    -cfracC_I_ji sin (theta_ij - phi_ij) - D_I_ji cos(theta_ij- phi_ij)V_j h_I_ji^2(mathbf x)\n    cfracmathrm partialh_psi_ji(mathbf x)mathrm partial V_j =\n    cfracC_I_ji sin (theta_ij - phi_ij) - D_I_ji cos(theta_ij- phi_ij)V_i h_I_ji^2(mathbf x)\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Rectangular-To-Bus-Current-Phasor-Measurements","page":"AC State Estimation","title":"Rectangular To-Bus Current Phasor Measurements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"When introducing a PMU at branch (ij) in mathcal E, it can be placed at the to-bus end, denoted as (I_ji psi_ji) in barmathcal P, and it will be integrated into the AC state estimation model using rectangular coordinates by default. The user will specify the measurement values, variances, and measurement functions of vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfz_barmathcal P = z_Re(barI_ji) z_Im(barI_ji) \n    mathbfv_barmathcal P = v_Re(barI_ji) v_Im(barI_ji) \n    mathbfh_barmathcal P(mathbf x) = h_Re(barI_ji)(mathbf x) h_Im(barI_ji)(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For example:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"I₃₂, ψ₃₂\", to = 3, magnitude = 0.3, angle = -2.9,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, measurement values are obtained according to:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    z_Re(barI_ji) = z_I_ji cos z_psi_ji\n    z_Im(barI_ji) = z_I_ji sin z_psi_ji\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The variances can be calculated as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    v_Re(barI_ji) = v_I_ji (cos z_psi_ji)^2 + v_psi_ji (z_I_ji sin z_psi_ji)^2 \n    v_Im(barI_ji) = v_I_ji (sin z_psi_ji)^2 + v_psi_ji (z_I_ji cos z_psi_ji)^2\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The functions defining the current phasor measurement at the to-bus end are:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    h_Re(barI_ji)(mathbf x) = (A_psi_ji costheta_j - B_psi_ji sintheta_j)V_j - C_psi_ji cos(theta_i - phi_ij) - D_psi_ji sin (theta_i - phi_ij)V_i\n    h_Im(barI_ji)(mathbf x) = (A_psi_ji sintheta_j + B_psi_ji costheta_j)V_j - C_psi_ji sin(theta_i - phi_ij) + D_psi_ji cos (theta_i - phi_ij)V_i\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Jacobian expressions corresponding to the measurement function h_Re(barI_ji)(mathbf x) are defined as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Re(barI_ji)(mathbf x)mathrm partial theta_i =\n    C_psi_ji sin (theta_i - phi_ij) + D_psi_ji cos (theta_i - phi_ij)V_i\n    cfracmathrm partialh_Re(barI_ji)(mathbf x)mathrm partial theta_j =\n    -(A_psi_ji sintheta_j + B_psi_ji cos theta_j ) V_j \n    cfracmathrm partialh_Re(barI_ji)(mathbf x)mathrm partial V_i =\n    - C_psi_ji cos (theta_i - phi_ij) + D_psi_ji sin(theta_i - phi_ij)\n    cfracmathrm partialh_Re(barI_ji)(mathbf x)mathrm partial V_j =\n    A_psi_ji cos theta_j - B_psi_ji  sin theta_j\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"while Jacobian expressions corresponding to the measurement function h_Im(barI_ji)(mathbf x) are:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    cfracmathrm partialh_Im(barI_ji)(mathbf x)mathrm partial theta_i =\n    -C_psi_ji cos (theta_i - phi_ij) + D_psi_ji sin (theta_i - phi_ij)V_i\n    cfracmathrm partialh_Im(barI_ji)(mathbf x)mathrm partial theta_j =\n    (A_psi_ji costheta_j - B_psi_ji sin theta_j ) V_j \n    cfracmathrm partialh_Im(barI_ji)(mathbf x)mathrm partial V_i =\n    - C_psi_ji sin (theta_i - phi_ij) - D_psi_ji  cos(theta_i - phi_ij)\n    cfracmathrm partialh_Im(barI_ji)(mathbf x)mathrm partial V_j =\n    A_psi_ji sin theta_j + B_psi_ji  cos theta_j\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"As before, we are neglecting the covariances between the real and imaginary parts of the measurement. If desired, we can include them in the state estimation model by specifying the covariances of the vector:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"    mathbfw_barmathcalP = w_Re(barI_ji) w_Im(barI_ji)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"addPmu!(\n  monitoring; label = \"I₃₁, ψ₃₁\", to = 2, magnitude = 0.3, angle = 2.5,\n  varianceMagnitude = 1e-5, varianceAngle = 1e-5, correlated = true\n)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Then, the covariances are obtained as follows:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"   w_Re(barI_ji) = w_Im(barI_ji) = sin z_psi_ji cos z_psi_ji(v_I_ji - v_psi_ji z_I_ji^2)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#ACSEWLSStateEstimationTutorials","page":"AC State Estimation","title":"Weighted Least-Squares Estimation","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Given the available set of measurements mathcal M, the weighted least-squares (WLS) estimator hatmathbf x can be found using the Gauss-Newton method:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"begingathered\n\t\tBigmathbf J (mathbf x^(nu))^T bm Sigma^-1 mathbf J (mathbf x^(nu))Big mathbf Delta mathbf x^(nu) =\n\t\tmathbf J (mathbf x^(nu))^T bm Sigma^-1 mathbf r (mathbf x^(nu)) \n    mathbf x^(nu+1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)\nendgathered","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where nu = 012dots is the iteration index, mathbf Delta mathbf x in mathbb R^s is the vector of increments of the state variables, mathbf J (mathbf x)in mathbb R^k times s is the Jacobian matrix of measurement functions mathbf h (mathbf x) at mathbf x = mathbf x^(nu), bm Sigma in mathbb R^k times k is a measurement error covariance matrix, and mathbf r (mathbf x) = mathbfz - mathbf h (mathbf x) is the vector of residuals [14, Ch. 10]. It is worth noting that assuming uncorrelated measurement errors leads to a diagonal covariance matrix bm Sigma corresponding to measurement variances. However, when incorporating PMUs in a rectangular coordinate system and aiming to observe error correlation, this matrix loses its diagonal form.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The nonlinear or AC state estimation represents a non-convex problem arising from the nonlinear measurement functions [23]. Due to the fact that the values of state variables usually fluctuate in narrow boundaries, the model represents the mildly nonlinear problem, where solutions are in a reasonable-sized neighborhood which enables the use of the Gauss-Newton method. The Gauss-Newton method can produce different rates of convergence, which can be anywhere from linear to quadratic [24, Sec. 9.2]. The convergence rate in regard to power system state estimation depends on the topology and measurements, and if parameters are consistent (e.g., free bad data measurement set), the method shows near quadratic convergence rate [14, Sec. 11.2].","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Initialization","page":"AC State Estimation","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Let us begin by setting up a new set of measurements for the defined power system:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"monitoring = measurement(system)\n\n@wattmeter(label = \"Watmeter ?\")\naddWattmeter!(monitoring; bus = 3, active = -0.5, variance = 1e-3)\naddWattmeter!(monitoring; from = 1, active = 0.2, variance = 1e-4)\n\n@varmeter(label = \"Varmeter ?\")\naddVarmeter!(monitoring; bus = 2, reactive = -0.3, variance = 1e-3)\naddVarmeter!(monitoring; from = 1, reactive = 0.2, variance = 1e-4)\n\n@pmu(label = \"PMU ?\")\naddPmu!(monitoring; bus = 1, magnitude = 1.0, angle = 0, polar = true)\naddPmu!(monitoring; bus = 3, magnitude = 0.9, angle = -0.2)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To compute the voltage magnitudes and angles of buses using the Gauss-Newton method in JuliaGrid, we need to first execute the acModel! function to set up the system. Then, initialize the Gauss-Newton method using the gaussNewton function. The following code snippet demonstrates this process:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"acModel!(system)\nanalysis = gaussNewton(monitoring)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Initially, the gaussNewton function constructs the mean vector holding measurement values:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐳 = analysis.method.mean","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Additionally, it forms the precision or weighting matrix denoted as mathbf W = bm Sigma^-1. We can access these values using the following command:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐖 = analysis.method.precision","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Finally, using initial bus voltage magnitudes and angles from the PowerSystem type, the function creates the initial vector mathbfx^(0) of bus voltage magnitudes mathbfV^(0) and angles bmTheta^(0) for the Gauss-Newton method:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐕⁽⁰⁾ = analysis.voltage.magnitude\n𝚯⁽⁰⁾ = analysis.voltage.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here, we utilize a \"flat start\" approach in our method. It is important to keep in mind that when dealing with initial conditions in this manner, the Gauss-Newton method may encounter difficulties.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Iterative-Process","page":"AC State Estimation","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To apply the Gauss-Newton method, JuliaGrid provides the solve! function. This function is utilized iteratively until a stopping criterion is met, as demonstrated in the following code snippet:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"for iteration = 0:20\n    stopping = increment!(analysis)\n    if stopping < 1e-8\n        break\n    end\n    solve!(analysis)\nend","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The function increment! calculates the vector of residuals at each iteration using the equation:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  mathbf r (mathbf x^(nu)) = mathbfz - mathbf h (mathbf x^(nu))","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The resulting vector from these calculations is stored in the residual variable of the AcStateEstimation type and can be accessed through the following line of code:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐫 = analysis.method.residual","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The order of the residual vector follows a specific pattern. If all device types exist, the first mathcal V elements correspond to voltmeters, followed by mathcal I elements corresponding to ammeters. Then we have mathcal P elements for wattmeters and mathcal Q elements for varmeters. Finally, we have 2barmathcal P elements for PMUs. The order of these elements within specific devices follows the same order as they appear in the input data defined by the Measurement type.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"At the same time, the function forms the Jacobian matrix mathbf J (mathbf x^(nu)) and calculates the gain matrix mathbf G (mathbfx^(nu)) using:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"\t\tmathbf G (mathbf x^(nu)) = mathbf J (mathbf x^(nu))^T bm Sigma^-1 mathbf J (mathbf x^(nu))","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The Jacobian matrix and factorized gain matrix are stored in the AcStateEstimation type and can be accessed after each iteration:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐉 = analysis.method.jacobian\n𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Then finally, the function computes the vector of state variable increments using the equation:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"\t\tmathbf Delta mathbf x^(nu) = mathbf G (mathbf x^(nu))^-1 mathbf J (mathbf x^(nu))^T bm Sigma^-1 mathbf r (mathbf x^(nu))","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"tip: Tip\nBy default, JuliaGrid uses LU factorization as the primary method for factorizing the gain matrix mathbfG = mathbfLmathbfU, aiming to compute the increments. Nevertheless, users have the flexibility to opt for QR or LDLt factorization as an alternative method.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Increment values are stored in the AcStateEstimation type and can be accessed after each iteration:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝚫𝐱 = analysis.method.increment","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Here again, the JuliaGrid implementation of the AC state estimation follows a specific order to store the increment vector and Jacobian matrix. The vector of increments first contains n increments of bus voltage angles mathbf Delta bmTheta, followed by n increments of bus voltage magnitudes mathbf Delta mathbfV. This order also corresponds to the columns of the Jacobian matrix, while the order of rows of the Jacobian is defined according to the order of the residual vector.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Note that the increment vector and Jacobian matrix hold the slack bus with a known voltage angle. An element of the increment vector and a column of the Jacobian matrix are not deleted, and the presence on the slack bus is handled internally by JuliaGrid, which is evident from the factorization of the gain matrix.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Next, the increment! function provides the maximum absolute value of state variable increments, typically employed as the termination criterion for the iteration loop. Specifically, if it falls below a predefined stopping criterion epsilon, the algorithm converges:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  max Delta x_i forall i   epsilon","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Finally the function solve! adds the computed increment term to the previous solution to obtain a new solution:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  mathbf x^(nu + 1) = mathbf x^(nu) + mathbf Delta mathbf x^(nu)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Therefore, the bus voltage magnitudes mathbfV = V_i and angles bmTheta = theta_i are stored in the following vectors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Jacobian-Matrix","page":"AC State Estimation","title":"Jacobian Matrix","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"As a reminder, the Jacobian matrix consists of n columns representing bus voltage angles bm Theta, followed by n columns representing bus voltage magnitudes mathbf V. The arrangement of rows is structured such that the first mathcal V rows correspond to voltmeters, followed by mathcal I rows corresponding to ammeters. Then, we have mathcal P rows for wattmeters and mathcal Q rows for varmeters. Finally, there are 2barmathcal P rows for PMUs. The elements are computed based on the provided Jacobian expressions.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Precision-Matrix","page":"AC State Estimation","title":"Precision Matrix","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Let us revisit the precision matrix mathbf W. In the previous example, we introduced a PMU in rectangular coordinates without considering correlations between measurement errors. Now, let us update that PMU to include correlation between measurement errors:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"updatePmu!(analysis; label = \"PMU 2\", correlated = true)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Subsequently, we can examine the updated precision matrix mathbf W:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐖 = analysis.method.precision","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Observing the precision matrix, we notice that it loses its diagonal form due to the inclusion of measurement covariances in the model.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#GaussNewtonAlgorithmTutorials","page":"AC State Estimation","title":"The Gauss-Newton Algorithm","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In summary, the Gauss-Newton iterative algorithm for solving AC state estimation follows these steps:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Step Description Expression\n1. Initialize the iteration index nu = 0\n2. Set the initial state variable values mathbfx^(0) = mathbfV^(0) bmTheta^(0)\n3. Compute the measurement residuals mathbf r (mathbf x^(nu))\n4. Compute the gain matrix mathbf G (mathbf x^(nu))\n5. Compute the state variable increments mathbf Delta mathbf x^(nu)\n6. Check for convergence Delta x_max  epsilon\n7. If the convergence criterion is met, stop the process \n8. Update the state variable values mathbfx^(nu + 1) = mathbfx^(nu) + mathbf Delta mathbfx^(nu)\n9. Increase the iteration index nu = nu + 1\n10 Repeat from step 3. \n  ","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The main computational effort is in step 5, which involves factorizing the gain matrix and performing forward and backward substitutions to obtain the vector of increments.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#ACAlternativeFormulationTutorials","page":"AC State Estimation","title":"Alternative Formulation","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The resolution of the WLS state estimation problem using the conventional method typically progresses smoothly. However, it is widely acknowledged that in certain situations common to real-world systems, this method can be vulnerable to numerical instabilities. Such conditions might impede the algorithm from converging to a satisfactory solution. In such scenarios, users may choose to apply an alternative formulation of the WLS estimator.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This approach is suitable when measurement errors are uncorrelated, and the precision matrix remains diagonal. Therefore, as a preliminary step, we need to eliminate the correlation, as we did previously:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"updatePmu!(monitoring; label = \"PMU 2\", correlated = false)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"For simplicity, the iteration index is omitted in the following expressions.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Orthogonal-Method","page":"AC State Estimation","title":"Orthogonal Method","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"One such alternative is the orthogonal method [6, Sec. 3.2], which offers increased numerical robustness, particularly in cases where measurement variances differ significantly:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring, Orthogonal)\n\nfor iteration = 0:20\n    stopping = increment!(analysis)\n    if stopping < 1e-8\n        break\n    end\n    solve!(analysis)\nend\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To explain the method, we begin with the WLS equation:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"\t  Bigmathbf J (mathbf x)^T mathbf W mathbf J (mathbf x)Big mathbf Delta mathbf x =\n\t\tmathbf J (mathbf x)^T mathbf W mathbf r (mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where mathbf W = bm Sigma^-1. Subsequently, we can write:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  leftmathbf W^12 mathbf J (mathbf x)right^T  mathbf W^12 mathbf J (mathbf x)  Delta mathbf x =\n  leftmathbf W^12 mathbf J (mathbf x)right^T mathbf W^12 mathbf r (mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Consequently, we have:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  barmathbf J (mathbf x)^T  barmathbf J (mathbf x) Delta mathbf x = barmathbf J (mathbf x)^T barmathbf r (mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  barmathbf J(mathbf x) = mathbf W^12 mathbf J (mathbf x) \n  barmathbf r (mathbf x) = mathbf W^12 mathbf r (mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Therefore, within each iteration of the Gauss-Newton method, JuliaGrid conducts QR factorization on the rectangular matrix:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  barmathbf J(mathbf x) = mathbf W^12 mathbf J (mathbf x) = mathbf Q(mathbf x) mathbf R(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Access to the factorized matrix is possible through:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐐 = analysis.method.factorization.Q\n𝐑 = analysis.method.factorization.R","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To obtain the solution, JuliaGrid avoids explicitly forming the orthogonal matrix mathbf Q(mathbf x). Once the algorithm converges, estimates of bus voltage magnitudes hatmathbf V = hatV_i and angles hatbm Theta = hattheta_i, where i in mathcal N  can be accessed using variables:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Peters-and-Wilkinson-Method","page":"AC State Estimation","title":"Peters and Wilkinson Method","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Another option is the Peters and Wilkinson method [6, Sec. 3.4]:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"analysis = gaussNewton(monitoring, PetersWilkinson)\n\nfor iteration = 0:20\n    stopping = increment!(analysis)\n    if stopping < 1e-8\n        break\n    end\n    solve!(analysis)\nend\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This method applies LU factorisation to the rectangular matrix barmathbf J:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  barmathbf J (mathbf x) = mathbf W^12 mathbf J (mathbf x) = mathbfL(mathbf x)mathbfU(mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Substituting this into the normal equation:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"\t  barmathbf J (mathbf x)^T barmathbf J(mathbf x) Delta mathbf x = barmathbf J(mathbf x)^T barmathbf r (mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"yields:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  mathbfU(mathbf x)^T mathbfL(mathbf x)^T mathbfL(mathbf x) mathbfU(mathbf x) Delta mathbf x = mathbfU(mathbf x)^T mathbfL(mathbf x)^T barmathbf r (mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"By eliminating mathbfU(mathbf x)^T from both sides and introducing a new vector Delta mathbf y = mathbfU(mathbf x) Delta mathbf x,  we obtain:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  mathbfL(mathbf x)^T mathbfL(mathbf x) Delta mathbf y = mathbfL(mathbf x)^T barmathbf r (mathbf x)","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The Peters and Wilkinson method first solves this equation to compute Delta mathbf y, and then obtains Delta mathbf x by backward substitution using equation Delta mathbf y = mathbfU(mathbf x) Delta mathbf x. The main advantage of this approach is that mathbfL(mathbf x)^T mathbfL(mathbf x) is generally less ill-conditioned than barmathbf J (mathbf x)^T barmathbf J(mathbf x), which improves numerical stability.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Access to the factorized matrix is possible through:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Finally, the estimates of bus voltage magnitudes hatmathbfV = hatV_i and angles hatbmTheta = hattheta_i, where i in mathcalN, can be obtained as:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#ACLAVTutorials","page":"AC State Estimation","title":"Least Absolute Value Estimation","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The least absolute value (LAV) method provides an alternative estimation approach that is considered more robust in comparison to the WLS method. The WLS state estimation problem relies on specific assumptions about measurement errors, whereas robust estimators aim to remain unbiased even in the presence of various types of measurement errors and outliers. This characteristic eliminates the need for bad data analysis, as discussed in [6, Ch. 6]. It is important to note that robustness often comes at the cost of increased computational complexity.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"This section outlines the method as described in [6, Sec. 6.5]. Hence, we consider the system of nonlinear equations:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  mathbfz=mathbfh(mathbf x)+mathbfu","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The LAV state estimator is then formulated as the solution to the following optimization problem:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    textminimize  sum_i in mathcal M r_i\n    textsubjectto  z_i - h_i(mathbf x) =  r_i  forall i in mathcal M\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"where r_i denotes the residual of the i-th measurement.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To explicitly handle absolute values, we introduce two nonnegative variables u_i ge 0 and v_i ge 0, referred to as positive and negative deviations. This allows the optimization problem to be rewritten as:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    textminimize  sum_i in mathcal M (u_i + v_i) \n    textsubjectto    z_i - h_i(mathbf x) = u_i - v_i  forall i in mathcal M \n                          u_i geq  0  v_i geq  0  forall i in mathcal M\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To form the above optimization problem, the user can call the following function:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"using Ipopt\nusing JuMP # hide\n\nanalysis = acLavStateEstimation(monitoring, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Then the user can solve the optimization problem by:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"JuMP.set_silent(analysis.method.jump) # hide\nsolve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Users can retrieve the estimated bus voltage magnitudes hatmathbf V = hatV_i and angles hatbm Theta = hattheta_i, i in mathcal N, using:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#ACPowerAnalysisTutorials","page":"AC State Estimation","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the power! function, which enables the calculation of powers associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses and branches:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Type Power Active Reactive\nBus Injections mathbf P = P_i mathbf Q = Q_i\nBus Generator injections mathbf P_mathrmp = P_mathrmpi mathbf Q_mathrmp = Q_mathrmpi\nBus Shunt elements mathbf P_mathrmsh = P_mathrmshi mathbf Q_mathrmsh = Q_mathrmshi\nBranch From-bus end flows mathbf P_mathrmi = P_ij mathbf Q_mathrmi = Q_ij\nBranch To-bus end flows mathbf P_mathrmj = P_ji mathbf Q_mathrmj = Q_ji\nBranch Shunt elements mathbf P_mathrms = P_mathrmsij mathbf Q_mathrms = Q_mathrmsij\nBranch Series elements mathbf P_mathrml = P_mathrmlij mathbf Q_mathrml = Q_mathrmlij\n   ","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Power-Injections","page":"AC State Estimation","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Active and reactive power injections are stored as the vectors mathbfP = P_i and mathbfQ = Q_i, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐏 = analysis.power.injection.active\n𝐐 = analysis.power.injection.reactive","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#ACGeneratorPowerInjectionsManual","page":"AC State Estimation","title":"Generator Power Injections","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"We can calculate the active and reactive power injections supplied by generators at each bus i in mathcal N by summing the active and reactive power injections and the active and reactive power demanded by consumers at each bus:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"  beginaligned\n    P_mathrmpi = P_i + P_mathrmdi\n    Q_mathrmpi = Q_i + Q_mathrmdi\n  endaligned","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The active and reactive power injections from the generators at each bus are stored as vectors, denoted by mathbfP_mathrmp = P_mathrmpi and mathbfQ_mathrmp = Q_mathrmpi, which can be obtained using:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐏ₚ = analysis.power.supply.active\n𝐐ₚ = analysis.power.supply.reactive","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Power-at-Bus-Shunt-Elements","page":"AC State Estimation","title":"Power at Bus Shunt Elements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Active and reactive powers associated with the shunt elements at each bus are represented by the vectors mathbfP_mathrmsh = P_mathrmshi and mathbfQ_mathrmsh = Q_mathrmshi. To retrieve these powers in JuliaGrid, use the following commands:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐏ₛₕ = analysis.power.shunt.active\n𝐐ₛₕ = analysis.power.shunt.reactive","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Power-Flows","page":"AC State Estimation","title":"Power Flows","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The resulting active and reactive power flows at each from-bus end are stored as the vectors mathbfP_mathrmi = P_ij and mathbfQ_mathrmi = Q_ij respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐏ᵢ = analysis.power.from.active\n𝐐ᵢ = analysis.power.from.reactive","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The vectors of active and reactive power flows at the to-bus end are stored as mathbfP_mathrmj = P_ji and mathbfQ_mathrmj = Q_ji, respectively, and can be retrieved using the following code:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐏ⱼ = analysis.power.to.active\n𝐐ⱼ = analysis.power.to.reactive","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Power-at-Branch-Shunt-Elements","page":"AC State Estimation","title":"Power at Branch Shunt Elements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Active and reactive powers associated with the branch shunt elements at each branch are represented by the vectors mathbfP_mathrms = P_mathrmsij and mathbfQ_mathrms = Q_mathrmsij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐏ₛ = analysis.power.charging.active\n𝐐ₛ = analysis.power.charging.reactive","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Power-at-Branch-Series-Elements","page":"AC State Estimation","title":"Power at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Active and reactive powers associated with the branch series element at each branch are represented by the vectors mathbfP_mathrml = P_mathrmlij and mathbfQ_mathrml = Q_mathrmlij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐏ₗ = analysis.power.series.active\n𝐐ₗ = analysis.power.series.reactive","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#PMUCurrentAnalysisTutorials","page":"AC State Estimation","title":"Current Analysis","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"JuliaGrid offers the current! function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"current!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Type Current Magnitude Angle\nBus Injections mathbf I = I_i bm psi = psi_i\nBranch From-bus end flows mathbf I_mathrmi = I_ij bm psi_mathrmi = psi_ij\nBranch To-bus end flows mathbf I_mathrmj = I_ji bm psi_mathrmj = psi_ji\nBranch Series elements mathbf I_mathrml = I_mathrmlij bm psi_mathrml = psi_mathrmlij\n   ","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Current-Injections","page":"AC State Estimation","title":"Current Injections","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"In JuliaGrid, complex current injections are stored in the vector of magnitudes denoted as mathbf I = I_i and the vector of angles represented as bm psi = psi_i. You can retrieve them using the following commands:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐈 = analysis.current.injection.magnitude\n𝛙 = analysis.current.injection.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Current-Flows","page":"AC State Estimation","title":"Current Flows","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To obtain the vectors of magnitudes mathbfI_mathrmi = I_ij and angles bmpsi_mathrmi = psi_ij for the resulting complex current flows, you can use the following commands:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐈ᵢ = analysis.current.from.magnitude\n𝛙ᵢ = analysis.current.from.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"Similarly, we can obtain the vectors of magnitudes mathbfI_mathrmj = I_ji and angles bmpsi_mathrmj = psi_ji of the resulting complex current flows using the following code:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐈ⱼ = analysis.current.to.magnitude\n𝛙ⱼ = analysis.current.to.angle","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"","category":"page"},{"location":"tutorials/acStateEstimation/#Current-at-Branch-Series-Elements","page":"AC State Estimation","title":"Current at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"To obtain the vectors of magnitudes mathbfI_mathrml = I_mathrmlij and angles bmpsi_mathrml = psi_mathrmlij of the resulting complex current flows, one can use the following code:","category":"page"},{"location":"tutorials/acStateEstimation/","page":"AC State Estimation","title":"AC State Estimation","text":"𝐈ₗ = analysis.current.series.magnitude\n𝛙ₗ = analysis.current.series.angle","category":"page"},{"location":"api/publicTypes/#PublicTypesAPI","page":"Public Types","title":"Public Types","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"This section introduces the public types available in JuliaGrid. These types are designed to model and represent key components of power systems, measurements, and analyses.","category":"page"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"To load public types into the current scope, utilize the following command:","category":"page"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"using JuliaGrid","category":"page"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Power-System-Model","page":"Public Types","title":"Power System Model","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"PowerSystem\nBus\nBranch\nGenerator\nBaseData\nModel","category":"page"},{"location":"api/publicTypes/#Measurement-Model","page":"Public Types","title":"Measurement Model","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"Measurement\nVoltmeter\nAmmeter\nWattmeter\nVarmeter\nPMU","category":"page"},{"location":"api/publicTypes/#Analysis","page":"Public Types","title":"Analysis","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"Analysis\nAC\nDC\nLDLt\nLU\nKLU\nQR","category":"page"},{"location":"api/publicTypes/#Power-Flow","page":"Public Types","title":"Power Flow","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"AcPowerFlow\nNewtonRaphson\nFastNewtonRaphson\nGaussSeidel\nDcPowerFlow","category":"page"},{"location":"api/publicTypes/#Optimal-Power-Flow","page":"Public Types","title":"Optimal Power Flow","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"AcOptimalPowerFlow\nDcOptimalPowerFlow","category":"page"},{"location":"api/publicTypes/#Observability-Analysis","page":"Public Types","title":"Observability Analysis","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"Island\nPmuPlacement","category":"page"},{"location":"api/publicTypes/#State-Estimation","page":"Public Types","title":"State Estimation","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"AcStateEstimation\nPmuStateEstimation\nDcStateEstimation\nGaussNewton\nWLS\nLAV\nWlsMethod\nNormal\nOrthogonal\nPetersWilkinson","category":"page"},{"location":"api/publicTypes/#Bad-Data-Analysis","page":"Public Types","title":"Bad Data Analysis","text":"","category":"section"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"ChiTest\nResidualTest","category":"page"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Power-System-Model-2","page":"Public Types","title":"Power System Model","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.PowerSystem","page":"Public Types","title":"JuliaGrid.PowerSystem","text":"PowerSystem\n\nA composite type constructed using the powerSystem function to store power system data.\n\nFields\n\nbus::Bus: Bus-related data.\nbranch::Branch: Branch-related data.\ngenerator::Generator: Generator-related data.\nbase::BaseData: Base power and base voltages.\nmodel::Model: Data related to AC and DC analyses.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Bus","page":"Public Types","title":"JuliaGrid.Bus","text":"Bus\n\nA composite type used in PowerSystem to store bus-related data.\n\nFields\n\nlabel::LabelDict: Bus labels.\ndemand::BusDemand: Active and reactive power demands.\nsupply::BusSupply: Active and reactive power supplies from generators.\nshunt::BusShunt: Active and reactive power injections or demands from shunt elements.\nvoltage::BusVoltage: Initial voltages and voltage magnitude constraints.\nlayout::BusLayout: Bus layout, including bus types.\nnumber::Int64: Total number of buses.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Branch","page":"Public Types","title":"JuliaGrid.Branch","text":"Branch\n\nA composite type used in PowerSystem to store branch-related data.\n\nFields\n\nlabel::LabelDict: Branch labels.\nparameter::BranchParameter: Data related to the π-model of the branches.\nflow::BranchFlow: Branch flow constraints.\nvoltage::BranchVoltage: Voltage angle difference constraints.\nlayout::BranchLayout: Branch layout, including operational statuses.\nnumber::Int64: Total number of branches.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Generator","page":"Public Types","title":"JuliaGrid.Generator","text":"Generator\n\nA composite type used in PowerSystem to store generator-related data.\n\nFields\n\nlabel::LabelDict: Generator labels.\noutput::GeneratorOutput: Active and reactive power outputs.\ncapability::GeneratorCapability: Power output constraints.\nvoltage::GeneratorVoltage: Voltage magnitude setpoints.\ncost::GeneratorCost: Costs associated with active and reactive power outputs.\nlayout::GeneratorLayout: Generator layout, including operational statuses.\nnumber::Int64: Total number of generators.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.BaseData","page":"Public Types","title":"JuliaGrid.BaseData","text":"BaseData\n\nA composite type used in PowerSystem to store base data.\n\nFields\n\npower::BasePower: Base power.\nvoltage::BaseVoltage: Base voltages.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Model","page":"Public Types","title":"JuliaGrid.Model","text":"Model\n\nA composite type used in PowerSystem to store vectors and matrices related to the power system's topology and parameters.\n\nFields\n\nac::AcModel: AC model, including the nodal admittance matrix and Y-parameters of two-port branches.\ndc::DcModel: DC model, including the nodal admittance matrix and branch admittances.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Measurement-Model-2","page":"Public Types","title":"Measurement Model","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.Measurement","page":"Public Types","title":"JuliaGrid.Measurement","text":"Measurement\n\nA composite type built using the measurement function to store measurement data.\n\nFields\n\nvoltmeter::Voltmeter: Data related to bus voltage magnitude measurements.\nammeter::Ammeter: Data related to branch current magnitude measurements.\nwattmeter::Wattmeter: Data related to active power injection and active power flow measurements.\nvarmeter::Varmeter: Data related to reactive power injection and reactive power flow measurements.\npmu::PMU: Data related to bus voltage and branch current phasor measurements.\nsystem::PowerSystem: The reference to the power system.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Voltmeter","page":"Public Types","title":"JuliaGrid.Voltmeter","text":"Voltmeter\n\nA composite type used in Measurement to store voltmeter-related data.\n\nFields\n\nlabel::LabelDict: Voltmeter labels.\nmagnitude::GaussMeter: Bus voltage magnitude measurements.\nlayout::VoltmeterLayout: Placement indices and indicators.\nnumber::Int64: Total number of voltmeters.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Ammeter","page":"Public Types","title":"JuliaGrid.Ammeter","text":"Ammeter\n\nA composite type used in Measurement to store ammeter-related data.\n\nFields\n\nlabel::LabelDict: Ammeter labels.\nmagnitude::GaussMeter: Branch current magnitude measurements.\nlayout::AmmeterLayout: Placement indices and indicators.\nnumber::Int64: Total number of ammeters.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Wattmeter","page":"Public Types","title":"JuliaGrid.Wattmeter","text":"Wattmeter\n\nA composite type used in Measurement to store wattmeter-related data.\n\nFields\n\nlabel::LabelDict: Wattmeter labels.\nactive::GaussMeter: Active power injection and active power flow measurements.\nlayout::PowermeterLayout: Placement indices and indicators.\nnumber::Int64: Total number of wattmeters.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Varmeter","page":"Public Types","title":"JuliaGrid.Varmeter","text":"Varmeter\n\nA composite type used in Measurement to store varmeter-related data.\n\nFields\n\nlabel::LabelDict: Varmeter labels.\nreactive::GaussMeter: Reactive power injection and reactive power flow measurements.\nlayout::PowermeterLayout: Placement indices and indicators.\nnumber::Int64: Total number of varmeters.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.PMU","page":"Public Types","title":"JuliaGrid.PMU","text":"PMU\n\nA composite type used in Measurement to store PMU-related data.\n\nFields\n\nlabel::LabelDict: PMU labels.\nmagnitude::GaussMeter: Bus voltage and branch current magnitude measurements.\nangle::GaussMeter: Bus voltage and branch current angle measurements.\nlayout::PmuLayout: Placement indices and indicators.\nnumber::Int64: Total number of PMUs.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Analysis-2","page":"Public Types","title":"Analysis","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.Analysis","page":"Public Types","title":"JuliaGrid.Analysis","text":"Analysis\n\nAn abstract type used for representing both AC and DC analyses in JuliaGrid.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.AC","page":"Public Types","title":"JuliaGrid.AC","text":"AC <: Analysis\n\nAn abstract type representing AC analyses in JuliaGrid.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.DC","page":"Public Types","title":"JuliaGrid.DC","text":"DC <: Analysis\n\nAn abstract type representing DC analyses in JuliaGrid.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.LDLt","page":"Public Types","title":"JuliaGrid.LDLt","text":"LDLt\n\nAn abstract type used for representing LDLt factorization in JuliaGrid.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.LU","page":"Public Types","title":"JuliaGrid.LU","text":"LU\n\nAn abstract type used for representing LU factorization in JuliaGrid.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.KLU","page":"Public Types","title":"JuliaGrid.KLU","text":"KLU\n\nAn abstract type used for representing KLU factorization in JuliaGrid.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.QR","page":"Public Types","title":"JuliaGrid.QR","text":"QR\n\nAn abstract type used for representing QR factorization in JuliaGrid.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Power-Flow-2","page":"Public Types","title":"Power Flow","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.AcPowerFlow","page":"Public Types","title":"JuliaGrid.AcPowerFlow","text":"AcPowerFlow{T <: Union{NewtonRaphson, FastNewtonRaphson, GaussSeidel}} <: AC\n\nA composite type representing an AC power flow model, where the type parameter T specifies the numerical method used to solve the power flow. Supported methods include NewtonRaphson, FastNewtonRaphson, and GaussSeidel.\n\nFields\n\nvoltage::Polar: Bus voltages represented in polar form.\npower::AcPower: Active and reactive powers at the buses, branches, and generators.\ncurrent::AcCurrent: Currents at the buses and branches.\nmethod::T: Vectors and matrices associated with the method used to solve the AC power flow.\nsystem::PowerSystem: The reference to the power system.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.NewtonRaphson","page":"Public Types","title":"JuliaGrid.NewtonRaphson","text":"NewtonRaphson\n\nA composite type built using the newtonRaphson function to define the AC power flow model, which will be solved using the Newton-Raphson method.\n\nFields\n\njacobian::SparseMatrixCSC{Float64, Int64}: Jacobian matrix.\nmismatch::Vector{Float64}: Vector of mismatches.\nincrement::Vector{Float64}: Vector of state variable increments.\nfactorization::Factorization: Factorization of the Jacobian matrix.\npq::Vector{Int64}: Indices related to demand buses.\npvpq::Vector{Int64}: Indices related to demand and generator buses.\nsignature::Signature: Tracks modifications in key variables.\niteration::Int64: The iteration counter.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.FastNewtonRaphson","page":"Public Types","title":"JuliaGrid.FastNewtonRaphson","text":"FastNewtonRaphson\n\nA composite type built using the fastNewtonRaphsonBX and fastNewtonRaphsonXB functions to define the AC power flow model, which will be solved using the fast Newton-Raphson method.\n\nFields\n\nactive:FastNewtonRaphsonModel: Jacobian, mismatches, and incrementes for active power equations.\nreactive:FastNewtonRaphsonModel: Jacobian, mismatches, and incrementes for active power equations.\npq::Vector{Int64}: Indices related to demand buses.\npvpq::Vector{Int64}: Indices related to demand and generator buses.\nsignature::Signature: Tracks modifications in key variables.\nbx::Bool: Version of the method, either BX or XB.\niteration::Int64: The iteration counter.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.GaussSeidel","page":"Public Types","title":"JuliaGrid.GaussSeidel","text":"GaussSeidel\n\nA composite type built using the gaussSeidel function to define the AC power flow model, which will be solved using the Gauss-Seidel method.\n\nFields\n\nvoltage::Vector{ComplexF64}: Vector of complex voltage values.\npq::Vector{Int64}: Indices related to demand buses.\npv::Vector{Int64}: Indices related to generator buses.\nsignature::Signature: Tracks modifications in key variables.\niteration::Int64: The iteration counter.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.DcPowerFlow","page":"Public Types","title":"JuliaGrid.DcPowerFlow","text":"DcPowerFlow <: DC\n\nA composite type built using the dcPowerFlow function to define the DC power flow model.\n\nFields\n\nvoltage::Angle: Bus voltage angles.\npower::DcPower: Active powers at the buses, branches, and generators.\nmethod::DcPowerFlowMethod: Factorization of the nodal admittance matrix.\nsystem::PowerSystem: The reference to the power system.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Optimal-Power-Flow-2","page":"Public Types","title":"Optimal Power Flow","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.AcOptimalPowerFlow","page":"Public Types","title":"JuliaGrid.AcOptimalPowerFlow","text":"AcOptimalPowerFlow <: AC\n\nA composite type built using the acOptimalPowerFlow function to define the AC optimal power flow model.\n\nFields\n\nvoltage::Polar: Bus voltages represented in polar form.\npower::AcPower: Active and reactive powers at buses, branches, and generators.\ncurrent::AcCurrent: Currents at buses and branches.\nmethod::AcOptimalPowerFlowMethod: The JuMP model, including variables, constraints, and objective.\nextended::Extended: User-defined variables and constraints.\nsystem::PowerSystem: The reference to the power system.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.DcOptimalPowerFlow","page":"Public Types","title":"JuliaGrid.DcOptimalPowerFlow","text":"DcOptimalPowerFlow <: DC\n\nA composite type built using the dcOptimalPowerFlow function to define the DC optimal power flow model.\n\nFields\n\nvoltage::Angle: Bus voltage angles.\npower::DcPower: Active powers at buses, branches, and generators.\nmethod::DcOptimalPowerFlowMethod: The JuMP model, including variables, constraints, and objective.\nextended::Extended: User-defined variables and constraints.\nsystem::PowerSystem: The reference to the power system.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Observability-Analysis-2","page":"Public Types","title":"Observability Analysis","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.Island","page":"Public Types","title":"JuliaGrid.Island","text":"Island\n\nA composite type built using the islandTopologicalFlow and islandTopological functions, which holds data about observable islands.\n\nFields\n\nisland::Vector{Vector{Int64}}: List of observable islands, represented by a vector of bus indices.\nbus::Vector{Int64}: Positions of buses in relation to each island.\ntie::TieData: Tie data associated with buses and branches.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.PmuPlacement","page":"Public Types","title":"JuliaGrid.PmuPlacement","text":"PmuPlacement\n\nA composite type built using the pmuPlacement function, which stores data on optimal PMU placement.\n\nFields\n\nbus::LabelDict: Phasor measurement placement at buses.\nfrom::LabelDict: Phasor measurement placement at from-buses.\nto::LabelDict: Phasor measurement placement at to-buses.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#State-Estimation-2","page":"Public Types","title":"State Estimation","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.AcStateEstimation","page":"Public Types","title":"JuliaGrid.AcStateEstimation","text":"AcStateEstimation{T <: Union{GaussNewton, LAV}} <: AC\n\nA composite type representing an AC state estimation model, where the type parameter T specifies the estimation method. Supported methods include GaussNewton and LAV. The model is constructed using either the gaussNewton or acLavStateEstimation function.\n\nFields\n\nvoltage::Polar: Bus voltages represented in polar form.\npower::AcPower: Active and reactive powers at the buses and branches.\ncurrent::AcCurrent: Currents at the buses and branches.\nmethod::T: The estimation model associated with the method used to solve the AC state estimation.\nsystem::PowerSystem: The reference to the power system.\nmonitoring::Measurement: The reference to the measurement model.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.PmuStateEstimation","page":"Public Types","title":"JuliaGrid.PmuStateEstimation","text":"PmuStateEstimation{T <: Union{WLS, LAV}} <: AC\n\nA composite type representing a PMU state estimation model, where the type parameter T specifies the estimation method. Supported methods include WLS and LAV. The model is constructed using either the pmuStateEstimation or pmuLavStateEstimation function.\n\nFields\n\nvoltage::Polar: Bus voltages represented in polar form.\npower::AcPower: Active and reactive powers at the buses and branches.\ncurrent::AcCurrent: Currents at the buses and branches.\nmethod::T: The estimation model associated with the method used to solve the PMU state estimation.\nsystem::PowerSystem: The reference to the power system.\nmonitoring::Measurement: The reference to the measurement model.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.DcStateEstimation","page":"Public Types","title":"JuliaGrid.DcStateEstimation","text":"DcStateEstimation{T <: Union{WLS, LAV}} <: DC\n\nA composite type representing a DC state estimation model, where the type parameter T specifies the estimation method. Supported methods include WLS and LAV. The model is constructed using either the dcStateEstimation or dcLavStateEstimation function.\n\nFields\n\nvoltage::Angle: Bus voltage angles.\npower::DcPower: Active powers at the buses and generators.\nmethod::T: The estimation model associated with the method used to solve the DC state estimation.\nsystem::PowerSystem: The reference to the power system.\nmonitoring::Measurement: The reference to the measurement model.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.GaussNewton","page":"Public Types","title":"JuliaGrid.GaussNewton","text":"GaussNewton{T <: WlsMethod}\n\nA composite type built using the gaussNewton function to define the AC state estimation model, which will be solved using the Gauss-Newton method.\n\nFields\n\njacobian::SparseMatrixCSC{Float64, Int64}: Jacobian matrix.\nprecision::SparseMatrixCSC{Float64, Int64}: Precision matrix.\nmean::Vector{Float64}: Mean vector.\nresidual::Vector{Float64}: Residual vector.\nincrement::Vector{Float64}: Increment vector.\nfactorization::Factorization: Factorization of the Jacobian matrix.\ntype::Vector{Int8}: Indicators of measurement types.\nindex::Vector{Int64}: Indices of buses and branches where measurements are located.\nrange::Vector{Int64}: Range of measurement devices.\nsignature::Signature: Tracks modifications in key variables.\nobjective::Float64: Value of the objective function.\niteration::Int64: The iteration counter.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.WLS","page":"Public Types","title":"JuliaGrid.WLS","text":"WLS{T <: WlsMethod}\n\nA composite type representing a linear weighted least-squares state estimation model.\n\nFields\n\ncoefficient::SparseMatrixCSC{Float64, Int64}: Coefficient matrix.\nprecision::SparseMatrixCSC{Float64, Int64}: Precision matrix.\nmean::Vector{Float64}: Mean vector.\nfactorization::Factorization: Factorization of the coefficient matrix.\nindex::OrderedDict{Int64, Int64}: Indices if needed.\nnumber::Int64: Number of measurement devices.\ninservice::Int64: Number of equations related to in-service measurement devices.\nsignature::Signature: Tracks modifications in key variables.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.LAV","page":"Public Types","title":"JuliaGrid.LAV","text":"LAV\n\nA composite type representing a least absolute value state estimation model.\n\nFields\n\njump::JuMP.Model: The JuMP optimization model.\nvariable::LavVariableRef: References to state variables and positive and negative deviations.\nresidual::Dict{Int64, ConstraintRef}: References to residual constraints.\nindex::OrderedDict{Int64, Int64}: Mapping of indices, if needed.\nrange::Vector{Int64}: Range of measurement devices.\nnumber::Int64: Total number of measurement devices.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.WlsMethod","page":"Public Types","title":"JuliaGrid.WlsMethod","text":"WlsMethod\n\nAn abstract type representing a method for solving WLS state estimation.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Normal","page":"Public Types","title":"JuliaGrid.Normal","text":"Normal <: WlsMethod\n\nAn abstract type representing weighted least-squares state estimation, where the normal equation is solved by factorizing the gain matrix and performing forward/backward substitutions on the right-hand-side vector. It is used as a type parameter in GaussNewton and WLS models.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.Orthogonal","page":"Public Types","title":"JuliaGrid.Orthogonal","text":"Orthogonal <: WlsMethod\n\nAn abstract type representing weighted least-squares state estimation, where the normal equation is solved using an orthogonal method. It is used as a type parameter in GaussNewton and WLS models.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.PetersWilkinson","page":"Public Types","title":"JuliaGrid.PetersWilkinson","text":"PetersWilkinson <: WlsMethod\n\nAn abstract type representing weighted least-squares state estimation, where the normal equation is solved using an Peters and Wilkinson method. It is used as a type parameter in GaussNewton and WLS models.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/","page":"Public Types","title":"Public Types","text":"","category":"page"},{"location":"api/publicTypes/#Bad-Data-Analysis-2","page":"Public Types","title":"Bad Data Analysis","text":"","category":"section"},{"location":"api/publicTypes/#JuliaGrid.ChiTest","page":"Public Types","title":"JuliaGrid.ChiTest","text":"ChiTest\n\nA composite type constructed using the chiTest function, which stores results from the Chi-squared bad data detection test.\n\nFields\n\ndetect::Bool: Flag indicating bad data detection.\nthreshold::Float64: Chi-squared critical value.\nobjective::Float64: Objective function value from WLS state estimation.\n\n\n\n\n\n","category":"type"},{"location":"api/publicTypes/#JuliaGrid.ResidualTest","page":"Public Types","title":"JuliaGrid.ResidualTest","text":"ResidualTest\n\nA composite type built using residualTest! function, which stores results from the bad data processing.\n\nFields\n\ndetect::Bool: Flag indicating bad data detection.\nmaxNormalizedResidual::Float64: The maximum value of the normalized residual.\nlabel::IntStr: The label of the measurement suspected to be an outlier.\nindex::Int64: The index of the outlier measurement within the model.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/dcPowerFlow/#DCPowerFlowTutorials","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid employs standard network components and the Unified Branch Model to obtain the DC power flow solution. To begin, let us generate the PowerSystem type, as illustrated by the following example:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n@config(label = Integer)\n@power(MW, MVAr)\n@voltage(pu, deg)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7)\naddBus!(system; label = 3, type = 2, conductance = 0.07)\n\naddBranch!(system; from = 1, to = 2, reactance = 0.26)\naddBranch!(system; from = 1, to = 3, reactance = 0.38)\naddBranch!(system; from = 2, to = 3, reactance = 0.17, turnsRatio = 0.97)\n\naddGenerator!(system; bus = 1, active = 2.0)\naddGenerator!(system; bus = 1, active = 4.0)\naddGenerator!(system; bus = 3, active = 5.0)\nnothing #hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcal G = (mathcal N mathcal E), where we have the set of buses mathcal N = 1 dots n, and the set of branches mathcal E subseteq mathcal N times mathcal N within the power system:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbf a, we use the notation mathbf a = a_i or mathbf a = a_ij, where a_i represents the element associated with bus i in mathcal N, and a_ij represents the element associated with branch (ij) in mathcal E.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Bus-Types","page":"DC Power Flow","title":"Bus Types","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In the context of Bus Types, demand and generator buses are treated identically in the DC power flow model. The only bus type that matters is the slack bus, whose voltage angle is known.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid verifies the slack bus during initialization, and its assignment can be adjusted within the dcPowerFlow function. Specifically, if a bus is labeled as the slack bus (type = 3) but does not have a connected in-service generator, it will be reclassified as a demand bus (type = 1). In that case, the first generator bus (type = 2) with a connected in-service generator is promoted to the slack bus (type = 3).","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCPowerFlowSolutionTutorials","page":"DC Power Flow","title":"Power Flow Solution","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"As discussed in section DC Model, the DC power flow problem can be represented by a set of linear equations:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"  mathbf P = mathbf B bm Theta + mathbfP_mathrmtr + mathbfP_mathrmsh","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Implementation","page":"DC Power Flow","title":"Implementation","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid offers a set of functions to solve the DC power flow problem and obtain the bus voltage angles. Firstly, the power system is loaded and the DC model is built using the following code sequence:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"dcModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The DC power flow solution is obtained through a non-iterative approach by solving the system of linear equations:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    bm Theta = mathbfB^-1(mathbf P - mathbfP_mathrmtr - mathbfP_mathrmsh)","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"JuliaGrid begins the process by establishing the DC power flow framework:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"analysis = dcPowerFlow(system)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The subsequent step involves performing the LU factorization of the nodal matrix mathbf B = mathbf L mathbf U and computing the bus voltage angles using:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"tip: Tip\nBy default, JuliaGrid utilizes LU factorization as the primary method to factorize the nodal matrix. However, users maintain the flexibility to opt for alternative factorization methods such as LDLt or QR.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The factorization of the nodal matrix can be accessed using:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"It is important to note that the slack bus voltage angle is excluded from the vector bm Theta only during the computation step. Consequently, the corresponding elements in the vectors mathbf P, mathbfP_mathrmtr, mathbfP_mathrmsh, and the corresponding row and column of the matrix mathbf B are removed. It is worth mentioning that this process is handled internally, and the stored elements remain unchanged.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Finally, the resulting bus voltage angles are saved in the vector as follows:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#DCPowerAnalysisTutorials","page":"DC Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"After obtaining the solution from the DC power flow, we can calculate powers related to buses, branches, and generators using the power! function:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols provided below, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Power-Injections","page":"DC Power Flow","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Active power injections are stored as the vector mathbf P = P_i, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏 = analysis.power.injection.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Generator-Power-Injections","page":"DC Power Flow","title":"Generator Power Injections","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The active power supplied by generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_mathrmpi = P_i + P_mathrmdi i in mathcalN_mathrmsb","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"where P_mathrmdi represents the active power demanded by consumers at the slack bus. The vector of active powers injected by generators into the buses, denoted by mathbfP_mathrmp = P_mathrmpi, can be obtained using the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ₚ = analysis.power.supply.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Power-Flows","page":"DC Power Flow","title":"Power Flows","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The resulting from-bus active power flows are stored as the vector mathbfP_mathrmi = P_ij, which can be retrieved using:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ᵢ = analysis.power.from.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"Similarly, the resulting to-bus active power flows are stored as the vector mathbfP_mathrmj = P_ji, which can be retrieved using:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ⱼ = analysis.power.to.active","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"","category":"page"},{"location":"tutorials/dcPowerFlow/#Generators-Power-Outputs","page":"DC Power Flow","title":"Generators Power Outputs","text":"","category":"section"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"The output active power of each generator located at bus i in mathcalN_mathrmpv cup mathcalN_mathrmpq is equal to the active power specified in the input data. If there are multiple generators, their output active powers are also equal to the active powers specified in the input data. However, the output active power of a generator located at the slack bus will be:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"    P_mathrmgi = P_i + P_mathrmdi  i in mathcalN_mathrmsb","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of P_mathrmgi. Then, this amount of power is reduced by the output active power of the other generators.","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"To retrieve the vector of active power outputs of generators, denoted as mathbfP_mathrmg = P_mathrmgi, i in mathcal S, where the set mathcal S represents the set of generators, users can utilize the following command:","category":"page"},{"location":"tutorials/dcPowerFlow/","page":"DC Power Flow","title":"DC Power Flow","text":"𝐏ₒ = analysis.power.generator.active","category":"page"},{"location":"manual/dcStateEstimation/#DCStateEstimationManual","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To perform the DC state estimation, we first need to have the PowerSystem type that has been created with the DC model, alongside the Measurement type that retains measurement data. Subsequently, we can formulate either the weighted least-squares (WLS) or the least absolute value (LAV) DC state estimation model encapsulated within the type DcStateEstimation using:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"dcStateEstimation,\ndcLavStateEstimation.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To obtain bus voltage angles and solve the DC state estimation problem, users can use the wrapper function:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"solve!.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"After solving the DC state estimation, JuliaGrid provides function for computing powers:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"power!.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Alternatively, instead of using functions responsible for solving state estimation and computing powers, users can use the wrapper function:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"stateEstimation!.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Users can also access specialized functions for computing specific types of powers for individual buses, branches, or generators within the power system.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#DCWLSStateEstimationSolutionManual","page":"DC State Estimation","title":"Weighted Least-Squares Estimator","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To solve the DC state estimation and derive WLS estimates using JuliaGrid, the process initiates by defining PowerSystem and Measurement types. Here is an illustrative example:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.5)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.2)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.3)\n\n@wattmeter(label = \"Wattmeter ?\")\naddWattmeter!(monitoring; bus = \"Bus 1\", active = 0.6, variance = 1e-3)\naddWattmeter!(monitoring; bus = \"Bus 3\", active = -0.4, variance = 1e-2)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.18, variance = 1e-4)\naddWattmeter!(monitoring; to = \"Branch 2\", active = -0.42, variance = 1e-4)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The dcStateEstimation function serves to establish the DC state estimation problem:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"tip: Tip\nHere, the user triggers LU factorization as the default method for solving the DC state estimation problem. However, the user also has the option to select alternative factorization methods such as KLU, LDLt or QR:analysis = dcStateEstimation(monitoring, LDLt)","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To obtain the bus voltage angles, the solve! function can be invoked as shown:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"solve!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Upon obtaining the solution, access the bus voltage angles using:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"print(system.bus.label, analysis.voltage.angle)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nWe recommend that readers refer to the tutorial on DC State Estimation for insights into the implementation.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Wrapper-Function","page":"DC State Estimation","title":"Wrapper Function","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"JuliaGrid provides a wrapper function for DC state estimation analysis and also supports the computation of powers using the stateEstimation! function:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis; verbose = 2)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Print-Results-in-the-REPL","page":"DC State Estimation","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Users have the option to print the results in the REPL using any units that have been configured, such as:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"@voltage(pu, deg)\nprintBusData(analysis)\n@default(unit) # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, users can easily customize the print results for specific buses, for example:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"printBusData(analysis; label = \"Bus 1\", header = true)\nprintBusData(analysis; label = \"Bus 2\")\nprintBusData(analysis; label = \"Bus 3\", footer = true)","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Save-Results-to-a-File","page":"DC State Estimation","title":"Save Results to a File","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Users can also redirect print output to a file. For example, data can be saved in a text file as follows:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"open(\"bus.txt\", \"w\") do file\n    printBusData(analysis, file)\nend","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"tip: Tip\nWe also provide functions to print state estimation results, such as estimated values and residuals. For more details, users can consult the Power Analysis section of this manual.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Alternative-Formulations","page":"DC State Estimation","title":"Alternative Formulations","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The conventional approach to solving the WLS state estimation problem generally performs well. However, it is well known that, under certain conditions often encountered in real-world systems, this method may suffer from numerical instabilities. These issues can prevent the algorithm from reaching a satisfactory solution. In such scenarios, users may choose to apply an alternative formulation of the WLS estimator.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Orthogonal-Method","page":"DC State Estimation","title":"Orthogonal Method","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"One such alternative is the orthogonal method [6, Sec. 3.2], which offers increased numerical robustness, particularly in cases where measurement variances differ significantly. By specifying the Orthogonal argument in the dcStateEstimation function, users can solve the WLS problem via QR factorisation applied to a rectangular matrix formed by multiplying the square root of the precision matrix with the coefficient matrix:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring, Orthogonal)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Peters-and-Wilkinson-Method","page":"DC State Estimation","title":"Peters and Wilkinson Method","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Another option is the Peters and Wilkinson method [6, Sec. 3.4], which applies LU factorisation to the same rectangular matrix, constructed using the square root of the precision matrix and the coefficient matrix. This method can be selected by passing the PetersWilkinson argument to the dcStateEstimation function:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"analysis = dcStateEstimation(monitoring, PetersWilkinson)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#DCLAVtateEstimationSolutionManual","page":"DC State Estimation","title":"Least Absolute Value Estimator","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"The LAV method presents an alternative estimation technique known for its increased robustness compared to WLS. While the WLS method relies on specific assumptions regarding measurement errors, robust estimators like LAV are designed to maintain unbiasedness even in the presence of various types of measurement errors and outliers. This characteristic often eliminates the need for extensive bad data analysis procedures [6, Ch. 6]. However, it is important to note that achieving robustness typically involves increased computational complexity.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To obtain an LAV estimator, users need to employ one of the solvers listed in the JuMP documentation. In many common scenarios, the Ipopt solver proves sufficient to obtain a solution:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using Ipopt\nusing JuMP  # hide\n\nanalysis = dcLavStateEstimation(monitoring, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Setup-Initial-Primal-Values","page":"DC State Estimation","title":"Setup Initial Primal Values","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"In JuliaGrid, the assignment of initial primal values for optimization variables takes place when the solve! function is executed. These values are derived from the voltage angles stored in the PowerSystem type and are assigned to the corresponding voltage field within the DcStateEstimation type:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"print(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Users have the flexibility to customize these values according to their requirements, and they will be utilized as the initial primal values when executing the solve! function. One practical approach is to obtaine WLS estimator and then apply the resulting solution as the starting point for state estimation:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"wls = dcStateEstimation(monitoring)\nstateEstimation!(wls)\n\nsetInitialPoint!(analysis, wls)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"As a result, the initial primal values will now reflect the outcome of the WLS state estimation solution:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"print(system.bus.label, analysis.voltage.angle)","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Solution","page":"DC State Estimation","title":"Solution","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To solve the formulated LAV state estimation model, simply execute the following function:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"stateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Upon obtaining the solution, access the bus voltage angles using:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"print(system.bus.label, analysis.voltage.angle)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nReaders can refer to the Least Absolute Value Estimation tutorial for implementation insights.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#DCMeasurementsAlterationManual","page":"DC State Estimation","title":"Measurement Set Update","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"We begin by creating the PowerSystem and Measurement types with the ems function. The DC model is then configured using dcModel! function. After that, we initialize the DcStateEstimation type through the dcStateEstimation function and solve the resulting state estimation problem:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.5)\n\ndcModel!(system)\n\n@wattmeter(label = \"Wattmeter ?\")\naddWattmeter!(monitoring; bus = \"Bus 2\", active = -0.11, variance = 1e-3)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.09, variance = 1e-4)\n\nanalysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, we modify the existing Measurement type using add and update functions. Then, we create the new DcStateEstimation type based on the modified system and solve the state estimation problem:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"addWattmeter!(monitoring; to = \"Branch 1\", active = -0.12, variance = 1e-4)\nupdateWattmeter!(monitoring; label = \"Wattmeter 1\", status = 0)\nupdateWattmeter!(monitoring; label = \"Wattmeter 2\", active = 0.1, noise = false)\n\nanalysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nThis concept removes the need to restart and recreate the Measurement type from the beginning when implementing changes to the existing measurement set.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#DCStateEstimationUpdateManual","page":"DC State Estimation","title":"State Estimation Update","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"An advanced methodology involves users establishing the DcStateEstimation type using dcStateEstimation or dcLavStateEstimation just once. After this initial setup, users can seamlessly modify existing measurement devices without the need to recreate the DcStateEstimation type.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"This advancement extends beyond the previous scenario where recreating the Measurement type was unnecessary, to now include the scenario where DcStateEstimation also does not need to be recreated. Such efficiency can be particularly advantageous in cases where JuliaGrid can reuse gain matrix factorization.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"tip: Tip\nThe addition of new measurements after the creation of DcStateEstimation is not practical in terms of reusing this type. Instead, we recommend that users create a final set of measurements and then utilize update functions to manage devices, either putting them in-service or out-of-service throughout the process.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Let us now revisit our defined PowerSystem, Measurement and DcStateEstimation types:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3)\naddBus!(system; label = \"Bus 2\")\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.5)\n\ndcModel!(system)\n\n@wattmeter(label = \"Wattmeter ?\")\naddWattmeter!(monitoring; bus = \"Bus 2\", active = -0.11, variance = 1e-3)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.09, variance = 1e-4)\naddWattmeter!(monitoring; to = \"Branch 1\", active = -0.12, variance = 1e-4, status = 0)\n\nanalysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Next, we modify the existing Measurement type as well as the DcStateEstimation type using add and update functions. We then immediately proceed to solve the state estimation problem:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"updateWattmeter!(analysis; label = \"Wattmeter 1\", status = 0)\nupdateWattmeter!(analysis; label = \"Wattmeter 2\", active = 0.1)\nupdateWattmeter!(analysis; label = \"Wattmeter 3\", status = 1, noise = false)\n\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nThis concept removes the need to rebuild both the Measurement and the DcStateEstimation from the beginning when implementing changes to the existing measurement set. In the scenario of employing the WLS model, JuliaGrid can reuse the symbolic factorizations of LU or LDLt, provided that the nonzero pattern of the gain matrix remains unchanged.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Reusing-Weighted-Least-Squares-Matrix-Factorization","page":"DC State Estimation","title":"Reusing Weighted Least-Squares Matrix Factorization","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Drawing from the preceding example, our focus now shifts to finding a solution involving modifications that entail adjusting the measurement value of the Wattmeter 2. It is important to note that these adjustments do not impact the variance or status of the measurement device, which can affect the gain matrix. To resolve this updated system, users can simply execute the solve! function:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nupdateWattmeter!(analysis; label = \"Wattmeter 2\", active = 0.091)\n\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nIn this scenario, JuliaGrid will recognize instances where the user has not modified parameters that impact the gain matrix. Consequently, JuliaGrid will leverage the previously performed gain matrix factorization, resulting in a significantly faster solution compared to recomputing the factorization.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#DCSEPowerAnalysisManual","page":"DC State Estimation","title":"Power Analysis","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"After obtaining the solution from the DC state estimation, calculating powers related to buses and branches is facilitated by using the power! function. For instance, let us consider the model for which we obtained the DC state estimation solution:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = \"Bus 1\", type = 3, conductance = 1e-3)\naddBus!(system; label = \"Bus 2\")\naddBus!(system; label = \"Bus 3\")\n\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", reactance = 0.5)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", reactance = 0.2)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", reactance = 0.3)\n\naddWattmeter!(monitoring; bus = \"Bus 1\", active = 0.6, variance = 1e-3)\naddWattmeter!(monitoring; bus = \"Bus 3\", active = -0.4, variance = 1e-2)\naddWattmeter!(monitoring; from = \"Branch 1\", active = 0.18, variance = 1e-4)\naddWattmeter!(monitoring; to = \"Branch 2\", active = -0.42, variance = 1e-4)\n\nanalysis = dcStateEstimation(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"We can compute active powers using the following function:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"For example, active power injections corresponding to buses are:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"print(system.bus.label, analysis.power.injection.active)","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"note: Info\nTo better understand the powers associated with buses, and branches that are calculated by the power! function, we suggest referring to the tutorials on.","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Print-Results-in-the-REPL-2","page":"DC State Estimation","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Users can utilize any of the print functions outlined in the Print API related to the DC analysis. For example, to print state estimation data related to wattmeters, we can use:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"@power(MW, pu)\nprintWattmeterData(analysis)\n@default(unit) # hide","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Save-Results-to-a-CSV-File","page":"DC State Estimation","title":"Save Results to a CSV File","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"For CSV output, users should first generate a simple table with style = false, and then save it to a CSV file:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"using CSV\n\nio = IOBuffer()\nprintWattmeterData(analysis, io; style = false)\nCSV.write(\"bus.csv\", CSV.File(take!(io); delim = \"|\"))","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Active-Power-Injection","page":"DC State Estimation","title":"Active Power Injection","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To calculate active power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"active = injectionPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Active-Power-Injection-from-Generators","page":"DC State Estimation","title":"Active Power Injection from Generators","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"To calculate active power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"active = supplyPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"","category":"page"},{"location":"manual/dcStateEstimation/#Active-Power-Flow","page":"DC State Estimation","title":"Active Power Flow","text":"","category":"section"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"Similarly, we can compute the active power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/dcStateEstimation/","page":"DC State Estimation","title":"DC State Estimation","text":"active = fromPower(analysis; label = \"Branch 1\")\nactive = toPower(analysis; label = \"Branch 1\")","category":"page"},{"location":"tutorials/acPowerFlow/#ACPowerFlowTutorials","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid uses standard network components and the Unified Branch Model for power flow analysis, allowing load profiles, generator capacities, voltage specifications, contingency analysis, and planning to be defined efficiently.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To begin, let us generate the PowerSystem type, as illustrated by the following example:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n@config(label = Integer)\n@power(MW, MVAr)\n@voltage(pu, deg)\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3)\naddBus!(system; label = 2, type = 1, active = 21.7, reactive = 12.7)\naddBus!(system; label = 3, type = 1, active = 11.2, reactive = -3.0)\naddBus!(system; label = 4, type = 2, conductance = 2.1, susceptance = 1.2)\n\naddBranch!(system; from = 1, to = 2, resistance = 0.02, reactance = 0.06)\naddBranch!(system; from = 1, to = 3, resistance = 0.05, reactance = 0.21)\naddBranch!(system; from = 2, to = 3, resistance = 0.13, reactance = 0.26)\naddBranch!(system; from = 3, to = 4, reactance = 0.17, susceptance = 0.2, conductance = 1e-4)\n\naddGenerator!(system; bus = 1)\naddGenerator!(system; bus = 3, active = 40.0, reactive = 42.4)\nnothing #hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcal G = (mathcal N mathcal E), where we have the set of buses mathcal N = 1 dots n, and the set of branches mathcal E subseteq mathcal N times mathcal N within the power system:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝒩 = collect(keys(system.bus.label))\nℰ = hcat([𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]])","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"ukw: Notation\nIn this section, when referring to a vector mathbf a, we use the notation mathbf a = a_i or mathbf a = a_ij, where a_i represents the element associated with bus i in mathcal N, and a_ij represents the element associated with branch (ij) in mathcal E.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#FlowNodalNetworkEquationsTutorials","page":"AC Power Flow","title":"Nodal Network Equations","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As previously demonstrated in the section on the Nodal Network Equations, we observe the system of equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfbarI = mathbf Y mathbfbarV","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex current injection at the bus i in mathcal N is defined as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barI_i = cfracS_i^*barV_i^*","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, for any given bus i in mathcal N, we can express it as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  cfracS_i^*barV_i^* = sum_j = 1^n Y_ij barV_j","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The complex power injection denoted by S_i consists of both the active power P_i and reactive power Q_i. This relationship can be represented as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  cfracP_i - mathrmj Q_ibarV_i^* = sum_j = 1^n Y_ij barV_j","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Recognizing that Y_ij =  G_ij + mathrmj B_ij, barV_i = V_i mathrme^mathrmjtheta_i, barV_j = V_j mathrme^mathrmjtheta_j, and by defining theta_ij = theta_i - theta_j,  we can break down the above equation into its real and imaginary parts, resulting in two equations that describe bus i in mathcal N as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    P_i = V_i sumlimits_j=1^n (G_ijcostheta_ij + B_ijsintheta_ij) V_j\n    Q_i = V_i sumlimits_j=1^n (G_ijsintheta_ij - B_ijcostheta_ij) V_j\n\tendaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BusTypesTutorials","page":"AC Power Flow","title":"Bus Types","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As demonstrated by the above equations, the bus i in mathcal N contains four unknown variables: the active power injection P_i, reactive power injection Q_i, bus voltage magnitude V_i, and bus voltage angle theta_i.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To solve these equations, it is necessary to specify two known variables. Although any two variables can be selected mathematically, the choice is determined by the devices that are connected to a particular bus. The standard options are listed in the table below, and these options are used to define the bus types [10].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Bus Type Label Known Unknown\nDemand 1 P_i, Q_i V_i, theta_i\nGenerator 2 P_i, V_i Q_i, theta_i\nSlack 3 V_i, theta_i P_i, Q_i\n   ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Consequently, JuliaGrid operates with sets mathcalN_mathrmpq and mathcalN_mathrmpv that contain demand and generator buses, respectively, and exactly one slack bus in the set mathcalN_mathrmsb, JuliaGrid cannot handle systems with multiple slack buses. The bus types are stored in the variable:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"system.bus.layout.type","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"When functions such as newtonRaphson, fastNewtonRaphsonBX, fastNewtonRaphsonXB, or gaussSeidel are used, the bus types are checked and may be modified automatically. Specifically, if a bus is labeled as a generator bus (type = 2) but does not have a connected in-service generator, it will be reclassified as a demand bus (type = 1). The same applies to the slack bus (type = 3), if it lacks an in-service generator, it is also converted to a demand bus (type = 1). In that case, the first generator bus (type = 2) with a connected in-service generator is promoted to slack bus (type = 3).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the bus types have been determined, we need the active power injections P_i and reactive power injections Q_i for demand and generator buses. However, standard power system data does not directly provide these injection values. Instead, they are computed as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  \tP_i = P_mathrmpi - P_mathrmdi \n    Q_i = Q_mathrmpi - Q_mathrmdi\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_mathrmdi and Q_mathrmdi denote the active and reactive power demanded at the bus i in mathcal N, while P_mathrmpi and Q_mathrmpi correspond to the active and reactive power produced by the generators at the bus i in mathcal N.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To provide a more comprehensive understanding, it is important to note that each bus i in mathcal N has the capacity to host multiple generators. This scenario can be conceptualized by introducing the set mathcalS_i, which encompasses all generators connected to bus i in mathcal N. With this perspective, we can calculate the values of P_mathrmpi and Q_mathrmpi as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n  \tP_mathrmpi = sum_k in mathcalS_i P_mathrmgk\n    Q_mathrmpi = sum_k in mathcalS_i Q_mathrmgk\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_mathrmgk and Q_mathrmgk represent the active and reactive power outputs of the k-th generator within the set mathcalS_i.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As a way to summarize, the power injection vectors, represented as mathbf P = P_i and mathbf Q = Q_i can be computed based on the following variables and expressions:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏 = system.bus.supply.active - system.bus.demand.active\n𝐐 = system.bus.supply.reactive - system.bus.demand.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Positive active or reactive power values, P_i  0 or Q_i  0, signify that power is being supplied into the power system from the specific bus. This indicates that the generators connected to this bus are producing more power than what the connected load is consuming. Conversely, negative values, P_i  0 or Q_i  0, indicate that the bus is drawing in active or reactive power from the power system. This suggests that the load's demand is exceeding the output from the generators.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#NewtonRaphsonMethodTutorials","page":"AC Power Flow","title":"Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Newton-Raphson method is commonly used in AC power flow calculations due to its quadratic rate of convergence. It provides an accurate approximation of the roots of the system of nonlinear equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf f (mathbf x) = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This, in turn, allows for the determination of unknown voltage magnitudes and angles of buses, represented by the state vector mathbf x = mathbf x_mathrma mathbf x_mathrmm^T. The state vector comprises two components:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"mathbf x_mathrma in mathbbR^n-1, which holds the bus voltage angles of demand and generator buses, represented by mathbf x_mathrma = theta_i, where i in mathcalN_mathrmpq cup mathcalN_mathrmpv,\nmathbf x_mathrmm in mathbbR^n_mathrmpq, which holds the bus voltage magnitudes of demand buses, represented by mathbf x_mathrmm = V_i, where i in mathcalN_mathrmpq, and n_mathrmpq = mathcalN_mathrmpq.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Knowing the voltage magnitudes and angles for certain types of buses is a consequence of the structure of the state vector mathbf x. Specifically, the voltage magnitude and angle at the slack bus are known, as well as the voltage magnitude at generator buses.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As detailed in the Nodal Network Equations section of this manual, the expressions for active and reactive power injection are as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    P_i = V_i sumlimits_j=1^n (G_ijcostheta_ij + B_ijsintheta_ij) V_j\n    Q_i = V_i sumlimits_j=1^n (G_ijsintheta_ij - B_ijcostheta_ij) V_j\n\tendaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Using the above equations, we can define the active power injection function for demand and generator buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_P_i(mathbf x) = V_i sumlimits_j=1^n (G_ijcostheta_ij + B_ijsintheta_ij) V_j - P_i = 0\n   forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"and the reactive power injection function for demand buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_Q_i(mathbf x) = V_i sumlimits_j=1^n (G_ijsintheta_ij - B_ijcostheta_ij) V_j - Q_i = 0\n   forall i in mathcalN_mathrmpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The active and reactive mismatches, often denoted as Delta P_i(mathbf x) and Delta Q_i(mathbf x), respectively, are defined as the functions f_P_i(mathbf x) and f_Q_i(mathbf x). The first terms on the right-hand side represent power injections at a bus, while the second term is constant and is obtained based on the active and reactive powers of the generators that supply a bus and active and reactive powers demanded by consumers at the same bus. Therefore, the Newton-Raphson method solves the system of nonlinear equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf f (mathbf x) =\n  beginbmatrix\n    mathbff_mathrmP(mathbf x)  mathbff_mathrmQ(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where the first n - 1 equations correspond to demand and generator buses, and the last n_mathrmpq equations correspond to demand buses.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To compute the voltage magnitudes and angles of buses using the Newton-Raphson method in JuliaGrid, you must first execute the acModel! function to set up the system, followed by initializing the Newton-Raphson method using the newtonRaphson function. The following code snippet demonstrates this process:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = newtonRaphson(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This results in the creation of the initial vectors of bus voltage magnitudes mathbfV^(0) and angles bmTheta^(0), as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = analysis.voltage.magnitude\n𝚯⁽⁰⁾ = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Here, we utilize a \"flat start\" approach in our method. It is important to keep in mind that when dealing with initial conditions in this manner, the Newton-Raphson method may encounter difficulties.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To implement the Newton-Raphson method, the iterative approach based on the Taylor series expansion, JuliaGrid provides the mismatch! and solve! functions. These functions are utilized to carry out the Newton-Raphson method iteratively until a stopping criterion is reached, as demonstrated in the following code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 0:20\n    stopping = mismatch!(analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(analysis)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The mismatch! function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration nu = 0 1 2 dots. The equations used for these computations are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_P_i(mathbf x^(nu)) = V_i^(nu) sumlimits_j=1^n (G_ijcostheta_ij^(nu) + B_ijsintheta_ij^(nu)) V_j^(nu) - P_i\n   forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"as well as the reactive power injection mismatch for demand buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_Q_i(mathbf x^(nu)) = V_i^(nu) sumlimits_j=1^n (G_ijsintheta_ij^(nu) - B_ijcostheta_ij^(nu)) V_j^(nu) - Q_i\n   forall i in mathcalN_mathrmpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting vector from these calculations is stored in the mismatch variable of the AcPowerFlow type and can be accessed through the following line of code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐟 = analysis.method.mismatch","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In addition to computing the mismatches in active and reactive power injection, the mismatch! function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  max f_P_i(mathbf x^(nu)) forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv   epsilon \n  max f_Q_i(mathbf x^(nu)) forall i in mathcalN_mathrmpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the function solve! computes the increments of bus voltage angle and magnitude at each iteration using:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf Delta mathbfx^(nu) = -mathbf J (mathbfx^(nu))^-1 mathbf f (mathbfx^(nu))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where mathbf Delta mathbf x = mathbf Delta mathbf x_mathrma mathbf Delta mathbf x_mathrmm^T consists of the vector of bus voltage angle increments mathbf Delta mathbf x_mathrma in mathbbR^n-1 and bus voltage magnitude increments mathbf Delta mathbf x_mathrmm in mathbbR^n_mathrmpq, and mathbf J (mathbfx) in mathbbR^n_mathrmu times n_mathrmu is the Jacobian matrix, n_mathrmu = n + n_mathrmpq - 1.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"tip: Tip\nBy default, JuliaGrid uses LU factorization as the primary method for factorizing the Jacobian matrix mathbfJ = mathbfLmathbfU, aiming to compute the increments. Nevertheless, users have the flexibility to opt for QR factorization as an alternative method.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"These values are stored in the AcPowerFlow type and can be accessed after each iteration:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱 = analysis.method.increment\n𝐉 = analysis.method.jacobian\n𝐋 = analysis.method.factorization.L\n𝐔 = analysis.method.factorization.U","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The JuliaGrid implementation of the AC power flow follows a specific order to store the increment mathbf Delta mathbf x and mismatch mathbff(mathbf x) vectors. The first n-1 elements of both vectors correspond to the demand and generator buses in the same order as they appear in the input data. The first n-1 elements of the increment vector mathbf Delta mathbf x correspond to the voltage angle increments mathbf Delta mathbf x_mathrma, while the first n-1 elements of the mismatch vector mathbff(mathbf x) correspond to the mismatch in active power injections mathbff_mathrmP(mathbf x).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The last n_mathrmpq elements of the increment mathbf Delta  mathbf x and mismatch mathbff(mathbf x) vectors correspond to the demand buses in the order they appear in the input data. For the increment vector mathbf Delta mathbf x, it matches the bus voltage magnitude increments mathbf Delta mathbf x_mathrmm, while for the mismatch vector mathbff(mathbf x), it matches the mismatch in reactive power injections mathbff_mathrmQ(mathbf x).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"These specified orders dictate the row and column order of the Jacobian matrix mathbf J(mathbf x).","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, the function solve! adds the computed increment term to the previous solution to obtain a new solution:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfx^(nu + 1) = mathbfx^(nu) + mathbf Delta mathbfx^(nu)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The bus voltage magnitudes mathbf V = V_i and angles bm Theta = theta_i are then updated based on the obtained solution mathbf x. It is important to note that only the voltage magnitudes related to demand buses and angles related to demand and generator buses are updated; not all values are updated. Therefore, the final solution obtained by JuliaGrid is stored in the following vectors:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Jacobian-Matrix","page":"AC Power Flow","title":"Jacobian Matrix","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To complete the tutorial on the Newton-Raphson method, we will now describe the Jacobian matrix and provide the equations involved in its evolution. Without loss of generality, we assume that the slack bus is the first bus, followed by the set of demand buses and the set of generator buses:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathcalN_mathrmsb =  1  \n    mathcalN_mathrmpq = 2 dots m \n    mathcalN_mathrmpv = m + 1dots n\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where mathcal N = mathcalN_mathrmsb cup mathcalN_mathrmpq cup mathcalN_mathrmpv. Therefore, we can express:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbf x_mathrma = theta_2 dots theta_n^T  mathbf Delta mathbf x_mathrma = Delta theta_2 dots Delta theta_n^T \n    mathbf x_mathrmm = V_2 dots V_m^T  mathbf Delta mathbf x_mathrmm = Delta V_2 dots Delta V_m^T\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Jacobian matrix mathbfJ(x^(nu)) in mathbbR^n_mathrmu times n_mathrmu is:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbfJ(x^(nu))=\n  left\n  beginarraycccccc\n    cfracmathrm partialf_P_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n    cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial theta_n \n    cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_2 cdots \n    cfracmathrm partialf_P_2(mathbf x^(nu))mathrm partial V_m\n    vdots  \n    cfracmathrm partialf_P_n(mathbf x^(nu)) mathrm partial theta_2  cdots \n    cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial theta_n \n    cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_2 cdots \n    cfracmathrm partialf_P_n(mathbf x^(nu))mathrm partial V_m 10pt\n    hline \n    cfracmathrm partialf_Q_2(mathbf x^(nu)) mathrm partial theta_2  cdots \n    cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial theta_n \n    cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_2 cdots \n    cfracmathrm partialf_Q_2(mathbf x^(nu))mathrm partial V_m\n    vdots  \n    cfracmathrm partialf_Q_m(mathbf x^(nu)) mathrm partial theta_2  cdots \n    cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial theta_n \n    cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_2 cdots \n    cfracmathrm partialf_Q_m(mathbf x^(nu))mathrm partial V_m\n  endarray\n  right","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Jacobian matrix can be expressed using four block matrices:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"\tmathbfJ(x^(nu)) =\n  beginbmatrix\n    mathbfJ_11(x^(nu))  mathbfJ_12(x^(nu))  mathbfJ_21(x^(nu))  mathbfJ_22(x^(nu))\n  endbmatrix","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where diagonal elements of the Jacobian sub-matrices are defined as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracmathrm partialf_P_i(mathbf x^(nu)) mathrm partial theta_i =\n    V_i^(nu) sumlimits_j=1^n (-G_ijsintheta_ij^(nu) + B_ijcostheta_ij^(nu)) V_j^(nu) - B_ii(V_i^(nu))^2\n    cfracmathrm partialf_P_i(mathbf x^(nu))mathrm partial V_i^(nu) =\n    sumlimits_j=1^n (G_ijcostheta_ij^(nu) + B_ijsintheta_ij^(nu)) V_j^(nu) + G_iiV_i^(nu)\n    cfracmathrm partialf_Q_i(mathbf x^(nu)) mathrm partial theta_i =\n    V_i^(nu) sumlimits_j=1^n (G_ijcostheta_ij^(nu) + B_ijsintheta_ij^(nu)) V_j^(nu) - G_ii(V_i^(nu))^2\n    cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm partial V_i =\n    sumlimits_j=1^n (G_ijsintheta_ij^(nu) - B_ijcostheta_ij^(nu)) V_j^(nu) - B_iiV_i^(nu)\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"while non-diagonal elements of the Jacobian sub-matrices are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracmathrm partialf_P_i(mathbf x^(nu))mathrm partial theta_j =\n    (G_ijsintheta_ij^(nu) - B_ijcostheta_ij^(nu)) V_i^(nu)V_j^(nu)\n    cfracmathrm partialf_P_i(mathbf x^(nu))mathrm partial V_j^(nu) =\n    (G_ijcostheta_ij^(nu) + B_ijsintheta_ij^(nu)) V_i^(nu)\n    cfracmathrm partialf_Q_i(mathbf x^(nu))mathrm partial theta_j =\n    -(G_ijcostheta_ij^(nu) + B_ijsintheta_ij^(nu)) V_i^(nu)V_j^(nu)\n    cfracmathrm partialf_Q_i(mathbf x^(nu))mathrmpartial V_j =\n    (G_ijsintheta_ij^(nu) - B_ijcostheta_ij^(nu)) V_i^(nu)\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#NewtonRaphsonAlgorithmTutorials","page":"AC Power Flow","title":"The Newton-Raphson Algorithm","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In summary, the Newton-Raphson iterative algorithm for solving AC power flow follows these steps:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Step Description Expression\n1. Initialize the iteration index nu = 0\n2. Set the initial bus voltage magnitudes and angles mathbfx^(0) = mathbfV^(0) bmTheta^(0)\n3. Compute mismatches for active and reactive power injections mathbf f (mathbfx^(nu))\n4. Check for convergence f_Pmax(mathbf x^(nu))  epsilon, f_Qmax(mathbf x^(nu))  epsilon\n5. If the convergence criteria are met, stop the process \n6. Compute the voltage magnitude and angle increments mathbf Delta mathbfx^(nu)\n7. Update the voltage magnitude and angle values mathbfx^(nu + 1) = mathbfx^(nu) + mathbf Delta mathbfx^(nu)\n8. Increase the iteration index nu = nu + 1\n9. Repeat from step 3. \n  ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The main computational effort is in step 6, which involves forming and factorizing the Jacobian matrix and performing forward and backward substitutions to obtain the vector of increments.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#FastNewtonRaphsonMethodTutorials","page":"AC Power Flow","title":"Fast Newton-Raphson Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Although the fast Newton-Raphson method may converge more slowly than the traditional Newton-Raphson method, the shorter solution time for the updates often compensates for this slower convergence, resulting in a shorter overall solution time. This is particularly true for systems that are not heavily loaded, where a shorter overall solution time is almost always achieved. It is important to note that if the algorithm converges, it will converge to a correct solution [7].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method involves decoupling the power flow equations. Namely, the Newton-Raphson method is based on the equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbfJ_12(x)  mathbfJ_21(x)  mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbf Delta mathbf x_mathrma  mathbf Delta mathbf x_mathrmm\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_mathrmP(mathbf x)  mathbff_mathrmQ(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where the iteration index has been omitted for simplicity. However, in transmission grids, there exists a strong coupling between active powers and voltage angles, as well as between reactive powers and voltage magnitudes. To achieve decoupling, two conditions must be satisfied: first, the resistance values r_ij of the branches must be small compared to their reactance values x_ij, and second, the angle differences must be small, i.e., theta_ij approx 0 [11]. Therefore, starting from the above equation, we have:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginbmatrix\n    mathbfJ_11(x)  mathbf 0  mathbf 0  mathbfJ_22(x)\n  endbmatrix\n  beginbmatrix\n    mathbf Delta mathbf x_mathrma  mathbf Delta mathbf x_mathrmm\n  endbmatrix\t+\n  beginbmatrix\n    mathbff_mathrmP(mathbf x)  mathbff_mathrmQ(mathbf x)\n  endbmatrix = mathbf 0","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"which gives the decoupled system as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbff_mathrmP(mathbf x) = -mathbfJ_11(x) mathbf Delta mathbf x_mathrma \n    mathbff_mathrmQ(mathbf x) = -mathbfJ_22(x) mathbf Delta mathbf x_mathrmm\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To examine the problem, it is helpful to express it as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = -Delta theta_2 cfracmathrm partialf_P_2(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_2(mathbf x)mathrm partial theta_n \n     vdots \n    f_P_n(mathbf x) = -Delta theta_2 cfracmathrm partialf_P_n(mathbf x) mathrm partial theta_2 - cdots -\n    Delta theta_n cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_n\n    f_Q_2(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) = - Delta V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots -\n    Delta V_m cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Firstly, the second part of the expressions is expanded as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_Q_2(mathbf x) =\n    -cfracDelta V_2V_2 V_2 cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_2 - cdots - cfracDelta V_mV_m V_m\n    cfracmathrm partialf_Q_2(mathbf x)mathrm partial V_m\n     vdots \n    f_Q_m(mathbf x) =\n    - cfracDelta V_2V_2 V_2 cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_2 - cdots - cfracDelta V_mV_m V_m\n    cfracmathrm partialf_Q_m(mathbf x)mathrm partial V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the Jacobian elements are derived. To achieve this, we can use the expressions defined for the Newton-Raphson method. For demand buses, the above expansions are applied as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = V_i sumlimits_j=1^n (-G_ijsintheta_ij + B_ijcostheta_ij) V_j - B_iiV_i^2\n    cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_j = (G_ijsintheta_ij - B_ijcostheta_ij) V_iV_j\n    V_i cfracmathrm partialf_Q_i(mathbf x)mathrm partial V_i = V_i sumlimits_j=1^n (G_ijsintheta_ij - B_ijcostheta_ij) V_j - B_iiV_i^2\n    V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j = (G_ijsintheta_ij - B_ijcostheta_ij) V_i V_j\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As the definition of reactive power is given by the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  Q_i = V_i sumlimits_j=1^n (G_ijsintheta_ij - B_ijcostheta_ij) V_j","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"the Jacobian elements can be expressed in the following manner:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -Q_i - B_iiV_i^2\n    cfracmathrm partialf_P_i(mathbf x)mathrm partial theta_j = (G_ijsintheta_ij - B_ijcostheta_ij) V_i V_j\n    V_i cfracmathrm partialf_Q_i(mathbf x)mathrm partial V_i = Q_i - B_iiV_i^2\n    V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j = (G_ijsintheta_ij - B_ijcostheta_ij) V_i V_j\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The decoupled model is established through the following approximations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    sin(theta_ij) approx 0 \n    cos(theta_ij) approx 1 \n    Q_i  B_iiV_i^2\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, when the approximations are made, the Jacobian elements are simplified, resulting in the decoupled model where the Jacobian elements are:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_i = -B_iiV_i^2\n    cfracmathrm partialf_P_i(mathbf x) mathrm partial theta_j = -B_ijV_iV_j\n    V_i cfracmathrm partialf_Q_i(mathbf x) mathrm partial V_i = -B_iiV_i^2\n    V_j cfracmathrm partialf_Q_i(mathbf x)mathrmpartial V_j = -B_ijV_iV_j\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Thus, the initial system of equations becomes:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = B_22 Delta theta_2 V_2^2 + cdots + B_2n Delta theta_n V_2V_n \n     vdots \n    f_P_n(mathbf x) = B_n2 Delta theta_2 V_2V_n + cdots + B_nn Delta theta_n V_n^2 \n    f_Q_2(mathbf x) = B_22 cfracDelta V_2V_2 V_2^2 + cdots + B_2m cfracDelta V_mV_m V_2V_m \n     vdots \n    f_Q_m(mathbf x) = B_m2 cfracDelta V_2V_2 V_2V_m + cdots + B_mm cfracDelta V_mV_m V_m^2\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Using V_j approx 1, wherein V_i^2 = V_iV_j j=i, the first part of the equations can be simplified to:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_2(mathbf x) = B_22 Delta theta_2 V_2 + cdots + B_2n Delta theta_n V_2 \n     vdots \n    f_P_n(mathbf x) = B_n2 Delta theta_2 V_n + cdots + B_nn Delta theta_n V_n\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, the second part of the equations can be simplified to:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_Q_2(mathbf x) = B_22 V_2 Delta V_2 + cdots + B_2m V_2 Delta V_m \n     vdots \n    f_Q_m(mathbf x) = B_m2 V_m Delta V_2 + cdots + B_mm V_m Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The fast Newton-Raphson method is ultimately based on the system of equations presented below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    cfracf_P_2(mathbf x)V_2 = B_22 Delta theta_2 + cdots + B_2n Delta theta_n \n     vdots \n    cfracf_P_n(mathbf x)V_n = B_n2 Delta theta_2 + cdots + B_nn Delta theta_n \n    cfracf_Q_2(mathbf x)V_2 = B_22 Delta V_2 + cdots + B_2m Delta V_m \n     vdots \n    cfracf_Q_m(mathbf x)V_m = B_m2 Delta V_2 + cdots +\n    B_mm Delta V_m\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This system can be written as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    mathbfh_mathrmP(mathbf x) = mathbfB_1 mathbf Delta mathbf x_mathrma \n    mathbfh_mathrmQ(mathbf x) = mathbfB_2 mathbf Delta mathbf x_mathrmm\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"One of the main advantages of this approach is that the Jacobian matrices mathbfB_1 and mathbfB_2 are constant and need only be formed once. Furthermore, this method can be used to define both the XB and BX versions of the fast Newton-Raphson method.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#XB-Version","page":"AC Power Flow","title":"XB Version","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The matrix mathbfB_1 is formed by neglecting the resistance r_ij, shunt susceptance Im  y_mathrmshi , charging susceptance Im  y_mathrmsij , and transformer tap ratio magnitude tau_ij. The matrix mathbfB_2 is constructed by disregarding the transformer phase shift angle phi_ij. This approach corresponds to the standard fast Newton-Raphson method and is known to exhibit exceptional convergence properties in typical scenarios [11].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To initialize the XB version of the fast Newton-Raphson method, one can utilize the following code snippet:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = fastNewtonRaphsonXB(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#BX-Version","page":"AC Power Flow","title":"BX Version","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The matrix mathbfB_1 ignores the shunt susceptanceIm  y_mathrmshi , charging susceptance Im  y_mathrmsij , and transformer tap ratio magnitude tau_ij. The matrix mathbfB_2 ignores the resistance r_ij and transformer phase shift angle phi_ij. In usual cases, the iteration count for the BX version is comparable to the XB scheme. However, for systems with high r_ijx_ij ratios, the BX scheme requires considerably fewer iterations than the XB scheme to solve the power flow [11].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To initialize the BX version of the fast Newton-Raphson method, you can use the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = fastNewtonRaphsonBX(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization-2","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"When a user creates the fast Newton-Raphson method in JuliaGrid, the Jacobian matrices mathbfB_1 and mathbfB_2 are formed to correspond to the active and reactive power equations, respectively:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐁₁ = analysis.method.active.jacobian\n𝐁₂ = analysis.method.reactive.jacobian","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Additionally, during this stage, JuliaGrid generates the initial vectors for bus voltage magnitudes mathbfV^(0) and angles bmTheta^(0) as demonstrated below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = analysis.voltage.magnitude\n𝚯⁽⁰⁾ = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process-2","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the mismatch! and solve! functions to implement the fast Newton-Raphson method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 0:100\n    stopping = mismatch!(analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(analysis)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The functions mathbff_mathrmP(mathbf x) and mathbff_mathrmQ(mathbf x) remain free of approximations, with only the calculation of the state variable increments affected [7]. As a result, we still use the following equations to compute the mismatches:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    f_P_i(mathbf x) = V_i sumlimits_j=1^n (G_ijcostheta_ij + B_ijsintheta_ij)V_j - P_i = 0\n     forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv\n    f_Q_i(mathbf x) = V_i sumlimits_j=1^n (G_ijsintheta_ij - B_ijcostheta_ij)V_j - Q_i = 0\n     forall i in mathcalN_mathrmpq\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Therefore, the mismatch! function calculates the mismatch in active power injection for demand and generator buses and the mismatch in reactive power injection for demand buses at each iteration nu = 0 1 2 dots:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    h_P_i(mathbf x^(nu)) =\n    sumlimits_j=1^n (G_ijcostheta_ij^(nu) + B_ijsintheta_ij^(nu))V_j^(nu) - cfracP_iV_i^(nu)\n     forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv \n    h_Q_i(mathbf x^(nu)) =\n    sumlimits_j=1^n (G_ijsintheta_ij^(nu) - B_ijcostheta_ij^(nu))V_j^(nu) - cfracQ_iV_i^(nu)\n     forall i in mathcalN_mathrmpq\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting vectors from these calculations are stored in the AcPowerFlow type and can be accessed by:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐡ₚ = analysis.method.active.increment\n𝐡ₒ = analysis.method.reactive.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In addition to computing the mismatches in active and reactive power injection, the mismatch! function also returns the maximum absolute values of these mismatches. These maximum values are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  max h_P_i(mathbf x^(nu)) forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv   epsilon \n  max h_Q_i(mathbf x^(nu)) forall i in mathcalN_mathrmpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Next, the function solve! computes the bus voltage angle increments:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf Delta mathbf x_mathrma^(nu) = mathbfB_1^-1 mathbfh_mathrmP(mathbf x^(nu))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the voltage angle increments, JuliaGrid initially performs LU factorization on the Jacobian matrix mathbfB_1 = mathbfL_1mathbfU_1. This factorization is executed only once and is utilized in each iteration of the algorithm:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐋₁ = analysis.method.active.factorization.L\n𝐔₁ = analysis.method.active.factorization.U","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"tip: Tip\nBy default, JuliaGrid uses LU factorization as the primary method for factorizing Jacobian matrix. Nevertheless, users have the flexibility to opt for QR factorization as an alternative method.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vector of increments that corresponds to the active power equations can be accessed using:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱ₐ = analysis.method.active.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The solution is then updated as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x_mathrma^(nu + 1) = mathbf x_mathrma^(nu) + mathbf Delta mathbf x_mathrma^(nu)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"It is important to note that only the voltage angles related to demand and generator buses are updated, while the vector of bus voltage angles of all buses is stored:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After calculating the update for voltage angles, to calculate the magnitude updates the fast Newton-Raphson method then solves the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf Delta mathbf x_mathrmm^(nu) = mathbfB_2^-1 mathbfh_mathrmQ(mathbf x^(nu))","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly to the previous instance, JuliaGrid initially executes LU factorization on the Jacobian matrix mathbfB_2 = mathbfL_2mathbfU_2. However, it provides the flexibility for users to opt for QR factorization instead. This factorization occurs only once and is utilized in each iteration of the fast Newton-Raphson algorithm:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐋₂ = analysis.method.reactive.factorization.L\n𝐔₂ = analysis.method.reactive.factorization.U","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vector of increments that corresponds to the reactive power equations can be accessed using:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝚫𝐱ₘ = analysis.method.active.increment","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Finally, the solution is updated as follows:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  mathbf x_mathrmm^(nu + 1) = mathbf x_mathrmm^(nu) + mathbf Delta mathbf x_mathrmm^(nu)","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Again, it is important to note that only the voltage magnitudes of demand buses are updated, while the vector of bus voltage magnitude for all buses is stored:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = analysis.voltage.magnitude","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#The-Fast-Newton-Raphson-Algorithm","page":"AC Power Flow","title":"The Fast Newton-Raphson Algorithm","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In summary, the fast Newton-Raphson iterative algorithm for solving AC power flow follows these steps:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Step Description Expression\n1. Initialize the iteration index nu = 0\n2. Set the initial bus voltage magnitudes and angles mathbfx^(0) = mathbfV^(0) bmTheta^(0)\n3. Compute mismatches for active and reactive power injections mathbfh_mathrmP(mathbf x^(nu)), mathbfh_mathrmQ(mathbf x^(nu))\n4. Check for convergence h_Pmax(mathbf x^(nu))  epsilon, h_Qmax(mathbf x^(nu))  epsilon\n5. If the convergence criteria are met, stop the process \n6. Compute the voltage angle increments mathbf Delta mathbf x_mathrma^(nu)\n7. Update the voltage angle values mathbf x_mathrma^(nu + 1) = mathbf x_mathrma^(nu) + mathbf Delta mathbf x_mathrma^(nu)\n8. Compute the voltage magnitude increments mathbf Delta mathbf x_mathrmm^(nu)\n9. Update the voltage magnitude values mathbf x_mathrmm^(nu + 1) = mathbf x_mathrmm^(nu) + mathbf Delta mathbf x_mathrmm^(nu)\n10. Increase the iteration index nu = nu + 1\n11. Repeat from step 3. \n  ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The main computational effort is in steps 6 and 8, where forward and backward substitutions are performed to obtain the vectors of increments using the Jacobian matrices, which are formed and factorized before the iterative algorithm is executed.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#GaussSeidelMethodTutorials","page":"AC Power Flow","title":"Gauss-Seidel Method","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"As elaborated in the Nodal Network Equations section of this manual, each bus is associated with the balance equation expressed as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  sum_j = 1^n Y_ij barV_j = cfracP_i - mathrmj Q_ibarV_i  forall i in mathcal N","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In its expanded form, this can be written as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    Y_11  barV_1 + cdots + Y_1nbarV_n = fracP_1 - mathrmj Q_1barV_1^* \n     vdots  \n    Y_n1  barV_1 + cdots + Y_nnbarV_n = fracP_n - mathrmj Q_nbarV_n^*\n\tendaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"While the Gauss-Seidel method directly solves the system of equations, it suffers from very slow convergence, which increases almost linearly with the system size, necessitating numerous iterations to obtain the desired solution [12]. Moreover, the convergence time of the Gauss-Seidel method increases significantly for large-scale systems and can face convergence issues for systems with high active power transfers. Nevertheless, power flow programs utilize both the Gauss-Seidel and Newton-Raphson methods in a complementary manner. Specifically, the Gauss-Seidel method is employed to obtain a quick approximate solution from a \"flat start\", while the Newton-Raphson method is utilized to obtain the final accurate solution [9].","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The Gauss-Seidel method is usually applied to a system of n complex equations, where one represents the slack bus. Consequently, one equation can be eliminated, resulting in a power flow problem with n-1 equations.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Initialization-3","page":"AC Power Flow","title":"Initialization","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid provides a way to utilize the Gauss-Seidel method for solving the AC power flow problem and determining the magnitudes and angles of bus voltages. To use this method, we need to execute the acModel! function first to set up the system and then initialize the Gauss-Seidel method using the gaussSeidel function. The code snippet below demonstrates this process:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"acModel!(system)\nanalysis = gaussSeidel(system)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"This results in the creation of the initial vectors of bus voltage magnitudes mathbfV^(0) and angles bmTheta^(0), as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕⁽⁰⁾ = analysis.voltage.magnitude\n𝚯⁽⁰⁾ = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Iterative-Process-3","page":"AC Power Flow","title":"Iterative Process","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the mismatch! and solve! functions to implement the Gauss-Seidel method iterations. These functions are used iteratively until a stopping criterion is met, as shown in the code snippet below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"for iteration = 0:300\n    stopping = mismatch!(analysis)\n    if all(stopping .< 1e-8)\n        break\n    end\n    solve!(analysis)\nend","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In contrast to the Newton-Raphson and fast Newton-Raphson methods, the Gauss-Seidel method does not require the calculation of the mismatch in active and reactive power injection at each iteration. Instead, the mismatch! function is used solely to verify the convergence criteria. At each iteration nu = 0 1 2 dots, we calculate the active power injection mismatch for demand and generator buses, as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_P_i(mathbf x^(nu)) = RebarV_i^(nu) barI_i^*(nu) - P_i  forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"We also compute the reactive power injection mismatch for demand buses, given by:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  f_Q_i(mathbf x^(nu)) = ImbarV_i^(nu) barI_i^*(nu) - Q_i  forall i in mathcalN_mathrmpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"However, these mismatches are not stored, as they are only used to obtain the maximum absolute values of these mismatches. The maximum values of these mismatches are used as termination criteria for the iteration loop if both are less than a predefined stopping criterion epsilon, as shown below:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  max f_P_i(mathbf x^(nu)) forall i in mathcalN_mathrmpq cup mathcalN_mathrmpv   epsilon \n  max f_Q_i(mathbf x^(nu)) forall i in mathcalN_mathrmpq   epsilon","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"After initializing complex bus voltages barV_i^(0) for all buses in the power system, the function solve! proceeds to compute the voltages for demand buses using the Gauss-Seidel method:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barV_i^(nu + 1) =\n  cfrac1Y_ii left(cfracP_i - mathrmj Q_ibarV_i^*(nu) -\n  sumlimits_substackj = 1^i - 1 Y_ijbarV_j^(nu + 1) -\n  sumlimits_substackj = i + 1^n Y_ijbarV_j^(nu)right)\n   forall i in mathcalN_mathrmpq","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The next step is to determine the solution for generator buses in two stages: first, the reactive power injection is calculated, and then the bus complex voltage is updated using the following equations:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  beginaligned\n    Q_i^(nu + 1) =\n    -Im left barV_i^*(nu + 1) sumlimits_j=1^n Y_ijbarV_j^(nu + 1)right  forall i in mathcalN_mathrmpv \n    barV_i^(nu + 1) =\n    cfrac1Y_ii Bigg(cfracP_i - mathrmj Q_i^(nu + 1)barV_i^*(nu + 1)-\n    sumlimits_substackj = 1j neq i^n Y_ijbarV_j^(nu + 1) Bigg)  forall i in mathcalN_mathrmpv\n  endaligned","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The obtained voltage magnitude may not be equal to the magnitude specified for the generator bus, so a voltage correction step is necessary:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  barV_i^(nu + 1) = V_i^(0) cfracbarV_i^(nu + 1)V_i^(nu + 1)  forall i in mathcalN_mathrmpv","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid stores the final results in vectors that contain all bus voltage magnitudes and angles:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐕 = analysis.voltage.magnitude\n𝚯 = analysis.voltage.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#The-Gauss-Seidel-Algorithm","page":"AC Power Flow","title":"The Gauss-Seidel Algorithm","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In summary, the Gauss-Seidel iterative algorithm for solving AC power flow follows these steps:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Step Description Expression\n1. Initialize the iteration index nu = 0\n2. Set the initial bus voltage magnitudes and angles mathbfx^(0) = mathbfV^(0) bmTheta^(0)\n3. Compute mismatches for active and reactive power injections f_P_i(mathbf x^(nu)), f_Q_i(mathbf x^(nu))\n4. Check for convergence h_Pmax(mathbf x^(nu))  epsilon, h_Qmax(mathbf x^(nu))  epsilon\n5. If the convergence criteria are met, stop the process \n6. Compute voltages for demand buses barV_i^(nu + 1), forall i in mathcalN_mathrmpv\n7. Compute the reactive power injections for generator buses Q_i^(nu + 1), forall i in mathcalN_mathrmpq\n8. Update and apply correction the bus voltages for generator buses barV_i^(nu + 1), forall i in mathcalN_mathrmpq\n9. Increase the iteration index nu = nu + 1\n10. Repeat from step 3. \n  ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The computational effort per iteration is negligible, while the main bottleneck is the large number of iterations required for convergence.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#ACPowerAnalysisTutorials","page":"AC Power Flow","title":"Power Analysis","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Once the computation of voltage magnitudes and angles at each bus is completed, various electrical quantities can be determined. JuliaGrid offers the power! function, which enables the calculation of powers associated with buses, branches, and generators. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"power!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The function stores the computed powers in the rectangular coordinate system. It calculates the following powers related to buses, branches, and generators:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Type Power Active Reactive\nBus Injections mathbf P = P_i mathbf Q = Q_i\nBus Generator injections mathbf P_mathrmp = P_mathrmpi mathbf Q_mathrmp = Q_mathrmpi\nBus Shunt elements mathbf P_mathrmsh = P_mathrmshi mathbf Q_mathrmsh = Q_mathrmshi\nBranch From-bus end flows mathbf P_mathrmi = P_ij mathbf Q_mathrmi = Q_ij\nBranch To-bus end flows mathbf P_mathrmj = P_ji mathbf Q_mathrmj = Q_ji\nBranch Shunt elements mathbf P_mathrms = P_mathrmsij mathbf Q_mathrms = Q_mathrmsij\nBranch Series elements mathbf P_mathrml = P_mathrmlij mathbf Q_mathrml = Q_mathrmlij\nGenerator Outputs mathbf P_mathrmg = P_mathrmgi mathbf Q_mathrmg = Q_mathrmgi\n   ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Injections","page":"AC Power Flow","title":"Power Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active and reactive power injections are stored as the vectors mathbfP = P_i and mathbfQ = Q_i, respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏 = analysis.power.injection.active\n𝐐 = analysis.power.injection.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#GeneratorPowerInjectionsManual","page":"AC Power Flow","title":"Generator Power Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The power! function in JuliaGrid also computes the active and reactive power injections from the generators at each bus. The active power supplied by the generators to the buses can be calculated by summing the given generator active powers in the input data, except for the slack bus, which can be determined as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  P_mathrmpi = P_i + P_mathrmdi  i in mathcalN_mathrmsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where P_mathrmdi represents the active power demanded by consumers at the slack bus. The active power injections from the generators at each bus are stored as the vector, denoted by mathbfP_mathrmp = P_mathrmpi, can be obtained using:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₚ = analysis.power.supply.active","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The calculation of reactive power injection from the generators at generator or slack buses can be achieved using the subsequent equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  Q_mathrmpi = Q_i + Q_mathrmdi  forall i in mathcalN_mathrmpv cup mathcalN_mathrmsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"where Q_mathrmdi represents the reactive power demanded by consumers at the corresponding bus. Further, the reactive power injected by the generators at buses from mathcalN_mathrmpq can be calculated by summing the given generator reactive powers in the input data. The vector of these reactive power injections by the generators to the buses, denoted by mathbfQ_mathrmp = Q_mathrmpi, can be retrieved using the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐐ₚ = analysis.power.supply.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-at-Bus-Shunt-Elements","page":"AC Power Flow","title":"Power at Bus Shunt Elements","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active and reactive powers associated with the shunt elements at each bus are represented by the vectors mathbfP_mathrmsh = P_mathrmshi and mathbfQ_mathrmsh = Q_mathrmshi. To retrieve these powers in JuliaGrid, use the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₛₕ = analysis.power.shunt.active\n𝐐ₛₕ = analysis.power.shunt.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-Flows","page":"AC Power Flow","title":"Power Flows","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The resulting active and reactive power flows at each from-bus end are stored as the vectors mathbfP_mathrmi = P_ij and mathbfQ_mathrmi = Q_ij respectively, and can be retrieved using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ᵢ = analysis.power.from.active\n𝐐ᵢ = analysis.power.from.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The vectors of active and reactive power flows at the to-bus end are stored as mathbfP_mathrmj = P_ji and mathbfQ_mathrmj = Q_ji, respectively, and can be retrieved using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ⱼ = analysis.power.to.active\n𝐐ⱼ = analysis.power.to.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-at-Branch-Shunt-Elements","page":"AC Power Flow","title":"Power at Branch Shunt Elements","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active and reactive powers associated with the branch shunt elements at each branch are represented by the vectors mathbfP_mathrms = P_mathrmsij and mathbfQ_mathrms = Q_mathrmsij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₛ = analysis.power.charging.active\n𝐐ₛ = analysis.power.charging.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Power-at-Branch-Series-Elements","page":"AC Power Flow","title":"Power at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Active and reactive powers associated with the branch series element at each branch are represented by the vectors mathbfP_mathrml = P_mathrmlij and mathbfQ_mathrml = Q_mathrmlij. We can retrieve these values using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₗ = analysis.power.series.active\n𝐐ₗ = analysis.power.series.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#GeneratorPowerOutputsManual","page":"AC Power Flow","title":"Generator Power Outputs","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the output active powers of each generator connected to bus i in mathcalN_mathrmpq cup mathcalN_mathrmpv, the given active power in the input data is utilized. For the generator connected to the slack bus, the output active power is determined using the equation:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  P_mathrmgi = P_i + P_mathrmdi i in mathcalN_mathrmsb","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In the case of multiple generators connected to the slack bus, the first generator in the input data is assigned the obtained value of P_mathrmgi. Then, this amount of power is reduced by the output active power of the other generators.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To retrieve the vector of active power outputs of generators, denoted as mathbfP_mathrmg = P_mathrmgi, i in mathcal S, where the set mathcal S represents the set of generators, users can utilize the following command:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐏ₒ = analysis.power.generator.active","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The output reactive powers of each generator located at the bus is obtained as:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"  Q_mathrmgi = Q_i + Q_mathrmdi i in mathcal N","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"If there are multiple generators at the same bus, the reactive power is allocated proportionally among the generators based on their reactive power capabilities.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To retrieve the vector of reactive power outputs of generators, denoted as mathbfQ_mathrmg = Q_mathrmgi, i in mathcal S, users can utilize:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐐ₒ = analysis.power.generator.reactive","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#ACCurrentAnalysisTutorials","page":"AC Power Flow","title":"Current Analysis","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"JuliaGrid offers the current! function, which enables the calculation of currents associated with buses and branches. Here is an example code snippet demonstrating its usage:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"current!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"The function stores the computed currents in the polar coordinate system. It calculates the following currents related to buses and branches:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Type Current Magnitude Angle\nBus Injections mathbf I = I_i bm psi = psi_i\nBranch From-bus end flows mathbf I_mathrmi = I_ij bm psi_mathrmi = psi_ij\nBranch To-bus end flows mathbf I_mathrmj = I_ji bm psi_mathrmj = psi_ji\nBranch Series elements mathbf I_mathrml = I_mathrmlij bm psi_mathrml = psi_mathrmlij\n   ","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"note: Info\nFor a clear comprehension of the equations, symbols presented in this section, as well as for a better grasp of power directions, please refer to the Unified Branch Model.","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Injections","page":"AC Power Flow","title":"Current Injections","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"In JuliaGrid, complex current injections are stored in the vector of magnitudes denoted as mathbfI = I_i and the vector of angles represented as bmpsi = psi_i. You can retrieve them using the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈 = analysis.current.injection.magnitude\n𝛙 = analysis.current.injection.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-Flows","page":"AC Power Flow","title":"Current Flows","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the vectors of magnitudes mathbfI_mathrmi = I_ij and angles bmpsi_mathrmi = psi_ij for the resulting complex current flows, you can use the following commands:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ᵢ = analysis.current.from.magnitude\n𝛙ᵢ = analysis.current.from.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"Similarly, we can obtain the vectors of magnitudes mathbfI_mathrmj = I_ji and angles bmpsi_mathrmj = psi_ji of the resulting complex current flows using the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ⱼ = analysis.current.to.magnitude\n𝛙ⱼ = analysis.current.to.angle","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"","category":"page"},{"location":"tutorials/acPowerFlow/#Current-at-Branch-Series-Elements","page":"AC Power Flow","title":"Current at Branch Series Elements","text":"","category":"section"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"To obtain the vectors of magnitudes mathbfI_mathrml = I_mathrmlij and angles bmpsi_mathrml = psi_mathrmlij of the resulting complex current flows, one can use the following code:","category":"page"},{"location":"tutorials/acPowerFlow/","page":"AC Power Flow","title":"AC Power Flow","text":"𝐈ₗ = analysis.current.series.magnitude\n𝛙ₗ = analysis.current.series.angle","category":"page"},{"location":"tutorials/badDataAnalysis/#BadDataTutorials","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"section"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"One of the essential state estimation routines is the bad data analysis, which follows after obtaining the weighted least-squares (WLS) estimator. Its main task is to detect and identify measurement errors, and eliminate them if possible. This is usually done by processing the measurement residuals [6, Ch. 5], and typically, the largest normalized residual test is used to identify bad data. The largest normalized residual test is performed after we obtained the solution of the state estimation in the repetitive process of identifying and eliminating bad data measurements one after another [25].","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Additionally, the Chi-squared test, which can precede the largest normalized residual test, serves to detect the presence of bad data and quickly determine if the largest normalized residual test should be performed [6, Sec. 5.4].","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"To initiate the process, let us construct the PowerSystem type and formulate the AC model:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\naddBus!(system; label = 1, type = 3, active = 0.5)\naddBus!(system; label = 2, reactive = 0.3)\naddBus!(system; label = 3, active = 0.5)\n\n@branch(resistance = 0.02, susceptance = 0.04)\naddBranch!(system; label = 1, from = 1, to = 2, reactance = 0.6)\naddBranch!(system; label = 2, from = 1, to = 3, reactance = 0.7)\naddBranch!(system; label = 3, from = 2, to = 3, reactance = 0.2)\n\nacModel!(system)\nnothing # hide","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Following that, we introduce the Measurement type, which represents a set of measurement devices mathcal M:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"monitoring = measurement(system)\n\naddWattmeter!(monitoring; label = \"Watmeter 1\", bus = 3, active = -0.5)\naddWattmeter!(monitoring; label = \"Watmeter 2\", from = 1, active = 0.2)\naddWattmeter!(monitoring; label = \"Watmeter 3\", bus = 3, active = 3.1)\n\naddVarmeter!(monitoring; label = \"Varmeter 1\", bus = 2, reactive = -0.3)\naddVarmeter!(monitoring; label = \"Varmeter 3\", from = 1, reactive = 0.2)\n\naddPmu!(monitoring; label = \"PMU 1\", bus = 1, magnitude = 1.0, angle = 0.0)\naddPmu!(monitoring; label = \"PMU 2\", bus = 3, magnitude = 0.9, angle = -0.2)\nnothing # hide","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Let the WLS estimator hat mathbf x be obtained by solving the AC state estimation:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"analysis = gaussNewton(monitoring)\nstateEstimation!(analysis)","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"tutorials/badDataAnalysis/#ChiTestTutorials","page":"Bad Data Analysis","title":"Chi-Squared Test","text":"","category":"section"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Next, we perform the chi-squared test to check for the presence of outliers:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"chi = chiTest(analysis; confidence = 0.96)\nnothing # hide","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"At this stage, JuliaGrid uses the objective value obtained from the AC state estimation:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"\tf(hatmathbf x) = sum_i=1^kcfracz_i - h_i(hatmathbf x)^2v_i","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"This value is stored in the ChiTest type as:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"chi.objective","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Next, retrieve the value from the Chi-squared distribution corresponding to the detection confidence and (k - s) degrees of freedom, where k is the number of measurement functions and s is the number of state variables. This provides the value of chi^2_p(k - s):","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"chi.treshold","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Then, the bad data test can be defined as:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"\tf(hatmathbf x) geq chi^2_p(k - s)","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"If the inequality is satisfied, bad data is suspected in the measurement set:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"chi.detect","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"tutorials/badDataAnalysis/#ResidualTestTutorials","page":"Bad Data Analysis","title":"Largest Normalized Residual Test","text":"","category":"section"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"As observed from the Chi-squared test, bad data is present in the measurement set. We then perform the largest normalized residual test to identify the outlier and remove it from the measurements:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier = residualTest!(analysis; threshold = 4.0)\n\nnothing # hide","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"In this step, we employ the largest normalized residual test, guided by the analysis outlined in [6, Sec. 5.7]. To be more precise, we compute all measurement residuals based on the obtained estimate of state variables:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"    r_i = z_i - h_i(hat mathbf x)  i in mathcal M","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"The normalized residuals for all measurements are computed as follows:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"    barr_i  = cfracr_isqrtS_iiSigma_ii = cfracr_isqrtC_ii  i in mathcal M","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"In this equation, we denote the diagonal entries of the residual covariance matrix mathbf C in mathbbR^k times k as C_ii = S_iiSigma_ii, where S_ii is the diagonal entry of the residual sensitivity matrix mathbf S representing the sensitivity of the measurement residuals to the measurement errors.","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"The subsequent step involves selecting the largest normalized residual, and the j-th measurement is then suspected as bad data and potentially removed from the measurement set mathcalM:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"    barr_j = textmax barr_i forall i in mathcalM ","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Users can access this information using the variable:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.maxNormalizedResidual","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"If the largest normalized residual, denoted as barr_j, satisfies the inequality:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"    barr_j ge epsilon","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"the corresponding measurement is identified as bad data and subsequently removed. In this example, the bad data identification threshold is set to epsilon = 4. Users can verify the satisfaction of this inequality by inspecting:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.detect","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"This indicates that the measurement labeled as:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.label","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"is removed from the measurement set and marked as out-of-service.","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Subsequently, we can solve the system again, but this time without the removed measurement:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"analysis = gaussNewton(monitoring)\nstateEstimation!(analysis)\nnothing # hide","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"Following that, we check for outliers once more:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier = residualTest!(analysis; threshold = 4.0)\nnothing # hide","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"To examine the value:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.maxNormalizedResidual","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"As this value is now less than the threshold epsilon = 4, the measurement is not removed, or there are no outliers. This can also be verified by observing the bad data flag:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"outlier.detect","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"","category":"page"},{"location":"tutorials/badDataAnalysis/#Residual-Covariance-Matrix","page":"Bad Data Analysis","title":"Residual Covariance Matrix","text":"","category":"section"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"In AC state estimation, the residual covariance matrix mathbf C is given by:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"    mathbf C = mathbf S bm Sigma = bm Sigma - mathbf J (hat mathbf x) mathbf J (hat mathbf x)^T bm Sigma^-1 mathbf J (hat mathbf x)^-1 mathbf J (hat mathbf x)^T","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"while for DC state estimation and state estimation using only PMUs, it is computed as:","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"    mathbf C = mathbf S bm Sigma = bm Sigma - mathbf H mathbf H^T bm Sigma^-1 mathbf H^-1 mathbf H^T","category":"page"},{"location":"tutorials/badDataAnalysis/","page":"Bad Data Analysis","title":"Bad Data Analysis","text":"It is important to note that only the diagonal entries of mathbf C are required. The main computational challenge lies in computing the inverse on the right-hand side of the equations. The JuliaGrid package employs a computationally efficient sparse inverse method, obtaining only the necessary elements.","category":"page"},{"location":"tutorials/measurementModel/#MeasurementModelTutorials","page":"Measurement Model","title":"Measurement Model","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Let us begin by examining a power system. To do that, we will construct one as shown below:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"using JuliaGrid # hide\n@default(unit) # hide\n@default(template) # hide\n\nsystem, monitoring = ems()\n\naddBus!(system; label = 1)\naddBus!(system; label = 2)\naddBus!(system; label = 3)\n\n@branch(reactance = 0.03)\naddBranch!(system; label = 1, from = 1, to = 2)\naddBranch!(system; label = 2, from = 1, to = 3)\naddBranch!(system; label = 3, from = 2, to = 3)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"To review, we can conceptualize the bus/branch model as the graph denoted by mathcalG = (mathcalN mathcalE), where we have the set of buses mathcalN = 1 dots n, and the set of branches mathcalE subseteq mathcalN times mathcalN within the power system:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝒩 = collect(keys(system.bus.label))\nℰ = [𝒩[system.branch.layout.from] 𝒩[system.branch.layout.to]]","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Our goal is to monitor the power system, and this process involves collecting measurement data for various electrical quantities distributed throughout the power system.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Power-System-Monitoring","page":"Measurement Model","title":"Power System Monitoring","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Measurement data is obtained through two main technologies: SCADA (Supervisory Control and Data Acquisition) and WAMS (Wide Area Measurement System). These technologies enable the collection of a wide range of measurements distributed throughout the power system. This extensive dataset allows us to employ state estimation algorithms to obtain the present state of the power system, in contrast to power flow algorithms, which are typically used for offline analyses. To commence, we will represent the entire set of measurement devices as mathcal M.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"SCADA provides legacy measurements with low sampling rates, making them unsuitable for capturing real-time system dynamics. It provides a snapshot of the power system's state, with delays measured in seconds and minutes. These legacy measurement devices, subsets of the set mathcal M, include:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"a set of voltmeters mathcal V for measuring bus voltage magnitudes,\na set of ammeters mathcal I for measuring branch current magnitudes,\na set of wattmeters mathcal P for active power injection and flow measurements,\na set of varmeters mathcal Q for reactive power injection and flow measurements.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"In contrast, WAMS technology utilizes PMUs (Phasor Measurement Units) to provide data with high sampling rates, typically ranging between 10 and 20 ms, facilitating real-time monitoring of the system. Therefore, PMUs expand the set mathcal M as follows:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"a set of PMUs barmathcal P for bus voltage and branch current phasor measurements.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"ukw: Notation\nIn this section, when referring to a vector mathbf a, we use the notation mathbf a = a_i, where a_i represents the element associated measurement i in mathcal M.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Measurement-Model","page":"Measurement Model","title":"Measurement Model","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The measurement model, as defined by the set mathcal M, can be expressed as a system of equations [13]:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"    mathbf z=mathbf h(mathbf x) + mathbf u","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"where mathbf x = x_1 dots x_s^T is the vector of state variables, mathbf h(mathbf x)= h_1(mathbf x), dots, h_k(mathbf x)^T is the vector of measurement functions, mathbf z = z_1 dots z_k^T is the vector of measurement values, and mathbf u = u_1 dots u_k^T is the vector of measurement errors. In the context of transmission grids, this model is often an overdetermined system of equations (k  s) [14, Sec. 2.1].","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"These errors are assumed to follow a Gaussian distribution with a zero-mean and covariance matrix bm Sigma. The diagonal elements of bm Sigma correspond to the measurement variances mathbf v = v_1 dots v_k^T, while the off-diagonal elements represent the covariances between the measurement errors mathbf w = w_1 dots w_k^T. These covariances exist only if PMUs are observed in rectangular coordinates and correlation is required.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Gaussian-Probability-Density-Function","page":"Measurement Model","title":"Gaussian Probability Density Function","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Each legacy measurement and each magnitude or angle measurement from PMUs is associated with a measured value z_i, a measurement error u_i, and a measurement function h_i(mathbf x). Assuming that measurement errors u_i follow a zero mean Gaussian distribution, the probability density function associated with the i-th measurement is proportional to:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"  mathcalN(z_imathbf xv_i) propto expleft-cfracz_i - h_i(mathbf x)^22 v_iright","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"where v_i is the measurement variance defined by the measurement error u_i, and the measurement function h_i(mathbf x) connects the vector of state variables mathbf x to the value of the i-th measurement.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Artificial-Generation-of-Measurement-Values","page":"Measurement Model","title":"Artificial Generation of Measurement Values","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"When defining the system of equations, it is essential to have measurement values represented by mathbf z. In JuliaGrid, users have the option to either directly specify measurement values or artificially generate the vector mathbf z. The artificial generation process involves setting the keyword noise = true, which introduces white Gaussian noise with variances v_1 dots v_k added to the provided values e_1 dots e_k, typically representing the exact values of the respective electrical quantities:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"  epsilon_i sim mathcalN(0  v_i) 5pt\n  z_i = e_i + epsilon_i","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Voltmeters","page":"Measurement Model","title":"Voltmeters","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"A voltmeter V_i in mathcal V measures the bus voltage magnitude at bus i in mathcal N. Let us introduce two voltmeters that measure voltage magnitudes at the first and third bus. For the first voltmeter, we directly pass the measurement value, while for the second voltmeter, we generate the measurement value artificially:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addVoltmeter!(monitoring; label = \"V₁\", bus = 1, magnitude = 1.1, variance = 1e-3)\naddVoltmeter!(monitoring; label = \"V₃\", bus = 3, magnitude = 1.0, noise = true)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Consequently, we establish the set of voltmeters mathcal V subset mathcal M:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝒱 = collect(keys(monitoring.voltmeter.label))","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"This set of voltmeters defines vectors of measurement values denoted as mathbf z_mathcalV = z_i and variances denoted as mathbf v_mathcalV = v_i, where i in mathcal V, and can be accessed through the following variables:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝐳ᵥ = monitoring.voltmeter.magnitude.mean\n𝐯ᵥ = monitoring.voltmeter.magnitude.variance","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Ammeters","page":"Measurement Model","title":"Ammeters","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"An ammeter I_ij in mathcal I measures the magnitude of branch current at the from-bus end of the branch (ij) in mathcal E. Let us add this type of ammeter at the first branch between buses 1 and 2:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addAmmeter!(monitoring; label = \"I₁₂\", from = 1, magnitude = 0.3, variance = 1e-3)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Additionally, an ammeter can measure the branch current magnitude at the to-bus end of the branch (ij) in mathcal E, denoted as I_ji in mathcal I. For example, we can include this type of ammeter at the same branch:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addAmmeter!(monitoring; label = \"I₂₁\", to = 1, magnitude = 0.2, variance = 1e-3)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Consequently, we establish the set of ammeters mathcal I subset mathcal M:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"ℐ = collect(keys(monitoring.ammeter.label))","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"This set of ammeters defines vectors of measurement values denoted as mathbf z_mathcalI = z_i and variances denoted as mathbf v_mathcalI = v_i, where i in mathcal I, and can be accessed through the following variables:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝐳ₒ = monitoring.ammeter.magnitude.mean\n𝐯ₒ = monitoring.ammeter.magnitude.variance","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Wattmeters","page":"Measurement Model","title":"Wattmeters","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"A wattmeter P_i in mathcal P measures the active power injection at bus i in mathcal N. Hence, let us add it to the second bus:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addWattmeter!(monitoring; label = \"P₂\", bus = 2, active = 0.1, variance = 1e-4)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Next, a wattmeter denoted as P_ij in mathcal P measures the active power flow at the from-bus end of the branch (ij) in mathcal E. Let us add this type of wattmeter at the second branch:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addWattmeter!(monitoring; label = \"P₁₃\", from = 2, active = 0.2, variance = 1e-3)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Moreover, a wattmeter can also measure the active power flow at the to-bus end of the branch (ij) in mathcal E, denoted as P_ji in mathcal P. For example, we can include this type of wattmeter at the same branch:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addWattmeter!(monitoring; label = \"P₃₁\", to = 2, active = 0.3, variance = 1e-3)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Consequently, we establish the set of wattmeters mathcal P subset mathcal M:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝒫 = collect(keys(monitoring.wattmeter.label))","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"This set of wattmeters defines vectors of measurement values denoted as mathbf z_mathcalP = z_i and variances denoted as mathbf v_mathcalP = v_i, where i in mathcal P, and can be accessed through the following variables:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝐳ₚ = monitoring.wattmeter.active.mean\n𝐯ₚ = monitoring.wattmeter.active.variance","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#Varmeters","page":"Measurement Model","title":"Varmeters","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"A varmeter Q_i in mathcal Q measures the reactive power injection at bus i in mathcal N. Hence, let us add it to the first bus:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addVarmeter!(monitoring; label = \"Q₁\", bus = 1, reactive = 0.01, variance = 1e-2)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Next, a varmeter denoted as Q_ij in mathcal Q measures the reactive power flow at the from-bus end of the branch (ij) in mathcal E. Let us add this type of varmeter at the first branch:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addVarmeter!(monitoring; label = \"Q₁₂\", from = 1, reactive = 0.02, variance = 1e-3)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Moreover, a varmeter can also measure the reactive power flow at the to-bus end of the branch (ij) in mathcal E, denoted as Q_ji in mathcal Q. For example, we can include this type of varmeter at the same branch:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addVarmeter!(monitoring; label = \"Q₂₁\", to = 1, reactive = 0.03, noise = true)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Consequently, we establish the set of varmeters mathcal Q subset mathcal M:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝒬 = collect(keys(monitoring.varmeter.label))","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"This set of varmeters defines vectors of measurement values denoted as mathbf z_mathcalQ = z_i and variances denoted as mathbf v_mathcalQ = v_i, where i in mathcal Q, and can be accessed through the following variables:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝐳ₒ = monitoring.varmeter.reactive.mean\n𝐯ₒ = monitoring.varmeter.reactive.variance","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#PMUs","page":"Measurement Model","title":"PMUs","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"PMUs measure voltage and current phasors in the polar coordinate system, thus each PMU output is represented by magnitude and angle along with corresponding variances [15, Sec. 5.6]. When installed on buses, they measure bus voltage phasors, while on branches, they measure current phasors.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"A PMU (V_i theta_i) in barmathcal P measures the voltage phasor at bus i in mathcal N. Let us integrate this type of PMU at the first bus:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addPmu!(monitoring; label = \"V₁, θ₁\", bus = 1, magnitude = 1, angle = 0, noise = true)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Next, a PMU (I_ij psi_ij) in barmathcal P measures the branch current phasor at the from-bus end of the branch (ij) in mathcal E. Let us add this type of PMU at the first branch:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addPmu!(monitoring; label = \"I₁₂, ψ₁₂\", from = 1, magnitude = 0.2, angle = -0.1)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Moreover, a PMU can measure the branch current phasor at the to-bus end of the branch (ij) in mathcal E, denoted as (I_ji psi_ji) in barmathcal P. For example, let us include this type of PMU at the same branch:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"addPmu!(monitoring; label = \"I₂₁, ψ₂₁\", to = 1, magnitude = 0.3, angle = -0.2)\nnothing  # hide","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"Consequently, we establish the set of PMUs barmathcal P subset mathcal M:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"𝒫̄ = collect(keys(monitoring.pmu.label))","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"This set of PMUs establishes vectors representing measurement magnitudes and angles mathbf z_barmathcal P = z_i z_j, along with their corresponding variances mathbf v_barmathcal P = v_i v_j, where (i j) in barmathcal P. These values can be accessed as:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"pmu = monitoring.pmu;\n\n𝐳ₚ = collect(Iterators.flatten(zip(pmu.magnitude.mean, pmu.angle.mean)))\n𝐯ₚ = collect(Iterators.flatten(zip(pmu.magnitude.variance, pmu.angle.variance)))","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"note: Info\nPMUs can be handled in state estimation algorithms according to our definition in polar coordinate systems. However, they can also be processed in rectangular coordinates, where we observe the real and imaginary parts of the phasor measurements rather than magnitude and angle. Further details can be found in tutorials that describe specific state estimation analyses.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"","category":"page"},{"location":"tutorials/measurementModel/#State-Estimation","page":"Measurement Model","title":"State Estimation","text":"","category":"section"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"After establishing the measurement model, which includes specifying measurement values, variances, the locations of measurement devices, and known power system network parameters, the subsequent step involves the process of state estimation. State estimation is a component of energy management systems and typically encompasses network topology processing, observability analysis, state estimation algorithms, and bad data analysis.","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The primary goal of state estimation algorithms is to determine state variables, often associated with bus voltages. Therefore, by representing the vector of state variables as mathbf x and the vector of noisy measurement values as mathbf z, we can effectively describe the state estimation problem using the following conditional probability equation:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":" \t\tp(mathbf xmathbf z)= cfracp(mathbf zmathbf x)p(mathbf x)p(mathbf z)","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"If we assume that the prior probability distribution p(mathbf x) is uniform and that p(mathbf z) does not depend on mathbf x, the maximum a posteriori solution simplifies to the maximum likelihood solution, as shown below [16]:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"\thatmathbf x = mathrmargmax_mathbf xp(mathbf xmathbf z) =\n\tmathrmargmax_mathbf xp(mathbf zmathbf x) = mathrmargmax_mathbf xmathcalL(mathbf zmathbf x)","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"We can find this solution by maximizing the likelihood function mathcalL(mathbf zmathbf x), which is defined based on the likelihoods of k independent measurements:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"\thatmathbf x = mathrmarg max_mathbf xmathcalL(mathbf zmathbf x)=\n\tmathrmarg max_mathbf x prod_i=1^k mathcalN(z_imathbf x v_i)","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"It can be demonstrated that the solution to the maximum a posteriori problem can be obtained by solving the following optimization problem, commonly referred to as the weighted least-squares problem [10, Sec. 9.3]:","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"\thatmathbf x = mathrmargmin_mathbf x sum_i=1^kcfracz_i - h_i(mathbf x)^2v_i","category":"page"},{"location":"tutorials/measurementModel/","page":"Measurement Model","title":"Measurement Model","text":"The state estimate, denoted as hatmathbf x, resulting from the solution to the above optimization problem, is known as the weighted least-squares estimator. Both the maximum likelihood and weighted least-squares estimators are equivalent to the maximum a posteriori solution [16, Sec. 8.6].","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalPowerFlowManual","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid utilizes the JuMP package to construct optimal power flow models, allowing users to manipulate these models using the standard functions provided by JuMP. As a result, JuliaGrid supports popular solvers mentioned in the JuMP documentation to solve the optimization problem.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To perform the AC optimal power flow, we first need to have the PowerSystem type that has been created with the AC model. After that, create the AcOptimalPowerFlow type to establish the AC optimal power flow framework using the function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"acOptimalPowerFlow.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To solve the AC optimal power flow problem and obtain generator active and reactive power outputs, as well as bus voltage magnitudes and angles, users can use the following function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"solve!.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After solving the AC optimal power flow, JuliaGrid provides functions for computing powers and currents:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"power!,\ncurrent!.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Alternatively, instead of using functions responsible for solving optimal power flow and computing powers and currents, users can use the wrapper function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"powerFlow!.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can also access specialized functions for computing specific types of powers or currents for individual buses, branches, or generators within the power system.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalPowerFlowModelManual","page":"AC Optimal Power Flow","title":"Optimal Power Flow Model","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To set up the AC optimal power flow, we begin by creating the model. To illustrate this, consider the following:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using JuliaGrid # hide\nusing JuMP, Ipopt\n@default(unit) # hide\n@default(template) # hide\n\nsystem = powerSystem()\n\n@bus(minMagnitude = 0.95, maxMagnitude = 1.05)\naddBus!(system; label = \"Bus 1\", type = 3, active = 0.1, angle = -0.1)\naddBus!(system; label = \"Bus 2\", reactive = 0.01, magnitude = 1.1)\n\n@branch(minDiffAngle = -pi, maxDiffAngle = pi, reactance = 0.5, type = 1)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", maxFromBus = 0.15)\n\n@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1, status = 0)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 0.4, reactive = 0.2)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.2, reactive = 0.1)\n\ncost!(system; generator = \"Generator 1\", active = 2, polynomial = [800.0; 200.0; 80.0])\ncost!(system; generator = \"Generator 2\", active = 1, piecewise = [10 12.3; 14.7 16.8; 18 19])\n\ncost!(system; generator = \"Generator 1\", reactive = 2, polynomial = [2.0])\ncost!(system; generator = \"Generator 2\", reactive = 1, piecewise = [2.0 4.0; 6.0 8.0])\n\nacModel!(system)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, the acOptimalPowerFlow function is utilized to formulate the AC optimal power flow problem:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nAll non-box two-sided constraints are modeled as intervals by default. However, users can choose to represent them as two separate constraints, one for the lower bound and one for the upper bound, by setting:analysis = acOptimalPowerFlow(system, Ipopt.Optimizer; interval = false)Although this approach may be less efficient in terms of model creation and could lead to longer execution times depending on the solver, it allows for precise definition of the starting dual values.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimizationVariablesManual","page":"AC Optimal Power Flow","title":"Optimization Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the AC optimal power flow model, the active and reactive power outputs of the generators are expressed as nonlinear functions of the bus voltage magnitudes and angles. As a result, the variables in this model include the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.all_variables(analysis.method.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"It is important to note that this is not a comprehensive set of optimization variables. When the cost function is defined as a piecewise linear function comprising multiple segments, as illustrated in the case of the active power output cost for Generator 2, JuliaGrid automatically generates helper optimization variables named actwise and reactwise, and formulates a set of linear constraints to effectively address these cost functions. For the sake of simplicity, we initially assume that Generator 2 is out-of-service. Consequently, the helper variable is not included in the set of optimization variables. However, as we progress through this manual, we will activate the generator, introducing the helper variable and additional constraints to the optimization model.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"It is worth emphasizing that in instances where a piecewise linear cost function consists of only a single segment, as demonstrated by the reactive power output cost of Generator 2, the function is modeled as a standard linear function, avoiding the need for additional helper optimization variables.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Please be aware that JuliaGrid maintains references to all variables, which are categorized into six fields:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"fieldnames(typeof(analysis.method.variable.voltage))\nfieldnames(typeof(analysis.method.variable.power))","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Variable-Names","page":"AC Optimal Power Flow","title":"Variable Names","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users have the option to define custom variable names for printing equations, which can help present them in a more compact form. For example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis = acOptimalPowerFlow(system, Ipopt.Optimizer; magnitude = \"V\", angle = \"θ\")\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Add-Variables","page":"AC Optimal Power Flow","title":"Add Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Once the AcOptimalPowerFlow type is established, users can add new variables representing generator active power outputs by introducing additional generators. For example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"addGenerator!(analysis; label = \"Generator 3\", bus = \"Bus 1\", maxActive = 0.2, status = 1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"This command adds both a new variables and the corresponding box constraints to the optimization model.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To confirm that the variable has been successfully added, you can use the following function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.is_valid(analysis.method.jump, analysis.method.variable.power.active[3])\nJuMP.is_valid(analysis.method.jump, analysis.method.variable.power.reactive[3])","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACConstraintFunctionsManual","page":"AC Optimal Power Flow","title":"Constraint Functions","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid keeps track of all the references to internally formed constraints in the constraint field of the AcOptimalPowerFlow type. These constraints are divided into six fields:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"fieldnames(typeof(analysis.method.constraint))","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"They fall into two main categories: box constraints and non-box constraints.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nWe suggest that readers refer to the tutorial on AC Optimal Power Flow for insights into the implementation.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Box-Constraints","page":"AC Optimal Power Flow","title":"Box Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The slack constraint is represented as an equality tied to the fixed voltage angle at the slack bus.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The capability constraints define variable bounds on both active and reactive power generation and are always implemented as two separate constraints: one for the lower bound and one for the upper bound. If the bounds are equal, or if the generator is out-of-service, JuliaGrid models the constraint as an equality instead.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The magnitude field of the voltage constraints defines bounds on bus voltage magnitude values and is also implemented using a lower and an upper bound. If the bounds are equal, JuliaGrid models the constraint as an equality instead.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Non-Box-Constraints","page":"AC Optimal Power Flow","title":"Non-Box Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The balance constraints correspond to the active and reactive power balance equations defined at each bus and are modeled as equality constraints.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The angle field of the voltage constraints are associated with the minimum and maximum voltage angle difference between the from-bus and to-bus ends of each branch and are modeled as interval constraints by default. If the bounds are equal, an equality constraint is used instead.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The flow constraints, which refer to branch flow limits at both ends of each branch, are also modeled as interval constraints by default. If the bounds are equal, an equality constraint is used.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"If preferred, both the angle field of the voltage constraints and the flow constraints can be represented as two separate one-sided constraints, one for the lower and one for the upper bound, by setting the keyword argument interval = false when calling the acOptimalPowerFlow function.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Finally, the piecewise constraints are introduced when piecewise linear cost functions with multiple segments are defined, and they impose only upper bounds.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Slack-Bus-Constraint","page":"AC Optimal Power Flow","title":"Slack Bus Constraint","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The slack field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the addBus! function using the angle keyword:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.slack.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the updateBus! function, for example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBus!(analysis; label = \"Bus 1\", type = 1)\nupdateBus!(analysis; label = \"Bus 2\", type = 3, angle = -0.2)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Subsequently, the updated slack constraint can be inspected as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.slack.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Bus-Power-Balance-Constraints","page":"AC Optimal Power Flow","title":"Bus Power Balance Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The balance field contains references to the equality constraints associated with the active and reactive power balance equations defined for each bus. These constraints ensure that the total active and reactive power injected by the generators matches the total active and reactive power demanded at each bus.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constant term in the active power balance equations is determined by the active keyword within the addBus! function, which defines the active power demanded at the bus. We can access the references to the active power balance constraints using the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.balance.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the constant term in the reactive power balance equations is determined by the reactive keyword within the addBus! function, which defines the reactive power demanded at the bus. We can access the references to the reactive power balance constraints using the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.balance.reactive)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system, for example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBus!(analysis; label = \"Bus 2\", active = 0.5)\nupdateBranch!(analysis; label = \"Branch 1\", reactance = 0.25)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The updated set of active power balance constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.balance.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Bus-Voltage-Constraints","page":"AC Optimal Power Flow","title":"Bus Voltage Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The voltage field contains references to the inequality constraints associated with the voltage magnitude and voltage angle difference limits. These constraints ensure that the bus voltage magnitudes and the angle differences between the from-bus and to-bus ends of each branch are within specified limits.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The minimum and maximum bus voltage magnitude limits are set using the minMagnitude and maxMagnitude keywords within the addBus! function. The constraints associated with these limits can be accessed using:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.voltage.magnitude)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The minimum and maximum voltage angle difference limits between the from-bus and to-bus ends of each branch are set using the minDiffAngle and maxDiffAngle keywords within the addBranch! function. The constraints associated with these limits can be accessed using the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nPlease note that if the limit constraints are set to minDiffAngle = -2π and maxDiffAngle = 2π for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By employing the updateBus! and updateBranch! functions, users have the ability to modify these constraints:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBus!(analysis; label = \"Bus 1\", minMagnitude = 1.0, maxMagnitude = 1.0)\nupdateBranch!(analysis; label = \"Branch 1\", minDiffAngle = -1.7, maxDiffAngle = 1.7)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Subsequently, the updated set of constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.constraint.voltage.magnitude)\nprint(system.branch.label, analysis.method.constraint.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACBranchFlowConstraintsManual","page":"AC Optimal Power Flow","title":"Branch Flow Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The flow field refers to inequality constraints that enforce limits on the apparent power flow, active power flow, or current flow magnitude at the from-bus and to-bus ends of each branch. The type of constraint applied is specified using the type keyword in the addBranch! function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"type = 1 active power flow,\ntype = 2 apparent power flow,\ntype = 3 apparent power flow with a squared inequality constraint,\ntype = 4 current flow magnitude,\ntype = 5 current flow magnitude with a squared inequality constraint.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"tip: Tip\nSquared versions of constraints typically make the optimization problem numerically more robust. However, they often result in slower convergence compared to their non-squared counterparts used in the constraints.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"These limits are specified using the minFromBus, maxFromBus, minToBus and maxToBus keywords within the addBranch! function. By default, these limit keywords are associated with apparent power (type = 3).","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"However, in the example, we configured it to use active power flow by setting type = 1. To access the flow constraints of branches at the from-bus end, we can utilize the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.flow.from)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nIf the branch flow limits are set to minFromBus = 0.0 and maxFromBus = 0.0 for the corresponding branch, JuliGrid will omit the corresponding inequality constraint at the from-bus end of the branch. The same applies to the to-bus end if minToBus = 0.0 and maxToBus = 0.0 are set.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Additionally, by employing the updateBranch! function, we have the ability to modify these specific constraints:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateBranch!(analysis; label = \"Branch 1\", minFromBus = -0.15, maxToBus = 0.15)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The updated set of flow constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.flow.from)\nprint(system.branch.label, analysis.method.constraint.flow.to)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"tip: Tip\nIn typical scenarios, minFromBus is equal to minToBus, and maxFromBus is equal to maxToBus. However, we allow these values to be defined separately for greater flexibility, enabling, among other things, the option to apply constraints on only one side of the branch.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Generator-Power-Capability-Constraints","page":"AC Optimal Power Flow","title":"Generator Power Capability Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The capability field contains references to the inequality constraints associated with the minimum and maximum active and reactive power outputs of the generators.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The constraints associated with the minimum and maximum active power output limits of the generators are defined using the minActive and maxActive keywords within the addGenerator! function. To access the constraints associated with these limits, we can use the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.method.constraint.capability.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the constraints associated with the minimum and maximum reactive power output limits of the generators are specified using the minReactive and maxReactive keywords within the addGenerator! function. To access these constraints, we can use the following code snippet:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.method.constraint.capability.reactive)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As demonstrated, the active and reactive power outputs of Generator 1 and Generator 2 are currently fixed at zero due to previous actions that set these generators out-of-service. However, we can modify these specific constraints by utilizing the updateGenerator! function, as shown below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateGenerator!(analysis; label = \"Generator 1\", status = 1)\nupdateGenerator!(analysis; label = \"Generator 2\", status = 1, minActive = 0.1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Subsequently, the updated set of constraints can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.method.constraint.capability.active)\nprint(system.generator.label, analysis.method.constraint.capability.reactive)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nThis representation may not fully capture the generator's power output behavior due to the tradeoff between active and reactive power outputs. JuliaGrid can incorporate this tradeoff in its optimization model. For more information, see the tutorial on Power Capability Constraints.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Power-Piecewise-Constraints","page":"AC Optimal Power Flow","title":"Power Piecewise Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In cost modeling, the piecewise field serves as a reference to the inequality constraints associated with piecewise linear cost functions. These constraints are defined using the cost! function with active = 1 or reactive = 1.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In our example, only the active power cost of Generator 2 is modeled as a piecewise linear function with two segments, and JuliaGrid takes care of setting up the appropriate inequality constraints for each segment:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.method.constraint.piecewise.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"It is worth noting that these constraints can also be automatically updated using the cost! function. Readers can find more details in the section discussing the objective function.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As mentioned at the beginning, piecewise linear cost functions with multiple segments will also introduce helper variables that are added to the objective function. In this specific example, the helper variable is:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis.method.variable.power.actwise[2]","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Add-Constraints","page":"AC Optimal Power Flow","title":"Add Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can effortlessly introduce additional constraints into the defined AC optimal power flow model by utilizing the addBranch! functions. Specifically, if a user wishes to include a new branch or generator in an already defined PowerSystem and AcOptimalPowerFlow type:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"addBranch!(analysis; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 2\", reactance = 1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"This will affect all constraints related to branches, but it will also update balance constraints to configure the optimization model to match the current state of the power system. For example, we can observe the following updated constraints:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, the addGenerator! function adds both new variables and its associated box constraints.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Delete-Constraints","page":"AC Optimal Power Flow","title":"Delete Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"When a branch or generator is taken out-of-service, JuliaGrid automatically adjusts the optimization problem to reflect that action, which may include removing certain constraints.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In some cases, users may also want to manually remove specific constraints. This can be done using the remove! function by specifying the constraint type: :slack, :capability, :balance, :voltage, :flow, or :piecewise.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For constraint types such as :capability, :balance, and :piecewise, users must also specify whether the constraint targets :active or :reactive power. Similarly, for :voltage, the options are :magnitude or :angle, and for :flow, the options are :from or :to.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For example, to delete the constraint associated with the voltage angle difference at Branch 2, use:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"remove!(analysis, :voltage, :angle; label = \"Branch 2\")\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Alternatively, instead of using a label, constraints can also be deleted by index:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"remove!(analysis, :voltage, :angle; index = 4)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After these operations, the remaining voltage angle difference constraints can be displayed as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.branch.label, analysis.method.constraint.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nIn the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACObjectiveFunctionManual","page":"AC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The objective function of the AC optimal power flow is formulated using polynomial and piecewise linear cost functions associated with the generators, defined using the cost! functions.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the provided example, the objective function to be minimized in order to obtain optimal values for the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles, is as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.method.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The objective function is stored in the variable analysis.objective, where it is organized to separate its quadratic and nonlinear components.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Update-Objective-Function","page":"AC Optimal Power Flow","title":"Update Objective Function","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By utilizing the cost! functions, users have the flexibility to modify the objective function by adjusting polynomial or piecewise linear coefficients or by changing the type of polynomial or piecewise linear function employed. For example, consider Generator 1, which employs a quadratic polynomial cost function for active power. We can redefine the cost function for this generator as a cubic polynomial and thereby define a nonlinear objective function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"cost!(analysis; generator = \"Generator 1\", active = 2, polynomial = [63; 25; 4; 0.5])\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"This leads to an updated objective function, which can be examined as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.method.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#AcSetupPrimalStartingValuesManual","page":"AC Optimal Power Flow","title":"Setup Initial Values","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In JuliaGrid, the assignment of initial primal and dual values for optimization variables and constraints takes place when the solve! function is executed.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Initial-Primal-Values","page":"AC Optimal Power Flow","title":"Initial Primal Values","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Initial primal values are determined based on the generator and voltage fields within the AcOptimalPowerFlow type. By default, these values are initially established using the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"generator = analysis.power.generator;\nprint(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users have the flexibility to adjust these values according to their specifications, which will then be used as the initial primal values when executing the solve! function.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Using-AC-Power-Flow","page":"AC Optimal Power Flow","title":"Using AC Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In this perspective, users have the capability to conduct the AC power flow analysis and leverage the resulting solution to configure initial primal values. Here is an illustration of how this can be achieved:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"flow = newtonRaphson(system)\npowerFlow!(flow; power = true)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After obtaining the solution, we can use the active and reactive power outputs of the generators, along with bus voltage magnitudes and angles, to set the initial values:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"setInitialPoint!(analysis, flow)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Initial-Dual-Values","page":"AC Optimal Power Flow","title":"Initial Dual Values","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Dual variables, often referred to as Lagrange multipliers or Kuhn-Tucker multipliers, represent the shadow prices or marginal costs associated with constraints. The assignment of initial dual values occurs when the solve! function is executed. By default, dual values are undefined, but users can manually assign them using the addDual! function.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"If a constraint is defined as an equality, an interval, or has only a lower or upper bound, it corresponds to a single dual variable. In such cases, an initial value can be set using the dual keyword. For example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"addDual!(analysis, :balance, :active; label = \"Bus 1\", dual = 1e-3)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For constraints with both lower and upper bounds, users can assign initial dual values separately using the lower and upper keywords. For example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"addDual!(analysis, :capability, :reactive; label = \"Generator 1\", lower = 500.0, upper = 0.0)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Alternatively, dual variables can be added by specifying the constraint index instead of a label:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"addDual!(analysis, :capability, :reactive; index = 1, lower = 500.0, upper = 0.0)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#AcOptimalPowerFlowSolutionManual","page":"AC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To establish the AC optimal power flow problem, we utilize the acOptimalPowerFlow function. After setting up the problem, we can use the solve! function to compute the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes angles:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"solve!(analysis)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"By executing this function, we will obtain the solution with the optimal values for the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"generator = analysis.power.generator;\nprint(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Objective-Value","page":"AC Optimal Power Flow","title":"Objective Value","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To obtain the objective value of the optimal power flow solution, we can use the objective_value function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_value(analysis.method.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Dual-Variables","page":"AC Optimal Power Flow","title":"Dual Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The values of the dual variables are stored in the dual field of the AcOptimalPowerFlow type. For example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.method.dual.balance.active)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Wrapper-Function","page":"AC Optimal Power Flow","title":"Wrapper Function","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuliaGrid provides a wrapper function for AC optimal power flow analysis and also supports the computation of powers and currents using the powerFlow! function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"setInitialPoint!(analysis) # hide\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis; verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Print-Results-in-the-REPL","page":"AC Optimal Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can utilize the functions printBusData and printGeneratorData to display results. Additionally, the functions listed in the Print Constraint Data section allow users to print constraint data related to buses, branches, or generators in the desired units. For example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"show = Dict(\"Active Power Balance\" => false)\nprintBusConstraint(analysis; show)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, users can easily customize the print results for specific constraint, for example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"printBusConstraint(analysis; label = \"Bus 1\", header = true)\nprintBusConstraint(analysis; label = \"Bus 2\", footer = true)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Save-Results-to-a-File","page":"AC Optimal Power Flow","title":"Save Results to a File","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can also redirect print output to a file. For example, data can be saved in a text file as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"open(\"bus.txt\", \"w\") do file\n    printBusConstraint(analysis, file)\nend","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Save-Results-to-a-CSV-File","page":"AC Optimal Power Flow","title":"Save Results to a CSV File","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For CSV output, users should first generate a simple table with style = false, and then save it to a CSV file:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using CSV\n\nio = IOBuffer()\nprintBusConstraint(analysis, io; style = false)\nCSV.write(\"constraint.csv\", CSV.File(take!(io); delim = \"|\"))","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Primal-and-Dual-Warm-Start","page":"AC Optimal Power Flow","title":"Primal and Dual Warm Start","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Utilizing the AcOptimalPowerFlow type and proceeding directly to the solver offers the advantage of a warm start. In this scenario, the initial primal and dual values for the subsequent solving step correspond to the solution obtained from the previous step, including any user-defined data previously integrated in JuliaGrid.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Primal-Variables","page":"AC Optimal Power Flow","title":"Primal Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"In the previous example, the following solution was obtained, representing the values of the primal variables:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"generator = analysis.power.generator;\n\nprint(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Dual-Variables-2","page":"AC Optimal Power Flow","title":"Dual Variables","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We also obtained all dual values. Here, we list only the dual variables for one type of constraint as an example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.generator.label, analysis.method.dual.capability.reactive)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Modify-Optimal-Power-Flow","page":"AC Optimal Power Flow","title":"Modify Optimal Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Now, let us introduce changes to the power system from the previous example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"updateGenerator!(analysis; label = \"Generator 3\", maxActive = 0.05)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, we want to solve this modified optimal power flow problem. If we use solve! at this point, the primal and dual initial values will be set to the previously obtained values:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"powerFlow!(analysis, verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"As a result, we obtain a new solution:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"generator = analysis.power.generator;\n\nprint(system.generator.label, generator.active, generator.reactive)\nprint(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Reset-Primal-and-Dual-Values","page":"AC Optimal Power Flow","title":"Reset Primal and Dual Values","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users retain the flexibility to reset initial primal and dual values to their default configurations at any juncture. This can be accomplished by utilizing the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles extracted from the PowerSystem type, employing the setInitialPoint! function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"setInitialPoint!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The primal initial values will now be identical to those that would be obtained if the acOptimalPowerFlow function were executed after all the updates have been applied, while all dual variable values will be removed.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#AcExtendedFormulationManual","page":"AC Optimal Power Flow","title":"Extended Formulation","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The JuMP model created by JuliaGrid is stored in the method.jump field of the AcOptimalPowerFlow type. This allows users to modify the model directly using JuMP macros and functions as needed. However, when making such modifications, users become responsible for tasks like setting initial values and extracting solutions, since these changes operate outside the standard JuliaGrid workflow.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Beyond this approach, JuliaGrid also provides a way to extend the standard AC optimal power flow formulation within its own framework. This lets users take advantage of features such as warm start and automatic solution storage, as described below.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Add-Variable","page":"AC Optimal Power Flow","title":"Add Variable","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"User-defined variables can be added to the DC optimal power flow model using the @addVariable macro. It also allows immediate assignment of initial primal and dual values. For example:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"@addVariable(analysis, 0.0 <= y <= 0.2, primal = 0.1, lower = 10.0, upper = 0.0)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can also define collections of variables:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"@addVariable(analysis, 0.0 <= x[i = 1:2] <= 0.4, primal = [0.1, 0.2], upper = [0.0; -2.5])\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Add-Constraints-2","page":"AC Optimal Power Flow","title":"Add Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Custom constraints can be added to the DC optimal power flow model using the @addConstraint macro. These constraints are not limited to user-defined variables; any optimization variable defined up to that point can be used. Let us focus on the voltage angle variables:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"θ = analysis.method.variable.voltage.angle\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Next, a new constraint can be defined, and at the same time, an initial dual value can be specified:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"@addConstraint(analysis, 0.1 <= x[1] + 2 * x[2] + y + θ[2] <= 1.2, dual = 0.0)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Collections of constraints can also be defined:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"@addConstraint(analysis, [i = 1:2], x[i] + 2 * θ[i] <= 0.6, dual = [0.0; 0.5])\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Delete-Constraints-2","page":"AC Optimal Power Flow","title":"Delete Constraints","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To remove a constraint, use the remove! function with the :constraint symbol. For example, to remove the first added constraint:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"remove!(analysis, :constraint; index = 1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Objective-Function","page":"AC Optimal Power Flow","title":"Objective Function","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can modify the objective function using the set_objective_function function from the JuMP package. In JuliaGrid, the original objective is stored in the objective field of the AcOptimalPowerFlow type, which can be accessed and customized as needed. This makes it possible to simultaneously remove nonlinear components and adjust the quadratic part of the objective function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"expr = 50 * x[1] - x[2]^2 + y + 123\nJuMP.set_objective_function(analysis.method.jump, analysis.method.objective.quadratic - expr)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can now observe the updated objective function as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"JuMP.objective_function(analysis.method.jump)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Optimal-Power-Flow-Solution","page":"AC Optimal Power Flow","title":"Optimal Power Flow Solution","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can now solve the extended formulation using:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"powerFlow!(analysis; verbose = 1)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After solving, users can access the optimal values as follows:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"analysis.power.generator.active\nanalysis.power.generator.reactive\nanalysis.voltage.magnitude\nanalysis.voltage.angle\nanalysis.extended.solution","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#ACOptimalPowerCurrentAnalysisManual","page":"AC Optimal Power Flow","title":"Power and Current Analysis","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"After obtaining the solution from the AC optimal power flow, we can calculate various electrical quantities related to buses and branches using the power! and current! functions. For instance, let us consider the power system for which we obtained the AC optimal power flow solution:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"using JuliaGrid, JuMP # hide\nusing Ipopt\n\n@default(unit) # hide\n@default(template) # hide\nsystem = powerSystem()\n\n@bus(minMagnitude = 0.9, maxMagnitude = 1.1)\naddBus!(system; label = \"Bus 1\", type = 3, magnitude = 1.05, angle = 0.17)\naddBus!(system; label = \"Bus 2\", active = 0.1, reactive = 0.01, conductance = 0.04)\naddBus!(system; label = \"Bus 3\", active = 0.05, reactive = 0.02)\n\n@branch(resistance = 0.5, reactance = 1.0, conductance = 1e-4, susceptance = 0.01)\naddBranch!(system; label = \"Branch 1\", from = \"Bus 1\", to = \"Bus 2\", maxFromBus = 0.15)\naddBranch!(system; label = \"Branch 2\", from = \"Bus 1\", to = \"Bus 3\", maxFromBus = 0.10)\naddBranch!(system; label = \"Branch 3\", from = \"Bus 2\", to = \"Bus 3\", maxFromBus = 0.25)\n\n@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1)\naddGenerator!(system; label = \"Generator 1\", bus = \"Bus 1\", active = 3.2, reactive = 0.5)\naddGenerator!(system; label = \"Generator 2\", bus = \"Bus 2\", active = 0.2, reactive = 0.1)\n\ncost!(system; generator = \"Generator 1\", active = 2, polynomial = [1100.2; 500; 80])\ncost!(system; generator = \"Generator 2\", active = 1, piecewise = [10 12.3; 14.7 16.8; 18 19])\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can now utilize the following functions to calculate powers and currents:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"power!(analysis)\ncurrent!(analysis)\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"For instance, if we want to show the active power injections and the from-bus current magnitudes, we can employ:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"print(system.bus.label, analysis.power.injection.active)\nprint(system.branch.label, analysis.current.from.magnitude)","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"note: Info\nTo better understand the powers and current associated with buses and branches that are calculated by the power! and current! functions, we suggest referring to the tutorials on AC Optimal Power Flow.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Print-Results-in-the-REPL-2","page":"AC Optimal Power Flow","title":"Print Results in the REPL","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Users can utilize any of the print functions outlined in the Print Power System Data or Print Power System Summary. For example, to create a bus data with the desired units, users can use the following function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"@voltage(pu, deg)\n@power(MW, MVAr)\nshow = Dict(\"Power Generation\" => false, \"Current Injection\" => false)\nprintBusData(analysis; show)\n@default(unit) # hide\nnothing # hide","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-Injection","page":"AC Optimal Power Flow","title":"Active and Reactive Power Injection","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = injectionPower(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-Injection-from-Generators","page":"AC Optimal Power Flow","title":"Active and Reactive Power Injection from Generators","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = supplyPower(analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Shunt-Element","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Shunt Element","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = shuntPower(analysis; label = \"Bus 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-Flow","page":"AC Optimal Power Flow","title":"Active and Reactive Power Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = fromPower(analysis; label = \"Branch 2\")\nactive, reactive = toPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Charging-Admittances","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Charging Admittances","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the total active and reactive power linked with branch charging admittances of the particular branch, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = chargingPower(analysis; label = \"Branch 1\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"Active powers indicate active losses within the branch's charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Active-and-Reactive-Power-at-Series-Impedance","page":"AC Optimal Power Flow","title":"Active and Reactive Power at Series Impedance","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the active and reactive power across the series impedance of the branch, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"active, reactive = seriesPower(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance's inductive characteristics.","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Current-Injection","page":"AC Optimal Power Flow","title":"Current Injection","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the current injection associated with a specific bus, the function can be used:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"magnitude, angle = injectionCurrent(analysis; label = \"Bus 1\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Current-Flow","page":"AC Optimal Power Flow","title":"Current Flow","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"We can compute the current flow at both the from-bus and to-bus ends of the specific branch by using:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"magnitude, angle = fromCurrent(analysis; label = \"Branch 2\")\nmagnitude, angle = toCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"page"},{"location":"manual/acOptimalPowerFlow/#Current-Through-Series-Impedance","page":"AC Optimal Power Flow","title":"Current Through Series Impedance","text":"","category":"section"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:","category":"page"},{"location":"manual/acOptimalPowerFlow/","page":"AC Optimal Power Flow","title":"AC Optimal Power Flow","text":"magnitude, angle = seriesCurrent(analysis; label = \"Branch 2\")","category":"page"},{"location":"api/optimalPowerFlow/#OptimalPowerFlowAPI","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"For further information on this topic, please see the AC Optimal Power Flow or DC Optimal Power Flow sections of the Manual. Below, we have provided a list of functions that can be utilized for optimal power flow analysis.","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"To load optimal power flow API functionalities into the current scope, one can employ the following command:","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"using JuliaGrid, Ipopt","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#AC-Optimal-Power-Flow","page":"Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"acOptimalPowerFlow\nsolve!\nsetInitialPoint!\npowerFlow!","category":"page"},{"location":"api/optimalPowerFlow/#DC-Optimal-Power-Flow","page":"Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"dcOptimalPowerFlow\nsolve!\nsetInitialPoint!\npowerFlow!","category":"page"},{"location":"api/optimalPowerFlow/#Extended-Formulation","page":"Optimal Power Flow","title":"Extended Formulation","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"@addVariable\n@addConstraint","category":"page"},{"location":"api/optimalPowerFlow/#Utility-Functions","page":"Optimal Power Flow","title":"Utility Functions","text":"","category":"section"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"addDual!\nremove!","category":"page"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#AC-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.acOptimalPowerFlow","text":"acOptimalPowerFlow(system::PowerSystem, optimizer;\n    iteration, tolerance, bridge, interval, name,\n    magnitude, angle, active, reactive, actwise, reactwise, verbose)\n\nThe function sets up the optimization model for solving the AC optimal power flow problem.\n\nArguments\n\nThe function requires the PowerSystem type to establish the framework. Next, the optimizer argument is also required to create and solve the optimization problem. Specifically, JuliaGrid constructs the AC optimal power flow using the JuMP package and provides support for commonly employed solvers. For more detailed information, please consult the JuMP documentation.\n\nKeywords\n\nUsers can configure the following parameters:\n\niteration: Specifies the maximum number of iterations.\ntolerance: Specifies the allowed deviation from the optimal solution.\nbridge: Manage the bridging mechanism (default: false).\ninterval: Uses interval form for two-sided constraints (default: true).\nname: Manage the creation of string names (default: true).\nverbose: Controls the output display, ranging from silent mode (0) to detailed output (3).\n\nAdditionally, users can modify the variable names used for printing and writing by setting the keywords for the variables magnitude, angle, active, and reactive, as well as the helper variables actwise and reactwise. For instance, users can choose magnitude = \"V\" and angle = \"θ\" to display equations in a more readable format.\n\nUpdates\n\nIf the AC model has not been created, the function automatically initiates an update within the ac field of the PowerSystem type.\n\nReturns\n\nThe function returns an instance of the AcOptimalPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer; iteration = 50, verbose = 1)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(analysis::AcOptimalPowerFlow)\n\nThe function solves the AC optimal power flow model, computing the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles.\n\nUpdates\n\nThe calculated active and reactive powers, as well as voltage magnitudes and angles, are stored in the power.generator and voltage fields of the AcOptimalPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.setInitialPoint!-Tuple{AcOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(analysis::AcOptimalPowerFlow)\n\nThe function sets the initial point of the AC optimal power flow to the values from the PowerSystem type.\n\nUpdates\n\nThe function modifies the voltage and generator fields of the AcOptimalPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nupdateBus!(analysis; label = \"Bus 14 LV\", reactive = 0.13, magnitude = 1.2, angle = -0.17)\n\nsetInitialPoint!(analysis)\npowerFlow!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.setInitialPoint!-Tuple{AcOptimalPowerFlow, AC}","page":"Optimal Power Flow","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(target::AcOptimalPowerFlow, source::Analysis)\n\nThe function initializes the AC optimal power flow based on results from the Analysis type, whether from an AC or DC analysis.\n\nThe function assigns the active and reactive power outputs of the generators, along with the bus voltage magnitudes and angles in the target argument, using data from the source argument. This allows users to initialize primal values as needed. Additionally, if source is of type AcOptimalPowerFlow, the function also assigns initial dual values in the target argument based on data from source.\n\nIf source comes from a DC analysis, only the active power outputs of the generators and bus voltage angles are assigned in the target argument, while the reactive power outputs of the generators and bus voltage magnitudes remain unchanged. Additionally, if source is of type DcOptimalPowerFlow, the corresponding dual variable values are also assigned in the target argument.\n\nUpdates\n\nThis function may modify the voltage, generator, and method.dual fields of the AcOptimalPowerFlow type.\n\nExample\n\nUse the AC power flow results to initialize the AC optimal power flow:\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nsource = newtonRaphson(system)\npowerFlow!(source)\n\ntarget = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\nsetInitialPoint!(target, source)\npowerFlow!(target)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{AcOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.powerFlow!","text":"powerFlow!(analysis::AcOptimalPowerFlow; iteration, tolerance, power, current, verbose)\n\nThe function serves as a wrapper for solving AC optimal power flow and includes the functions:\n\nsolve!,\npower!,\ncurrent!.\n\nIt computes the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles, with an option to compute the powers and currents related to buses and branches.\n\nKeywords\n\nUsers can use the following keywords:\n\niteration: Specifies the maximum number of iterations.\ntolerance: Specifies the allowed deviation from the optimal solution.\npower: Enables the computation of powers (default: false).\ncurrent: Enables the computation of currents (default: false).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\nacModel!(system)\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis; power = true, verbose = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#DC-Optimal-Power-Flow-2","page":"Optimal Power Flow","title":"DC Optimal Power Flow","text":"","category":"section"},{"location":"api/optimalPowerFlow/#JuliaGrid.dcOptimalPowerFlow","page":"Optimal Power Flow","title":"JuliaGrid.dcOptimalPowerFlow","text":"dcOptimalPowerFlow(system::PowerSystem, optimizer;\n    iteration, tolerance, bridge, interval, name, angle, active, actwise, verbose)\n\nThe function sets up the optimization model for solving the DC optimal power flow problem.\n\nArguments\n\nThe function requires the PowerSystem type to establish the framework. Next, the optimizer argument is also required to create and solve the optimization problem. Specifically, JuliaGrid constructs the DC optimal power flow using the JuMP package and provides support for commonly employed solvers. For more detailed information, please consult the JuMP documentation.\n\nKeywords\n\nUsers can configure the following parameters:\n\niteration: Specifies the maximum number of iterations.\ntolerance: Specifies the allowed deviation from the optimal solution.\nbridge: Controls the bridging mechanism (default: false).\ninterval: Uses interval form for two-sided expression constraints (default: true).\nname: Enables or disables the creation of string names (default: true).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nAdditionally, users can modify the variable names used for printing and writing by setting the keywords for the voltage variables angle and active, as well as the helper variable actwise. For example, users may set angle = \"θ\", active = \"P\", and actwise = \"H\" to display equations in a more readable format.\n\nUpdates\n\nIf the DC model has not been created, the function automatically initiates an update within the dc field of the PowerSystem type.\n\nReturns\n\nThe function returns an instance of the DcOptimalPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{DcOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.solve!","text":"solve!(analysis::DcOptimalPowerFlow)\n\nThe function solves the DC optimal power flow model, computing the active power outputs of the generators, as well as the bus voltage angles.\n\nUpdates\n\nThe calculated active powers, as well as voltage angles, are stored in the power.generator and voltage fields of the DcOptimalPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\nsolve!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.setInitialPoint!-Tuple{DcOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(analysis::DcOptimalPowerFlow)\n\nThe function sets the initial point of the DC optimal power flow to the values from the PowerSystem type.\n\nUpdates\n\nThe function modifies the voltage and generator fields of the DcOptimalPowerFlow type.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis)\n\nupdateBus!(analysis; label = \"Bus 14 LV\", active = 0.1, angle = -0.17)\n\nsetInitialPoint!(analysis)\npowerFlow!(analysis)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.setInitialPoint!-Tuple{DcOptimalPowerFlow, DC}","page":"Optimal Power Flow","title":"JuliaGrid.setInitialPoint!","text":"setInitialPoint!(target::DcOptimalPowerFlow, source::Analysis)\n\nThe function initializes the DC optimal power flow based on results from the Analysis type, whether from an AC or DC analysis.\n\nThe function assigns the active power outputs of the generators, along with the bus voltage angles in the target argument, using data from the source argument. This allows users to initialize primal values as needed. Additionally, if source is of type AcOptimalPowerFlow or DcOptimalPowerFlow, the function also assigns initial dual values in the target argument based on data from source.\n\nUpdates\n\nThis function may modify the voltage, generator, and method.dual fields of the DcOptimalPowerFlow type.\n\nExample\n\nUse the DC power flow results to initialize the DC optimal power flow:\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nsource = dcPowerFlow(system)\nsolve!(source)\n\ntarget = dcOptimalPowerFlow(system, Ipopt.Optimizer)\n\nsetInitialPoint!(target, source)\nsolve!(target)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{DcOptimalPowerFlow}","page":"Optimal Power Flow","title":"JuliaGrid.powerFlow!","text":"powerFlow!(analysis::DcOptimalPowerFlow; iteration, tolerance, power, verbose)\n\nThe function serves as a wrapper for solving DC optimal power flow and includes the functions:\n\nsolve!,\npower!.\n\nIt computes the active power outputs of the generators, as well as the bus voltage angles, with an option to compute the powers related to buses and branches.\n\nKeywords\n\nUsers can use the following keywords:\n\niteration: Specifies the maximum number of iterations.\ntolerance: Specifies the allowed deviation from the optimal solution.\npower: Enables the computation of powers (default: false).\nverbose: Controls the output display, ranging from the default silent mode (0) to detailed output (3).\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\ndcModel!(system)\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\npowerFlow!(analysis; power = true, verbose = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/optimalPowerFlow/","page":"Optimal Power Flow","title":"Optimal Power Flow","text":"","category":"page"},{"location":"api/optimalPowerFlow/#Extended-Formulation-2","page":"Optimal Power Flow","title":"Extended Formulation","text":"","category":"section"},{"location":"api/optimalPowerFlow/#JuliaGrid.@addVariable","page":"Optimal Power Flow","title":"JuliaGrid.@addVariable","text":"@addVariable(analysis::OptimalPowerFlow, expr, primal, lower, upper, args..., kwargs...)\n\nThis macro wraps the JuMP @variable macro, adding an optimization variable defined by expr to the model. In addition to creating the JuMP variable, it also registers the variable within the JuliaGrid framework and optionally sets initial values for both primal and dual variables.\n\nThe positional arguments args and keyword arguments kwargs are consistent with those accepted by the @variable macro in JuMP.\n\nAdditionally, the following keyword arguments can be used:\n\nprimal: Sets the initial primal value.\nlower: If a lower bound is defined, sets the initial dual value.\nupper: If an upper bound is defined, sets the initial dual value.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\n\n@addVariable(analysis, 0.0 <= x <= 0.2, primal = 0.1, lower = 10.0, upper = 0.0)\n@addVariable(analysis, y[i = 1:2] <= 0.2, primal = [0.1, 0.2], upper = [0.0; -2.5])\n\n\n\n\n\n","category":"macro"},{"location":"api/optimalPowerFlow/#JuliaGrid.@addConstraint","page":"Optimal Power Flow","title":"JuliaGrid.@addConstraint","text":"@addConstraint(analysis::OptimalPowerFlow, expr, dual, args..., kwargs...)\n\nThis macro wraps the JuMP @constraint macro, adding an constraint defined by expr to the model. In addition to creating the JuMP constraint, it also registers the constraint within the JuliaGrid framework and optionally sets initial dual value.\n\nThe positional arguments args and keyword arguments kwargs are consistent with those accepted by the @constraint macro in JuMP.\n\nAdditionally, the keyword dual can be used to set the initial dual value.\n\nExample\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\n\n@addVariable(analysis, 0.0 <= x[i = 1:2] <= 0.2)\n@addConstraint(analysis, x[1] + 2 * x[2] <= 1.2, dual = 0.1)\n\n\n\n\n\n","category":"macro"},{"location":"api/optimalPowerFlow/#Utility-Functions-2","page":"Optimal Power Flow","title":"Utility Functions","text":"","category":"section"},{"location":"api/optimalPowerFlow/#JuliaGrid.addDual!","page":"Optimal Power Flow","title":"JuliaGrid.addDual!","text":"addDual!(analysis::OptimalPowerFlow, field::Symbol, subfield::Symbol;\n    label, index, subindex, dual, lower, upper)\n\nAssigns an initial dual value to a specific constraint in the optimal power flow model.\n\nFor DC optimal power flow, only field is required to identify the constraint. For AC optimal power flow, both field and subfield must be provided to target the specific constraint type.\n\nArguments\n\nfield: Specifies the primary constraint category.\nsubfield: Specifies the constraint subtype within the selected field.\n\nInitial dual values are assigned according to the selected constraint:\n\n:slack: Slack angle constraint.\n:capability: Generator capability constraints:\n:active: Active power.\n:reactive: Reactive power.\n:lower: PQ capability curve.\n:upper: PQ capability curve.\n:balance: Power balance constraints:\n:active: Active power balance.\n:reactive: Reactive power balance.\n:voltage: Voltage constraints:\n:magnitude: Voltage magnitude.\n:angle: Angle difference.\n:flow: Branch power flow constraints:\n:from: From-bus end.\n:to: To-bus end.\n:piecewise: Piecewise linear cost constraints:\n:active: Active power.\n:reactive: Reactive power.\n:variable: Constraint on external user-defined variable.\n:constraint: External user-defined constraint.\n\nKeywords\n\nThe following keyword arguments can be used:\n\nlabel: Identifies the constraint by the label of a bus, branch, or generator.\nindex: Identifies the constraint by numerical index.\nsubindex: Specify a subconstraint index for :piecewise constraints only.\ndual: Sets the dual value for equality or interval constraints.\nlower: Sets the dual value associated with the lower bound.\nupper: Sets the dual value associated with the upper bound.\n\nExamples\n\nAC optimal power flow:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\naddDual!(analysis, :balance, :active; index = 2, dual = 258.23)\naddDual!(analysis, :voltage, :magnitude; index = 2, lower = 0.0, upper = 587.23)\n\nDC optimal power flow:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\n\naddDual!(analysis, :balance; index = 2, dual = 258.23)\naddDual!(analysis, :capability; index = 2, lower = 0.0, upper = 587.23)\n\n\n\n\n\n","category":"function"},{"location":"api/optimalPowerFlow/#JuliaGrid.remove!","page":"Optimal Power Flow","title":"JuliaGrid.remove!","text":"remove!(analysis::OptimalPowerFlow, field::Symbol, subfield::Symbol; label, index)\n\nRemoves a specific constraint from the optimal power flow model.\n\nFor DC optimal power flow, only field is required to identify the constraint. For AC optimal power flow, both field and subfield must be provided to target the specific constraint type.\n\nArguments\n\nfield: Specifies the primary constraint category.\nsubfield: Specifies the constraint subtype within the selected field.\n\nThe constraint to be removed can correspond to one of the following:\n\n:slack: Slack angle constraint.\n:capability: Generator capability constraints:\n:active: Active power.\n:reactive: Reactive power.\n:lower: PQ capability curve.\n:upper: PQ capability curve.\n:balance: Power balance constraints:\n:active: Active power balance.\n:reactive: Reactive power balance.\n:voltage: Voltage constraints:\n:magnitude: Voltage magnitude.\n:angle: Angle difference.\n:flow: Branch power flow constraints:\n:from: From-bus end.\n:to: To-bus end.\n:piecewise: Piecewise linear cost constraints:\n:active: Active power.\n:reactive: Reactive power.\n:variable: Constraint on external user-defined variable.\n:constraint: External user-defined constraint.\n\nKeywords\n\nThe following keyword arguments can be used:\n\nlabel: Identifies the constraint by the label of a bus, branch, or generator.\nindex: Identifies the constraint by numerical index.\n\nExamples\n\nAC optimal power flow:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = acOptimalPowerFlow(system, Ipopt.Optimizer)\n\nremove!(analysis, :balance, :active; index = 2)\nremove!(analysis, :voltage, :magnitude; index = 2)\n\nDC optimal power flow:\n\nsystem = powerSystem(\"case14.h5\")\n\nanalysis = dcOptimalPowerFlow(system, Ipopt.Optimizer)\n\nremove!(analysis, :balance; index = 2)\nremove!(analysis, :capability; index = 2)\n\n\n\n\n\n","category":"function"}]
}
