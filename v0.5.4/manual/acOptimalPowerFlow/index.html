<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AC Optimal Power Flow · JuliaGrid</title><meta name="title" content="AC Optimal Power Flow · JuliaGrid"/><meta property="og:title" content="AC Optimal Power Flow · JuliaGrid"/><meta property="twitter:title" content="AC Optimal Power Flow · JuliaGrid"/><meta name="description" content="Documentation for JuliaGrid."/><meta property="og:description" content="Documentation for JuliaGrid."/><meta property="twitter:description" content="Documentation for JuliaGrid."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/subfigure.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="JuliaGrid logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">JuliaGrid</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../dcPowerFlow/">DC Power Flow</a></li><li class="is-active"><a class="tocitem" href>AC Optimal Power Flow</a><ul class="internal"><li><a class="tocitem" href="#ACOptimalPowerFlowModelManual"><span>Optimal Power Flow Model</span></a></li><li><a class="tocitem" href="#ACOptimizationVariablesManual"><span>Optimization Variables</span></a></li><li><a class="tocitem" href="#ACConstraintFunctionsManual"><span>Constraint Functions</span></a></li><li><a class="tocitem" href="#ACObjectiveFunctionManual"><span>Objective Function</span></a></li><li><a class="tocitem" href="#AcSetupPrimalStartingValuesManual"><span>Setup Initial Values</span></a></li><li><a class="tocitem" href="#AcOptimalPowerFlowSolutionManual"><span>Optimal Power Flow Solution</span></a></li><li><a class="tocitem" href="#Primal-and-Dual-Warm-Start"><span>Primal and Dual Warm Start</span></a></li><li><a class="tocitem" href="#AcExtendedFormulationManual"><span>Extended Formulation</span></a></li><li><a class="tocitem" href="#ACOptimalPowerCurrentAnalysisManual"><span>Power and Current Analysis</span></a></li></ul></li><li><a class="tocitem" href="../dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../badDataAnalysis/">Bad Data Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../tutorials/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../tutorials/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../tutorials/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../tutorials/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../tutorials/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../tutorials/dcStateEstimation/">DC State Estimation</a></li><li><a class="tocitem" href="../../tutorials/badDataAnalysis/">Bad Data Analysis</a></li><li><a class="tocitem" href="../../tutorials/perunit/">Per-Unit System</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/powerSystemDatasets/">Power System Datasets</a></li><li><a class="tocitem" href="../../examples/acPowerFlow/">AC Power Flow</a></li><li><a class="tocitem" href="../../examples/dcPowerFlow/">DC Power Flow</a></li><li><a class="tocitem" href="../../examples/acOptimalPowerFlow/">AC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/dcOptimalPowerFlow/">DC Optimal Power Flow</a></li><li><a class="tocitem" href="../../examples/observabilityAnalysis/">Observability Analysis</a></li><li><a class="tocitem" href="../../examples/acStateEstimation/">AC State Estimation</a></li><li><a class="tocitem" href="../../examples/pmuStateEstimation/">PMU State Estimation</a></li><li><a class="tocitem" href="../../examples/dcStateEstimation/">DC State Estimation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/powerSystemModel/">Power System Model</a></li><li><a class="tocitem" href="../../api/powerFlow/">Power Flow</a></li><li><a class="tocitem" href="../../api/optimalPowerFlow/">Optimal Power Flow</a></li><li><a class="tocitem" href="../../api/measurementModel/">Measurement Model</a></li><li><a class="tocitem" href="../../api/stateEstimation/">State Estimation</a></li><li><a class="tocitem" href="../../api/analysis/">Powers and Currents</a></li><li><a class="tocitem" href="../../api/setupPrint/">Setup and Print</a></li><li><a class="tocitem" href="../../api/publicTypes/">Public Types</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/installation/">Installation Guide</a></li><li><a class="tocitem" href="../../background/bibliography/">Bibliography</a></li><li><a class="tocitem" href="../../background/releasenotes/">Release Notes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AC Optimal Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mcosovic/JuliaGrid.jl/blob/master/docs/src/manual/acOptimalPowerFlow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ACOptimalPowerFlowManual"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowManual">AC Optimal Power Flow</a><a id="ACOptimalPowerFlowManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowManual" title="Permalink"></a></h1><p>JuliaGrid utilizes the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package to construct optimal power flow models, allowing users to manipulate these models using the standard functions provided by JuMP. As a result, JuliaGrid supports popular <a href="https://jump.dev/JuMP.jl/stable/packages/solvers/">solvers</a> mentioned in the JuMP documentation to solve the optimization problem.</p><p>To perform the AC optimal power flow, we first need to have the <code>PowerSystem</code> type that has been created with the AC model. After that, create the <code>AcOptimalPowerFlow</code> type to establish the AC optimal power flow framework using the function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a>.</li></ul><hr/><p>To solve the AC optimal power flow problem and obtain generator active and reactive power outputs, as well as bus voltage magnitudes and angles, users can use the following function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}"><code>solve!</code></a>.</li></ul><p>After solving the AC optimal power flow, JuliaGrid provides functions for computing powers and currents:</p><ul><li><a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a>,</li><li><a href="../../api/analysis/#JuliaGrid.current!-Tuple{AC}"><code>current!</code></a>.</li></ul><p>Alternatively, instead of using functions responsible for solving optimal power flow and computing powers and currents, users can use the wrapper function:</p><ul><li><a href="../../api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{AcOptimalPowerFlow}"><code>powerFlow!</code></a>.</li></ul><p>Users can also access specialized functions for computing specific types of <a href="../../api/analysis/#ACPowerAnalysisAPI">powers</a> or <a href="../../api/analysis/#ACCurrentAnalysisAPI">currents</a> for individual buses, branches, or generators within the power system.</p><hr/><h2 id="ACOptimalPowerFlowModelManual"><a class="docs-heading-anchor" href="#ACOptimalPowerFlowModelManual">Optimal Power Flow Model</a><a id="ACOptimalPowerFlowModelManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerFlowModelManual" title="Permalink"></a></h2><p>To set up the AC optimal power flow, we begin by creating the model. To illustrate this, consider the following:</p><pre><code class="language-julia hljs">using JuMP, Ipopt

system = powerSystem()

@bus(minMagnitude = 0.95, maxMagnitude = 1.05)
addBus!(system; label = &quot;Bus 1&quot;, type = 3, active = 0.1, angle = -0.1)
addBus!(system; label = &quot;Bus 2&quot;, reactive = 0.01, magnitude = 1.1)

@branch(minDiffAngle = -pi, maxDiffAngle = pi, reactance = 0.5, type = 1)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, maxFromBus = 0.15)

@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1, status = 0)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 0.4, reactive = 0.2)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.2, reactive = 0.1)

cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [800.0; 200.0; 80.0])
cost!(system; generator = &quot;Generator 2&quot;, active = 1, piecewise = [10 12.3; 14.7 16.8; 18 19])

cost!(system; generator = &quot;Generator 1&quot;, reactive = 2, polynomial = [2.0])
cost!(system; generator = &quot;Generator 2&quot;, reactive = 1, piecewise = [2.0 4.0; 6.0 8.0])

acModel!(system)</code></pre><p>Next, the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function is utilized to formulate the AC optimal power flow problem:</p><pre><code class="language-julia hljs">analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>All non-box two-sided constraints are modeled as intervals by default. However, users can choose to represent them as two separate constraints, one for the lower bound and one for the upper bound, by setting:</p><pre><code class="language-julia hljs">analysis = acOptimalPowerFlow(system, Ipopt.Optimizer; interval = false)</code></pre><p>Although this approach may be less efficient in terms of model creation and could lead to longer execution times depending on the solver, it allows for precise definition of the starting dual values.</p></div></div><hr/><h2 id="ACOptimizationVariablesManual"><a class="docs-heading-anchor" href="#ACOptimizationVariablesManual">Optimization Variables</a><a id="ACOptimizationVariablesManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimizationVariablesManual" title="Permalink"></a></h2><p>In the AC optimal power flow model, the active and reactive power outputs of the generators are expressed as nonlinear functions of the bus voltage magnitudes and angles. As a result, the variables in this model include the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.all_variables(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{VariableRef}:
 magnitude[1]
 magnitude[2]
 angle[1]
 angle[2]
 active[1]
 active[2]
 reactive[1]
 reactive[2]</code></pre><p>It is important to note that this is not a comprehensive set of optimization variables. When the cost function is defined as a piecewise linear function comprising multiple segments, as illustrated in the case of the active power output cost for <code>Generator 2</code>, JuliaGrid automatically generates helper optimization variables named <code>actwise</code> and <code>reactwise</code>, and formulates a set of linear constraints to effectively address these cost functions. For the sake of simplicity, we initially assume that <code>Generator 2</code> is out-of-service. Consequently, the helper variable is not included in the set of optimization variables. However, as we progress through this manual, we will activate the generator, introducing the helper variable and additional constraints to the optimization model.</p><p>It is worth emphasizing that in instances where a piecewise linear cost function consists of only a single segment, as demonstrated by the reactive power output cost of <code>Generator 2</code>, the function is modeled as a standard linear function, avoiding the need for additional helper optimization variables.</p><p>Please be aware that JuliaGrid maintains references to all variables, which are categorized into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.variable.voltage))</code><code class="nohighlight hljs ansi" style="display:block;">(:magnitude, :angle)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.variable.power))</code><code class="nohighlight hljs ansi" style="display:block;">(:active, :reactive, :actwise, :reactwise)</code></pre><hr/><h5 id="Variable-Names"><a class="docs-heading-anchor" href="#Variable-Names">Variable Names</a><a id="Variable-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Names" title="Permalink"></a></h5><p>Users have the option to define custom variable names for printing equations, which can help present them in a more compact form. For example:</p><pre><code class="language-julia hljs">analysis = acOptimalPowerFlow(system, Ipopt.Optimizer; magnitude = &quot;V&quot;, angle = &quot;θ&quot;)</code></pre><hr/><h5 id="Add-Variables"><a class="docs-heading-anchor" href="#Add-Variables">Add Variables</a><a id="Add-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variables" title="Permalink"></a></h5><p>Once the <code>AcOptimalPowerFlow</code> type is established, users can add new variables representing generator active power outputs by introducing additional generators. For example:</p><pre><code class="language-julia hljs">addGenerator!(analysis; label = &quot;Generator 3&quot;, bus = &quot;Bus 1&quot;, maxActive = 0.2, status = 1)</code></pre><p>This command adds both a new variables and the corresponding box constraints to the optimization model.</p><p>To confirm that the variable has been successfully added, you can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.method.jump, analysis.method.variable.power.active[3])</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.is_valid(analysis.method.jump, analysis.method.variable.power.reactive[3])</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><hr/><h2 id="ACConstraintFunctionsManual"><a class="docs-heading-anchor" href="#ACConstraintFunctionsManual">Constraint Functions</a><a id="ACConstraintFunctionsManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACConstraintFunctionsManual" title="Permalink"></a></h2><p>JuliaGrid keeps track of all the references to internally formed constraints in the <code>constraint</code> field of the <code>AcOptimalPowerFlow</code> type. These constraints are divided into six fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(typeof(analysis.method.constraint))</code><code class="nohighlight hljs ansi" style="display:block;">(:slack, :balance, :voltage, :flow, :capability, :piecewise)</code></pre><p>They fall into two main categories: box constraints and non-box constraints.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We suggest that readers refer to the tutorial on <a href="../../tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a> for insights into the implementation.</p></div></div><hr/><h5 id="Box-Constraints"><a class="docs-heading-anchor" href="#Box-Constraints">Box Constraints</a><a id="Box-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Box-Constraints" title="Permalink"></a></h5><p>The <code>slack</code> constraint is represented as an <code>equality</code> tied to the fixed voltage angle at the slack bus.</p><p>The <code>capability</code> constraints define variable bounds on both active and reactive power generation and are always implemented as two separate constraints: one for the <code>lower</code> bound and one for the <code>upper</code> bound. If the bounds are equal, or if the generator is out-of-service, JuliaGrid models the constraint as an <code>equality</code> instead.</p><p>The <code>magnitude</code> field of the <code>voltage</code> constraints defines bounds on bus voltage magnitude values and is also implemented using a <code>lower</code> and an <code>upper</code> bound. If the bounds are equal, JuliaGrid models the constraint as an <code>equality</code> instead.</p><hr/><h5 id="Non-Box-Constraints"><a class="docs-heading-anchor" href="#Non-Box-Constraints">Non-Box Constraints</a><a id="Non-Box-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Box-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> constraints correspond to the active and reactive power balance equations defined at each bus and are modeled as <code>equality</code> constraints.</p><p>The <code>angle</code> field of the <code>voltage</code> constraints are associated with the minimum and maximum voltage angle difference between the from-bus and to-bus ends of each branch and are modeled as <code>interval</code> constraints by default. If the bounds are equal, an <code>equality</code> constraint is used instead.</p><p>The <code>flow</code> constraints, which refer to branch flow limits at both ends of each branch, are also modeled as <code>interval</code> constraints by default. If the bounds are equal, an <code>equality</code> constraint is used.</p><p>If preferred, both the <code>angle</code> field of the <code>voltage</code> constraints and the <code>flow</code> constraints can be represented as two separate one-sided constraints, one for the <code>lower</code> and one for the <code>upper</code> bound, by setting the keyword argument <code>interval = false</code> when calling the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function.</p><p>Finally, the <code>piecewise</code> constraints are introduced when piecewise linear cost functions with multiple segments are defined, and they impose only <code>upper</code> bounds.</p><hr/><h5 id="Slack-Bus-Constraint"><a class="docs-heading-anchor" href="#Slack-Bus-Constraint">Slack Bus Constraint</a><a id="Slack-Bus-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Slack-Bus-Constraint" title="Permalink"></a></h5><p>The <code>slack</code> field contains a reference to the equality constraint associated with the fixed bus voltage angle value of the slack bus. This constraint is set within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function using the <code>angle</code> keyword:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: θ[1] = -0.1</code></pre><p>Users have the flexibility to modify this constraint by changing which bus serves as the slack bus and by adjusting the value of the bus angle. This can be achieved using the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> function, for example:</p><pre><code class="language-julia hljs">updateBus!(analysis; label = &quot;Bus 1&quot;, type = 1)
updateBus!(analysis; label = &quot;Bus 2&quot;, type = 3, angle = -0.2)</code></pre><p>Subsequently, the updated slack constraint can be inspected as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.slack.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 2: θ[2] = -0.2</code></pre><hr/><h5 id="Bus-Power-Balance-Constraints"><a class="docs-heading-anchor" href="#Bus-Power-Balance-Constraints">Bus Power Balance Constraints</a><a id="Bus-Power-Balance-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Power-Balance-Constraints" title="Permalink"></a></h5><p>The <code>balance</code> field contains references to the equality constraints associated with the active and reactive power balance equations defined for each bus. These constraints ensure that the total active and reactive power injected by the generators matches the total active and reactive power demanded at each bus.</p><p>The constant term in the active power balance equations is determined by the <code>active</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, which defines the active power demanded at the bus. We can access the references to the active power balance constraints using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: active[3] + (V[1] * ((V[2] * ( - (2.0 * sin(θ[1] - θ[2])))))) = 0.1
Bus 2: V[2] * ((V[1] * ( - (2.0 * sin(-θ[1] + θ[2]))))) = 0</code></pre><p>Similarly, the constant term in the reactive power balance equations is determined by the <code>reactive</code> keyword within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function, which defines the reactive power demanded at the bus. We can access the references to the reactive power balance constraints using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.balance.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: reactive[3] + (V[1] * ((-2 V[1]) + (V[2] * ((2.0 * cos(θ[1] - θ[2])))))) = 0
Bus 2: V[2] * ((-2 V[2]) + (V[1] * ((2.0 * cos(-θ[1] + θ[2]))))) = 0.01</code></pre><p>During the execution of functions that add or update power system components, these constraints are automatically adjusted to reflect the current configuration of the power system, for example:</p><pre><code class="language-julia hljs">updateBus!(analysis; label = &quot;Bus 2&quot;, active = 0.5)
updateBranch!(analysis; label = &quot;Branch 1&quot;, reactance = 0.25)</code></pre><p>The updated set of active power balance constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: active[3] + (V[1] * ((V[2] * ( - (4.0 * sin(θ[1] - θ[2])))))) = 0.1
Bus 2: V[2] * ((V[1] * ( - (4.0 * sin(-θ[1] + θ[2]))))) = 0.5</code></pre><hr/><h5 id="Bus-Voltage-Constraints"><a class="docs-heading-anchor" href="#Bus-Voltage-Constraints">Bus Voltage Constraints</a><a id="Bus-Voltage-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Bus-Voltage-Constraints" title="Permalink"></a></h5><p>The <code>voltage</code> field contains references to the inequality constraints associated with the voltage magnitude and voltage angle difference limits. These constraints ensure that the bus voltage magnitudes and the angle differences between the from-bus and to-bus ends of each branch are within specified limits.</p><p>The minimum and maximum bus voltage magnitude limits are set using the <code>minMagnitude</code> and <code>maxMagnitude</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBus!"><code>addBus!</code></a> function. The constraints associated with these limits can be accessed using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.voltage.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: V[1] ≤ 1.05, V[1] ≥ 0.95
Bus 2: V[2] ≤ 1.05, V[2] ≥ 0.95</code></pre><p>The minimum and maximum voltage angle difference limits between the from-bus and to-bus ends of each branch are set using the <code>minDiffAngle</code> and <code>maxDiffAngle</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. The constraints associated with these limits can be accessed using the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-3.141592653589793, 3.141592653589793]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Please note that if the limit constraints are set to <code>minDiffAngle = -2π</code> and <code>maxDiffAngle = 2π</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint.</p></div></div><p>By employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBus!"><code>updateBus!</code></a> and <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> functions, users have the ability to modify these constraints:</p><pre><code class="language-julia hljs">updateBus!(analysis; label = &quot;Bus 1&quot;, minMagnitude = 1.0, maxMagnitude = 1.0)
updateBranch!(analysis; label = &quot;Branch 1&quot;, minDiffAngle = -1.7, maxDiffAngle = 1.7)</code></pre><p>Subsequently, the updated set of constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.constraint.voltage.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: V[1] = 1
Bus 2: V[2] ≤ 1.05, V[2] ≥ 0.95</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-1.7, 1.7]</code></pre><hr/><h5 id="ACBranchFlowConstraintsManual"><a class="docs-heading-anchor" href="#ACBranchFlowConstraintsManual">Branch Flow Constraints</a><a id="ACBranchFlowConstraintsManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACBranchFlowConstraintsManual" title="Permalink"></a></h5><p>The <code>flow</code> field refers to inequality constraints that enforce limits on the apparent power flow, active power flow, or current flow magnitude at the from-bus and to-bus ends of each branch. The type of constraint applied is specified using the <code>type</code> keyword in the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function:</p><ul><li><code>type = 1</code> active power flow,</li><li><code>type = 2</code> apparent power flow,</li><li><code>type = 3</code> apparent power flow with a squared inequality constraint,</li><li><code>type = 4</code> current flow magnitude,</li><li><code>type = 5</code> current flow magnitude with a squared inequality constraint.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Squared versions of constraints typically make the optimization problem numerically more robust. However, they often result in slower convergence compared to their non-squared counterparts used in the constraints.</p></div></div><p>These limits are specified using the <code>minFromBus</code>, <code>maxFromBus</code>, <code>minToBus</code> and <code>maxToBus</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> function. By default, these limit keywords are associated with apparent power (<code>type = 3</code>).</p><p>However, in the example, we configured it to use active power flow by setting <code>type = 1</code>. To access the flow constraints of branches at the from-bus end, we can utilize the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.from)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1:  - ((V[1]*V[2]) * ((-4.0 * sin(θ[1] - θ[2])))) ∈ [0, 0.15]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If the branch flow limits are set to <code>minFromBus = 0.0</code> and <code>maxFromBus = 0.0</code> for the corresponding branch, JuliGrid will omit the corresponding inequality constraint at the from-bus end of the branch. The same applies to the to-bus end if <code>minToBus = 0.0</code> and <code>maxToBus = 0.0</code> are set.</p></div></div><p>Additionally, by employing the <a href="../../api/powerSystemModel/#JuliaGrid.updateBranch!"><code>updateBranch!</code></a> function, we have the ability to modify these specific constraints:</p><pre><code class="language-julia hljs">updateBranch!(analysis; label = &quot;Branch 1&quot;, minFromBus = -0.15, maxToBus = 0.15)</code></pre><p>The updated set of flow constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.from)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1:  - ((V[1]*V[2]) * ((-4.0 * sin(θ[1] - θ[2])))) ∈ [-0.15, 0.15]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.flow.to)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1:  - ((V[1]*V[2]) * ( - (-4.0 * sin(θ[1] - θ[2])))) ∈ [0, 0.15]</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In typical scenarios, <code>minFromBus</code> is equal to <code>minToBus</code>, and <code>maxFromBus</code> is equal to <code>maxToBus</code>. However, we allow these values to be defined separately for greater flexibility, enabling, among other things, the option to apply constraints on only one side of the branch.</p></div></div><hr/><h5 id="Generator-Power-Capability-Constraints"><a class="docs-heading-anchor" href="#Generator-Power-Capability-Constraints">Generator Power Capability Constraints</a><a id="Generator-Power-Capability-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-Power-Capability-Constraints" title="Permalink"></a></h5><p>The <code>capability</code> field contains references to the inequality constraints associated with the minimum and maximum active and reactive power outputs of the generators.</p><p>The constraints associated with the minimum and maximum active power output limits of the generators are defined using the <code>minActive</code> and <code>maxActive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To access the constraints associated with these limits, we can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] = 0
Generator 2: active[2] = 0
Generator 3: active[3] ≤ 0.2, active[3] ≥ 0</code></pre><p>Similarly, the constraints associated with the minimum and maximum reactive power output limits of the generators are specified using the <code>minReactive</code> and <code>maxReactive</code> keywords within the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function. To access these constraints, we can use the following code snippet:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: reactive[1] = 0
Generator 2: reactive[2] = 0
Generator 3: reactive[3] ≤ 0.1, reactive[3] ≥ -0.1</code></pre><p>As demonstrated, the active and reactive power outputs of <code>Generator 1</code> and <code>Generator 2</code> are currently fixed at zero due to previous actions that set these generators out-of-service. However, we can modify these specific constraints by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.updateGenerator!"><code>updateGenerator!</code></a> function, as shown below:</p><pre><code class="language-julia hljs">updateGenerator!(analysis; label = &quot;Generator 1&quot;, status = 1)
updateGenerator!(analysis; label = &quot;Generator 2&quot;, status = 1, minActive = 0.1)</code></pre><p>Subsequently, the updated set of constraints can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: active[1] ≤ 0.5, active[1] ≥ 0
Generator 2: active[2] ≤ 0.5, active[2] ≥ 0.1
Generator 3: active[3] ≤ 0.2, active[3] ≥ 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.capability.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: reactive[1] ≤ 0.1, reactive[1] ≥ -0.1
Generator 2: reactive[2] ≤ 0.1, reactive[2] ≥ -0.1
Generator 3: reactive[3] ≤ 0.1, reactive[3] ≥ -0.1</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This representation may not fully capture the generator&#39;s power output behavior due to the tradeoff between active and reactive power outputs. JuliaGrid can incorporate this tradeoff in its optimization model. For more information, see the tutorial on <a href="../../tutorials/acOptimalPowerFlow/#ACPowerCapabilityConstraintsTutorials">Power Capability Constraints</a>.</p></div></div><hr/><h5 id="Power-Piecewise-Constraints"><a class="docs-heading-anchor" href="#Power-Piecewise-Constraints">Power Piecewise Constraints</a><a id="Power-Piecewise-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Piecewise-Constraints" title="Permalink"></a></h5><p>In cost modeling, the <code>piecewise</code> field serves as a reference to the inequality constraints associated with piecewise linear cost functions. These constraints are defined using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function with <code>active = 1</code> or <code>reactive = 1</code>.</p><p>In our example, only the active power cost of <code>Generator 2</code> is modeled as a piecewise linear function with two segments, and JuliaGrid takes care of setting up the appropriate inequality constraints for each segment:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.constraint.piecewise.active)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 2: 0.9574468085106385 active[2] - actwise[2] ≤ -2.7255319148936152
Generator 2: 0.6666666666666663 active[2] - actwise[2] ≤ -7.000000000000007</code></pre><p>It is worth noting that these constraints can also be automatically updated using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> function. Readers can find more details in the section discussing the objective function.</p><p>As mentioned at the beginning, piecewise linear cost functions with multiple segments will also introduce helper variables that are added to the objective function. In this specific example, the helper variable is:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.method.variable.power.actwise[2]</code><code class="nohighlight hljs ansi" style="display:block;">actwise[2]</code></pre><hr/><h5 id="Add-Constraints"><a class="docs-heading-anchor" href="#Add-Constraints">Add Constraints</a><a id="Add-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Constraints" title="Permalink"></a></h5><p>Users can effortlessly introduce additional constraints into the defined AC optimal power flow model by utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.addBranch!"><code>addBranch!</code></a> functions. Specifically, if a user wishes to include a new branch or generator in an already defined <code>PowerSystem</code> and <code>AcOptimalPowerFlow</code> type:</p><pre><code class="language-julia hljs">addBranch!(analysis; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, reactance = 1)</code></pre><p>This will affect all constraints related to branches, but it will also update balance constraints to configure the optimization model to match the current state of the power system. For example, we can observe the following updated constraints:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-1.7, 1.7]
Branch 2: θ[1] - θ[2] ∈ [-3.141592653589793, 3.141592653589793]</code></pre><p>Similarly, the <a href="../../api/powerSystemModel/#JuliaGrid.addGenerator!"><code>addGenerator!</code></a> function adds both new variables and its associated box constraints.</p><hr/><h5 id="Delete-Constraints"><a class="docs-heading-anchor" href="#Delete-Constraints">Delete Constraints</a><a id="Delete-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints" title="Permalink"></a></h5><p>When a branch or generator is taken out-of-service, JuliaGrid automatically adjusts the optimization problem to reflect that action, which may include removing certain constraints.</p><p>In some cases, users may also want to manually remove specific constraints. This can be done using the <a href="../../api/optimalPowerFlow/#JuliaGrid.remove!"><code>remove!</code></a> function by specifying the constraint type: <code>:slack</code>, <code>:capability</code>, <code>:balance</code>, <code>:voltage</code>, <code>:flow</code>, or <code>:piecewise</code>.</p><p>For constraint types such as <code>:capability</code>, <code>:balance</code>, and <code>:piecewise</code>, users must also specify whether the constraint targets <code>:active</code> or <code>:reactive</code> power. Similarly, for <code>:voltage</code>, the options are <code>:magnitude</code> or <code>:angle</code>, and for <code>:flow</code>, the options are <code>:from</code> or <code>:to</code>.</p><p>For example, to delete the constraint associated with the voltage angle difference at <code>Branch 2</code>, use:</p><pre><code class="language-julia hljs">remove!(analysis, :voltage, :angle; label = &quot;Branch 2&quot;)</code></pre><p>Alternatively, instead of using a label, constraints can also be deleted by index:</p><pre><code class="language-julia hljs">remove!(analysis, :voltage, :angle; index = 4)</code></pre><p>After these operations, the remaining voltage angle difference constraints can be displayed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.method.constraint.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: θ[1] - θ[2] ∈ [-1.7, 1.7]</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In the event that a user deletes a constraint and subsequently executes a function that updates bus, branch, or generator parameters, and if the deleted constraint is affected by these functions, JuliaGrid will automatically reinstate that constraint.</p></div></div><hr/><h2 id="ACObjectiveFunctionManual"><a class="docs-heading-anchor" href="#ACObjectiveFunctionManual">Objective Function</a><a id="ACObjectiveFunctionManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACObjectiveFunctionManual" title="Permalink"></a></h2><p>The objective function of the AC optimal power flow is formulated using polynomial and piecewise linear cost functions associated with the generators, defined using the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions.</p><p>In the provided example, the objective function to be minimized in order to obtain optimal values for the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles, is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">800 active[1]² + 200 active[1] + actwise[2] + reactive[2] + 84</code></pre><p>The objective function is stored in the variable <code>analysis.objective</code>, where it is organized to separate its quadratic and nonlinear components.</p><hr/><h5 id="Update-Objective-Function"><a class="docs-heading-anchor" href="#Update-Objective-Function">Update Objective Function</a><a id="Update-Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Objective-Function" title="Permalink"></a></h5><p>By utilizing the <a href="../../api/powerSystemModel/#JuliaGrid.cost!"><code>cost!</code></a> functions, users have the flexibility to modify the objective function by adjusting polynomial or piecewise linear coefficients or by changing the type of polynomial or piecewise linear function employed. For example, consider <code>Generator 1</code>, which employs a quadratic polynomial cost function for active power. We can redefine the cost function for this generator as a cubic polynomial and thereby define a nonlinear objective function:</p><pre><code class="language-julia hljs">cost!(analysis; generator = &quot;Generator 1&quot;, active = 2, polynomial = [63; 25; 4; 0.5])</code></pre><p>This leads to an updated objective function, which can be examined as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">(25 active[1]² + actwise[2] + reactive[2] + 4 active[1] + 4.5) + (63.0 * (active[1] ^ 3.0))</code></pre><hr/><h2 id="AcSetupPrimalStartingValuesManual"><a class="docs-heading-anchor" href="#AcSetupPrimalStartingValuesManual">Setup Initial Values</a><a id="AcSetupPrimalStartingValuesManual-1"></a><a class="docs-heading-anchor-permalink" href="#AcSetupPrimalStartingValuesManual" title="Permalink"></a></h2><p>In JuliaGrid, the assignment of initial primal and dual values for optimization variables and constraints takes place when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}"><code>solve!</code></a> function is executed.</p><hr/><h5 id="Initial-Primal-Values"><a class="docs-heading-anchor" href="#Initial-Primal-Values">Initial Primal Values</a><a id="Initial-Primal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Primal-Values" title="Permalink"></a></h5><p>Initial primal values are determined based on the <code>generator</code> and <code>voltage</code> fields within the <code>AcOptimalPowerFlow</code> type. By default, these values are initially established using the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generator = analysis.power.generator;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.4, 0.2
Generator 2: 0.2, 0.1
Generator 3: 0.0, 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.1
Bus 2: 1.1, 0.0</code></pre><p>Users have the flexibility to adjust these values according to their specifications, which will then be used as the initial primal values when executing the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}"><code>solve!</code></a> function.</p><hr/><h5 id="Using-AC-Power-Flow"><a class="docs-heading-anchor" href="#Using-AC-Power-Flow">Using AC Power Flow</a><a id="Using-AC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Using-AC-Power-Flow" title="Permalink"></a></h5><p>In this perspective, users have the capability to conduct the AC power flow analysis and leverage the resulting solution to configure initial primal values. Here is an illustration of how this can be achieved:</p><pre><code class="language-julia hljs">flow = newtonRaphson(system)
powerFlow!(flow; power = true)</code></pre><p>After obtaining the solution, we can use the active and reactive power outputs of the generators, along with bus voltage magnitudes and angles, to set the initial values:</p><pre><code class="language-julia hljs">setInitialPoint!(analysis, flow)</code></pre><hr/><h5 id="Initial-Dual-Values"><a class="docs-heading-anchor" href="#Initial-Dual-Values">Initial Dual Values</a><a id="Initial-Dual-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Dual-Values" title="Permalink"></a></h5><p>Dual variables, often referred to as Lagrange multipliers or Kuhn-Tucker multipliers, represent the shadow prices or marginal costs associated with constraints. The assignment of initial dual values occurs when the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}"><code>solve!</code></a> function is executed. By default, dual values are undefined, but users can manually assign them using the <a href="../../api/optimalPowerFlow/#JuliaGrid.addDual!"><code>addDual!</code></a> function.</p><p>If a constraint is defined as an equality, an interval, or has only a lower or upper bound, it corresponds to a single dual variable. In such cases, an initial value can be set using the <code>dual</code> keyword. For example:</p><pre><code class="language-julia hljs">addDual!(analysis, :balance, :active; label = &quot;Bus 1&quot;, dual = 1e-3)</code></pre><p>For constraints with both lower and upper bounds, users can assign initial dual values separately using the <code>lower</code> and <code>upper</code> keywords. For example:</p><pre><code class="language-julia hljs">addDual!(analysis, :capability, :reactive; label = &quot;Generator 1&quot;, lower = 500.0, upper = 0.0)</code></pre><p>Alternatively, dual variables can be added by specifying the constraint index instead of a label:</p><pre><code class="language-julia hljs">addDual!(analysis, :capability, :reactive; index = 1, lower = 500.0, upper = 0.0)</code></pre><hr/><h2 id="AcOptimalPowerFlowSolutionManual"><a class="docs-heading-anchor" href="#AcOptimalPowerFlowSolutionManual">Optimal Power Flow Solution</a><a id="AcOptimalPowerFlowSolutionManual-1"></a><a class="docs-heading-anchor-permalink" href="#AcOptimalPowerFlowSolutionManual" title="Permalink"></a></h2><p>To establish the AC optimal power flow problem, we utilize the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function. After setting up the problem, we can use the <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}"><code>solve!</code></a> function to compute the optimal values for the active and reactive power outputs of the generators and the bus voltage magnitudes angles:</p><pre><code class="language-julia hljs">solve!(analysis)</code></pre><p>By executing this function, we will obtain the solution with the optimal values for the active and reactive power outputs of the generators, as well as the bus voltage magnitudes and angles.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generator = analysis.power.generator;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.373524037461336e-9, 0.05626636529233223
Generator 2: 0.49999999019365665, -0.10000000749409634
Generator 3: 0.10000001917986744, 0.05626636529233222</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.1999999979935736
Bus 2: 0.9774934538830672, -0.2</code></pre><hr/><h5 id="Objective-Value"><a class="docs-heading-anchor" href="#Objective-Value">Objective Value</a><a id="Objective-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Value" title="Permalink"></a></h5><p>To obtain the objective value of the optimal power flow solution, we can use the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.objective_value"><code>objective_value</code></a> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_value(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">11.733333214313491</code></pre><hr/><h5 id="Dual-Variables"><a class="docs-heading-anchor" href="#Dual-Variables">Dual Variables</a><a id="Dual-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-Variables" title="Permalink"></a></h5><p>The values of the dual variables are stored in the <code>dual</code> field of the <code>AcOptimalPowerFlow</code> type. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.method.dual.balance.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 9.61257632143584e-15
Bus 2: 0.8096015952603774</code></pre><hr/><h5 id="Wrapper-Function"><a class="docs-heading-anchor" href="#Wrapper-Function">Wrapper Function</a><a id="Wrapper-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-Function" title="Permalink"></a></h5><p>JuliaGrid provides a wrapper function for AC optimal power flow analysis and also supports the computation of powers and currents using the <a href="../../api/optimalPowerFlow/#JuliaGrid.powerFlow!-Tuple{AcOptimalPowerFlow}">powerFlow!</a> function:</p><pre><code class="language-julia hljs">analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)
powerFlow!(analysis; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><hr/><h5 id="Print-Results-in-the-REPL"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL">Print Results in the REPL</a><a id="Print-Results-in-the-REPL-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL" title="Permalink"></a></h5><p>Users can utilize the functions <a href="../../api/setupPrint/#JuliaGrid.printBusData"><code>printBusData</code></a> and <a href="../../api/setupPrint/#JuliaGrid.printGeneratorData"><code>printGeneratorData</code></a> to display results. Additionally, the functions listed in the <a href="../../api/setupPrint/#PrintConstraintDataAPI">Print Constraint Data</a> section allow users to print constraint data related to buses, branches, or generators in the desired units. For example:</p><pre><code class="language-julia hljs">show = Dict(&quot;Active Power Balance&quot; =&gt; false)
printBusConstraint(analysis; show)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|---------------------------------------------------------------------------|
| Bus Constraint Data                                                       |
|---------------------------------------------------------------------------|
| Label |            Voltage Magnitude             | Reactive Power Balance |
|       |                                          |                        |
|       | Minimum | Solution | Maximum |      Dual |   Solution |      Dual |
|       |    [pu] |     [pu] |    [pu] | [$/pu-hr] |       [pu] | [$/pu-hr] |
|-------|---------|----------|---------|-----------|------------|-----------|
| Bus 1 |  1.0000 |   1.0000 |  1.0000 |   -0.0000 |    -0.0000 |    0.0000 |
| Bus 2 |  0.9500 |   0.9775 |  1.0500 |    0.0000 |     0.0000 |    0.0000 |
|---------------------------------------------------------------------------|</code></pre><p>Next, users can easily customize the print results for specific constraint, for example:</p><pre><code class="language-julia hljs">printBusConstraint(analysis; label = &quot;Bus 1&quot;, header = true)
printBusConstraint(analysis; label = &quot;Bus 2&quot;, footer = true)</code></pre><hr/><h5 id="Save-Results-to-a-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-File">Save Results to a File</a><a id="Save-Results-to-a-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-File" title="Permalink"></a></h5><p>Users can also redirect print output to a file. For example, data can be saved in a text file as follows:</p><pre><code class="language-julia hljs">open(&quot;bus.txt&quot;, &quot;w&quot;) do file
    printBusConstraint(analysis, file)
end</code></pre><hr/><h5 id="Save-Results-to-a-CSV-File"><a class="docs-heading-anchor" href="#Save-Results-to-a-CSV-File">Save Results to a CSV File</a><a id="Save-Results-to-a-CSV-File-1"></a><a class="docs-heading-anchor-permalink" href="#Save-Results-to-a-CSV-File" title="Permalink"></a></h5><p>For CSV output, users should first generate a simple table with <code>style = false</code>, and then save it to a CSV file:</p><pre><code class="language-julia hljs">using CSV

io = IOBuffer()
printBusConstraint(analysis, io; style = false)
CSV.write(&quot;constraint.csv&quot;, CSV.File(take!(io); delim = &quot;|&quot;))</code></pre><hr/><h2 id="Primal-and-Dual-Warm-Start"><a class="docs-heading-anchor" href="#Primal-and-Dual-Warm-Start">Primal and Dual Warm Start</a><a id="Primal-and-Dual-Warm-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-and-Dual-Warm-Start" title="Permalink"></a></h2><p>Utilizing the <code>AcOptimalPowerFlow</code> type and proceeding directly to the solver offers the advantage of a warm start. In this scenario, the initial primal and dual values for the subsequent solving step correspond to the solution obtained from the previous step, including any user-defined data previously integrated in JuliaGrid.</p><hr/><h5 id="Primal-Variables"><a class="docs-heading-anchor" href="#Primal-Variables">Primal Variables</a><a id="Primal-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-Variables" title="Permalink"></a></h5><p>In the previous example, the following solution was obtained, representing the values of the primal variables:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generator = analysis.power.generator;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -9.373593224513171e-9, 0.05626636529232862
Generator 2: 0.49999999019699026, -0.10000000749409634
Generator 3: 0.10000001917660305, 0.05626636529233582</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.1999999979942667
Bus 2: 0.9774934538830672, -0.2</code></pre><hr/><h5 id="Dual-Variables-2"><a class="docs-heading-anchor" href="#Dual-Variables-2">Dual Variables</a><a class="docs-heading-anchor-permalink" href="#Dual-Variables-2" title="Permalink"></a></h5><p>We also obtained all dual values. Here, we list only the dual variables for one type of constraint as an example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, analysis.method.dual.capability.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: -4.126311435827629e-8
Generator 1: 0.0
Generator 2: 0.0
Generator 2: 0.9999999449411637
Generator 3: -4.126311435828731e-8
Generator 3: 0.0</code></pre><hr/><h5 id="Modify-Optimal-Power-Flow"><a class="docs-heading-anchor" href="#Modify-Optimal-Power-Flow">Modify Optimal Power Flow</a><a id="Modify-Optimal-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Modify-Optimal-Power-Flow" title="Permalink"></a></h5><p>Now, let us introduce changes to the power system from the previous example:</p><pre><code class="language-julia hljs">updateGenerator!(analysis; label = &quot;Generator 3&quot;, maxActive = 0.05)</code></pre><p>Next, we want to solve this modified optimal power flow problem. If we use <a href="../../api/optimalPowerFlow/#JuliaGrid.solve!-Tuple{AcOptimalPowerFlow}"><code>solve!</code></a> at this point, the primal and dual initial values will be set to the previously obtained values:</p><pre><code class="language-julia hljs">powerFlow!(analysis, verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><p>As a result, we obtain a new solution:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; generator = analysis.power.generator;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.generator.label, generator.active, generator.reactive)</code><code class="nohighlight hljs ansi" style="display:block;">Generator 1: 0.04999998074011849, 0.056266365292332234
Generator 2: 0.5000000096192797, -0.10000000749409634
Generator 3: 0.05000000964060179, 0.056266365292332234</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.voltage.magnitude, analysis.voltage.angle)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: 1.0, -0.20000000196815226
Bus 2: 0.9774934538830672, -0.2</code></pre><hr/><h5 id="Reset-Primal-and-Dual-Values"><a class="docs-heading-anchor" href="#Reset-Primal-and-Dual-Values">Reset Primal and Dual Values</a><a id="Reset-Primal-and-Dual-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Reset-Primal-and-Dual-Values" title="Permalink"></a></h5><p>Users retain the flexibility to reset initial primal and dual values to their default configurations at any juncture. This can be accomplished by utilizing the active and reactive power outputs of the generators and the initial bus voltage magnitudes and angles extracted from the <code>PowerSystem</code> type, employing the <a href="../../api/optimalPowerFlow/#JuliaGrid.setInitialPoint!-Tuple{AcOptimalPowerFlow}"><code>setInitialPoint!</code></a> function:</p><pre><code class="language-julia hljs">setInitialPoint!(analysis)</code></pre><p>The primal initial values will now be identical to those that would be obtained if the <a href="../../api/optimalPowerFlow/#JuliaGrid.acOptimalPowerFlow"><code>acOptimalPowerFlow</code></a> function were executed after all the updates have been applied, while all dual variable values will be removed.</p><hr/><h2 id="AcExtendedFormulationManual"><a class="docs-heading-anchor" href="#AcExtendedFormulationManual">Extended Formulation</a><a id="AcExtendedFormulationManual-1"></a><a class="docs-heading-anchor-permalink" href="#AcExtendedFormulationManual" title="Permalink"></a></h2><p>The JuMP model created by JuliaGrid is stored in the <code>method.jump</code> field of the <code>AcOptimalPowerFlow</code> type. This allows users to modify the model directly using JuMP macros and functions as needed. However, when making such modifications, users become responsible for tasks like setting initial values and extracting solutions, since these changes operate outside the standard JuliaGrid workflow.</p><p>Beyond this approach, JuliaGrid also provides a way to extend the standard AC optimal power flow formulation within its own framework. This lets users take advantage of features such as warm start and automatic solution storage, as described below.</p><hr/><h5 id="Add-Variable"><a class="docs-heading-anchor" href="#Add-Variable">Add Variable</a><a id="Add-Variable-1"></a><a class="docs-heading-anchor-permalink" href="#Add-Variable" title="Permalink"></a></h5><p>User-defined variables can be added to the DC optimal power flow model using the <a href="../../api/optimalPowerFlow/#JuliaGrid.@addVariable"><code>@addVariable</code></a> macro. It also allows immediate assignment of initial primal and dual values. For example:</p><pre><code class="language-julia hljs">@addVariable(analysis, 0.0 &lt;= y &lt;= 0.2, primal = 0.1, lower = 10.0, upper = 0.0)</code></pre><p>We can also define collections of variables:</p><pre><code class="language-julia hljs">@addVariable(analysis, 0.0 &lt;= x[i = 1:2] &lt;= 0.4, primal = [0.1, 0.2], upper = [0.0; -2.5])</code></pre><hr/><h5 id="Add-Constraints-2"><a class="docs-heading-anchor" href="#Add-Constraints-2">Add Constraints</a><a class="docs-heading-anchor-permalink" href="#Add-Constraints-2" title="Permalink"></a></h5><p>Custom constraints can be added to the DC optimal power flow model using the <a href="../../api/optimalPowerFlow/#JuliaGrid.@addConstraint"><code>@addConstraint</code></a> macro. These constraints are not limited to user-defined variables; any optimization variable defined up to that point can be used. Let us focus on the voltage angle variables:</p><pre><code class="language-julia hljs">θ = analysis.method.variable.voltage.angle</code></pre><p>Next, a new constraint can be defined, and at the same time, an initial dual value can be specified:</p><pre><code class="language-julia hljs">@addConstraint(analysis, 0.1 &lt;= x[1] + 2 * x[2] + y + θ[2] &lt;= 1.2, dual = 0.0)</code></pre><p>Collections of constraints can also be defined:</p><pre><code class="language-julia hljs">@addConstraint(analysis, [i = 1:2], x[i] + 2 * θ[i] &lt;= 0.6, dual = [0.0; 0.5])</code></pre><hr/><h5 id="Delete-Constraints-2"><a class="docs-heading-anchor" href="#Delete-Constraints-2">Delete Constraints</a><a class="docs-heading-anchor-permalink" href="#Delete-Constraints-2" title="Permalink"></a></h5><p>To remove a constraint, use the <a href="../../api/optimalPowerFlow/#JuliaGrid.remove!"><code>remove!</code></a> function with the <code>:constraint</code> symbol. For example, to remove the first added constraint:</p><pre><code class="language-julia hljs">remove!(analysis, :constraint; index = 1)</code></pre><hr/><h5 id="Objective-Function"><a class="docs-heading-anchor" href="#Objective-Function">Objective Function</a><a id="Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function" title="Permalink"></a></h5><p>Users can modify the objective function using the <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.set_objective_function"><code>set_objective_function</code></a> function from the JuMP package. In JuliaGrid, the original objective is stored in the <code>objective</code> field of the <code>AcOptimalPowerFlow</code> type, which can be accessed and customized as needed. This makes it possible to simultaneously remove nonlinear components and adjust the quadratic part of the objective function:</p><pre><code class="language-julia hljs">expr = 50 * x[1] - x[2]^2 + y + 123
JuMP.set_objective_function(analysis.method.jump, analysis.method.objective.quadratic - expr)</code></pre><p>We can now observe the updated objective function as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; JuMP.objective_function(analysis.method.jump)</code><code class="nohighlight hljs ansi" style="display:block;">25 active[1]² + x[2]² + 4 active[1] + actwise[2] + reactive[2] - 50 x[1] - y - 118.5</code></pre><hr/><h5 id="Optimal-Power-Flow-Solution"><a class="docs-heading-anchor" href="#Optimal-Power-Flow-Solution">Optimal Power Flow Solution</a><a id="Optimal-Power-Flow-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Power-Flow-Solution" title="Permalink"></a></h5><p>Users can now solve the extended formulation using:</p><pre><code class="language-julia hljs">powerFlow!(analysis; verbose = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EXIT: The optimal solution was found.</code></pre><p>After solving, users can access the optimal values as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.power.generator.active</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.04999998029613146
 0.5000000098437287
 0.05000000986013984</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.power.generator.reactive</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.05626636612837133
 -0.10000000909090911
  0.05626636612837133</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.voltage.magnitude</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.0
 0.9774934535486515</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.voltage.angle</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -0.20000000201407564
 -0.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analysis.extended.solution</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 0.2000000090909091
 0.40000000998181817
 4.393914459490238e-5</code></pre><hr/><h2 id="ACOptimalPowerCurrentAnalysisManual"><a class="docs-heading-anchor" href="#ACOptimalPowerCurrentAnalysisManual">Power and Current Analysis</a><a id="ACOptimalPowerCurrentAnalysisManual-1"></a><a class="docs-heading-anchor-permalink" href="#ACOptimalPowerCurrentAnalysisManual" title="Permalink"></a></h2><p>After obtaining the solution from the AC optimal power flow, we can calculate various electrical quantities related to buses and branches using the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{AC}"><code>current!</code></a> functions. For instance, let us consider the power system for which we obtained the AC optimal power flow solution:</p><pre><code class="language-julia hljs">using Ipopt

system = powerSystem()

@bus(minMagnitude = 0.9, maxMagnitude = 1.1)
addBus!(system; label = &quot;Bus 1&quot;, type = 3, magnitude = 1.05, angle = 0.17)
addBus!(system; label = &quot;Bus 2&quot;, active = 0.1, reactive = 0.01, conductance = 0.04)
addBus!(system; label = &quot;Bus 3&quot;, active = 0.05, reactive = 0.02)

@branch(resistance = 0.5, reactance = 1.0, conductance = 1e-4, susceptance = 0.01)
addBranch!(system; label = &quot;Branch 1&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 2&quot;, maxFromBus = 0.15)
addBranch!(system; label = &quot;Branch 2&quot;, from = &quot;Bus 1&quot;, to = &quot;Bus 3&quot;, maxFromBus = 0.10)
addBranch!(system; label = &quot;Branch 3&quot;, from = &quot;Bus 2&quot;, to = &quot;Bus 3&quot;, maxFromBus = 0.25)

@generator(maxActive = 0.5, minReactive = -0.1, maxReactive = 0.1)
addGenerator!(system; label = &quot;Generator 1&quot;, bus = &quot;Bus 1&quot;, active = 3.2, reactive = 0.5)
addGenerator!(system; label = &quot;Generator 2&quot;, bus = &quot;Bus 2&quot;, active = 0.2, reactive = 0.1)

cost!(system; generator = &quot;Generator 1&quot;, active = 2, polynomial = [1100.2; 500; 80])
cost!(system; generator = &quot;Generator 2&quot;, active = 1, piecewise = [10 12.3; 14.7 16.8; 18 19])

analysis = acOptimalPowerFlow(system, Ipopt.Optimizer)
powerFlow!(analysis)</code></pre><p>We can now utilize the following functions to calculate powers and currents:</p><pre><code class="language-julia hljs">power!(analysis)
current!(analysis)</code></pre><p>For instance, if we want to show the active power injections and the from-bus current magnitudes, we can employ:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.bus.label, analysis.power.injection.active)</code><code class="nohighlight hljs ansi" style="display:block;">Bus 1: -9.583329214392367e-9
Bus 2: 0.08516587136754697
Bus 3: -0.04999999997621973</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(system.branch.label, analysis.current.from.magnitude)</code><code class="nohighlight hljs ansi" style="display:block;">Branch 1: 0.026583569097689393
Branch 2: 0.02328034568030229
Branch 3: 0.0381409682904692</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To better understand the powers and current associated with buses and branches that are calculated by the <a href="../../api/analysis/#JuliaGrid.power!-Tuple{AcPowerFlow}"><code>power!</code></a> and <a href="../../api/analysis/#JuliaGrid.current!-Tuple{AC}"><code>current!</code></a> functions, we suggest referring to the tutorials on <a href="../../tutorials/acOptimalPowerFlow/#ACOptimalPowerFlowTutorials">AC Optimal Power Flow</a>.</p></div></div><hr/><h5 id="Print-Results-in-the-REPL-2"><a class="docs-heading-anchor" href="#Print-Results-in-the-REPL-2">Print Results in the REPL</a><a class="docs-heading-anchor-permalink" href="#Print-Results-in-the-REPL-2" title="Permalink"></a></h5><p>Users can utilize any of the print functions outlined in the <a href="../../api/setupPrint/#PrintPowerSystemDataAPI">Print Power System Data</a> or <a href="../../api/setupPrint/#PrintPowerSystemSummaryAPI">Print Power System Summary</a>. For example, to create a bus data with the desired units, users can use the following function:</p><pre><code class="language-julia hljs">@voltage(pu, deg)
@power(MW, MVAr)
show = Dict(&quot;Power Generation&quot; =&gt; false, &quot;Current Injection&quot; =&gt; false)
printBusData(analysis; show)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">|-------------------------------------------------------------------------------------------|
| Bus Data                                                                                  |
|-------------------------------------------------------------------------------------------|
| Label |       Voltage       |    Power Demand    |  Power Injection   |    Shunt Power    |
|       |                     |                    |                    |                   |
|   Bus | Magnitude |   Angle |  Active | Reactive |  Active | Reactive | Active | Reactive |
|       |      [pu] |   [deg] |    [MW] |   [MVAr] |    [MW] |   [MVAr] |   [MW] |   [MVAr] |
|-------|-----------|---------|---------|----------|---------|----------|--------|----------|
| Bus 1 |    0.9279 |  9.7403 |  0.0000 |   0.0000 | -0.0000 |   3.0790 | 0.0000 |  -0.0000 |
| Bus 2 |    0.9140 | 11.6476 | 10.0000 |   1.0000 |  8.5166 |  -3.2859 | 3.3417 |  -0.0000 |
| Bus 3 |    0.9000 |  9.1611 |  5.0000 |   2.0000 | -5.0000 |  -2.0000 | 0.0000 |  -0.0000 |
|-------------------------------------------------------------------------------------------|</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection">Active and Reactive Power Injection</a><a id="Active-and-Reactive-Power-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection" title="Permalink"></a></h5><p>To calculate the active and reactive power injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = injectionPower(analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-9.583329214392367e-9, 0.030789711880008647)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Injection-from-Generators"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Injection-from-Generators">Active and Reactive Power Injection from Generators</a><a id="Active-and-Reactive-Power-Injection-from-Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Injection-from-Generators" title="Permalink"></a></h5><p>To calculate the active and reactive power injection from the generators at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = supplyPower(analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.1851658713222782, -0.022858875148502034)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Shunt-Element"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Shunt-Element">Active and Reactive Power at Shunt Element</a><a id="Active-and-Reactive-Power-at-Shunt-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Shunt-Element" title="Permalink"></a></h5><p>To calculate the active and reactive power associated with shunt element at a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = shuntPower(analysis; label = &quot;Bus 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.03341721910987035, -0.0)</code></pre><hr/><h5 id="Active-and-Reactive-Power-Flow"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-Flow">Active and Reactive Power Flow</a><a id="Active-and-Reactive-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-Flow" title="Permalink"></a></h5><p>Similarly, we can compute the active and reactive power flow at both the from-bus and to-bus ends of the specific branch by utilizing the provided functions below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = fromPower(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.01718399882598644, 0.013091667390527213)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = toPower(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(-0.016754093702898584, -0.02075438599122779)</code></pre><hr/><h5 id="Active-and-Reactive-Power-at-Charging-Admittances"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Charging-Admittances">Active and Reactive Power at Charging Admittances</a><a id="Active-and-Reactive-Power-at-Charging-Admittances-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Charging-Admittances" title="Permalink"></a></h5><p>To calculate the total active and reactive power linked with branch charging admittances of the particular branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = chargingPower(analysis; label = &quot;Branch 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(8.482535529692715e-5, -0.008482535529692714)</code></pre><p>Active powers indicate active losses within the branch&#39;s charging admittances. Moreover, charging admittances injected reactive powers into the power system due to their capacitive nature, as denoted by a negative sign.</p><hr/><h5 id="Active-and-Reactive-Power-at-Series-Impedance"><a class="docs-heading-anchor" href="#Active-and-Reactive-Power-at-Series-Impedance">Active and Reactive Power at Series Impedance</a><a id="Active-and-Reactive-Power-at-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Active-and-Reactive-Power-at-Series-Impedance" title="Permalink"></a></h5><p>To calculate the active and reactive power across the series impedance of the branch, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; active, reactive = seriesPower(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.0003463509187067052, 0.0006927018374134103)</code></pre><p>The active power also considers active losses originating from the series resistance of the branch, while the reactive power represents reactive losses resulting from the impedance&#39;s inductive characteristics.</p><hr/><h5 id="Current-Injection"><a class="docs-heading-anchor" href="#Current-Injection">Current Injection</a><a id="Current-Injection-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Injection" title="Permalink"></a></h5><p>To calculate the current injection associated with a specific bus, the function can be used:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = injectionCurrent(analysis; label = &quot;Bus 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.033180637369821964, -1.4007966380459163)</code></pre><hr/><h5 id="Current-Flow"><a class="docs-heading-anchor" href="#Current-Flow">Current Flow</a><a id="Current-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Flow" title="Permalink"></a></h5><p>We can compute the current flow at both the from-bus and to-bus ends of the specific branch by using:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = fromCurrent(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.02328034568030229, -0.4810434670251617)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = toCurrent(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.029636431574178668, 2.4098367486797905)</code></pre><hr/><h5 id="Current-Through-Series-Impedance"><a class="docs-heading-anchor" href="#Current-Through-Series-Impedance">Current Through Series Impedance</a><a id="Current-Through-Series-Impedance-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Through-Series-Impedance" title="Permalink"></a></h5><p>To calculate the current passing through the series impedance of the branch in the direction from the from-bus end to the to-bus end, we can use the following function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; magnitude, angle = seriesCurrent(analysis; label = &quot;Branch 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(0.026319229422865145, -0.6228132099043933)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dcPowerFlow/">« DC Power Flow</a><a class="docs-footer-nextpage" href="../dcOptimalPowerFlow/">DC Optimal Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 2 October 2025 18:57">Thursday 2 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
